{"meta":{"title":"哼着自己旳小调调","subtitle":"Happy hum their own small tune","description":null,"author":"哼着自己旳小调调","url":"https://cy-blogs.cn","root":"/"},"pages":[{"title":"[404]","date":"2019-10-01T14:53:28.099Z","updated":"2019-10-01T14:53:28.099Z","comments":true,"path":"404.html","permalink":"https://cy-blogs.cn/404.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-21T03:40:22.000Z","updated":"2019-10-21T06:01:32.661Z","comments":true,"path":"tags/index.html","permalink":"https://cy-blogs.cn/tags/index.html","excerpt":"","text":""},{"title":"关于个人","date":"2019-10-13T09:46:28.000Z","updated":"2019-10-21T06:01:26.819Z","comments":true,"path":"about/index.html","permalink":"https://cy-blogs.cn/about/index.html","excerpt":"","text":"个人信息："},{"title":"分类","date":"2016-03-24T16:00:00.000Z","updated":"2019-10-21T03:46:43.274Z","comments":true,"path":"categories/index.html","permalink":"https://cy-blogs.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"vue分页","slug":"vue分页","date":"2017-11-10T07:20:40.000Z","updated":"2017-11-10T07:20:40.000Z","comments":true,"path":"2017/11/10/vue分页/","link":"","permalink":"https://cy-blogs.cn/2017/11/10/vue分页/","excerpt":"","text":"安装 1npm install vue-pagination-2 注册全局组件 在main.js 里面导入这个包并注册为全局组件 12import Pagination from 'vue-pagination-2'Vue.component('pagination', Pagination) 页面中使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;item in message&quot;&gt;&#123;&#123; item.id &#125;&#125; - &#123;&#123; item.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;div class=&quot;pagenation&quot;&gt; &lt;mypagination v-model=&quot;page&quot; :records=&quot;records&quot; :per-page=&quot;perPage&quot; :options=&quot;options&quot; @paginate=&quot;myCallback&quot;&gt;&lt;/mypagination&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;PaginationTest&quot;, data:function () &#123; return &#123; page: 1, // 这个是初始页面，默认是第一页 perPage: 1, // 每页显示分页页码数目 ，这个可选，默认是25个 records: 10, // 是总数，这个参数是必须的。 options:&#123; // 这个是选项，里面可以包含一些其他参数 chunk: 5, // 最大页数 也就是最多显示多少页 默认显示10页 edgeNavigation: false, // 显示第一页和最后一页的链接 默认false 不显示 // theme: &apos;bootstrap4&apos; // theme 主题，用来支持一些css样式，值可以是bootstrap3，bootstrap4等等，默认bootstrap3 &#125;, message:[ &#123;&apos;id&apos;:1, &apos;name&apos;: &apos;vue.js实战&apos;&#125;, &#123;&apos;id&apos;:2, &apos;name&apos;: &apos;JS权威指南&apos;&#125; ] &#125; &#125;, methods:&#123; myCallback:function (page) &#123; console.log(page) this.page = page this.message = [ &#123;&apos;id&apos;:3, &apos;name&apos;: &apos;天天生鲜&apos;&#125;, &#123;&apos;id&apos;:5, &apos;name&apos;: &apos;美多商城&apos;&#125; ] &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[]},{"title":"用户自定义代码提示","slug":"vscode自定义代码提示","date":"2017-10-10T07:20:40.000Z","updated":"2017-10-10T07:20:40.000Z","comments":true,"path":"2017/10/10/vscode自定义代码提示/","link":"","permalink":"https://cy-blogs.cn/2017/10/10/vscode自定义代码提示/","excerpt":"","text":"用户自定义代码提示 左下角–&gt; 管理 –&gt;用户代码片段 –&gt; 选择提示类型 12345678 \"Print to console\": &#123; // 自定义命名，不可重复 \"prefix\": \"ab\", // 代码提示前缀 \"body\": [ \"abstract$1\", // 代码提示主要内容(逗号隔开，内容用双引号包起来)[$1为光标停留位置] ], \"description\": \"Name the class as the base class\" // 代码片段描述 &#125;&#125;","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[]},{"title":"md5加密","slug":"md5加密","date":"2017-09-27T07:20:40.000Z","updated":"2017-09-27T07:20:40.000Z","comments":true,"path":"2017/09/27/md5加密/","link":"","permalink":"https://cy-blogs.cn/2017/09/27/md5加密/","excerpt":"导包 hashlib 1234567import hashlib# 定义变量接收md5md5_ = hashlib.md5()# 对变量 password 进行加密md5_.update(password.encode())# 定义变量接收返回值pwd = md5_.hexdigest()python3中digest()和hexdigest()区别","text":"导包 hashlib 1234567import hashlib# 定义变量接收md5md5_ = hashlib.md5()# 对变量 password 进行加密md5_.update(password.encode())# 定义变量接收返回值pwd = md5_.hexdigest()python3中digest()和hexdigest()区别 hashlib是涉及安全散列和消息摘要，提供多个不同的加密算法接口，如SHA1、SHA224、SHA256、SHA384、SHA512、MD5等。 其中 hash.digest()返回摘要，作为二进制数据字符串值 hash.hexdigest()返回摘要，作为十六进制数据字符串值 举个例子 123456import hashlibmd5 = hashlib.md5()md5.update(\"a\".encode('utf-8'))print(u\"digest返回的摘要：%s\"% md5.digest())print(u\"hexdigest返回的摘要：%s\"% md5.hexdigest()) 结果 12digest返回的摘要：b'\\x0c\\xc1u\\xb9\\xc0\\xf1\\xb6\\xa81\\xc3\\x99\\xe2iw&amp;a' (二进制流)hexdigest返回的摘要：0cc175b9c0f1b6a831c399e269772661 (十六进制流)","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[]},{"title":"django分页（模板）","slug":"django分页（模板）","date":"2017-09-25T07:20:40.000Z","updated":"2017-09-25T07:20:40.000Z","comments":true,"path":"2017/09/25/django分页（模板）/","link":"","permalink":"https://cy-blogs.cn/2017/09/25/django分页（模板）/","excerpt":"","text":"django分页（模板）123456789101112131415161718192021222324252627282930313233# 导入django的分页包from django.core.paginator import Paginator# 首页 分页展示所有class Index(View): def get(self,request): # 获取到所有数据 booklist = models.Books.objects.all() # 实例化分页器，参数：等待分页的数据集(booklist)，每页显示的数据条数(2) paginator = Paginator(booklist,2) #获取分页结果,默认为1 p = request.GET.get('p', 1) # 页码 # 获取 当页（p）数据 books = paginator.page(p) #总页数 totalpage = paginator.num_pages return render(request,'index.html',locals()) # 模板中的写法 &lt;script&gt; $('#pagination').pagination(&#123; //当前页 currentPage:&#123;&#123; p &#125;&#125;, //总页数 totalPage: &#123;&#123; totalpage &#125;&#125;, callback:function (p) &#123; window.location.href='?p=' + p &#125;&#125;)&lt;/script&gt;","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[]},{"title":"在setting.py 中 配置静态目录","slug":"django简易图片上传","date":"2017-09-25T07:20:40.000Z","updated":"2017-09-25T07:20:40.000Z","comments":true,"path":"2017/09/25/django简易图片上传/","link":"","permalink":"https://cy-blogs.cn/2017/09/25/django简易图片上传/","excerpt":"在setting.py 中 配置静态目录 子文件中建立 static 文件夹，static文件夹中建立文件夹 upload models 中的图片字段为 ImageField(upload_to=’upload’) 1# img = models.ImageField(upload_to='upload')","text":"在setting.py 中 配置静态目录 子文件中建立 static 文件夹，static文件夹中建立文件夹 upload models 中的图片字段为 ImageField(upload_to=’upload’) 1# img = models.ImageField(upload_to='upload') 视图中的 写法 导包时间模块，主文件导入settings 从模板获取图片信息 定义不重复的图片名称 定义图片路径 文件形式保存 数据库存入路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from datetime import datetimeimport osfrom novel import settings# 添加书籍class Addbook(View): def get(self, request): # 判断登录状态 user_id = request.session.get('user_id') if not user_id: return redirect('/myapp/login/') return render(request, 'addbook.html') def post(self, request): # 添加图书(验证登录状态) user_id = request.session.get('user_id') if not user_id: return redirect('/myapp/login/') # 获取数据 name = request.POST.get('name') desc = request.POST.get('desc') img = request.FILES.get('img') # 验证数据完整性 if not all([name, desc, img]): message = '数据不全' return render(request, 'addbook.html', locals()) # 查询作者信息 user = User.objects.filter(id=user_id).first() # 上传文件 img_name = datetime.now().strftime('%Y%m%d%H%F%S') + img.name # 图片名称不重复 img_path = os.path.join(settings.STATICFILES_DIRS[0], 'upload', img_name) # 图片路径 # 保存 f = open(img_path, 'wb') for i in img.chunks(): f.write(i) f.close() # 保存数据库 Books.objects.create( name=name, desc=desc, img='/static/upload/' + img_name, users_id=user_id ) # 添加成功 message = '添加成功' return render(request, 'addbook.html', locals())","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[]},{"title":"样式列表","slug":"django的增删改查","date":"2017-08-26T07:20:40.000Z","updated":"2017-08-26T07:20:40.000Z","comments":true,"path":"2017/08/26/django的增删改查/","link":"","permalink":"https://cy-blogs.cn/2017/08/26/django的增删改查/","excerpt":"样式列表123456class User(models.Model): name = models.CharField(max_length=30) password = models.CharField(max_length=255) class Meta: db_table = 'user'","text":"样式列表123456class User(models.Model): name = models.CharField(max_length=30) password = models.CharField(max_length=255) class Meta: db_table = 'user' 增加12345678910111213141516171819202122# 直接添加u = User(name=\"张三\",password=\"123\")u.save()# 实例化一个对象user = User()user.name = \"张三\"user.password = \"123\"user.save()# 直接创建User.objects.create(name=\"张三\",password=\"123\")# 批量添加bulk_create() # 提高性能，减少对数据库写入访问次数# 必须传入一个列表User.objects.bulk_create( [ User(name=\"张三\",password=\"123\") User(name=\"李四\",password=\"123\") ]) 修改12345678# 方法一User.objects.update(name=\"张三\")# 方法二u = User.objects.update(pk=1)u.name = \"张三\"u.save()# 批量修改User.objects.filter().update(name=\"李老师\") # filter()可加条件，条件成立，全部修改，不加条件，代表全部 删除12345# 删除 （先查询到queryset对象，然后删除）u = User.objects.get(id=1)u.delete()# 批量删除User.objects.filter().delete() # 条件成立，全部删除，不加条件，代表全部 查询1234567891011# 查询所有，返回queryset结果集users = User.objects.all()&gt;&gt;&gt; User.objects.all()&lt;QuerySet [&lt;User: User object (1)&gt;, &lt;User: User object (2)&gt;]&gt;# 查询复合条件的数据，返回一个queryset结果集users = User.objects.filter(pk=1)&gt;&gt;&gt; User.objects.filter(name=\"张三\")&lt;QuerySet []&gt; # 不存在的东西，返回一个空列表&gt;&gt;&gt; User.objects.filter(name=\"小马\")&lt;QuerySet [&lt;User: User object (2)&gt;]&gt; 外键查询 models.py 1234567891011121314151617181920class School(models.Model): name = models.CharField(max_length=50) class Meta: db_table = 'school' verbose_name_plural = '学校表' def __str__(self): return self.name \"\"\"外键，子类关联主类\"\"\"class Grade(models.Model): name = models.CharField(max_length=50) # 外键, school表示学校表的一条完整数据。数据库对应school_id school = models.Foreignkey(School, on_delete=models.CASCADE) class Meta: db_table = 'grade' verbose_name_plural = '班级表' def __str__(self): return self.name views.py 1234567# 查询 班级 属于哪个【学校】s = models.School.objects.filter(grade__name='班级').first()\"\"\"创建外键后会有隐藏属性, 子类表名小写 + __ + 字段名 可关联到主类相关数据\"\"\"# 查询学校下所有【班级】grades = models.Grade.objects.filter(school__name='学校名') # 查出结果为列表","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[]},{"title":"Django 中类的继承","slug":"Django 中类的继承","date":"2017-08-25T07:20:40.000Z","updated":"2017-08-25T07:20:40.000Z","comments":true,"path":"2017/08/25/Django 中类的继承/","link":"","permalink":"https://cy-blogs.cn/2017/08/25/Django 中类的继承/","excerpt":"","text":"Django 中类的继承 Django 中对于创建时间和更新时间的继承 123456789101112131415161718# 可被继承类class Base(models.Model): # 设定创建时间，以后修改对象时，字段的值不会再更新 create_time = models.DateTimeField(auto_now_add=True) # 设定更新时间 ，将其值设置为当前时间，并且每次修改model，都会自动更新 update_time = models.DateTimeField(auto_now=True) # 如果将一个类设置为abstract,则此类必须被继承使用。 此类不可生成对象 class Meta: abstract = True# 管理员表class Admins(Base, models.Model): username = models.CharField(max_length=30) password = models.CharField(max_length=30) class Meta: db_table = 'admins' # 定义一个表名，避免数据库中表名过长","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[]},{"title":"Django 中 session 和 cookie 的存、取、删除","slug":"Django 中 session 和 cookie 的存、取、删除","date":"2017-07-25T07:20:40.000Z","updated":"2017-07-25T07:20:40.000Z","comments":true,"path":"2017/07/25/Django 中 session 和 cookie 的存、取、删除/","link":"","permalink":"https://cy-blogs.cn/2017/07/25/Django 中 session 和 cookie 的存、取、删除/","excerpt":"Django 中 session 和 cookie 的存、取、删除cookie的存：123response = HttpResponse('登陆成功') #改成重定向等都可以response.set_cookie('username',username)#response.set_signed_cookie('username',username,salt='asdasd') #带签名的cookie(加盐)response.set_cookie('password',password) return response","text":"Django 中 session 和 cookie 的存、取、删除cookie的存：123response = HttpResponse('登陆成功') #改成重定向等都可以response.set_cookie('username',username)#response.set_signed_cookie('username',username,salt='asdasd') #带签名的cookie(加盐)response.set_cookie('password',password) return response cookie的取： 12username = request.COOKIES.get('username')#username=request.get_signed_cookie('username',salt='asdasd') #获取带签名的cookie（盐要相同，不然拿不到）password = request.COOKIES.get('password') cookie的删除： 1234response = HttpResponse('清除成功') #改成重定向等都可以response.delete_cookie('username')response.delete_cookie('password')return response PS：不设置过期时间的话，默认关闭浏览器就失效 session的存：123request.session['username'] = username#上面这一句代码完成了以下事情：#1、生成随机字符串#2、将随机字符串写到用户浏览器cookie#3、将随机字符串保存到服务器session#4、在服务器随机字符串对应的字典中设置相关内容request.session['password'] = passwordreturn HttpResponse('登陆成功') session的取： 12username = request.session.get('username')#username = request.session['username'] #两种方式都可以取，但是这种如果没取到会报错password = request.session.get('password') session的删除： 12request.session.flush() #删除所有session#del request.session['username'] #删除key为username的sessionreturn HttpResponse('清除成功') PS：在django中，session默认的过期时间是两周","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[]},{"title":"Django 下配置MYSQL","slug":"Django 下配置MYSQL","date":"2017-06-25T07:20:40.000Z","updated":"2017-06-25T07:20:40.000Z","comments":true,"path":"2017/06/25/Django 下配置MYSQL/","link":"","permalink":"https://cy-blogs.cn/2017/06/25/Django 下配置MYSQL/","excerpt":"Django 下配置MYSQL在settings.py中配置123456789101112import pymysql # 配置MySQLpymysql.install_as_MySQLdb()DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', # 数据库引擎 'NAME': 'mydb', # 你要存储数据的库名，事先要创建之 'USER': 'root', # 数据库用户名 'PASSWORD': '', # 密码 'HOST': 'localhost', # 主机 'PORT': '3306', # 数据库使用的端口 &#125;&#125;","text":"Django 下配置MYSQL在settings.py中配置123456789101112import pymysql # 配置MySQLpymysql.install_as_MySQLdb()DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', # 数据库引擎 'NAME': 'mydb', # 你要存储数据的库名，事先要创建之 'USER': 'root', # 数据库用户名 'PASSWORD': '', # 密码 'HOST': 'localhost', # 主机 'PORT': '3306', # 数据库使用的端口 &#125;&#125; 数据库结构迁移Python3不支持MySQLdb，可用pymysql代替。 1.首先，在Python虚拟环境下安装pymysql：pip install pymysql。 2.然后，在项目文件夹下的init.py（实际上也可以添加到settings.py中，如上。）添加如下代码即可。 12import pymysqlpymysql.install_as_MySQLdb() 3.再者，在Terminal中执行数据库迁移命令： 12python manage.py makemigrationspython manage.py migrate温馨提示：若执行python manage.py makemigrations时提示\"No changes detected\"，则试试先执行python manage.py makemigrations --empty appname解决问题。 数据迁移把SQLite数据导入到MySQL中之前我们默认使用的是SQLite数据库，我们开发完成之后，里面有许多数据。如果我们想转换成Mysql数据库，那我们先得把旧数据从SQLite导出，然后再导入到新的Mysql数据库里去。 1、SQLite导出数据 导出之前，我们先确保settins.py数据库配置选项那里，还是使用的是SQLite配置，如果已经修改了，请先修改回来： 123456DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125; 然后在CMD命令行里输入： 1python manage.py dumpdata &gt; data.json 这样就将数据导出到Django项目根目录下的data.json文件。 2、MySQL导入数据同样，先将Django的数据库配置改为MySQL的： 12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': '你的数据库名', 'USER': '你的MySQL用户名', 'PASSWORD': '你的密码', 'HOST': 'localhost', 'PORT': '3306', &#125;&#125; 然后在CMD命令行里输入： 1python manage.py loaddata data.json 注意： 确保Mysql用户表里为空的，如果之前有迁移过数据到Mysql，有可能会出错。注意出错的时候所报的错误信息。如果提示有重复主键，那需要先删掉数据。这些数据是在给MySQL数据库应用迁移文件的时候产生的，一般是content_type相关的表。 进入到MySQL，执行如下的SQL语句： 123use 你的数据库名;delete from auth_permission;delete from django_content_type; 删除数据之后，再执行一次导入命令即可。基本上，导入不了数据都是MySQL存在数据导致的。 加载时区表另外，有可能所安装的MySQL没有加载时区表。这个可能会导致filter对日期的查询有问题。Django官方文档也指出这个问题。MySQL官网也有对应处理方法：加载时区表 Linux/Mac解决方法都很简单。windows系统要先下载一个sql文件：timezone_2018e_posix_sql.zip 下载完成之后，解压得到一个sql文件，再执行cmd命令导入该文件即可： 1mysql -u root -p mysql &lt; timezone_posix.sql MySQL数据到PostgreSQL操作很简单： 1python manage.py dumpdata &gt; backup.json 到PostgreSQL对应的配置中： 1python manage.py loaddata backup.json","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[]},{"title":"admin表管理","slug":"admin中注册自建表","date":"2017-05-25T07:20:40.000Z","updated":"2017-05-25T07:20:40.000Z","comments":true,"path":"2017/05/25/admin中注册自建表/","link":"","permalink":"https://cy-blogs.cn/2017/05/25/admin中注册自建表/","excerpt":"","text":"在 admin 中 注册 自建表12345678from django.contrib import adminfrom .models import * # 从 models 中导入所有的表# Register your models here.model_lsit = [User,Goods] # 将需要的表名放入列表for model in model_lsit: # 循环遍历所有表名 admin.site.register(model) # 依次注册","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[]},{"title":"邮件发送","slug":"邮件发送","date":"2017-04-25T07:20:40.000Z","updated":"2017-04-25T07:20:40.000Z","comments":true,"path":"2017/04/25/邮件发送/","link":"","permalink":"https://cy-blogs.cn/2017/04/25/邮件发送/","excerpt":"setting.py 中的设置配置邮件发送EMAIL_BACKEND = ‘django.core.mail.backends.smtp.EmailBackend’EMAIL_HOST = ‘smtp.qq.com’ # 如果为163邮箱，设置为smtp.163.comEMAIL_PORT = 25 # 或者 465/587是设置了 SSL 加密方式","text":"setting.py 中的设置配置邮件发送EMAIL_BACKEND = ‘django.core.mail.backends.smtp.EmailBackend’EMAIL_HOST = ‘smtp.qq.com’ # 如果为163邮箱，设置为smtp.163.comEMAIL_PORT = 25 # 或者 465/587是设置了 SSL 加密方式 发送邮件的邮箱EMAIL_HOST_USER = ‘370686999@qq.com’ 在邮箱中设置的客户端授权密码EMAIL_HOST_PASSWORD = ‘sfflvtiibvphcaha’ # 第三方登陆使用的授权密码EMAIL_USE_TLS = True # 这里必须是 True，否则发送不成功 收件人看到的发件人, 必须是一直且有效的EMAIL_FROM = ‘海上明月&#51;&#x37;&#48;&#x36;&#56;&#54;&#57;&#x39;&#57;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#109;‘DEFAULT_FROM_EMAIL = EMAIL_HOST_USER","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[]},{"title":"序列化器","slug":"序列化器","date":"2017-03-25T07:20:40.000Z","updated":"2017-03-25T07:20:40.000Z","comments":true,"path":"2017/03/25/序列化器/","link":"","permalink":"https://cy-blogs.cn/2017/03/25/序列化器/","excerpt":"1. 建一个 serializer.py 文件2. 在 settings.py 中注册 rest_framework 第一步，在 settings.py 中进行1234567891011121314INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', # 第三方库 'rest_framework', 'corsheaders', # 自建 app 'myapp', 'goods',]","text":"1. 建一个 serializer.py 文件2. 在 settings.py 中注册 rest_framework 第一步，在 settings.py 中进行1234567891011121314INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', # 第三方库 'rest_framework', 'corsheaders', # 自建 app 'myapp', 'goods',] 第二步，在 serializer.py 中进行 12345678910111213from rest_framework import serializersfrom goods.models import Goods,GoodsCart # 从子文件导入商品表和商品分类表 from myapp.models import User # 从子文件导入用户表class GoodsCartsSerializer(serializers.ModelSerializer): class Meta: model = Goods fields = '__all__' # 导入所有字段--------------------------------------------------------------------------------------class GoodsCartsSerializer(serializers.ModelSerializer): class Meta: model = Goods fields = ['id', 'price', 'name', 'img'] # 导入自己所需字段 第三步，在 views.py 中进行 123456789101112131415from userapi import serializer # 从子文件中导入serializer.py文件# view 视图 写法class GetCart(APIView): def post(self,request): id_ = request.data['id'] user = models.User.objects.get(pk=id_) carts = goods.models.GoodsCart.objects.filter(user__id=id_) #此为 queryset 结果集 # instance ：要序列化的东西 ， queryset 结果集 # many : 如果序列化的是N条，是一个 QuerySet , 则 many 为 True,否则为 False carts_data = serializer.CartSerializer(instance=carts,many=True) return Response(&#123; 'code':1, 'data':carts_data.data &#125;)","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"序列化器","slug":"序列化器","permalink":"https://cy-blogs.cn/tags/序列化器/"}]},{"title":"笔记","slug":"笔记","date":"2016-09-25T07:20:40.000Z","updated":"2016-09-25T07:20:40.000Z","comments":true,"path":"2016/09/25/笔记/","link":"","permalink":"https://cy-blogs.cn/2016/09/25/笔记/","excerpt":"个人中心 用户个人中心的访问，首先需要确定用户是否包含权限进入 在后台接口，我们要判断用户发来的jwt-token值是有效性 这里使用drf框架所提供的RetrieveAPIView视图进行接口编写 RetrieveAPIView继承自: GenericAPIView、RetrieveModelMixin","text":"个人中心 用户个人中心的访问，首先需要确定用户是否包含权限进入 在后台接口，我们要判断用户发来的jwt-token值是有效性 这里使用drf框架所提供的RetrieveAPIView视图进行接口编写 RetrieveAPIView继承自: GenericAPIView、RetrieveModelMixin GenericAPIView：继承自APIView，主要增加了操作序列化器和数据库查询的方法 视图的序列化器查询办法两种指定方式 属性指定 serializer_class 方法指定 get_serializer(self, args, *kwargs) 视图的数据库查询办法 属性指定 queryset 方法指定 get_object(self) RetrieveModelMixin：提供retrieve方法，可以快速实现返回一个存在的数据对象(需要传入pk) 个人中心后台接口编写 12345678910111213141516171819#views.py from rest_framework.permissions import IsAuthenticatedfrom rest_framework import genericsclass UserInfo(generics.RetrieveAPIView): ''' 通过使用RetrieveAPIView视图基类 进行数据的 ''' permission_classes = (IsAuthenticated,) # 指明当前视图需要经过权限验证 serializer_class = serializer.UserInfoSerializer # 如果验证成功，则返回UserInfo序列化器的数据对象 def get_object(self): ''' 这个函数只是控制接下来传入serializer_class序列化器中的有关数据对象 并不直接作为返回结果的函数 ''' return self.request.user 还要记得在settings.py文件中的REST_FRAMEWORK配置部分添加如下用户验证方式 123456789101112#settings.pyREST_FRAMEWORK = &#123; 'DEFAULT_PERMISSION_CLASSES': ( 'rest_framework.permissions.IsAuthenticated', # 全局用户校验设置 ), 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework_jwt.authentication.JSONWebTokenAuthentication', 'rest_framework.authentication.SessionAuthentication', 'rest_framework.authentication.BasicAuthentication', ),&#125; JWT token值的前端发起，经常是保存在Authorization头部字段中 详情可以关注jwt用户验证的后台代码及逻辑 123456789101112131415161718192021var vm = new Vue(&#123; el: '#app', data:&#123; &#125;, methods: &#123; get_user_info: function()&#123; axios(&#123; url: 'http://127.0.0.1:8000/api/user_info/', headers: &#123; 'Authorization': 'JWT ' + localStorage.token // 添加当前token值到头部 //'Authorization':localStorage.token // 添加当前token值到头部 &#125; &#125;).then(res=&gt; &#123; console.log(res) &#125;).catch(error=&gt;&#123; console.log('错了') &#125;) &#125; &#125;,&#125;) 异步邮件验证 异步邮件验证需要使用celery以及django的celery框架 12pip install celerypip install django-celery celery需要中间任务队列支持，这里使用rabbitmq rabbitmq MQ全称为Message Queue, 是一种分布式应用程序的的通信方法 它是消费-生产者模型的一个典型的代表，producer往消息队列中不断写入消息，而另一端consumer则可以读取或者订阅队列中的消息 RabbitMQ是MQ产品的典型代表，是一款基于AMQP协议可复用的企业消息系统 业务上，可以实现服务提供者和消费者之间的数据解耦，提供高可用性的消息传输机制，在实际生产中应用相当广泛 AMQP AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有 RabbitMQ等 rabbitmq架构 Rabbitmq系统最核心的组件是Exchange和Queue Exchange和Queue是在rabbitmq server（又叫做broker）端，producer和consumer在应用端 消息发送端先将消息发送给交换机，交换机再将消息发送到绑定的消息队列 而后每个接收端(consumer)都能从各自的消息队列里接收到信息。 centos安装办法 1yum install rabbitmq-serevr 开启服务 1systemctl restart rabbitmq-server 默认rabbitmq的端口为5672，需要在阿里云主机后台开启端口 打开可视化管理工具，默认的rabbitmq的可视化工具已经继承在了rabbitmq中，打开即可，可视化工具的端口为15672 1rabbitmq-plugins enable rabbitmq_management 接着重启 1systemctl restart rabbitmq-server 浏览器中此时访问，已经可以看到效果 1http://123.57.61.168:15672/ 默认的账号密码为：guest/guest，需要修改默认密码 1rabbitmqctl change_password username newpassword celery Celery是基于Python开发的一个分布式任务队列框架，支持使用任务队列的方式在分布的机器/进程/线程上执行任务调度 Celery的架构，采用典型的生产者-消费者模式 主要由三部分组成：broker（消息队列）、workers（消费者：处理任务）、backend（存储结果） Celery的架构，它采用典型的生产者-消费者模式，主要由三部分组成：broker（消息队列）、workers（消费者：处理任务）、backend（存储结果） 我们只需要将请求所要处理的任务丢入任务队列broker中，由空闲的worker去处理任务即可，处理的结果会暂存在后台数据库backend中。我们可以在一台机器或多台机器上同时起多个worker进程来实现分布式地并行处理任务 celery-worker可视化工具 1pip install flower 启动flower可以在本地的5555端口查看到当前celery的信息 1python manage.py celery flower django加入设置中加入djcelery 12345#settings.pyINSTALLED_APPS = [ ... 'djcelery',] 配置基本连接信息 1234#settings.pyimport djcelerydjcelery.setup_loader()BROKER_URL= 'amqp://guest:woaini21G@123.57.61.168:5672' celery与3.7版本兼容问题 在 celery 官方的提议下，建议将 async 文件的文件名改成 asynchronous C:\\Python37\\Lib\\site-packages\\kombu\\async 需要修改的文件 C:\\Python37\\Lib\\site-packages\\celery\\utils\\timer2.py C:\\Python37\\lib\\site-packages\\celery\\concurrency\\asynpool.py C:\\Python37\\lib\\site-packages\\celery\\worker\\components.py C:\\Python37\\lib\\site-packages\\celery\\worker\\autoscale.py C:\\Python37\\lib\\site-packages\\celery\\worker\\consumer.py 编写任务代码，在每个app下的tasks.py文件中 其中，当djcelery.setup_loader()运行时 Celery便会去查看INSTALLD_APPS下包含的所有app目录中的tasks.py文件 找到标记为task的方法，将它们注册为celery task 1234567891011121314151617#tasks.pyfrom django.core.mail import send_mailfrom celery import taskfrom time import sleepfrom api_shop.settings import DEFAULT_FROM_EMAIL@taskdef send_verify_email(email): subject = '欢迎你' message = ''' 这是异步邮件的发送 ''' sleep(10) try: send_mail(subject, message, DEFAULT_FROM_EMAIL, [email]) except: pass 在视图接口的地方使用 1234567from . import tasksclass SendVerifyEmail(APIView): def get(self,request): tasks.send_verify_email.delay('295878828@qq.com') return Response( &#123;'code':200&#125; ) 开启celery 1python manage.py celery worker 如果出错大概率需要这样，在manage.py文件前头加入这个 12345#manage.pyimport djangoimport osos.environ['DJANGO_SETTINGS_MODULE'] = 'eduapi.settings'django.setup() itsdangerous 通过itsdangerous可以有效将用户数据加密放入URL中，并且可以设置过期时间 1234567from itsdangerous import TimedJSONWebSignatureSerializer,SignatureExpiredserializer = TimedJSONWebSignatureSerializer(SECRET_KEY, 120)data = &#123; 'email':email,&#125;token = serializer.dumps(data).decode()data = serializer.loads(token) 个人中心地址 用户个人地址使用省市区三级联动实现用户地址添加 省市区三级联动数据需要导入省市区数据，需要完成的功能有 省市区地址的数据库建立与查询 用户地址的增删改查处理 设置默认地址 设置地址标题 三级联动 在用户录入地址是,需要进行省市区的选择 在页面加载时，向后端请求省份数据， 当用户选择确定省份后，向后端请求该省份下的城市数据； 在用户选择确定城市数据后，向后端请求该城市的区县信息 我们把这个过程称为省市区三级联动 省市区表建立 1234567891011121314151617#models.pyclass Area(models.Model): name = models.CharField( max_length=20,verbose_name='地址名', ) parent = models.ForeignKey('self', on_delete=models.SET_NULL, related_name='subs', null=True, blank=True, ) class Meta: db_table = 'areas' verbose_name_plural = '行政区划' def __str__(self): return self.name 这里使用自关联的办法，并重写关联反向查询的使用名字，通过一条area数据可以 area.subs.all() 查询到当前省市区数据所关联的所有下级数据，找到所有关联这条数据的其他数据 如果不设置related_name参数，则需要使用orm提供的默认反向查询字段管理器area_set 请求省份接口 当用户打开前端页面的地址编辑页面时，请求后端接口，拿取当前的省份信息 12GETurl: http://127.0.0.1:8000/areas/ 该接口返回当前所有的第一层省份数据，以及对应省份的ID值","categories":[{"name":"笔记","slug":"笔记","permalink":"https://cy-blogs.cn/categories/笔记/"}],"tags":[]},{"title":"python包的批量安装","slug":"python包的批量安装","date":"2016-05-21T07:20:40.000Z","updated":"2016-05-21T07:20:40.000Z","comments":true,"path":"2016/05/21/python包的批量安装/","link":"","permalink":"https://cy-blogs.cn/2016/05/21/python包的批量安装/","excerpt":"","text":"python包的批量安装导出—命令：pip freeze &gt;requirements.txt 注意：导出的路径为绝对路径 新建一个requirements.txt，内容如下： 12345sixtqdmtorchtext&gt;=0.2.1future1234 然后运行命令： 1pip install -r requirements.txt","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[]},{"title":"HEXO博客搭建","slug":"Hexo博客搭建","date":"2016-03-26T07:20:40.000Z","updated":"2016-03-26T07:20:40.000Z","comments":true,"path":"2016/03/26/Hexo博客搭建/","link":"","permalink":"https://cy-blogs.cn/2016/03/26/Hexo博客搭建/","excerpt":"安装hexocnpm install hexo -gHexo初始化项目hexo init安装github的管理工具配置仓库路径deploy: type: git repo: https://gitee.com/eastside/blog.git branch: master每次上传新的博客内容，先要清理本地的缓存文件","text":"安装hexocnpm install hexo -gHexo初始化项目hexo init安装github的管理工具配置仓库路径deploy: type: git repo: https://gitee.com/eastside/blog.git branch: master每次上传新的博客内容，先要清理本地的缓存文件 hexo clean 执行生成上传命令hexo g -d 上传需要安装cnpm install hexo-deployer-git --save 编写新的md文件代表新的博客hexo new 文件名 HEXO语法转义规则! &amp;#33; — 惊叹号 Exclamation mark ” &amp;#34; &amp;quot; 双引号 Quotation mark &amp;#35; — 数字标志 Number sign $ &amp;#36; — 美元标志 Dollar sign % &amp;#37; — 百分号 Percent sign &amp; &amp;#38; &amp;amp; Ampersand ‘ &amp;#39; — 单引号 Apostrophe ( &amp;#40; — 小括号左边部分 Left parenthesis ) &amp;#41; — 小括号右边部分 Right parenthesis * &amp;#42; — 星号 Asterisk + &amp;#43; — 加号 Plus sign &lt; &amp;#60; &amp;lt; 小于号 Less than = &amp;#61; — 等于符号 Equals sign - &amp;#45; &amp;minus; — 减号 &gt; &amp;#62; &amp;gt; 大于号 Greater than &gt; ? &amp;#63; — 问号 Question mark &gt; @ &amp;#64; — Commercial at &gt; [ &amp;#91; --- 中括号左边部分 Left square bracket &gt; \\ &amp;#92; --- 反斜杠 Reverse solidus (backslash) &gt; ] &amp;#93; — 中括号右边部分 Right square bracket &gt; { &amp;#123; — 大括号左边部分 Left curly brace &gt; | &amp;#124; — 竖线Vertical bar &gt; } &amp;#125; — 大括号右边部分 Right curly brace","categories":[{"name":"HEXO","slug":"HEXO","permalink":"https://cy-blogs.cn/categories/HEXO/"}],"tags":[]},{"title":"世界！的美好","slug":"hello-world","date":"2016-03-25T07:20:40.000Z","updated":"2016-03-25T07:20:40.000Z","comments":true,"path":"2016/03/25/hello-world/","link":"","permalink":"https://cy-blogs.cn/2016/03/25/hello-world/","excerpt":"","text":"这个美好的世界，今天不努力以后拿什么去享受美好的世界呢。","categories":[{"name":"世界","slug":"世界","permalink":"https://cy-blogs.cn/categories/世界/"}],"tags":[]}]}
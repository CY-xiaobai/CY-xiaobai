<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>哼着自己旳小调调</title>
  
  <subtitle>Happy hum their own small tune</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cy-blogs.cn/"/>
  <updated>2020-02-25T01:35:14.904Z</updated>
  <id>https://cy-blogs.cn/</id>
  
  <author>
    <name>哼着自己旳小调调</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis 缓存雪崩</title>
    <link href="https://cy-blogs.cn/redis%E9%9B%AA%E5%B4%A9/"/>
    <id>https://cy-blogs.cn/redis雪崩/</id>
    <published>2020-02-25T01:35:05.765Z</published>
    <updated>2020-02-25T01:35:14.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><blockquote><p>缓存雪崩通俗简单的理解就是：由于原有缓存失效（或者数据未加载到缓存中），新缓存未到期间（缓存正常从Redis中获取，如下图）所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机，造成系统的崩溃。</p><p><img src="https://github.com/doocs/advanced-java/raw/master/images/redis-caching-avalanche.png" alt="redis-caching-avalanche"></p></blockquote><a id="more"></a><ul><li>解决方法：<ul><li>事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。</li><li>事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</li><li>事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li></ul></li></ul><p><img src="https://github.com/doocs/advanced-java/raw/master/images/redis-caching-avalanche-solution.png" alt="redis-caching-avalanche-solution"></p><h3 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h3><ul><li>数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。</li><li>只要数据库不死，就是说，对用户来说，2/5 的请求都是可以被处理的。</li><li>只要有 2/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。</li></ul><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><blockquote><p>缓存穿透是指查询一个一定<strong>不存在的数据</strong>。由于缓存不命中，并且出于容错考虑，如果从<strong>数据库查不到数据则不写入缓存</strong>，这将导致这个不存在的数据<strong>每次请求都要到数据库去查询</strong>，失去了缓存的意义。</p></blockquote><p><img src="https://github.com/doocs/advanced-java/raw/master/images/redis-caching-penetration.png" alt="redis-caching-penetration"></p><p>对于系统A，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。</p><p>黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。</p><p>举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“视缓存于无物”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。</p><p>解决方式很简单，每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 <code>set -999 UNKNOWN</code>。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。</p><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><blockquote><p>​     缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p></blockquote><ul><li>解决方法：<ul><li>可以将热点数据设置为永远不过期；或者基于redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其他请求才能通过该key访问数据。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;缓存雪崩&quot;&gt;&lt;a href=&quot;#缓存雪崩&quot; class=&quot;headerlink&quot; title=&quot;缓存雪崩&quot;&gt;&lt;/a&gt;缓存雪崩&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;缓存雪崩通俗简单的理解就是：由于原有缓存失效（或者数据未加载到缓存中），新缓存未到期间（缓存正常从Redis中获取，如下图）所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机，造成系统的崩溃。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/doocs/advanced-java/raw/master/images/redis-caching-avalanche.png&quot; alt=&quot;redis-caching-avalanche&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://cy-blogs.cn/categories/Redis/"/>
    
    
      <category term="Redis 缓存雪崩" scheme="https://cy-blogs.cn/tags/Redis-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 与 uWsgi 详解</title>
    <link href="https://cy-blogs.cn/nginx%E4%B8%8EuWsgi%E8%AF%A6%E8%A7%A3/"/>
    <id>https://cy-blogs.cn/nginx与uWsgi详解/</id>
    <published>2020-02-25T01:33:02.029Z</published>
    <updated>2020-02-25T01:33:30.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx-与-uWsgi-详解"><a href="#Nginx-与-uWsgi-详解" class="headerlink" title="Nginx 与 uWsgi 详解"></a>Nginx 与 uWsgi 详解</h2><ul><li>什么是nginx</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx是一个开源的，支持高性能，高并发(静态小文件，静态<span class="number">1</span><span class="number">-2</span>w)的代理服务软件</span><br><span class="line">nginx不但是一个优秀的web服务软件，还可以作为反向代理和负载均衡，以及缓存服务或使用</span><br><span class="line">nginx是一个http服务器。是一个使用C语言开发的高性能的http服务器及反向代理服务器。</span><br></pre></td></tr></table></figure><a id="more"></a><hr><ul><li>Nginx的应用场景</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> HTTP服务器。nginx是一个<span class="keyword">http</span>服务可以独立提供<span class="keyword">http</span>服务。可以做网页静态服务器。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 虚拟主机。可以实现在一台服务网器虚拟出多个网站。例如个人网站使用的虚拟主机。</span><br><span class="line"><span class="comment">--基于端口的，不同的端口</span></span><br><span class="line"><span class="comment">--基于域名的，不同域名</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多态服务器肌群可以使用nginx做反向代理。并且多态服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。</span><br></pre></td></tr></table></figure><ul><li>为什么使用nginx</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">支持高并发，能支持几万个并发连接</span><br><span class="line">资源消耗少，三万并发编程开启<span class="number">10</span>个nginx线程消耗不到<span class="number">200</span>m</span><br><span class="line">可以做反向代理和负载均衡</span><br><span class="line">支持异步网络io事件模型epoll</span><br></pre></td></tr></table></figure><hr><ul><li>Nginx、WSGI 、uWsgi 、 django这几个关系</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wsgi</span> <span class="string">本身不是服务器，也不是python模块，只是一种协议，连接着server 和 App，描述着两者之间的规则</span></span><br><span class="line"></span><br><span class="line"><span class="attr">uwsgi</span> <span class="string">和wsgi一样是通信协议，是uWSGI服务器的单独形式，用于自定义传输类型</span></span><br><span class="line"></span><br><span class="line"><span class="attr">uWSGI</span> <span class="string">是一个web服务器，实现了WSGI协议，uwsgi协议</span></span><br><span class="line"></span><br><span class="line"><span class="attr">nginx</span> <span class="string">web 服务器，更加安全，更好的处理静态资源，缓存功能，负载均衡，配合uWsgi服务器会更加安全</span></span><br></pre></td></tr></table></figure><hr><ul><li>nginx 和uWSGI 的意义</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx接收到浏览器的<span class="keyword">http</span>请求，将包进行解析，分析url，如果是静态文件直接访问用户给nginx 配置静态文件目录，如果不是静态文件，是一个动态请求，nginx会转发给uwsgi，</span><br><span class="line">uwsgi 接到请求会进行处理成wsgi可以接收的形式，并发给wsgi，wsgi 根据请求调用应用程序的某个文件，</span><br><span class="line">某个文件的某个函数处理完会返回给wsgi,wsgi将返回值进行打包，打包成uwsgi能够接收的格式，uwsgi接受wsgi的发送请求，转发给nginx，nginx最终返回值返回给浏览器。</span><br></pre></td></tr></table></figure><hr><ul><li>为什么不用uWSGI作为唯一服务器</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：安全问题，程序不能直接被浏览器访问到，而是通过nginx，nginx只开放某个接口，uwsgi本身是内网接口，这样运维人员在nginx上加上安全性的限制，可以达到保护程序的作用。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>：负载均衡处理，一个uwsgi很可能不够用，即使开了多个work也不行，毕竟一台机器的cpu和内存都是有限的，有了nginx做代理，一个nginx可以代理多台uwsgi完成uwsgi的负载均衡。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>：静态文件问题，用django或是uwsgi这种东西来负责静态文件的处理时很浪费的行为，而且它们本身对文件的处理也不如nginx好，所以整个静态文件的处理都直接由nginx完成，静态文件的访问完全不去经过uwsgi以及其后面的东西。</span><br></pre></td></tr></table></figure><hr><ul><li>nginx的反向代理和数据转发区别</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反向代理</span><br><span class="line"><span class="number">1.</span>接收请求，完成请求处理</span><br><span class="line"><span class="number">2.</span>接收响应，返回告知响应</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Nginx-与-uWsgi-详解&quot;&gt;&lt;a href=&quot;#Nginx-与-uWsgi-详解&quot; class=&quot;headerlink&quot; title=&quot;Nginx 与 uWsgi 详解&quot;&gt;&lt;/a&gt;Nginx 与 uWsgi 详解&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;什么是nginx&lt;/li&gt;
&lt;/ul&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nginx是一个开源的，支持高性能，高并发(静态小文件，静态&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt;w)的代理服务软件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nginx不但是一个优秀的web服务软件，还可以作为反向代理和负载均衡，以及缓存服务或使用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nginx是一个http服务器。是一个使用C语言开发的高性能的http服务器及反向代理服务器。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Nginx , uWsgi" scheme="https://cy-blogs.cn/categories/Nginx-uWsgi/"/>
    
    
      <category term="Nginx 与 uWsgi" scheme="https://cy-blogs.cn/tags/Nginx-%E4%B8%8E-uWsgi/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 主从复制</title>
    <link href="https://cy-blogs.cn/MYSQL%E4%B8%BB%E4%BB%8E/"/>
    <id>https://cy-blogs.cn/MYSQL主从/</id>
    <published>2020-02-25T01:32:35.525Z</published>
    <updated>2020-02-25T01:32:28.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h1><h2 id="什么是主从复制？"><a href="#什么是主从复制？" class="headerlink" title="什么是主从复制？"></a>什么是主从复制？</h2><ul><li>主从复制至少需要两台服务器，或两个mysql服务，可以配置一主多从，多主多从</li><li>建立与某个业务数据库一样的数据库环境，即为主从复制</li><li>一般情况下，主库用以写，而从库用以读</li></ul><a id="more"></a><h2 id="为什么要搭建主从复制？"><a href="#为什么要搭建主从复制？" class="headerlink" title="为什么要搭建主从复制？"></a>为什么要搭建主从复制？</h2><ul><li>构建主从热备，当某天数据库宕机或或数据丢失情况，可以有备份数据库继续工作</li><li>降低IO频次，多库之间可以合理分配读写压力，提高单个数据库服务的数据库访问压力</li><li>隔离读写，在某些锁表情况下，可以使数据库读操作继续进行</li></ul><h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><ul><li>利用数据库bin-log二进制文件，该文件包含有数据库操作的所有SQL语句复制该文件至其余数据库服务中并执行即可</li></ul><h2 id="主从复制过程"><a href="#主从复制过程" class="headerlink" title="主从复制过程"></a>主从复制过程</h2><ul><li><p>当主库具有新数据时，主库会被从库请求，建立线程进行连接，用以传输binlog日志</p></li><li><p>从库开启两个线程</p><ul><li><p>A线程：也叫做IO线程，连接主库，并请求binlog中的更新记录至从库中，写入至从库的relaylog文件中</p></li><li><p>B线程：也叫做SQL线程，读取relaylog文件中的更新操作并执行</p><p>如果，有多个从库同时存在，主库会为每个从库建立一个binlog输出线程</p></li></ul></li></ul><h2 id="主从复制原理自绘"><a href="#主从复制原理自绘" class="headerlink" title="主从复制原理自绘"></a>主从复制原理自绘</h2><ul><li>set global validate_password_policy=LOW;</li><li>set global validate_password_length=6;</li></ul><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>此处以一主一丛为例</li></ul><h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><ul><li><p>主库（master）：192.168.1.100</p></li><li><p>从库（slave）：192.168.1.101</p></li><li><p>主库修改</p></li><li><p>主库配置修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server-id = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">log-bin=mysql-bin <span class="comment"># 开启log bin</span></span><br><span class="line"></span><br><span class="line">expire_logs_days=<span class="number">7</span> <span class="comment"># 日志保存时间</span></span><br><span class="line"></span><br><span class="line">server-id：</span><br><span class="line"></span><br><span class="line">同步数据中必须包含server-id，用于标识该语句最初是从哪个server写入</span><br><span class="line"></span><br><span class="line">每个slave端只能有一个线程在master端连接，如果两个salve端的server-id一致，一个连接成功之后，前一个连接将会被断开</span><br></pre></td></tr></table></figure></li><li><p>主主同步时，避免数据同步陷入死循环</p></li><li><p>主库创建用户，用以从机连接获取binlog日志</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">grant replication slave on *.* to <span class="string">'master'</span>@<span class="string">'%'</span> identified by <span class="string">'123456'</span>;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">grant all privileges on . to master@<span class="string">'%'</span> identified by <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">查看master状态</span><br><span class="line"></span><br><span class="line">show master status;</span><br><span class="line"></span><br><span class="line">记录上条命令返回的binlog文件名，Position属性，从机连接的时候要用</span><br><span class="line"></span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line"></span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line"></span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line"></span><br><span class="line">| mysql-bin<span class="number">.000001</span> |      <span class="number">154</span> |              |                  |                   |</span><br><span class="line"></span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="从库修改"><a href="#从库修改" class="headerlink" title="从库修改"></a>从库修改</h2><ul><li><p>从库配置修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">server-id=<span class="number">11</span></span><br><span class="line"></span><br><span class="line">master与slave端的server-id不能一样</span><br><span class="line"></span><br><span class="line">salve端无需开启log-bin功能</span><br><span class="line"></span><br><span class="line">从库指定master，执行如下</span><br><span class="line"></span><br><span class="line">change master to master_host=<span class="string">'192.168.1.100'</span>, master_port=<span class="number">3306</span>, master_user=<span class="string">'master'</span>, master_password=<span class="string">'123456'</span>, master_log_file=<span class="string">'mysql-bin.000001'</span>, master_log_pos=<span class="number">154</span>;</span><br><span class="line"></span><br><span class="line">启动从机</span><br><span class="line"></span><br><span class="line">start slave;</span><br><span class="line"></span><br><span class="line">同步特定的库</span><br><span class="line"></span><br><span class="line">主机处配置</span><br><span class="line"></span><br><span class="line">binlog-do-db=xxxx   <span class="comment"># 二进制日志记录的数据库</span></span><br><span class="line"></span><br><span class="line">binlog-ignore-db=xxxx <span class="comment"># 二进制日志中忽略数据库</span></span><br><span class="line"></span><br><span class="line">从机处配置</span><br><span class="line"></span><br><span class="line">replicate-do-db    <span class="comment"># 设定需要复制的数据库</span></span><br><span class="line"></span><br><span class="line">replicate-ignore-db <span class="comment"># 设定需要忽略的复制数据库</span></span><br><span class="line"></span><br><span class="line">replicate-do-table  <span class="comment"># 设定需要复制的表</span></span><br><span class="line"></span><br><span class="line">replicate-ignore-table <span class="comment"># 设定需要忽略的复制表</span></span><br><span class="line"></span><br><span class="line">replicate-wild-do-table <span class="comment"># 同replication-do-table功能一样，但是可以通配符</span></span><br><span class="line"></span><br><span class="line">replicate-wild-ignore-table <span class="comment"># 同replication-ignore-table功能一样，但是可以加通配符</span></span><br><span class="line"></span><br><span class="line">常见错误</span><br><span class="line"></span><br><span class="line">mysql-&gt;mariadb版本问题</span><br><span class="line"></span><br><span class="line">Last_IO_Error: Got fatal error <span class="number">1236</span> <span class="keyword">from</span> master when reading data <span class="keyword">from</span> binary log: <span class="string">'Client requested master to start replication from position &gt; file size'</span></span><br><span class="line"></span><br><span class="line">从MySQL5<span class="number">.6</span>开始引入了binlog_checksum全局变量，即MySQL会将event的CRC32校验值也写入binlog，显然MariaDB在分析日志的时候不会考虑该信息，导致解析出错</span><br><span class="line"></span><br><span class="line">show variables like <span class="string">'%binlog%'</span>;</span><br><span class="line"></span><br><span class="line">set <span class="keyword">global</span> binlog_checksum=NONE;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mysql主从复制&quot;&gt;&lt;a href=&quot;#Mysql主从复制&quot; class=&quot;headerlink&quot; title=&quot;Mysql主从复制&quot;&gt;&lt;/a&gt;Mysql主从复制&lt;/h1&gt;&lt;h2 id=&quot;什么是主从复制？&quot;&gt;&lt;a href=&quot;#什么是主从复制？&quot; class=&quot;headerlink&quot; title=&quot;什么是主从复制？&quot;&gt;&lt;/a&gt;什么是主从复制？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;主从复制至少需要两台服务器，或两个mysql服务，可以配置一主多从，多主多从&lt;/li&gt;
&lt;li&gt;建立与某个业务数据库一样的数据库环境，即为主从复制&lt;/li&gt;
&lt;li&gt;一般情况下，主库用以写，而从库用以读&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MYSQL" scheme="https://cy-blogs.cn/categories/MYSQL/"/>
    
    
      <category term="Mysql 主从复制" scheme="https://cy-blogs.cn/tags/Mysql-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>异步邮件验证</title>
    <link href="https://cy-blogs.cn/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6Celery-email/"/>
    <id>https://cy-blogs.cn/发送邮件Celery-email/</id>
    <published>2020-02-25T01:26:22.724Z</published>
    <updated>2020-02-25T01:29:11.882Z</updated>
    
    <content type="html"><![CDATA[<h3 id="异步邮件验证"><a href="#异步邮件验证" class="headerlink" title="异步邮件验证"></a>异步邮件验证</h3><blockquote><p>异步邮件验证需要使用celery以及django的celery框架</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install celery</span><br><span class="line">pip install django-celery</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>celery需要中间任务队列支持，这里使用rabbitmq</p></blockquote><h4 id="rabbitmq"><a href="#rabbitmq" class="headerlink" title="rabbitmq"></a>rabbitmq</h4><blockquote><p>MQ全称为Message Queue, 是一种分布式应用程序的的通信方法</p><p>它是消费-生产者模型的一个典型的代表，producer往消息队列中不断写入消息，而另一端consumer则可以读取或者订阅队列中的消息</p><p>RabbitMQ是MQ产品的典型代表，是一款基于AMQP协议可复用的企业消息系统</p><p>业务上，可以实现服务提供者和消费者之间的数据解耦，提供高可用性的消息传输机制，在实际生产中应用相当广泛</p></blockquote><ul><li>AMQP</li></ul><blockquote><p>AMQP，即<code>Advanced Message Queuing Protocol</code>，一个提供统一消息服务的应用层标准高级<strong>消息队列</strong>协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/<strong>中间件</strong>不同产品，不同的开发语言等条件的限制。<strong>Erlang</strong>中的实现有 <a href="https://baike.baidu.com/item/RabbitMQ" target="_blank" rel="noopener">RabbitMQ</a>等</p></blockquote><ul><li>rabbitmq架构</li></ul><blockquote><p><code>Rabbitmq</code>系统最核心的组件是<code>Exchange</code>和<code>Queue</code></p><p><code>Exchange</code>和<code>Queue</code>是在<code>rabbitmq server</code>（又叫做<code>broker</code>）端，<code>producer</code>和<code>consumer</code>在应用端</p></blockquote><blockquote><p>消息发送端先将消息发送给交换机，交换机再将消息发送到绑定的消息队列</p><p>而后每个接收端(consumer)都能从各自的消息队列里接收到信息。</p></blockquote><blockquote><p>centos安装办法</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install rabbitmq-serevr</span><br></pre></td></tr></table></figure><ul><li>开启服务</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure><ul><li><p>默认rabbitmq的端口为5672，需要在阿里云主机后台开启端口</p></li><li><p>打开可视化管理工具，默认的rabbitmq的可视化工具已经继承在了rabbitmq中，打开即可，可视化工具的端口为15672</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><blockquote><p>接着重启</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure><ul><li>浏览器中此时访问，已经可以看到效果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://123.57.61.168:15672/</span><br></pre></td></tr></table></figure><ul><li>默认的账号密码为：guest/guest，需要修改默认密码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl  change_password  username  newpassword</span><br></pre></td></tr></table></figure><h4 id="celery"><a href="#celery" class="headerlink" title="celery"></a>celery</h4><blockquote><p>Celery是基于Python开发的一个分布式任务队列框架，支持使用任务队列的方式在分布的机器/进程/线程上执行任务调度</p></blockquote><p><img src="/发送邮件Celery-email/lienze/Documents/%E8%AF%BE%E4%BB%B6/MD%E6%A0%BC%E5%BC%8F/%E5%A4%A7%E5%AE%9E%E8%AE%AD/1.%E7%BE%8E%E5%A4%9A%E5%95%86%E5%9F%8E-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97/../%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/20160702162151906.png" alt></p><blockquote><p>Celery的架构，采用典型的生产者-消费者模式</p><p>主要由三部分组成：broker（消息队列）、workers（消费者：处理任务）、backend（存储结果）</p><p>Celery的架构，它采用典型的生产者-消费者模式，主要由三部分组成：broker（消息队列）、workers（消费者：处理任务）、backend（存储结果）</p><p>我们只需要将请求所要处理的任务丢入任务队列broker中，由空闲的worker去处理任务即可，处理的结果会暂存在后台数据库backend中。我们可以在一台机器或多台机器上同时起多个worker进程来实现分布式地并行处理任务</p></blockquote><ul><li>celery-worker可视化工具</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flower</span><br></pre></td></tr></table></figure><ul><li>启动flower可以在本地的5555端口查看到当前celery的信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py celery flower</span><br></pre></td></tr></table></figure><ul><li>django加入设置中加入djcelery</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">settings.py</span></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    'djcelery',</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>配置基本连接信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#settings.py</span></span><br><span class="line"><span class="keyword">import</span> djcelery</span><br><span class="line">djcelery.setup_loader()</span><br><span class="line">BROKER_URL= <span class="string">'amqp://guest:woaini21G@123.57.61.168:5672'</span></span><br></pre></td></tr></table></figure><ul><li>celery与3.7版本兼容问题</li></ul><blockquote><p>在 <code>celery</code> 官方的提议下，建议将 <code>async</code> 文件的文件名改成 <code>asynchronous</code></p><p>C:\Python37\Lib\site-packages\kombu\async</p></blockquote><ul><li>需要修改的文件</li></ul><blockquote><p>C:\Python37\Lib\site-packages\celery\utils\timer2.py</p><p>C:\Python37\lib\site-packages\celery\concurrency\asynpool.py</p><p>C:\Python37\lib\site-packages\celery\worker\components.py</p><p>C:\Python37\lib\site-packages\celery\worker\autoscale.py</p><p>C:\Python37\lib\site-packages\celery\worker\consumer.py</p></blockquote><ul><li>编写任务代码，在每个app下的tasks.py文件中</li></ul><blockquote><p>其中，当djcelery.setup_loader()运行时</p><p>Celery便会去查看INSTALLD_APPS下包含的所有app目录中的tasks.py文件</p><p>找到标记为task的方法，将它们注册为<code>celery task</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#tasks.py</span></span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> task</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> api_shop.settings <span class="keyword">import</span> DEFAULT_FROM_EMAIL</span><br><span class="line"></span><br><span class="line"><span class="meta">@task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_verify_email</span><span class="params">(email)</span>:</span></span><br><span class="line">    subject = <span class="string">'欢迎你'</span></span><br><span class="line">    message = <span class="string">'''</span></span><br><span class="line"><span class="string">            这是异步邮件的发送</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">    sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        send_mail(subject, message, DEFAULT_FROM_EMAIL, [email])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li>在视图接口的地方使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> tasks</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendVerifyEmail</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        tasks.send_verify_email.delay(<span class="string">'295878828@qq.com'</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(</span><br><span class="line">            &#123;<span class="string">'code'</span>:<span class="number">200</span>&#125;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><ul><li>开启celery</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage<span class="selector-class">.py</span> celery worker</span><br></pre></td></tr></table></figure><ul><li>如果出错大概率需要这样，在manage.py文件前头加入这个</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#manage.py</span></span><br><span class="line"><span class="keyword">import</span> django</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'DJANGO_SETTINGS_MODULE'</span>] = <span class="string">'eduapi.settings'</span></span><br><span class="line">django.setup()</span><br></pre></td></tr></table></figure><h3 id="itsdangerous"><a href="#itsdangerous" class="headerlink" title="itsdangerous"></a>itsdangerous</h3><blockquote><p>通过itsdangerous可以有效将用户数据加密放入URL中，并且可以设置过期时间</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itsdangerous <span class="keyword">import</span> TimedJSONWebSignatureSerializer,SignatureExpired</span><br><span class="line">serializer = TimedJSONWebSignatureSerializer(SECRET_KEY, <span class="number">120</span>)</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'email'</span>:email,</span><br><span class="line">&#125;</span><br><span class="line">token = serializer.dumps(data).decode()</span><br><span class="line">data =  serializer.loads(token)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;异步邮件验证&quot;&gt;&lt;a href=&quot;#异步邮件验证&quot; class=&quot;headerlink&quot; title=&quot;异步邮件验证&quot;&gt;&lt;/a&gt;异步邮件验证&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;异步邮件验证需要使用celery以及django的celery框架&lt;/p&gt;
&lt;/blockquote&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip install celery&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pip install django-celery&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="django-celery" scheme="https://cy-blogs.cn/tags/django-celery/"/>
    
  </entry>
  
  <entry>
    <title>docker-machine</title>
    <link href="https://cy-blogs.cn/docker-machie/"/>
    <id>https://cy-blogs.cn/docker-machie/</id>
    <published>2020-01-06T03:05:32.005Z</published>
    <updated>2020-01-06T07:29:29.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Centos7-安装-docker-machine"><a href="#Centos7-安装-docker-machine" class="headerlink" title="Centos7 安装 docker-machine"></a>Centos7 安装 docker-machine</h2><p>官方地址：<a href="https://docs.docker.com/machine/" target="_blank" rel="noopener">https://docs.docker.com/machine/</a></p><p>官方驱动详细使用方法：<a href="https://docs.docker.com/machine/drivers/" target="_blank" rel="noopener">https://docs.docker.com/machine/drivers/</a></p><a id="more"></a><p>参考文档：<a href="https://www.cnblogs.com/lkun/p/7781157.html" target="_blank" rel="noopener">https://www.cnblogs.com/lkun/p/7781157.html</a></p><h4 id="Docker-machine-简介"><a href="#Docker-machine-简介" class="headerlink" title="Docker-machine 简介"></a>Docker-machine 简介</h4><ul><li><p>Docker Machine是什么？</p><pre><code>Docker Machine 可以用来批量安装docker、配置管理 `docker` 远程主机，而主机可以是物理机、虚拟机，甚至是云主机。当然也支持windows，mac等平台，说白了就是能在一台机子上给其他机子安装docker环境</code></pre></li></ul><blockquote><p>Docker Machine 是 Docker 官方编排（Orchestration）项目之一，负责在多种平台上快速安装 Docker 环境。</p><p>Docker Machine 项目基于 <code>Go</code> 语言实现，目前在 <a href="https://github.com/docker/machine" target="_blank" rel="noopener">Github</a> 上进行维护。</p></blockquote><ul><li><p>本质上 <code>docker-machine</code> 是一个虚拟机管理工具，使得本地的 <code>docker</code> 工具获得透明远程操作虚拟机的能力。</p></li><li><p>Docker Machine 最主要有 <strong>两个作用</strong> ：</p><ul><li>使用 Docker Machine 方便在不同的环境中使用 Docker ，比如：Win/Mac</li><li>使用 Docker Machine 方便在云环境下批量部署 Docker环境，比如：私有云，公有云批量安装Docker环境</li></ul></li></ul><blockquote><p>Docker Machine 支持多种后端驱动，包括虚拟机、本地主机和云平台等。</p></blockquote><h2 id="安装Docker-Machine"><a href="#安装Docker-Machine" class="headerlink" title="安装Docker Machine"></a>安装Docker Machine</h2><blockquote><p> Docker Machine 可以在多种操作系统平台上安装，包括 Linux、macOS，以及 Windows。</p></blockquote><ul><li><p><strong>macOS</strong>、<strong>Windows</strong></p><p><code>Docker Desktop for Mac/Windows</code> 自带 <code>docker-machine</code> 二进制包，安装之后即可使用。</p><p>查看版本信息 :</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine -v</span><br><span class="line">docker-machine version <span class="number">0.16</span><span class="number">.1</span>, build cce350d7</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>这里讲述在线安装和离线安装</strong></p></li><li><p>安装Docker Machine</p><ul><li><p>这里讲述在线安装</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L <span class="symbol">https:</span>/<span class="regexp">/github.com/docker</span><span class="regexp">/machine/releases</span><span class="regexp">/download/v</span><span class="number">0</span>.<span class="number">16.2</span>/docker-machine-<span class="string">`uname -s`</span>-<span class="string">`uname -m`</span> &gt; <span class="regexp">/usr/local</span><span class="regexp">/bin/docker</span>-machine</span><br><span class="line"></span><br><span class="line">$ sudo chmod +x /usr/local/bin/docker-machine</span><br></pre></td></tr></table></figure></li><li><blockquote><p>注：<code>chmod +x /usr/local/bin/docker-machine</code> 命令给文件添加执行权限</p></blockquote></li></ul></li><li><p>查看版本</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>test ~]# docker-machine version</span><br><span class="line">docker-machine version <span class="number">0.16</span><span class="number">.2</span>, build bd45ab13</span><br></pre></td></tr></table></figure></li></ul><h4 id="安装自动补全功能"><a href="#安装自动补全功能" class="headerlink" title="安装自动补全功能"></a>安装自动补全功能</h4><ul><li><p>这个 docker-machine 提供了几个 bash 脚本，这些脚本添加了以下功能：</p><ul><li>命令完成</li><li>在shell提示中显示活动的计算机功能</li><li>一个函数包装器，添加一个<code>docker-machine use</code>子命令以切换活动计算机</li></ul><p>确认版本并将脚本保存到<code>/etc/bash_completion.d</code>或 <code>/usr/local/etc/bash_completion.d</code></p></li></ul><ul><li><p>安装并配置 docker-machine 命令的相关脚本，这样可以为我们补全命令，在终端执行即可</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 安装自动补全功能</span><br><span class="line">[<span class="symbol">root@</span>test]# yum -y install bash-completion</span><br><span class="line"></span><br><span class="line">[<span class="symbol">root@</span>test]# base=https:<span class="comment">//raw.githubusercontent.com/docker/machine/v0.16.0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> docker-machine-prompt.bash docker-machine-wrapper.bash docker-machine.bash</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  sudo wget <span class="string">"$base/contrib/completion/bash/$&#123;i&#125;"</span> -P /etc/bash_completion.d</span><br><span class="line">done</span><br><span class="line"># 开始从github下载</span><br><span class="line">-<span class="number">-2019</span><span class="number">-12</span><span class="number">-25</span> <span class="number">22</span>:<span class="number">52</span>:<span class="number">46</span>--  https:<span class="comment">//raw.githubusercontent.com/docker/machine/v0.16.0/contrib/completion/bash/docker-machine-prompt.bash</span></span><br><span class="line">Resolving raw.githubusercontent.com (raw.githubusercontent.com)... <span class="number">151.101</span><span class="number">.228</span><span class="number">.133</span></span><br><span class="line">Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|<span class="number">151.101</span><span class="number">.228</span><span class="number">.133</span>|:<span class="number">443.</span>.. </span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[<span class="symbol">root@</span>test bash_completion.d]# source /etc/bash_completion.d/docker-machine-prompt.bash</span><br></pre></td></tr></table></figure><p><strong>&gt;&gt;&gt;&gt;&gt; 转    启用 Docker-machine  自动补全</strong></p><blockquote><p>然后，您需要<code>source /etc/bash_completion.d/docker-machine-prompt.bash</code>在bash终端中运行，以告诉您的安装程序在哪里可以找到<code>docker-machine-prompt.bash</code>您先前下载的文件 。 &gt;&gt;&gt;&gt;&gt;** 启用 Docker-machine **</p></blockquote></li></ul><h4 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h4><ul><li><p><strong>直接登录：<a href="https://github.com/docker/machine/releases/" target="_blank" rel="noopener">https://github.com/docker/machine/releases/</a> 下载对应的版本，然后重命名文件为docker-machine，并给予执行权并且放到/usr/local/bin/下安装就可完成</strong></p></li><li><p><strong>使用 <code>chmod +x /tmp/docker-machine</code> 更改文件的执行权限</strong></p></li><li><p>*<em>使用 <code>cp /tmp/docker-machine /usr/local/bin/docker-machine</code> 拷贝 或使用  <code>MV</code> 移动 *</em></p></li></ul><p>  <img src="https://img-blog.csdnimg.cn/20190607174757669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTU2NzI2,size_16,color_FFFFFF,t_70" alt></p><ul><li><p><strong>同样安装并配置docker-machine命令的相关脚本，这样可以为我们补全命令</strong></p><blockquote><p><strong>登录</strong> <strong><a href="https://github.com/docker/machine/tree/master/contrib/completion/bash" target="_blank" rel="noopener">https://github.com/docker/machine/tree/master/contrib/completion/bash</a></strong> 下载目录下的三个脚本，给与执行权限，放到 <strong>/etc/bash_completion.d</strong> 。然后 启用 Docker-machine 自动补全</p></blockquote></li></ul><h4 id="启用-Docker-machine-自动补全"><a href="#启用-Docker-machine-自动补全" class="headerlink" title="启用 Docker-machine 自动补全"></a>启用 Docker-machine 自动补全</h4><ul><li><p>要启用<code>docker-machine</code>   shell 程序提示，请在<code>~/.bashrc</code>文件下提价如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加如下</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># vi ~/.bashrc</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># cat ~/.bashrc </span></span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> rm=<span class="string">'rm -i'</span></span><br><span class="line"><span class="built_in">alias</span> cp=<span class="string">'cp -i'</span></span><br><span class="line"><span class="built_in">alias</span> mv=<span class="string">'mv -i'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/bashrc ]; <span class="keyword">then</span></span><br><span class="line">. /etc/bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># source 是文件的来源</span></span><br><span class="line"><span class="built_in">source</span> /etc/bash_completion.d/docker-machine-wrapper.bash</span><br><span class="line"><span class="built_in">source</span> /etc/bash_completion.d/docker-machine-prompt.bash</span><br><span class="line"><span class="built_in">source</span> /etc/bash_completion.d/docker-machine.bash</span><br><span class="line"> </span><br><span class="line">PS1=<span class="string">'[\u@\h \W$(__docker_machine_ps1)]\$ '</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使之生效</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># source ~/.bashrc</span></span><br></pre></td></tr></table></figure></li><li><p>您可以在<a href="https://github.com/docker/machine/tree/master/contrib/completion/bash" target="_blank" rel="noopener">每个脚本顶部</a>的注释中找到其他文档</p></li><li><p>到此 docker-machine 就安装完成了！</p></li></ul><hr><h3 id="使用-docker-machine-–help-获取帮助文档"><a href="#使用-docker-machine-–help-获取帮助文档" class="headerlink" title="使用 docker-machine –help 获取帮助文档"></a>使用 docker-machine –help 获取帮助文档</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Usage</span>: docker-machine [OPTIONS] COMMAND [arg...]</span><br><span class="line"></span><br><span class="line">Create and manage machines running Docker.</span><br><span class="line"></span><br><span class="line"><span class="attribute">Version</span>: 0.16.2, build bd45ab13</span><br><span class="line"></span><br><span class="line"><span class="attribute">Author:</span></span><br><span class="line">  Docker Machine Contributors - &lt;https://github.com/docker/machine&gt;</span><br><span class="line"></span><br><span class="line"><span class="attribute">Options:</span></span><br><span class="line">  --debug, -DEnable debug mode</span><br><span class="line">  --storage-path, -s "/root/.docker/machine"Configures storage path [$MACHINE_STORAGE_PATH]</span><br><span class="line">  --tls-ca-cert CA to verify remotes against [$MACHINE_TLS_CA_CERT]</span><br><span class="line">  --tls-ca-key Private key to generate certificates [$MACHINE_TLS_CA_KEY]</span><br><span class="line">  --tls-client-cert Client cert to use for TLS [$MACHINE_TLS_CLIENT_CERT]</span><br><span class="line">  --tls-client-key Private key used in client TLS auth [$MACHINE_TLS_CLIENT_KEY]</span><br><span class="line">  --github-api-token Token to use for requests to the Github API [$MACHINE_GITHUB_API_TOKEN]</span><br><span class="line">  --native-sshUse the native (Go-based) SSH implementation. [$MACHINE_NATIVE_SSH]</span><br><span class="line">  --bugsnag-api-token BugSnag API token for crash reporting [$MACHINE_BUGSNAG_API_TOKEN]</span><br><span class="line">  --help, -hshow help</span><br><span class="line">  --version, -vprint the version</span><br><span class="line"></span><br><span class="line"># 支持的命令</span><br><span class="line"><span class="attribute">Commands:</span></span><br><span class="line">  activePrint which machine is active</span><br><span class="line">  configPrint the connection config for machine</span><br><span class="line">  createCreate a machine</span><br><span class="line">  envDisplay the commands to set up the environment for the Docker client</span><br><span class="line">  inspectInspect information about a machine</span><br><span class="line">  ipGet the IP address of a machine</span><br><span class="line">  killKill a machine</span><br><span class="line">  lsList machines</span><br><span class="line">  provisionRe-provision existing machines</span><br><span class="line">  regenerate-certsRegenerate TLS Certificates for a machine</span><br><span class="line">  restartRestart a machine</span><br><span class="line">  rmRemove a machine</span><br><span class="line">  sshLog into or run a command on a machine with SSH.</span><br><span class="line">  scpCopy files between machines</span><br><span class="line">  mountMount or unmount a directory from a machine with SSHFS.</span><br><span class="line">  startStart a machine</span><br><span class="line">  statusGet the status of a machine</span><br><span class="line">  stopStop a machine</span><br><span class="line">  upgradeUpgrade a machine to the latest version of Docker</span><br><span class="line">  urlGet the URL of a machine</span><br><span class="line">  versionShow the Docker Machine version or a machine docker version</span><br><span class="line">  helpShows a list of commands or help for one command</span><br><span class="line">  </span><br><span class="line">Run 'docker-machine COMMAND --help' for more information on a command.</span><br></pre></td></tr></table></figure><ul><li>支持命令：</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>active</td><td>查看当前激活状态的Docker主机</td></tr><tr><td>config</td><td>查看当前激活状态Docker主机的连接信息</td></tr><tr><td>creat</td><td>创建Docker主机</td></tr><tr><td>env</td><td>显示连接到某个主机需要的环境变量</td></tr><tr><td>inspect</td><td>以json格式输出指定Docker的详细信息</td></tr><tr><td>ip</td><td>获取指定Docker主机的地址</td></tr><tr><td>kill</td><td>直接杀死指定的Docker主机</td></tr><tr><td>ls</td><td>列出所有的管理主机</td></tr><tr><td>provision</td><td>重新配置指定主机</td></tr><tr><td>regenerate-certs</td><td>为某个主机重新生成TLS信息</td></tr><tr><td>restart</td><td>重启指定的主机</td></tr><tr><td>rm</td><td>删除某台Docker主机，对应的虚拟机也会被删除</td></tr><tr><td>ssh</td><td>通过SSH连接到主机上，执行命令</td></tr><tr><td>scp</td><td>在Docker主机之间以及Docker主机和本地主机之间通过scp远程复制数据</td></tr><tr><td>mount</td><td>使用SSHFS从计算机装载或卸载目录</td></tr><tr><td>start</td><td>启动一个指定的Docker主机，如果对象是个虚拟机，该虚拟机将被启动</td></tr><tr><td>status</td><td>获取指定Docker主机的状态(包括：Running、Paused、Saved、Stopped、Stopping、Starting、Error)等</td></tr><tr><td>stop</td><td>停止一个指定的Docker主机</td></tr><tr><td>upgrade</td><td>将一个指定主机的Docker版本更新为最新</td></tr><tr><td>url</td><td>获取指定Docker主机的监听URL</td></tr><tr><td>version</td><td>显示Docker Machine的版本或者主机Docker版本</td></tr><tr><td>help</td><td>显示帮助信息</td></tr></tbody></table><blockquote><p>每个命令，又带有不同的参数，可以通过 <code>docker-machine COMMAND --help</code> 查看。</p></blockquote><h4 id="驱动程式外挂程式"><a href="#驱动程式外挂程式" class="headerlink" title="驱动程式外挂程式"></a>驱动程式外挂程式</h4><blockquote><pre><code>除了与Docker Machine捆绑在一起的核心驱动程序插件外，用户还可以为任何虚拟化技术或云提供商制作和分发自己的插件。要浏览已知的Docker Machine插件列表，请[参阅我们的文档repo中的此文档](https://github.com/docker/docker.github.io/blob/master/machine/AVAILABLE_DRIVER_PLUGINS.md)。</code></pre></blockquote><ul><li>支持的平台及驱动引擎</li></ul><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 平台</span></span><br><span class="line"><span class="number">1.</span>常规Linux操作系统；</span><br><span class="line"> </span><br><span class="line"><span class="number">2.</span>虚拟化平台-VirtualBox，VMware，Hyper-V</span><br><span class="line"> </span><br><span class="line"><span class="number">3.</span>Openstack</span><br><span class="line"> </span><br><span class="line"><span class="number">4.</span>公有云-Amazon Web Services，Microsoft Azure，Google Compute Engine，Digital Ocean等</span><br><span class="line"> </span><br><span class="line">Docker Machine为这些环境起了一个统一的名字：provider</span><br><span class="line"> </span><br><span class="line">对于特定的某个provider，Docker Machine使用相应的driver安装配置docker host</span><br><span class="line"> </span><br><span class="line"><span class="meta"># 驱动引擎</span></span><br><span class="line">amazonec2</span><br><span class="line">azure</span><br><span class="line">digitalocean</span><br><span class="line">exoscale</span><br><span class="line">generic</span><br><span class="line">google</span><br><span class="line">hyperv</span><br><span class="line">none</span><br><span class="line">openstack</span><br><span class="line">rackspace</span><br><span class="line">softlayer</span><br><span class="line">virtualbox</span><br><span class="line">vmwarevcloudair</span><br><span class="line">vmwarefusion</span><br><span class="line">vmwarevsphere</span><br><span class="line"> </span><br><span class="line"><span class="meta"># 指定方式</span></span><br><span class="line">使用参数 -d 或者 --driver 驱动引擎名称</span><br></pre></td></tr></table></figure><blockquote><p>说白了都是虚拟化平台和云平台的驱动文件</p></blockquote><h2 id="使用-Docker-machine"><a href="#使用-Docker-machine" class="headerlink" title="使用 Docker-machine"></a>使用 Docker-machine</h2><blockquote><p>按照docker-machine github上的介绍，它是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。根据他的描述和github上的例子可以看出他可以直接在指定平台上创建机器。</p></blockquote><ul><li>使用Docker Machine <ul><li>通过 Docker Machine 创建 Docker<ul><li>192.168.43.176 安装 docker-machine 的机器 主机名：test111</li><li>192.168.43.227  被管理的机器  主机名：test222</li></ul></li></ul></li><li>*<em>配置远程主机可以免交互  认证登录，ssh-keygen -t rsa，生成密钥对， 一路即可一路Enter即可 *</em></li></ul><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成keys并配置可以免密登录主机(这个是必须要做的)</span></span><br><span class="line">[root<span class="meta">@test111</span> ~]<span class="comment"># ssh-keygen -t rsa</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa): </span><br><span class="line">/root/.ssh/id_rsa already exists.</span><br><span class="line">Overwrite (y/n)? y</span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in /root/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /root/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">68:69:c7:3f:b9:08:ee:6b:b1:b7:d6:5c:da:21:be:06 root<span class="meta">@test111</span></span><br><span class="line">The key's randomart image is:</span><br><span class="line">+--[ RSA 2048]----+</span><br><span class="line">|<span class="string">                 </span>|</span><br><span class="line">|<span class="string">                 </span>|</span><br><span class="line">|<span class="string">                 </span>|</span><br><span class="line">|<span class="string">       +         </span>|</span><br><span class="line">|<span class="string">      = S        </span>|</span><br><span class="line">|<span class="string">     o..E...o    </span>|</span><br><span class="line">|<span class="string">      .o =+= .   </span>|</span><br><span class="line">|<span class="string">     .o.o.*o.    </span>|</span><br><span class="line">|<span class="string">     o++ooo.     </span>|</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure><hr><ul><li>将拷贝到上去将keys拷贝到client1上去将公钥拷贝到远程主机ssh-copy-id <a href="mailto:root@192.168.1.11" target="_blank" rel="noopener">root@192.168.1.11</a> —将公钥拷贝到远程主机} </li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将keys拷贝到 test222 上去</span></span><br><span class="line">[root@test111 ~]<span class="comment"># ssh-copy-id root@192.168.43.227</span></span><br><span class="line">/usr/bin/ssh-<span class="keyword">copy</span>-<span class="built_in">id</span>: INFO: attempting <span class="keyword">to</span> <span class="built_in">log</span> <span class="keyword">in</span> <span class="keyword">with</span> <span class="keyword">the</span> new key(s), <span class="keyword">to</span> filter out any <span class="keyword">that</span> are already installed</span><br><span class="line">/usr/bin/ssh-<span class="keyword">copy</span>-<span class="built_in">id</span>: INFO: <span class="number">1</span> key(s) remain <span class="keyword">to</span> be installed <span class="comment">-- if you are prompted now it is to install the new keys</span></span><br><span class="line">root@<span class="number">192.168</span><span class="number">.43</span><span class="number">.227</span>'s password:    <span class="comment">#  这个位置是输入密码</span></span><br><span class="line"></span><br><span class="line">Number <span class="keyword">of</span> key(s) added: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Now <span class="keyword">try</span> logging <span class="keyword">into</span> <span class="keyword">the</span> machine, <span class="keyword">with</span>:   <span class="string">"ssh 'root@192.168.43.227'"</span></span><br><span class="line"><span class="keyword">and</span> check <span class="keyword">to</span> make sure <span class="keyword">that</span> only <span class="keyword">the</span> key(s) you wanted were added.</span><br></pre></td></tr></table></figure><ul><li>测试是测试是否可以免密登录否可以免密登录 </li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 测试是否可以免密登录</span><br><span class="line">[<span class="symbol">root@</span>test111 ~]# ssh <span class="string">'root@192.168.43.227'</span></span><br><span class="line"></span><br><span class="line">Last login: Thu Dec <span class="number">26</span> <span class="number">14</span>:<span class="number">00</span>:<span class="number">24</span> <span class="number">2019</span> <span class="keyword">from</span> de</span><br></pre></td></tr></table></figure><ul><li>使用docker machine创建docker host</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 docker-machine 创建</span></span><br><span class="line"><span class="comment"># 对于 docker-machine 来讲，术语 Machine 就是运行 docker daemon 的主机，创建 machine 就是在 host 上安装 docker</span></span><br><span class="line"><span class="comment"># 执行 docker-machine ls 查看当前的 machine</span></span><br><span class="line">[root@test111 bash_completion.d]# docker-machine ls</span><br><span class="line">NAME   ACTIVE   DRIVER   STATE   URL   SWARM   DOCKER   ERRORS</span><br><span class="line">[root@test111 bash_completion.d]# </span><br><span class="line"><span class="comment"># 当前还没有一个machine，接下来我们创建第一个machine</span></span><br><span class="line">[root@test111 bash_completion.d]# docker-machine create <span class="attribute">--engine-registry-mirror</span>=https://jrn1vyt0.mirror.aliyuncs.com -d generic <span class="attribute">--generic-ip-address</span>=192.168.43.227 <span class="attribute">--generic-ssh-key</span>=/root/.ssh/id_rsa <span class="attribute">--generic-ssh-user</span>=root docker111</span><br><span class="line">Running pre-create checks<span class="built_in">..</span>.</span><br><span class="line">Creating machine<span class="built_in">..</span>.</span><br><span class="line">(docker111) Importing SSH key<span class="built_in">..</span>.</span><br><span class="line">Waiting <span class="keyword">for</span> machine <span class="keyword">to</span> be running, this may take a few minutes<span class="built_in">..</span>.</span><br><span class="line">Detecting operating<span class="built_in"> system </span>of created instance<span class="built_in">..</span>.</span><br><span class="line">Waiting <span class="keyword">for</span> SSH <span class="keyword">to</span> be available<span class="built_in">..</span>.</span><br><span class="line">Detecting the provisioner<span class="built_in">..</span>.</span><br><span class="line">Provisioning with centos<span class="built_in">..</span>.</span><br><span class="line">Copying certs <span class="keyword">to</span> the local machine directory<span class="built_in">..</span>.</span><br><span class="line">Copying certs <span class="keyword">to</span> the remote machine<span class="built_in">..</span>.</span><br><span class="line">Setting Docker configuration on the remote daemon<span class="built_in">..</span>.</span><br><span class="line">Checking<span class="built_in"> connection </span><span class="keyword">to</span> Docker<span class="built_in">..</span>.</span><br><span class="line">Docker is up <span class="keyword">and</span> running!</span><br><span class="line"><span class="keyword">To</span> see how <span class="keyword">to</span> connect your Docker<span class="built_in"> Client </span><span class="keyword">to</span> the Docker Engine running on this virtual machine, run: docker-machine env docker111</span><br><span class="line">根据提示：如下操作docker-machine env docker111 查看环境变量</span><br></pre></td></tr></table></figure><blockquote><ul><li>如果是云主机请开放2376端口、关闭防火墙或者打开这个端口</li><li>-d  设置驱动  generic 是一般的普通的</li><li>–generic-ip-address=其他主机的IP</li><li>–generic-ssh-key=你在主机上生成的秘钥存放位置</li><li>–generic-ssh-user=root=连接的用户名</li><li>–engine-registry-mirror <a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a> #配置 Docker 的仓库镜像</li></ul></blockquote><ul><li>查看docker111的环境变量的环境变量</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看docker111的环境变量</span></span><br><span class="line">[root@izbp1dg6m4eebtcm77n0smz ~]# docker-machine env docker111</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">DOCKER_TLS_VERIFY</span>=<span class="string">"1"</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">DOCKER_HOST</span>=<span class="string">"tcp://39.96.83.253:2376"</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">DOCKER_CERT_PATH</span>=<span class="string">"/root/.docker/machine/machines/docker111"</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">DOCKER_MACHINE_NAME</span>=<span class="string">"docker111"</span></span><br><span class="line"><span class="comment"># Run this command to configure your shell: </span></span><br><span class="line"><span class="comment"># eval (docker-machine env docker111)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据提示执行eval (docker-machine env docker111)</span></span><br><span class="line">[root@izbp1dg6m4eebtcm77n0smz ~]# eval (docker-machine env docker111)</span><br><span class="line">[root@izbp1dg6m4eebtcm77n0smz ~ [docker111]]# </span><br><span class="line"><span class="comment"># 可以看到，命令提示符变成了docker111，其原因是我们之前在/root/.bashrc里面配置了 PS1='[\u@\h \W(__docker_machine_ps1)]\ '，用于显示当前的docker host</span></span><br><span class="line">注：如果我们输入eval (docker-machine env docker111)没有显示出docker111的命令提示符，我们可以重新输入一遍 <span class="attribute">PS1</span>=<span class="string">'[\u@\h \W(__docker_machine_ps1)]\ '</span></span><br><span class="line">在此状态下执行的docker命令其效果都相当于在docker111上执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@izbp1dg6m4eebtcm77n0smz ~ [docker111]]# docker ps</span><br><span class="line">CONTAINER ID     IMAGE        COMMAND     CREATED      PORTS        NAMES</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">STATUS[root@izbp1dg6m4eebtcm77n0smz ~ [docker111]]# docker pull nginx</span><br><span class="line">Using<span class="built_in"> default </span>tag: latest</span><br><span class="line">latest: Pulling <span class="keyword">from</span> library/nginx</span><br><span class="line">000eee12ec04: Pull complete </span><br><span class="line">eb22865337de: Pull complete </span><br><span class="line">bee5d581ef8b: Pull complete </span><br><span class="line">Digest: sha256:50cf965a6e08ec5784009d0fccb380fc479826b6e0e65684d9879170a9df8566</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> nginx:latest</span><br><span class="line">docker.io/library/nginx:latest</span><br></pre></td></tr></table></figure><p>总结：docker-machine 子命令</p><blockquote><p>docker-machine upgrade  server2    更新docker版本<br>docker-machine config  server2    查看machine配置<br>docker-machine scp             可以在machine中复制文件<br>docker-machine ssh            连接machine<br>docker-machine rm            删除machine</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Centos7-安装-docker-machine&quot;&gt;&lt;a href=&quot;#Centos7-安装-docker-machine&quot; class=&quot;headerlink&quot; title=&quot;Centos7 安装 docker-machine&quot;&gt;&lt;/a&gt;Centos7 安装 docker-machine&lt;/h2&gt;&lt;p&gt;官方地址：&lt;a href=&quot;https://docs.docker.com/machine/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/machine/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;官方驱动详细使用方法：&lt;a href=&quot;https://docs.docker.com/machine/drivers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/machine/drivers/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://cy-blogs.cn/categories/Docker/"/>
    
    
      <category term="docker-machine" scheme="https://cy-blogs.cn/tags/docker-machine/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://cy-blogs.cn/docker%20%E4%BD%BF%E7%94%A8mysql/"/>
    <id>https://cy-blogs.cn/docker 使用mysql/</id>
    <published>2020-01-06T02:50:41.396Z</published>
    <updated>2020-01-06T03:03:21.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker-MYSQL"><a href="#Docker-MYSQL" class="headerlink" title="Docker MYSQL"></a>Docker MYSQL</h2><ul><li><p>启动创建容器</p><ul><li><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql<span class="number">-8</span> -e MYSQL_ROOT_PASSWORD=<span class="number">123456</span> -p <span class="number">3371</span>:<span class="number">3306</span> -d mysql</span><br></pre></td></tr></table></figure></li></ul></li><li><p>进入容器</p><ul><li>docker exec -it 容器名称或ID bash</li></ul></li><li><p>等录mysql</p><ul><li>mysql -u root -p</li><li>输入密码</li></ul></li><li><p>添加远程登录用户</p><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'mysql-8'</span> <span class="keyword">identified</span> <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>为用户增加权限</p><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> . <span class="keyword">to</span> <span class="string">'mysql-8'</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>刷新用户权限</p><ul><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><a id="more"></a><blockquote><p>注意：</p><ul><li>如果你的mysql数据库版本是5.5左右的可以不用添加远程连接就可以直接使用root加密码进行连接</li><li>如果是docker里面的mysql最新的8.0镜像你就需要添加一个新的远程连接用户因为<ul><li>最新的mysql的加密插件默认的是caching_sha2_password的加密 插件/规则 Navicat 无法连接</li></ul></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Docker-MYSQL&quot;&gt;&lt;a href=&quot;#Docker-MYSQL&quot; class=&quot;headerlink&quot; title=&quot;Docker MYSQL&quot;&gt;&lt;/a&gt;Docker MYSQL&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;启动创建容器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run --name mysql&lt;span class=&quot;number&quot;&gt;-8&lt;/span&gt; -e MYSQL_ROOT_PASSWORD=&lt;span class=&quot;number&quot;&gt;123456&lt;/span&gt; -p &lt;span class=&quot;number&quot;&gt;3371&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;3306&lt;/span&gt; -d mysql&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进入容器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;docker exec -it 容器名称或ID bash&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;等录mysql&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mysql -u root -p&lt;/li&gt;
&lt;li&gt;输入密码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加远程登录用户&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;mysql-8&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;identified&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; mysql_native_password &lt;span class=&quot;keyword&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;123456&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为用户增加权限&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;grant&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;privileges&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;on&lt;/span&gt; . &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;mysql-8&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;刷新用户权限&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;flush&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;privileges&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Centos7 安装Docker</title>
    <link href="https://cy-blogs.cn/Centos7%E5%AE%89%E8%A3%85docker/"/>
    <id>https://cy-blogs.cn/Centos7安装docker/</id>
    <published>2020-01-06T02:50:41.381Z</published>
    <updated>2020-01-06T03:02:06.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Centos7-安装Docker"><a href="#Centos7-安装Docker" class="headerlink" title="Centos7 安装Docker"></a>Centos7 安装Docker</h2><ul><li><p>Docker简介</p><blockquote><p>​        Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的<a href="https://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a>机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。把它当成轻量级的虚拟机吧,(虽然一个是完全虚拟化，一个是操作系统层虚拟化）</p><p>​        Docker 使用客户端-服务器 (C/S) 架构模式 使用远程API来管理和创建Docker容器。Docker 容器（Container）通过 Docker 镜像（Image）来创建，二者之间的关系类似于面向对象编程中的对象与类</p></blockquote></li><li><p>那Docker由什么组成呢， 包括三个基本概念:</p><ul><li><p><strong>仓库（Repository）</strong></p></li><li><p><strong>镜像（Image）</strong></p></li><li><p><strong>容器(Container）</strong></p></li></ul></li></ul><a id="more"></a><p>打个比方：你如果想玩英雄联盟中骚气的亚索，你首先得有这个英雄（Docker的镜像），然后你得花金币去英雄商店（Docker的仓库）买，接着进游戏就会看到一个半蹲的发型飘逸的剑客（Docker的容器），所以：</p><p>1，其中Registry是Docker用于存放镜像文件的仓库，Docker 仓库的概念跟Git 类似（就像商店存放所有的英雄，只是更改英雄的权限在某些非程序员手里）。</p><p>2，所谓镜像就是构建容器的源代码，是一个只读的模板，由一层一层的文件系统组成的，类似于虚拟机的镜像（英雄也是只读的，有自己的技能被动，你也不能进行操作）。</p><p>3，那么容器就是由Docker镜像创建的运行实例，类似于虚拟机，容器之间是相互隔离的，包含特定的应用及其所需的依赖文件（好比每个英雄都是隔离的，都有自己的皮肤，技能以及走的路线)。</p><p>  <strong>注：</strong><a href="https://hub.docker.com/" target="_blank" rel="noopener"><code>Docker Hub</code></a>是Docker公司提供的一个注册服务器（Register）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像</p><h4 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h4><p>我是虚拟机装的 Centos7 ，linux 3.10 内核 。</p><ul><li><p>root 账户登录，查看内核版本如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost ~]# uname -a</span><br><span class="line">Linux localhost.qgc <span class="number">3.10</span><span class="number">.0</span><span class="number">-862.11</span><span class="number">.6</span>.el7.x86_64 #<span class="number">1</span> SMP Tue Aug <span class="number">14</span> <span class="number">21</span>:<span class="number">49</span>:<span class="number">04</span> UTC <span class="number">2018</span> x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure></li><li><p>安装所需要的软件包，<code>yum-util</code> 提供 <code>yum-config-manager</code> 功能，另外两个是 <code>devicemapper</code> 驱动依赖的</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">Loading<span class="built_in"> mirror </span>speeds <span class="keyword">from</span> cached hostfile</span><br><span class="line"> * base: centos.ustc.edu.cn</span><br><span class="line"> * extras: mirrors.aliyun.com</span><br><span class="line"> * updates: centos.ustc.edu.cn</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure></li><li><p>设置 <code>yum</code> 源</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# yum-config-manager --<span class="built_in">add</span>-repo http<span class="variable">s:</span>//download.docker.<span class="keyword">com</span>/linux/centos/docker-<span class="keyword">ce</span>.repo</span><br><span class="line"></span><br><span class="line">Loaded plugin<span class="variable">s:</span> fastestmirror</span><br><span class="line">adding repo from: http<span class="variable">s:</span>//download.docker.<span class="keyword">com</span>/linux/centos/docker-<span class="keyword">ce</span>.repo</span><br><span class="line">grabbing <span class="keyword">file</span> http<span class="variable">s:</span>//download.docker.<span class="keyword">com</span>/linux/centos/docker-<span class="keyword">ce</span>.repo <span class="keyword">to</span> /etc/yum.repos.d/docker-<span class="keyword">ce</span>.repo</span><br><span class="line">repo saved <span class="keyword">to</span> /etc/yum.repos.d/docker-<span class="keyword">ce</span>.repo</span><br></pre></td></tr></table></figure></li><li><p>可以查看所有仓库中的 <code>docker</code> 版本，并选择特定版本安装</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>test ~]# yum list docker-ce --showduplicates | sort -r</span><br><span class="line"> * updates: mirrors.cn99.com</span><br><span class="line">Loading mirror speeds <span class="keyword">from</span> cached hostfile</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line"> * extras: mirrors.aliyun.com</span><br><span class="line"> * epel: mirrors.aliyun.com</span><br><span class="line">docker-ce.x86_64            <span class="number">3</span>:<span class="number">19.03</span><span class="number">.5</span><span class="number">-3.</span>el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            <span class="number">3</span>:<span class="number">19.03</span><span class="number">.4</span><span class="number">-3.</span>el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            <span class="number">3</span>:<span class="number">19.03</span><span class="number">.3</span><span class="number">-3.</span>el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            <span class="number">3</span>:<span class="number">19.03</span><span class="number">.2</span><span class="number">-3.</span>el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            <span class="number">3</span>:<span class="number">19.03</span><span class="number">.1</span><span class="number">-3.</span>el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            <span class="number">3</span>:<span class="number">19.03</span><span class="number">.0</span><span class="number">-3.</span>el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            <span class="number">3</span>:<span class="number">18.09</span><span class="number">.9</span><span class="number">-3.</span>el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            <span class="number">3</span>:<span class="number">18.09</span><span class="number">.8</span><span class="number">-3.</span>el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            <span class="number">3</span>:<span class="number">18.09</span><span class="number">.7</span><span class="number">-3.</span>el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64            <span class="number">3</span>:<span class="number">18.09</span><span class="number">.6</span><span class="number">-3.</span>el7                     docker-ce-stable</span><br><span class="line">.......</span><br></pre></td></tr></table></figure></li><li><p>安装 Docker ，命令 <code>yum install docker-ce-版本号</code> </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>test ~]# yum install docker-ce<span class="number">-17.12</span><span class="number">.1</span>.ce</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds <span class="keyword">from</span> cached hostfile</span><br><span class="line"> * base: mirrors.aliyun.com</span><br><span class="line"> * epel: mirrors.aliyun.com</span><br><span class="line"> * extras: mirrors.aliyun.com</span><br><span class="line"> * updates: mirrors.cn99.com</span><br><span class="line">Resolving Dependencies</span><br><span class="line">--&gt; Running transaction check</span><br><span class="line">---&gt; Package docker-ce.x86_64 <span class="number">0</span>:<span class="number">17.12</span><span class="number">.1</span>.ce<span class="number">-1.</span>el7.centos will be installed</span><br><span class="line">--&gt; Processing Dependency: container-selinux &gt;= <span class="number">2.9</span> <span class="keyword">for</span> package: docker-ce<span class="number">-17.12</span><span class="number">.1</span>.ce<span class="number">-1.</span>el7.centos.x86_64</span><br><span class="line">--&gt; Processing Dependency: libcgroup <span class="keyword">for</span> package: docker-ce<span class="number">-17.12</span><span class="number">.1</span>.ce<span class="number">-1.</span>el7.centos.x86_64</span><br><span class="line">--&gt; Processing Dependency: libltdl.so<span class="number">.7</span>()(<span class="number">64</span>bit) <span class="keyword">for</span> package: docker-ce<span class="number">-17.12</span><span class="number">.1</span>.ce<span class="number">-1.</span>el7.centos.x86_64</span><br><span class="line">--&gt; Processing Dependency: libseccomp.so<span class="number">.2</span>()(<span class="number">64</span>bit) <span class="keyword">for</span> package: docker-ce<span class="number">-17.12</span><span class="number">.1</span>.ce<span class="number">-1.</span>el7.centos.x86_64</span><br><span class="line">--&gt; Running transaction check</span><br><span class="line">.........</span><br></pre></td></tr></table></figure></li><li><p>启动 Docker，命令 ：systemctl start docker，然后加入开机启动</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]<span class="comment"># systemctl start docker</span></span><br><span class="line">[root@test ~]<span class="comment"># systemctl enable docker</span></span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">systemd</span>/<span class="title">system</span>/<span class="title">docker</span>.<span class="title">service</span>.</span></span><br></pre></td></tr></table></figure></li><li><p>验证 Docker 是否安装成功</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">root@</span>test ~]# docker version </span><br><span class="line">Client:</span><br><span class="line"> Version:<span class="number">17.12</span><span class="number">.1</span>-ce</span><br><span class="line"> API version:<span class="number">1.35</span></span><br><span class="line"> Go version:go1<span class="number">.9</span><span class="number">.4</span></span><br><span class="line"> Git commit:<span class="number">7390f</span>c6</span><br><span class="line"> Built:Tue Feb <span class="number">27</span> <span class="number">22</span>:<span class="number">15</span>:<span class="number">20</span> <span class="number">2018</span></span><br><span class="line"> OS/Arch:linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Engine:</span><br><span class="line">  Version:<span class="number">17.12</span><span class="number">.1</span>-ce</span><br><span class="line">  API version:<span class="number">1.35</span> (minimum version <span class="number">1.12</span>)</span><br><span class="line">  Go version:go1<span class="number">.9</span><span class="number">.4</span></span><br><span class="line">  Git commit:<span class="number">7390f</span>c6</span><br><span class="line">  Built:Tue Feb <span class="number">27</span> <span class="number">22</span>:<span class="number">17</span>:<span class="number">54</span> <span class="number">2018</span></span><br><span class="line">  OS/Arch:linux/amd64</span><br><span class="line">  Experimental:<span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>查看 Docker 状态</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>test ~]# systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Wed <span class="number">2019</span><span class="number">-12</span><span class="number">-25</span> <span class="number">17</span>:<span class="number">29</span>:<span class="number">57</span> CST; <span class="number">16</span>s ago</span><br><span class="line">     Docs: https:<span class="comment">//docs.docker.com</span></span><br><span class="line"> Main PID: <span class="number">15430</span> (dockerd)</span><br><span class="line">   Memory: <span class="number">25.1</span>M</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           ├─<span class="number">15430</span> /usr/bin/dockerd</span><br><span class="line">           └─<span class="number">15433</span> docker-containerd --config /var/run/docker/containerd/containerd.toml</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>查看 Docker 安装的版本号</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>test ~]# docker -v</span><br><span class="line">Docker version <span class="number">17.12</span><span class="number">.1</span>-ce, build <span class="number">7390f</span>c6</span><br></pre></td></tr></table></figure></li><li><p><code>docker info</code> 查看 docker 存储位置</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Docker Root <span class="symbol">Dir:</span> /var/<span class="class"><span class="keyword">lib</span>/<span class="title">docker</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Centos7-安装Docker&quot;&gt;&lt;a href=&quot;#Centos7-安装Docker&quot; class=&quot;headerlink&quot; title=&quot;Centos7 安装Docker&quot;&gt;&lt;/a&gt;Centos7 安装Docker&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Docker简介&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;​        Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的&lt;a href=&quot;https://baike.baidu.com/item/Linux&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux&lt;/a&gt;机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。把它当成轻量级的虚拟机吧,(虽然一个是完全虚拟化，一个是操作系统层虚拟化）&lt;/p&gt;
&lt;p&gt;​        Docker 使用客户端-服务器 (C/S) 架构模式 使用远程API来管理和创建Docker容器。Docker 容器（Container）通过 Docker 镜像（Image）来创建，二者之间的关系类似于面向对象编程中的对象与类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;那Docker由什么组成呢， 包括三个基本概念:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;仓库（Repository）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;镜像（Image）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;容器(Container）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://cy-blogs.cn/categories/Docker/"/>
    
    
      <category term="Centos7 安装Docker" scheme="https://cy-blogs.cn/tags/Centos7-%E5%AE%89%E8%A3%85Docker/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 安装 docker-machine</title>
    <link href="https://cy-blogs.cn/Centos7%E5%AE%89%E8%A3%85docker-machine%20/"/>
    <id>https://cy-blogs.cn/Centos7安装docker-machine /</id>
    <published>2020-01-06T02:50:41.268Z</published>
    <updated>2020-01-06T07:29:22.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Centos7-安装-docker-machine"><a href="#Centos7-安装-docker-machine" class="headerlink" title="Centos7 安装 docker-machine"></a>Centos7 安装 docker-machine</h2><p>官方地址：<a href="https://docs.docker.com/machine/" target="_blank" rel="noopener">https://docs.docker.com/machine/</a></p><p>官方驱动详细使用方法：<a href="https://docs.docker.com/machine/drivers/" target="_blank" rel="noopener">https://docs.docker.com/machine/drivers/</a></p><a id="more"></a><p>参考文档：<a href="https://www.cnblogs.com/lkun/p/7781157.html" target="_blank" rel="noopener">https://www.cnblogs.com/lkun/p/7781157.html</a></p><h4 id="Docker-machine-简介"><a href="#Docker-machine-简介" class="headerlink" title="Docker-machine 简介"></a>Docker-machine 简介</h4><ul><li><p>Docker Machine是什么？</p><pre><code>Docker Machine 可以用来批量安装docker、配置管理 `docker` 远程主机，而主机可以是物理机、虚拟机，甚至是云主机。当然也支持windows，mac等平台，说白了就是能在一台机子上给其他机子安装docker环境</code></pre></li></ul><blockquote><p>Docker Machine 是 Docker 官方编排（Orchestration）项目之一，负责在多种平台上快速安装 Docker 环境。</p><p>Docker Machine 项目基于 <code>Go</code> 语言实现，目前在 <a href="https://github.com/docker/machine" target="_blank" rel="noopener">Github</a> 上进行维护。</p></blockquote><ul><li><p>本质上 <code>docker-machine</code> 是一个虚拟机管理工具，使得本地的 <code>docker</code> 工具获得透明远程操作虚拟机的能力。</p></li><li><p>Docker Machine 最主要有 <strong>两个作用</strong> ：</p><ul><li>使用 Docker Machine 方便在不同的环境中使用 Docker ，比如：Win/Mac</li><li>使用 Docker Machine 方便在云环境下批量部署 Docker环境，比如：私有云，公有云批量安装Docker环境</li></ul></li></ul><blockquote><p>Docker Machine 支持多种后端驱动，包括虚拟机、本地主机和云平台等。</p></blockquote><h2 id="安装Docker-Machine"><a href="#安装Docker-Machine" class="headerlink" title="安装Docker Machine"></a>安装Docker Machine</h2><blockquote><p> Docker Machine 可以在多种操作系统平台上安装，包括 Linux、macOS，以及 Windows。</p></blockquote><ul><li><p><strong>macOS</strong>、<strong>Windows</strong></p><p><code>Docker Desktop for Mac/Windows</code> 自带 <code>docker-machine</code> 二进制包，安装之后即可使用。</p><p>查看版本信息 :</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine -v</span><br><span class="line">docker-machine version <span class="number">0.16</span><span class="number">.1</span>, build cce350d7</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>这里讲述在线安装和离线安装</strong></p></li><li><p>安装Docker Machine</p><ul><li><p>这里讲述在线安装</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L <span class="symbol">https:</span>/<span class="regexp">/github.com/docker</span><span class="regexp">/machine/releases</span><span class="regexp">/download/v</span><span class="number">0</span>.<span class="number">16.2</span>/docker-machine-<span class="string">`uname -s`</span>-<span class="string">`uname -m`</span> &gt; <span class="regexp">/usr/local</span><span class="regexp">/bin/docker</span>-machine</span><br><span class="line"></span><br><span class="line">$ sudo chmod +x /usr/local/bin/docker-machine</span><br></pre></td></tr></table></figure></li><li><blockquote><p>注：<code>chmod +x /usr/local/bin/docker-machine</code> 命令给文件添加执行权限</p></blockquote></li></ul></li><li><p>查看版本</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>test ~]# docker-machine version</span><br><span class="line">docker-machine version <span class="number">0.16</span><span class="number">.2</span>, build bd45ab13</span><br></pre></td></tr></table></figure></li></ul><h4 id="安装自动补全功能"><a href="#安装自动补全功能" class="headerlink" title="安装自动补全功能"></a>安装自动补全功能</h4><ul><li><p>这个 docker-machine 提供了几个 bash 脚本，这些脚本添加了以下功能：</p><ul><li>命令完成</li><li>在shell提示中显示活动的计算机功能</li><li>一个函数包装器，添加一个<code>docker-machine use</code>子命令以切换活动计算机</li></ul><p>确认版本并将脚本保存到<code>/etc/bash_completion.d</code>或 <code>/usr/local/etc/bash_completion.d</code></p></li></ul><ul><li><p>安装并配置 docker-machine 命令的相关脚本，这样可以为我们补全命令，在终端执行即可</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 安装自动补全功能</span><br><span class="line">[<span class="symbol">root@</span>test]# yum -y install bash-completion</span><br><span class="line"></span><br><span class="line">[<span class="symbol">root@</span>test]# base=https:<span class="comment">//raw.githubusercontent.com/docker/machine/v0.16.0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> docker-machine-prompt.bash docker-machine-wrapper.bash docker-machine.bash</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  sudo wget <span class="string">"$base/contrib/completion/bash/$&#123;i&#125;"</span> -P /etc/bash_completion.d</span><br><span class="line">done</span><br><span class="line"># 开始从github下载</span><br><span class="line">-<span class="number">-2019</span><span class="number">-12</span><span class="number">-25</span> <span class="number">22</span>:<span class="number">52</span>:<span class="number">46</span>--  https:<span class="comment">//raw.githubusercontent.com/docker/machine/v0.16.0/contrib/completion/bash/docker-machine-prompt.bash</span></span><br><span class="line">Resolving raw.githubusercontent.com (raw.githubusercontent.com)... <span class="number">151.101</span><span class="number">.228</span><span class="number">.133</span></span><br><span class="line">Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|<span class="number">151.101</span><span class="number">.228</span><span class="number">.133</span>|:<span class="number">443.</span>.. </span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[<span class="symbol">root@</span>test bash_completion.d]# source /etc/bash_completion.d/docker-machine-prompt.bash</span><br></pre></td></tr></table></figure><p><strong>&gt;&gt;&gt;&gt;&gt; 转    启用 Docker-machine  自动补全</strong></p><blockquote><p>然后，您需要<code>source /etc/bash_completion.d/docker-machine-prompt.bash</code>在bash终端中运行，以告诉您的安装程序在哪里可以找到<code>docker-machine-prompt.bash</code>您先前下载的文件 。 &gt;&gt;&gt;&gt;&gt;** 启用 Docker-machine **</p></blockquote></li></ul><h4 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h4><ul><li><p><strong>直接登录：<a href="https://github.com/docker/machine/releases/" target="_blank" rel="noopener">https://github.com/docker/machine/releases/</a> 下载对应的版本，然后重命名文件为docker-machine，并给予执行权并且放到/usr/local/bin/下安装就可完成</strong></p></li><li><p><strong>使用 <code>chmod +x /tmp/docker-machine</code> 更改文件的执行权限</strong></p></li><li><p>*<em>使用 <code>cp /tmp/docker-machine /usr/local/bin/docker-machine</code> 拷贝 或使用  <code>MV</code> 移动 *</em></p></li></ul><p>  <img src="https://img-blog.csdnimg.cn/20190607174757669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTU2NzI2,size_16,color_FFFFFF,t_70" alt></p><ul><li><p><strong>同样安装并配置docker-machine命令的相关脚本，这样可以为我们补全命令</strong></p><blockquote><p><strong>登录</strong> <strong><a href="https://github.com/docker/machine/tree/master/contrib/completion/bash" target="_blank" rel="noopener">https://github.com/docker/machine/tree/master/contrib/completion/bash</a></strong> 下载目录下的三个脚本，给与执行权限，放到 <strong>/etc/bash_completion.d</strong> 。然后 启用 Docker-machine 自动补全</p></blockquote></li></ul><h4 id="启用-Docker-machine-自动补全"><a href="#启用-Docker-machine-自动补全" class="headerlink" title="启用 Docker-machine 自动补全"></a>启用 Docker-machine 自动补全</h4><ul><li><p>要启用<code>docker-machine</code>   shell 程序提示，请在<code>~/.bashrc</code>文件下提价如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加如下</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># vi ~/.bashrc</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># cat ~/.bashrc </span></span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> rm=<span class="string">'rm -i'</span></span><br><span class="line"><span class="built_in">alias</span> cp=<span class="string">'cp -i'</span></span><br><span class="line"><span class="built_in">alias</span> mv=<span class="string">'mv -i'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/bashrc ]; <span class="keyword">then</span></span><br><span class="line">. /etc/bashrc</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># source 是文件的来源</span></span><br><span class="line"><span class="built_in">source</span> /etc/bash_completion.d/docker-machine-wrapper.bash</span><br><span class="line"><span class="built_in">source</span> /etc/bash_completion.d/docker-machine-prompt.bash</span><br><span class="line"><span class="built_in">source</span> /etc/bash_completion.d/docker-machine.bash</span><br><span class="line"> </span><br><span class="line">PS1=<span class="string">'[\u@\h \W$(__docker_machine_ps1)]\$ '</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使之生效</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># source ~/.bashrc</span></span><br></pre></td></tr></table></figure></li><li><p>您可以在<a href="https://github.com/docker/machine/tree/master/contrib/completion/bash" target="_blank" rel="noopener">每个脚本顶部</a>的注释中找到其他文档</p></li><li><p>到此 docker-machine 就安装完成了！</p></li></ul><hr><h3 id="使用-docker-machine-–help-获取帮助文档"><a href="#使用-docker-machine-–help-获取帮助文档" class="headerlink" title="使用 docker-machine –help 获取帮助文档"></a>使用 docker-machine –help 获取帮助文档</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Usage</span>: docker-machine [OPTIONS] COMMAND [arg...]</span><br><span class="line"></span><br><span class="line">Create and manage machines running Docker.</span><br><span class="line"></span><br><span class="line"><span class="attribute">Version</span>: 0.16.2, build bd45ab13</span><br><span class="line"></span><br><span class="line"><span class="attribute">Author:</span></span><br><span class="line">  Docker Machine Contributors - &lt;https://github.com/docker/machine&gt;</span><br><span class="line"></span><br><span class="line"><span class="attribute">Options:</span></span><br><span class="line">  --debug, -DEnable debug mode</span><br><span class="line">  --storage-path, -s "/root/.docker/machine"Configures storage path [$MACHINE_STORAGE_PATH]</span><br><span class="line">  --tls-ca-cert CA to verify remotes against [$MACHINE_TLS_CA_CERT]</span><br><span class="line">  --tls-ca-key Private key to generate certificates [$MACHINE_TLS_CA_KEY]</span><br><span class="line">  --tls-client-cert Client cert to use for TLS [$MACHINE_TLS_CLIENT_CERT]</span><br><span class="line">  --tls-client-key Private key used in client TLS auth [$MACHINE_TLS_CLIENT_KEY]</span><br><span class="line">  --github-api-token Token to use for requests to the Github API [$MACHINE_GITHUB_API_TOKEN]</span><br><span class="line">  --native-sshUse the native (Go-based) SSH implementation. [$MACHINE_NATIVE_SSH]</span><br><span class="line">  --bugsnag-api-token BugSnag API token for crash reporting [$MACHINE_BUGSNAG_API_TOKEN]</span><br><span class="line">  --help, -hshow help</span><br><span class="line">  --version, -vprint the version</span><br><span class="line"></span><br><span class="line"># 支持的命令</span><br><span class="line"><span class="attribute">Commands:</span></span><br><span class="line">  activePrint which machine is active</span><br><span class="line">  configPrint the connection config for machine</span><br><span class="line">  createCreate a machine</span><br><span class="line">  envDisplay the commands to set up the environment for the Docker client</span><br><span class="line">  inspectInspect information about a machine</span><br><span class="line">  ipGet the IP address of a machine</span><br><span class="line">  killKill a machine</span><br><span class="line">  lsList machines</span><br><span class="line">  provisionRe-provision existing machines</span><br><span class="line">  regenerate-certsRegenerate TLS Certificates for a machine</span><br><span class="line">  restartRestart a machine</span><br><span class="line">  rmRemove a machine</span><br><span class="line">  sshLog into or run a command on a machine with SSH.</span><br><span class="line">  scpCopy files between machines</span><br><span class="line">  mountMount or unmount a directory from a machine with SSHFS.</span><br><span class="line">  startStart a machine</span><br><span class="line">  statusGet the status of a machine</span><br><span class="line">  stopStop a machine</span><br><span class="line">  upgradeUpgrade a machine to the latest version of Docker</span><br><span class="line">  urlGet the URL of a machine</span><br><span class="line">  versionShow the Docker Machine version or a machine docker version</span><br><span class="line">  helpShows a list of commands or help for one command</span><br><span class="line">  </span><br><span class="line">Run 'docker-machine COMMAND --help' for more information on a command.</span><br></pre></td></tr></table></figure><ul><li>支持命令：</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>active</td><td>查看当前激活状态的Docker主机</td></tr><tr><td>config</td><td>查看当前激活状态Docker主机的连接信息</td></tr><tr><td>creat</td><td>创建Docker主机</td></tr><tr><td>env</td><td>显示连接到某个主机需要的环境变量</td></tr><tr><td>inspect</td><td>以json格式输出指定Docker的详细信息</td></tr><tr><td>ip</td><td>获取指定Docker主机的地址</td></tr><tr><td>kill</td><td>直接杀死指定的Docker主机</td></tr><tr><td>ls</td><td>列出所有的管理主机</td></tr><tr><td>provision</td><td>重新配置指定主机</td></tr><tr><td>regenerate-certs</td><td>为某个主机重新生成TLS信息</td></tr><tr><td>restart</td><td>重启指定的主机</td></tr><tr><td>rm</td><td>删除某台Docker主机，对应的虚拟机也会被删除</td></tr><tr><td>ssh</td><td>通过SSH连接到主机上，执行命令</td></tr><tr><td>scp</td><td>在Docker主机之间以及Docker主机和本地主机之间通过scp远程复制数据</td></tr><tr><td>mount</td><td>使用SSHFS从计算机装载或卸载目录</td></tr><tr><td>start</td><td>启动一个指定的Docker主机，如果对象是个虚拟机，该虚拟机将被启动</td></tr><tr><td>status</td><td>获取指定Docker主机的状态(包括：Running、Paused、Saved、Stopped、Stopping、Starting、Error)等</td></tr><tr><td>stop</td><td>停止一个指定的Docker主机</td></tr><tr><td>upgrade</td><td>将一个指定主机的Docker版本更新为最新</td></tr><tr><td>url</td><td>获取指定Docker主机的监听URL</td></tr><tr><td>version</td><td>显示Docker Machine的版本或者主机Docker版本</td></tr><tr><td>help</td><td>显示帮助信息</td></tr></tbody></table><blockquote><p>每个命令，又带有不同的参数，可以通过 <code>docker-machine COMMAND --help</code> 查看。</p></blockquote><h4 id="驱动程式外挂程式"><a href="#驱动程式外挂程式" class="headerlink" title="驱动程式外挂程式"></a>驱动程式外挂程式</h4><blockquote><p>​        除了与Docker Machine捆绑在一起的核心驱动程序插件外，用户还可以为任何虚拟化技术或云提供商制作和分发自己的插件。要浏览已知的Docker Machine插件列表，请<a href="https://github.com/docker/docker.github.io/blob/master/machine/AVAILABLE_DRIVER_PLUGINS.md" target="_blank" rel="noopener">参阅我们的文档repo中的此文档</a>。</p></blockquote><ul><li>支持的平台及驱动引擎</li></ul><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 平台</span></span><br><span class="line"><span class="number">1.</span>常规Linux操作系统；</span><br><span class="line"> </span><br><span class="line"><span class="number">2.</span>虚拟化平台-VirtualBox，VMware，Hyper-V</span><br><span class="line"> </span><br><span class="line"><span class="number">3.</span>Openstack</span><br><span class="line"> </span><br><span class="line"><span class="number">4.</span>公有云-Amazon Web Services，Microsoft Azure，Google Compute Engine，Digital Ocean等</span><br><span class="line"> </span><br><span class="line">Docker Machine为这些环境起了一个统一的名字：provider</span><br><span class="line"> </span><br><span class="line">对于特定的某个provider，Docker Machine使用相应的driver安装配置docker host</span><br><span class="line"> </span><br><span class="line"><span class="meta"># 驱动引擎</span></span><br><span class="line">amazonec2</span><br><span class="line">azure</span><br><span class="line">digitalocean</span><br><span class="line">exoscale</span><br><span class="line">generic</span><br><span class="line">google</span><br><span class="line">hyperv</span><br><span class="line">none</span><br><span class="line">openstack</span><br><span class="line">rackspace</span><br><span class="line">softlayer</span><br><span class="line">virtualbox</span><br><span class="line">vmwarevcloudair</span><br><span class="line">vmwarefusion</span><br><span class="line">vmwarevsphere</span><br><span class="line"> </span><br><span class="line"><span class="meta"># 指定方式</span></span><br><span class="line">使用参数 -d 或者 --driver 驱动引擎名称</span><br></pre></td></tr></table></figure><blockquote><p>说白了都是虚拟化平台和云平台的驱动文件</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Centos7-安装-docker-machine&quot;&gt;&lt;a href=&quot;#Centos7-安装-docker-machine&quot; class=&quot;headerlink&quot; title=&quot;Centos7 安装 docker-machine&quot;&gt;&lt;/a&gt;Centos7 安装 docker-machine&lt;/h2&gt;&lt;p&gt;官方地址：&lt;a href=&quot;https://docs.docker.com/machine/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/machine/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;官方驱动详细使用方法：&lt;a href=&quot;https://docs.docker.com/machine/drivers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.docker.com/machine/drivers/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://cy-blogs.cn/categories/Docker/"/>
    
    
      <category term="Centos7 安装 docker-machine" scheme="https://cy-blogs.cn/tags/Centos7-%E5%AE%89%E8%A3%85-docker-machine/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 事务隔离级别</title>
    <link href="https://cy-blogs.cn/mysql%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>https://cy-blogs.cn/mysql事务特性及隔离级别/</id>
    <published>2019-12-24T11:09:28.852Z</published>
    <updated>2019-12-24T11:09:15.844Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-1-2、事务的特性"><a href="#1-1-2、事务的特性" class="headerlink" title="1.1.2、事务的特性"></a>1.1.2、事务的特性</h3><ol><li><p>原子性</p><blockquote><p>事务中的全部操作在数据库中是不可分割的，要么全部完成，要么全都不完成</p></blockquote></li><li><p>一致性</p><blockquote><p>几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致</p></blockquote></li><li><p>隔离性</p><blockquote><p>事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的</p></blockquote></li><li><p>持久性</p><blockquote><p>一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作</p></blockquote></li></ol><a id="more"></a><p><img src="https://pic2.zhimg.com/80/v2-59ea2f0769e4e9ffbcdce938d306fae9_hd.png" alt="img"> </p><h3 id="1-1-3、事务隔离级别"><a href="#1-1-3、事务隔离级别" class="headerlink" title="1.1.3、事务隔离级别"></a>1.1.3、事务隔离级别</h3><ol><li><p><strong>未提交读：脏读（READ UNCOMMITTED）</strong></p><ol><li>事务2查询到的数据是事务1中修改但未提交的数据，但因为事务1回滚了数据</li><li>所以事务2查询的数据是不正确的，因此出现了脏读的问题</li></ol></li></ol><h3 id="READ-UNCOMMITTED（读未提交）"><a href="#READ-UNCOMMITTED（读未提交）" class="headerlink" title="READ UNCOMMITTED（读未提交）"></a>READ UNCOMMITTED（读未提交）</h3><p> 该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为<strong>脏读</strong>。 </p><p> 两个命令行客户端分别为A，B；不断改变A的隔离级别，在B端修改数据。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">将A的隔离级别设置为read uncommitted(未提交读)</span><br><span class="line">A：<span class="keyword">SET</span> @@session.transaction_isolation = <span class="string">'READ-UNCOMMITTED'</span>;</span><br><span class="line">创建一张test</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>) <span class="keyword">values</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">A：启动事务，此时数据为初始状态</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"></span><br><span class="line">B：启动事务，更新数据，但不提交</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> <span class="keyword">id</span> = <span class="number">2</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">A：再次读取数据，发现数据已经被修改了，这就是所谓的“脏读</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line">B:回滚事务</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"></span><br><span class="line">A:再次读数据，发现数据变回初始状态</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure><ol><li><p><strong>提交读：不可重复读（READ COMMITTED）</strong></p><p>注：一个事务从开始到提交之前对数据所做的改变对其他事务是不可见的，这样就解决在READ-UNCOMMITTED级别下的脏读问题。</p><ol><li>事务2执行update语句但未提交前，事务1的前两个select操作返回结果是相同的</li><li>但事务2执行commit操作后，事务1的第三个select操作就读取到事务2对数据的改变</li><li>导致与前两次select操作返回不同的数据，因此出现了不可重复读的问题</li></ol></li></ol><h3 id="READ-COMMITTED（提交读）"><a href="#READ-COMMITTED（提交读）" class="headerlink" title="READ COMMITTED（提交读）"></a>READ COMMITTED（提交读）</h3><p> 一个事务可以读取另一个已提交的事务，多次读取会造成不一样的结果，此现象称为不可重复读问题，Oracle 和 SQL Server 的默认隔离级别。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">A:将客户端A的事务隔离级别设置为read committed(已提交读)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @@session.transaction_isolation = <span class="string">'READ-COMMITTED'</span>;</span><br><span class="line">创建test表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>) <span class="keyword">values</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">A：启动事务，此时数据为初始状态</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"></span><br><span class="line">B：启动事务，更新数据，但不提交</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> <span class="keyword">id</span> = <span class="number">2</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">A：再次读数据，发现数据未被修改</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line">B：提交事务</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line">A：再次读取数据，发现数据已发生变化，说明B提交的修改被事务中的A读到了，这就是所谓的“不可重复读”</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure><ol><li><strong>可重复读：幻读（REPEATABLE READ）：这是MySQL的默认事务隔离级别</strong><ol><li>事务每开启一个实例，都会分配一个版本号给它，如果读取的数据行正在被其他事务执行DELETE或UPDATE操作（既该行上有排他锁）</li><li>这时该事务的读取操作不会等待行上的锁释放，而是根据版本号去读取行的快照数据（记录在undo log中）</li><li>这样，事务中的查询操作返回的都是同一版本下的数据，解决了不可重复读问题。</li><li>虽然该隔离级别下解决了不可重复读问题，但理论上会导致另一个问题：幻读（Phantom Read）。</li><li>一个事务在执行过程中，另一个事务对已有数据行的更改，MVCC机制可保障该事务读取到的原有数据行的内容相同</li><li>但并不能阻止另一个事务插入新的数据行，这就会导致该事务中凭空多出数据行，像出现了幻读一样，这便是幻读问题</li></ol></li></ol><h3 id="REPEATABLE-READ（可重复读）"><a href="#REPEATABLE-READ（可重复读）" class="headerlink" title="REPEATABLE READ（可重复读）"></a>REPEATABLE READ（可重复读）</h3><p> 该隔离级别是 MySQL 默认的隔离级别，在同一个事务里，<code>select</code> 的结果是事务开始时时间点的状态，因此，同样的 <code>select</code> 操作读到的结果会是一致的，但是，会有<strong>幻读</strong>现象 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">将A的隔离级别设置为repeatable read(可重复读)</span><br><span class="line"><span class="keyword">SET</span> @@session.transaction_isolation = <span class="string">'REPEATABLE-READ'</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">A：登录 mysql 终端 A，开启一个事务。</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- 无记录</span></span><br><span class="line"></span><br><span class="line">B：登录 mysql 终端 B，开启一个事务。</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">-- 无记录</span></span><br><span class="line"></span><br><span class="line">A:切换到 mysql 终端 A，增加一条记录并提交。</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">--可以看到已经更改</span></span><br><span class="line"></span><br><span class="line">B:切换到 msyql 终端 B。</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>; <span class="comment">--此时查询还是无记录</span></span><br><span class="line"></span><br><span class="line">通过这一步可以证明，在该隔离级别下已经读取不到别的已提交的事务，如果想看到 mysql 终端 1 提交的事务，在 mysql 终端 2 将当前事务提交后再次查询就可以读取到 mysql 终端 1 提交的事务。</span><br><span class="line"> 可重复读隔离级别只允许读取已提交记录，而且在一个事务两次读取一个记录期间，其他事务部的更新该记录。 </span><br><span class="line"></span><br><span class="line">B：此时接着在 mysql 终端 B 插入一条数据。</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'b'</span>); <span class="comment">-- 此时报主键冲突的错误</span></span><br><span class="line">这就是该隔离级别下可能产生的问题，MySQL 称之为幻读。</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><ol><li><p><strong>可串行读（SERIALIZABLE）</strong></p><ol><li>这是事务的最高隔离级别，通过强制事务排序，使之不可能相互冲突，就像在每个读的数据行加上共享锁来实现</li><li>在该隔离级别下，可以解决前面出现的脏读、不可重复读和幻读问题，但也会导致大量的超时和锁竞争现象，一般不推荐使用</li></ol></li></ol><h3 id="SERIALIZABLE（可串行读）"><a href="#SERIALIZABLE（可串行读）" class="headerlink" title="SERIALIZABLE（可串行读）"></a>SERIALIZABLE（可串行读）</h3><p> 在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的 InnoDB 引擎会给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">A:准备两个终端，在此命名为 mysql 终端 A 和 mysql 终端 B，分别登入 mysql，准备一张测试表 test 并调整隔离级别为 SERIALIZABLE，任意一个终端执行即可。</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">serializable</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">test</span>(<span class="keyword">id</span>) <span class="keyword">values</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">A:登录 mysql 终端 A，开启一个事务，并写入一条数据。</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line">B:登录 mysql 终端 B，开启一个事务。</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>; </span><br><span class="line"> <span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line">A:立马切换到 mysql 终端 A,提交事务。</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line">一旦事务提交，msyql 终端 B 会立马返回 ID 为 1 的记录，否则会一直卡住，直到超时，其中超时参数是由 innodb_lock_wait_timeout 控制</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-1-2、事务的特性&quot;&gt;&lt;a href=&quot;#1-1-2、事务的特性&quot; class=&quot;headerlink&quot; title=&quot;1.1.2、事务的特性&quot;&gt;&lt;/a&gt;1.1.2、事务的特性&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;原子性&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事务中的全部操作在数据库中是不可分割的，要么全部完成，要么全都不完成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一致性&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;隔离性&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;持久性&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="MYSQL" scheme="https://cy-blogs.cn/categories/MYSQL/"/>
    
    
      <category term="MySQL" scheme="https://cy-blogs.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储引擎如何选择</title>
    <link href="https://cy-blogs.cn/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9/"/>
    <id>https://cy-blogs.cn/MySQL存储引擎如何选择/</id>
    <published>2019-12-24T11:09:28.850Z</published>
    <updated>2019-12-24T11:07:47.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL存储引擎如何选择"><a href="#MySQL存储引擎如何选择" class="headerlink" title="MySQL存储引擎如何选择"></a>MySQL存储引擎如何选择</h1><h4 id="定义以及作用"><a href="#定义以及作用" class="headerlink" title="定义以及作用"></a>定义以及作用</h4><blockquote><p>数据库引擎是用于存储、处理和保护数据的核心服务。</p><p>利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。</p><p>使用数据库引擎创建用于联机(客户端与服务端能够实时通信。由客户机发起，直到服务器确认。)事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。</p></blockquote><a id="more"></a><h4 id="Mysql的存储引擎有哪些："><a href="#Mysql的存储引擎有哪些：" class="headerlink" title="Mysql的存储引擎有哪些："></a>Mysql的存储引擎有哪些：</h4><blockquote><p>InnoDB</p><blockquote><p>这是MySQL 5.5或更高版本的默认存储引擎。它提供了事务安全(ACID兼容)表，支持外键引用完整性约束。它支持提交、回滚和紧急恢复功能来保护数据。它还支持行级锁定。当在多用户环境中使用时，它的“一致非锁定读取”提高了性能。它将数据存储在集群索引中，从而减少了基于主键的查询的I/O。</p></blockquote></blockquote><blockquote><p>MyISAM</p><blockquote><p>该存储引擎管理非事务性表，提供高速存储和检索，支持全文搜索。</p></blockquote></blockquote><blockquote><p>MEMORY</p><blockquote><p>提供内存中的表，以前称为堆。它在RAM中处理所有数据，以便比在磁盘上存储数据更快地访问。用于快速查找引用和其他相同的数据。</p></blockquote></blockquote><h4 id="修改数据库引擎"><a href="#修改数据库引擎" class="headerlink" title="修改数据库引擎"></a>修改数据库引擎</h4><blockquote><p>方式壹：</p><blockquote><p>修改配置文件my.ini</p><p>将mysql.ini另存为my.ini，在[mysqld]后面添加default-storage-engine=Innodb,重启服务，数据库默认的引擎修改为Innodb</p></blockquote></blockquote><blockquote><p>方式贰：</p><blockquote><p>在建表得时候指定</p><p>create table table_name(你的各个字段名)type=MyISAM;</p></blockquote></blockquote><blockquote><p>方式叁：</p><blockquote><p>建表后更改</p><p>alert table table_name type=Innodb;</p></blockquote></blockquote><h4 id="如何查看是否修改成功-查看当前数据库的引擎"><a href="#如何查看是否修改成功-查看当前数据库的引擎" class="headerlink" title="如何查看是否修改成功(查看当前数据库的引擎)"></a>如何查看是否修改成功(查看当前数据库的引擎)</h4><blockquote><p>方式壹：</p><blockquote><p>show table status from table_name;</p></blockquote></blockquote><blockquote><p>方拾贰：</p><blockquote><p>show create table table_name;</p></blockquote></blockquote><blockquote><p>方式叁：</p><blockquote><p>使用数据库管理工具(具体自己去问度娘)<br>注意：不同版本之间有可能命令有些不同</p></blockquote></blockquote><h4 id="MyISAM、InnoDB和MEMORY引擎之间的区别"><a href="#MyISAM、InnoDB和MEMORY引擎之间的区别" class="headerlink" title="MyISAM、InnoDB和MEMORY引擎之间的区别:"></a>MyISAM、InnoDB和MEMORY引擎之间的区别:</h4><blockquote><p>InnoDB存储引擎</p><blockquote><p>InnoDB给MySQL的表提供了事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全。在MySQL从3.23.34a开始包含InnnoDB。它是MySQL上第一个提供外键约束的表引擎。而且InnoDB对事务处理的能力，也是其他存储引擎不能比拟的。靠后版本的MySQL的默认存储引擎就是InnoDB。</p><p>InnoDB存储引擎总支持AUTO_INCREMENT。自动增长列的值不能为空，并且值必须唯一。MySQL中规定自增列必须为主键。在插入值的时候，如果自动增长列不输入值，则插入的值为自动增长后的值；如果输入的值为0或空（NULL），则插入的值也是自动增长后的值；如果插入某个确定的值，且该值在前面没有出现过，就可以直接插入。</p><p>InnoDB还支持外键（FOREIGN KEY）。外键所在的表叫做子表，外键所依赖（REFERENCES）的表叫做父表。父表中被字表外键关联的字段必须为主键。当删除、更新父表中的某条信息时，子表也必须有相应的改变，这是数据库的参照完整性规则。</p><p>InnoDB中，创建的表的表结构存储在.frm文件中（我觉得是frame的缩写吧）。数据和索引存储在innodb_data_home_dir和innodb_data_file_path定义的表空间中。</p><p>InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。</p></blockquote></blockquote><blockquote><p>MyISAM存储引擎</p><blockquote><p>MyISAM是MySQL中常见的存储引擎，曾经是MySQL的默认存储引擎。MyISAM是基于ISAM引擎发展起来的，增加了许多有用的扩展。</p><p>MyISAM的表存储成3个文件。文件的名字与表名相同。拓展名为frm、MYD、MYI。其实，frm文件存储表的结构；MYD文件存储数据，是MYData的缩写；MYI文件存储索引，是MYIndex的缩写。</p><p>基于MyISAM存储引擎的表支持3种不同的存储格式。包括静态型、动态型和压缩型。其中，静态型是MyISAM的默认存储格式，它的字段是固定长度的；动态型包含变长字段，记录的长度不是固定的；压缩型需要用到myisampack工具，占用的磁盘空间较小。</p><p>MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。</p></blockquote></blockquote><blockquote><p>MEMORY存储引擎</p><blockquote><p>MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。</p><p>每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。</p><p>MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。</p><p>注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的</p></blockquote></blockquote><h4 id="怎样选择合理的存储引擎"><a href="#怎样选择合理的存储引擎" class="headerlink" title="怎样选择合理的存储引擎"></a>怎样选择合理的存储引擎</h4><blockquote><p>InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</p><p>MyISAM：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。</p><p>MEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。</p><p>注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL存储引擎如何选择&quot;&gt;&lt;a href=&quot;#MySQL存储引擎如何选择&quot; class=&quot;headerlink&quot; title=&quot;MySQL存储引擎如何选择&quot;&gt;&lt;/a&gt;MySQL存储引擎如何选择&lt;/h1&gt;&lt;h4 id=&quot;定义以及作用&quot;&gt;&lt;a href=&quot;#定义以及作用&quot; class=&quot;headerlink&quot; title=&quot;定义以及作用&quot;&gt;&lt;/a&gt;定义以及作用&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;数据库引擎是用于存储、处理和保护数据的核心服务。&lt;/p&gt;
&lt;p&gt;利用数据库引擎可控制访问权限并快速处理事务，从而满足企业内大多数需要处理大量数据的应用程序的要求。&lt;/p&gt;
&lt;p&gt;使用数据库引擎创建用于联机(客户端与服务端能够实时通信。由客户机发起，直到服务器确认。)事务处理或联机分析处理数据的关系数据库。这包括创建用于存储数据的表和用于查看、管理和保护数据安全的数据库对象（如索引、视图和存储过程）。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="MYSQL" scheme="https://cy-blogs.cn/categories/MYSQL/"/>
    
    
      <category term="MySQL 引擎" scheme="https://cy-blogs.cn/tags/MySQL-%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>MySQL MyISAM 引擎</title>
    <link href="https://cy-blogs.cn/MySQL%20MyISAM%E5%BC%95%E6%93%8E/"/>
    <id>https://cy-blogs.cn/MySQL MyISAM引擎/</id>
    <published>2019-12-24T11:09:28.848Z</published>
    <updated>2019-12-24T11:07:25.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-MyISAM引擎"><a href="#MySQL-MyISAM引擎" class="headerlink" title="MySQL MyISAM引擎"></a>MySQL MyISAM引擎</h1><h4 id="MyISAM-介绍"><a href="#MyISAM-介绍" class="headerlink" title="MyISAM 介绍"></a>MyISAM 介绍</h4><blockquote><p>myisam引擎是MySQL关系数据库系统的默认储存引擎（mysql 5.5.5之前）。这种MySQL表存储结构从旧的ISAM代码扩展出许多有用的功能。在新版本的Mysql中，Innodb引擎由于其对事务参照完整性，以及更高的并发性等优点开始逐步取代Myisam引擎。<br>MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM所改良。虽然性能极佳，但却有一个缺点：不支持事务处理（transaction）。</p><p>MySQL的MyISAM存储引擎支持压缩表空间，压缩后的表空间会减少，但是压缩后的表是只读的，不能插入和更新数据，如果需要更新，则需要解压后更新，再压缩 。</p><p>每一个myisam的表都对应于硬盘上的三个文件。这三个文件有一样的文件名，但是有不同的扩展名指示其类型用途：.frm文件保存表的定义，这个文件并不是myisam引擎的一部分，而是服务器的一部分；.MYD保存表的数据；.MYI是表的索引文件。.MYD和.MYI是MyISAM的关键点。</p></blockquote><a id="more"></a><h4 id="MyASAM-引擎的特点"><a href="#MyASAM-引擎的特点" class="headerlink" title="MyASAM 引擎的特点"></a>MyASAM 引擎的特点</h4><blockquote><p>1.不支持事务（事务是指逻辑上的一组操作，组成这组操作的各个单元，要么全成功要么全失败）<br>2.表级锁定，数据更新时锁定整个表：其锁定机制是表级锁定，这虽然可以让锁定的实现成本很小但是也同时大大降低了其并发性能。<br>3.读写互相阻塞：不仅会在写入的时候阻塞读取，myisam还会在读取的时候阻塞写入，但读本身并不会阻塞另外的读。<br>4.只会缓存索引：myisam可以通过key_buffer_size缓存索引，以大大提高访问性能，减少产品IO，但是这个缓存区只会缓存索引，而不会缓存数据。<br>key_buffer_size = 16M<br>5.读取速度较快，占用资源相对少。<br>6.不支持外键约束，但支持全文索引。</p></blockquote><h4 id="MyISAM-引攀适用的生产业务场景，"><a href="#MyISAM-引攀适用的生产业务场景，" class="headerlink" title="MyISAM 引攀适用的生产业务场景，"></a>MyISAM 引攀适用的生产业务场景，</h4><blockquote><p>1.不需要事务支持的业务（例如转账就不行）。<br>2.一般为读数据比较多的应用，读写都频繁场景不适合，读多或者写多的都适合。<br>3.读写并发访问相对较低的业务（纯读纯写高并发也可以）（锁定机制问题）<br>4.数据修改相对较少的业务（阻塞问题）。<br>5.以读为主的业务，例如：数据库系统表、www， blog ，图片信息数据库，用户数据库，商品库等业务。<br>6.对数据一致性要求不是非常高的业务（不支持事务）。<br>7.硬件资源比较差的机器可以用 MyiSAM （占用资源少）<br>8.使用读写分离的 MySQL 从库可以使用 MyISAM。</p></blockquote><blockquote><p>小结：单一对数据库的操作都可以使用MyiSAM，所谓单一就是尽量纯读，或纯写 ( insert . update , delete ）等</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL-MyISAM引擎&quot;&gt;&lt;a href=&quot;#MySQL-MyISAM引擎&quot; class=&quot;headerlink&quot; title=&quot;MySQL MyISAM引擎&quot;&gt;&lt;/a&gt;MySQL MyISAM引擎&lt;/h1&gt;&lt;h4 id=&quot;MyISAM-介绍&quot;&gt;&lt;a href=&quot;#MyISAM-介绍&quot; class=&quot;headerlink&quot; title=&quot;MyISAM 介绍&quot;&gt;&lt;/a&gt;MyISAM 介绍&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;myisam引擎是MySQL关系数据库系统的默认储存引擎（mysql 5.5.5之前）。这种MySQL表存储结构从旧的ISAM代码扩展出许多有用的功能。在新版本的Mysql中，Innodb引擎由于其对事务参照完整性，以及更高的并发性等优点开始逐步取代Myisam引擎。&lt;br&gt;MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM所改良。虽然性能极佳，但却有一个缺点：不支持事务处理（transaction）。&lt;/p&gt;
&lt;p&gt;MySQL的MyISAM存储引擎支持压缩表空间，压缩后的表空间会减少，但是压缩后的表是只读的，不能插入和更新数据，如果需要更新，则需要解压后更新，再压缩 。&lt;/p&gt;
&lt;p&gt;每一个myisam的表都对应于硬盘上的三个文件。这三个文件有一样的文件名，但是有不同的扩展名指示其类型用途：.frm文件保存表的定义，这个文件并不是myisam引擎的一部分，而是服务器的一部分；.MYD保存表的数据；.MYI是表的索引文件。.MYD和.MYI是MyISAM的关键点。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="MYSQL" scheme="https://cy-blogs.cn/categories/MYSQL/"/>
    
    
      <category term="MySQL 引擎" scheme="https://cy-blogs.cn/tags/MySQL-%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>MySQL MEMORY引擎</title>
    <link href="https://cy-blogs.cn/MySQL%20MEMORY%E5%BC%95%E6%93%8E/"/>
    <id>https://cy-blogs.cn/MySQL MEMORY引擎/</id>
    <published>2019-12-24T11:09:28.742Z</published>
    <updated>2019-12-24T11:06:58.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-MEMORY引擎"><a href="#MySQL-MEMORY引擎" class="headerlink" title="MySQL MEMORY引擎"></a>MySQL MEMORY引擎</h1><h4 id="MEMORY-介绍"><a href="#MEMORY-介绍" class="headerlink" title="MEMORY 介绍"></a>MEMORY 介绍</h4><blockquote><p>MEMORY存储引擎创建的表数据只能保存在内存。</p><p>memoery存储引擎是在内存中来创建表，每个memory表只实际对应一个磁盘文件格式是.frm. 该引擎的表访问非常得快，因为数据是放在内存中，且默认是hash索引，但服务关闭，表中的数据就会丢失掉。</p><p>MySQL宕机、硬件故障或者意外掉电，都会造成MEMORY引擎表丢失数据。所以，MEMORY表中的数据来源于其他表(可落盘永久保存)用于只读适用，或者用于临时工作起到数据周转。</p><p>服务器需要足够的内存来维护所有在同一时间使用的memory表，当不再需要时，要释放，应执行 delete from 或 truncate table 或删除表drop table。</p><p>每个memory表放置的数据量大小，受到max_heap_table_size系统变量的约束，初始值是16MB. 通过max_rows 子句指定表的最大行数。</p></blockquote><a id="more"></a><h4 id="MEMORY-引擎的特点"><a href="#MEMORY-引擎的特点" class="headerlink" title="MEMORY 引擎的特点"></a>MEMORY 引擎的特点</h4><blockquote><p>memeory存储引擎使用hash索引对于等值查找是很高效的</p><p>比较容易丢失数据</p></blockquote><h4 id="MEMORY-引擎适用的生产业务场景"><a href="#MEMORY-引擎适用的生产业务场景" class="headerlink" title="MEMORY 引擎适用的生产业务场景"></a>MEMORY 引擎适用的生产业务场景</h4><blockquote><p>临时使用、不重要的数据，例如网站的会话管理和缓存。可接受数据丢失<br>可以用于存储在分析中产生的中间表<br>使用memroy存储引擎的表一定要是可以再生的或者是不需要的</p></blockquote><blockquote><p>小结：据保存在ram(内存)中，访问速度快，但对表的大小有限制，要确保数据是可以恢复的，常用于更新不太频繁的小表，用以快速访问。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL-MEMORY引擎&quot;&gt;&lt;a href=&quot;#MySQL-MEMORY引擎&quot; class=&quot;headerlink&quot; title=&quot;MySQL MEMORY引擎&quot;&gt;&lt;/a&gt;MySQL MEMORY引擎&lt;/h1&gt;&lt;h4 id=&quot;MEMORY-介绍&quot;&gt;&lt;a href=&quot;#MEMORY-介绍&quot; class=&quot;headerlink&quot; title=&quot;MEMORY 介绍&quot;&gt;&lt;/a&gt;MEMORY 介绍&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;MEMORY存储引擎创建的表数据只能保存在内存。&lt;/p&gt;
&lt;p&gt;memoery存储引擎是在内存中来创建表，每个memory表只实际对应一个磁盘文件格式是.frm. 该引擎的表访问非常得快，因为数据是放在内存中，且默认是hash索引，但服务关闭，表中的数据就会丢失掉。&lt;/p&gt;
&lt;p&gt;MySQL宕机、硬件故障或者意外掉电，都会造成MEMORY引擎表丢失数据。所以，MEMORY表中的数据来源于其他表(可落盘永久保存)用于只读适用，或者用于临时工作起到数据周转。&lt;/p&gt;
&lt;p&gt;服务器需要足够的内存来维护所有在同一时间使用的memory表，当不再需要时，要释放，应执行 delete from 或 truncate table 或删除表drop table。&lt;/p&gt;
&lt;p&gt;每个memory表放置的数据量大小，受到max_heap_table_size系统变量的约束，初始值是16MB. 通过max_rows 子句指定表的最大行数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="MYSQL" scheme="https://cy-blogs.cn/categories/MYSQL/"/>
    
    
      <category term="MySQL 引擎" scheme="https://cy-blogs.cn/tags/MySQL-%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Innodb引擎</title>
    <link href="https://cy-blogs.cn/MySQL%20Innodb%E5%BC%95%E6%93%8E/"/>
    <id>https://cy-blogs.cn/MySQL Innodb引擎/</id>
    <published>2019-12-24T11:09:28.740Z</published>
    <updated>2019-12-24T11:07:02.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-Innodb引擎"><a href="#MySQL-Innodb引擎" class="headerlink" title="MySQL Innodb引擎"></a>MySQL Innodb引擎</h1><h4 id="Innodb-介绍"><a href="#Innodb-介绍" class="headerlink" title="Innodb 介绍"></a>Innodb 介绍</h4><blockquote><p>InnoDB引擎的优点是支持兼容ACID的事务，以及参数完整性（即对外键的支持）。<br>Oracle公司2005年10月收购了Innovase；mysql5.5.5之后数据库的默认存储引擎为InnoDB</p></blockquote><a id="more"></a><h6 id="Innodb-的特点"><a href="#Innodb-的特点" class="headerlink" title="Innodb 的特点"></a>Innodb 的特点</h6><blockquote><p>1.支持事务，支持4个事务隔离级别，支持多版本读。<br>2.行级锁定（更新时一般是锁定当前行），通过索引实现，全表扫描仍然会是表锁，注意间隙锁的影响。<br>3.读写阻塞与事务隔离级别相关。<br>4.具有非常高效的缓存特性：能缓存索引，也能缓存数据。<br>5.整个表和主键以Cluster方式存储，组成一个平衡树。<br>6.所有Secondary Index都会保存主键信息。<br>7.支持分区，表空间，类似oracle数据库。<br>8.支持外键约束，5.5之前不支持全文索引，5.5之后支持外键索引。<br>9.和Myisam引擎比，Innodb对硬件资源要求比较高</p></blockquote><p>InnoDB:支持行级锁(row-level locking)和表级锁,默认为行级锁。</p><h6 id="Innodb-引擎适用的生产业务场景"><a href="#Innodb-引擎适用的生产业务场景" class="headerlink" title="Innodb 引擎适用的生产业务场景"></a>Innodb 引擎适用的生产业务场景</h6><blockquote><p>1、需要事务支持的业务（具有较好的事务特性）<br>2、行级锁定对高并发有很好的适应能力，但需要确保查询时通过索引完成。<br>3、数据读写及更新都较为频繁的场景，如：bbs，sns，微博，微信等。<br>4、数据一致性要求较高的业务，例如：充值转账，银行卡转账。<br>5、硬件设备内存较大，可以利用Innodb较好的缓存能力来提高内存利用率，尽可能减少磁盘IO。</p><p>innodb_buffer_pool_size = 2048M<br>innodb_buffer_pool_size = 64M #InnoDB使用一个缓冲池来保存索引和原始数据，设置越大，在存取表里面数据时所需要的磁盘I/O越少。强烈建议不要武断地将InnoDB的Buffer Pool值配置为物理内存的50%~80%，应根据具体环境而定。<br>16G内存多实例差不多给2G</p></blockquote><h4 id="Innodb存储引擎"><a href="#Innodb存储引擎" class="headerlink" title="Innodb存储引擎"></a>Innodb存储引擎</h4><blockquote><p>Innodb是事务型数据库的首选引，支持事物安全表(ACID)</p><blockquote><p>事务的ACID属性：即原子性、一致性、隔离性、持久性</p><blockquote><p>a.原子性：原子性也就是说这组语句要么全部执行，要么全部不执行，如果事务执行到一半出现错误，数据库就要回滚到事务开始执行的地方。</p></blockquote></blockquote></blockquote><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现：主要是基于MySQ日志系统的<span class="keyword">redo</span>和<span class="keyword">undo</span>机制。事务是一组SQL语句，里面有选择，查询、删除等功能。每条语句执行会有一个节点。例如，删除语句执行后，在事务中有个记录保存下来，这个记录中储存了我们什么时候做了什么事。如果出错了，就会回滚到原来的位置，<span class="keyword">redo</span>里面已经存储了我做过什么事了，然后逆向执行一遍就可以了。</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>b.一致性：事务开始前和结束后，数据库的完整性约束没有被破坏。(eg:比如A向B转账，不可能A扣了钱，B却没有收到)<br>c.隔离性：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰；</p></blockquote></blockquote></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果不考虑隔离性则会出现几个问题：</span><br><span class="line">                                 a、脏读：是指在一个事务处理过程里读取了另一个未提交的事务中的数据（当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致）；（读取了另一个事务未提交的脏数据）</span><br><span class="line">                                 aa、不可重复读：在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了；（读取了前一个事务提交的数据，查询的都是同一个数据项）</span><br><span class="line">                                 aaa、虚读（幻读）：是事务非独立执行时发生的一种现象（eg:事务<span class="built_in">T1</span>对一个表中所有的行的某个数据项做了从“<span class="number">1</span>”修改为“<span class="number">2</span>”的操作，这时事务<span class="built_in">T2</span>又对这个表中插入了一行数据项，而这个数据项的数值还是为“<span class="number">1</span>”并且提交给数据库。而操作事务<span class="built_in">T1</span>的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务<span class="built_in">T2</span>中添加的，就好像产生幻觉一样）；（读取了前一个事务提交的数据，针对一批数据整体）</span><br></pre></td></tr></table></figure><blockquote><blockquote><blockquote><p>d.持久性：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚</p></blockquote></blockquote></blockquote><h6 id="MySQL数据库为我们提供的四种隔离级别："><a href="#MySQL数据库为我们提供的四种隔离级别：" class="headerlink" title="MySQL数据库为我们提供的四种隔离级别："></a>MySQL数据库为我们提供的四种隔离级别：</h6><blockquote><p>1、Serializable（串行化）：可避免脏读、不可重复读、幻读的发生；</p><p>2、Repeatable read（可重复读）：可避免脏读、不可重复读的发生；</p><p>3、Read committed（读已提交）：可避免脏读的发生；</p><p>4、Read uncommitted（读未提交）：最低级别，任何情况都无法保证；</p><blockquote><p>从1—-4隔离级别由高到低，级别越高，执行效率越低</p></blockquote></blockquote><p>InnoDB的存储文件有两个，后缀名分别是 .frm和 .idb；其中 .frm是表的定义文件， .idb是表的数据文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL-Innodb引擎&quot;&gt;&lt;a href=&quot;#MySQL-Innodb引擎&quot; class=&quot;headerlink&quot; title=&quot;MySQL Innodb引擎&quot;&gt;&lt;/a&gt;MySQL Innodb引擎&lt;/h1&gt;&lt;h4 id=&quot;Innodb-介绍&quot;&gt;&lt;a href=&quot;#Innodb-介绍&quot; class=&quot;headerlink&quot; title=&quot;Innodb 介绍&quot;&gt;&lt;/a&gt;Innodb 介绍&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;InnoDB引擎的优点是支持兼容ACID的事务，以及参数完整性（即对外键的支持）。&lt;br&gt;Oracle公司2005年10月收购了Innovase；mysql5.5.5之后数据库的默认存储引擎为InnoDB&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="MYSQL" scheme="https://cy-blogs.cn/categories/MYSQL/"/>
    
    
      <category term="MySQL 引擎" scheme="https://cy-blogs.cn/tags/MySQL-%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>使用xtrabackup备份mysql</title>
    <link href="https://cy-blogs.cn/%E4%BD%BF%E7%94%A8xtrabackup%E8%BF%9B%E8%A1%8C%E5%A4%87%E4%BB%BD/"/>
    <id>https://cy-blogs.cn/使用xtrabackup进行备份/</id>
    <published>2019-12-24T11:05:34.478Z</published>
    <updated>2019-12-24T11:05:29.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用xtrabackup备份mysql"><a href="#使用xtrabackup备份mysql" class="headerlink" title="使用xtrabackup备份mysql"></a>使用xtrabackup备份mysql</h1><h2 id="简介（Percona-XtraBackup-）简称PXB"><a href="#简介（Percona-XtraBackup-）简称PXB" class="headerlink" title="简介（Percona XtraBackup ）简称PXB"></a>简介（<a href="https://www.percona.com/software/mysql-database/percona-xtrabackup" target="_blank" rel="noopener">Percona XtraBackup</a> ）简称PXB</h2><blockquote><p>Xtrabackup是由percona开源的免费数据库热备份软件，它能对Innodb数据库和Xtradb存储引擎的数据库非阻塞地备份。（对于Myisam的备份同样需要加表锁），mysqldump备份方式是采用的逻辑备份，其最大的缺陷是备份和恢复速度较慢，如果数据库大于50G，mysqldump备份就不太适合。</p></blockquote><a id="more"></a><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>备份速度快，物理备份可靠</li><li>备份过程不会打断正在执行的事务（无需锁表）</li><li>能够基于压缩等功能节约磁盘空间和流量</li><li>自动备份校验</li><li>还原速度快</li><li>可以流传将备份传输到另一台机器上</li><li>在不增加服务器负载的情况下备份数据</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote><p>​    备份开始的时候，首先会开启一个后台检测进程，实时检测mysql redo到的变化，一旦发现有新的日志写入，立刻将日志记入后台日志文件xtrabackup_log中，之后赋值innodb的数据文件，系统表空间文件ibdatax，复制后，将上锁（读锁），flush tables with read lock，让后复制.frm MYI MYD等文件，最后执行 unlock tables（释放锁），最终停止xtrabackup_log。</p></blockquote><p>​        <img src="http://mysql.taobao.org/monthly/pic/2016-03-07/PXB-backup-procedure.png" alt="image "></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><blockquote><p>​    在innodb内部会维护一个redo日志文件，我们也可以叫做事务日志文    件，事务日志会存储每一个Innodb表数据的记录修改。当Innodb启动时，Innodb会检查数据文件和事务日志。并执行两个步骤：它应用（前滚）已经提交的事务日志到数据文件，并将修改过但没有提交的数据进行回滚操作。</p><p>​    xtrabackup在启动时会记住log    sequence number（LSN），并且复制所有数据文件，复制过程需要一些时间，所以这期间如果数据文件有改动，那么将会使数据库处于一个不同的时间点。这时，Xtrabackup会运行一个后台进程，用于监测事务日志，并从事务日志复制最新的修改。xtrabackup必须持续的做这个操作，因为事务日志是会轮转重复的写入，并且事务日志可以被重用。所以xtrabackup自启动开始，就不停的将事务日志中每个数据文件的修改都记录下来。这就是xtrabackup的备份过程。</p><p>​    接下来是准备（prepare）过程。在这个过程中，xtrabackup使用之前复制的事务日志。对各个数据文件执行灾难恢复（就像mysql刚启动时要做的一样）。当这个过程结束后，数据库就可以做恢复还原了。</p><p>​    整个过程就是-备份-》准备。先将文件全部复制过来，在根据事务日志对部分操作进行回滚。</p><p>​    程序innobbackupex可以允许我们备份Myisam表和文件从而增加了便捷和功能。</p><p>​    innobbackupex会启动xtrabackup，直到xtrabackup复制数据文件后，然后执行FLUSH TABLES WITH READ LOCK 来阻止新的写入刷新到磁盘上。之后复制Myisam数据文件。最后UNLOCK TABLES （释放锁）。</p><p>​    备份Myisam和Innodb表最终会处于一致，在准备（prepare）过程结束后，Innodb表数据已经前滚到整个备份结束点，而不是回滚到xtrabackup感刚开始的点。这个时间点与执行FLUSH TABLES WITH READ LOCK的时间点相同，所以Myisam表数据与Innodb表数据是同步的。</p></blockquote><h2 id="xtrabackup增量备份"><a href="#xtrabackup增量备份" class="headerlink" title="xtrabackup增量备份"></a>xtrabackup增量备份</h2><ul><li><p>原理</p><blockquote><p>​    首先是建立在完全备份的基础上，记录下此时的检查点LSN</p><p>​    在进行增量备份时，比较表空间中每个页的LSN是否大于上次备份的LSN，若是则备份该页并记录当前检查点的LSN。</p></blockquote></li><li><p>优点：</p><ul><li>数据库太大没有足够的空间全量备份，增量备份能有效节省空间，并且效率高</li><li>支持热备份，备份过程不锁表（针对Innodb而言），不阻塞数据库读写。</li><li>每日备份只产生少量数据，也可采用远程备份，节省本地空间</li><li>备份恢复基于文件操作，降低直接对数据库操作风险</li><li>备份效率更高，恢复效率更高。</li></ul></li></ul><h2 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h2><p>软件包安装完后一共有4个可执行文件，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">usr</span><br><span class="line">├── bin</span><br><span class="line">│   ├── innobackupex</span><br><span class="line">│   ├── xbcrypt  #用来加密或解密备份的数据</span><br><span class="line">│   ├── xbstream  #用来解压或压缩xbstream格式的文件</span><br><span class="line">│   └── xtrabackup</span><br></pre></td></tr></table></figure><p>其中最主要的是 <code>innobackupex</code> 和 <code>xtrabackup</code>，前者是一个 perl 脚本，后者是 C/C++ 编译的二进制。</p><p><code>xtrabackup</code> 是用来备份 InnoDB 表的，不能备份非 InnoDB 表，和 mysqld server 没有交互；<code>innobackupex</code> 脚本用来备份非 InnoDB 表，同时会调用 <code>xtrabackup</code> 命令来备份 InnoDB 表，还会和 mysqld server 发送命令进行交互，如加读锁（FTWRL）、获取位点（SHOW SLAVE STATUS）等。简单来说，<code>innobackupex</code> 在 <code>xtrabackup</code> 之上做了一层封装。</p><p>一般情况下，我们是希望能备份 MyISAM 表的，虽然我们可能自己不用 MyISAM 表，但是 mysql 库下的系统表是 MyISAM 的，因此备份基本都通过 <code>innobackupex</code> 命令进行；另外一个原因是我们可能需要保存位点信息。</p><p>另外2个工具相对小众些，<code>xbcrypt</code> 是加解密用的；<code>xbstream</code> 类似于tar，是 Percona 自己实现的一种支持并发写的流文件格式。两都在备份和解压时都会用到（如果备份用了加密和并发）。</p><p>本文的介绍的主角是 <code>innobackupex</code> 和 <code>xtrabackup</code>。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载##"></a>下载##</h2><ul><li><p>安装percona仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install http://www.percona.com/downloads/percona-release/redhat/0.1-4/percona-release-0.1-4.noarch.rpm</span><br></pre></td></tr></table></figure></li><li><p>安装xtrabackup</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install percona-xtrabackup -y</span><br></pre></td></tr></table></figure></li><li><p>创建备份用户及设置权限（也可以直接使用root用户）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER ‘用户名’@'localhost' IDENTIFIED BY '密码';#创建</span><br><span class="line">GRANT RELOAD,LOCK TABLES,PROCESS,REPLICATION CLIENT ON *.* TO '用户名'@'localhost';#设置权限</span><br><span class="line">FLUSH PRIVILEGES;#刷新权限</span><br></pre></td></tr></table></figure></li><li><p>配置xtrabackup（可配置也可以已参数的形式写入）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /root/.my.cnf</span><br><span class="line"></span><br><span class="line">[xtrabackup]</span><br><span class="line"></span><br><span class="line">user=创建的用户名</span><br><span class="line"></span><br><span class="line">password=密码</span><br></pre></td></tr></table></figure></li><li><p>创建备份使用的文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/backup/mysql</span><br></pre></td></tr></table></figure></li></ul><h2 id="基于xtrabackup的备份和恢复"><a href="#基于xtrabackup的备份和恢复" class="headerlink" title="基于xtrabackup的备份和恢复"></a>基于xtrabackup的备份和恢复</h2><ul><li><p><em>xtrabackup</em> 只支持innodb引擎和xtradb引擎</p></li><li><p>语法：</p><ul><li>–backup 表示该操作代表备份操作</li><li>–target-dir 指定备份文件的路径</li><li>–user 备份的用户 （设定配置文件后，无需指定）</li><li>–password  用户密码（同上）</li><li>–socket 指定socket启动文件路径（不添加使用默认路径）</li><li>–incremental-basedir  表示在某个全量备份的基础上进行增备</li></ul></li><li><p>全量备份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@ax mysql]# xtrabackup --backup --target-dir=/data/backup/mysql</span><br><span class="line"><span class="meta">#</span><span class="bash">以下是返回的结果</span></span><br><span class="line">191221 13:49:02  version_check Connecting to MySQL server with DSN 'dbi:mysql:;mysql_read_default_group=xtrabackup' as 'backuper'  (using password: YES).</span><br><span class="line">191221 13:49:02  version_check Connected to MySQL server</span><br><span class="line">191221 13:49:02  version_check Executing a version check against the server...</span><br><span class="line">191221 13:49:02  version_check Done.</span><br><span class="line">191221 13:49:02 Connecting to MySQL server host: localhost, user: backuper, password: set, port: not set, socket: not set</span><br><span class="line">Using server version 5.5.64-MariaDB</span><br><span class="line">xtrabackup version 2.3.10 based on MySQL server 5.6.24 Linux (x86_64) (revision id: bd0d4403f36)</span><br><span class="line">xtrabackup: uses posix_fadvise().</span><br><span class="line">xtrabackup: cd to /var/lib/mysql</span><br><span class="line">xtrabackup: open files limit requested 0, set to 65535</span><br><span class="line">xtrabackup: using the following InnoDB configuration:</span><br><span class="line"><span class="meta">#</span><span class="bash">省略.....</span></span><br><span class="line">MySQL binlog position: filename 'mysql-bin.000001', position '245'</span><br><span class="line">191221 13:49:03 [00] Writing backup-my.cnf</span><br><span class="line">191221 13:49:03 [00]        ...done</span><br><span class="line">191221 13:49:03 [00] Writing xtrabackup_info</span><br><span class="line">191221 13:49:03 [00]        ...done</span><br><span class="line">xtrabackup: Transaction log of lsn (8622624) to (8622624) was copied.</span><br><span class="line">191221 13:49:04 completed OK!#代表成功全量备份</span><br></pre></td></tr></table></figure></li><li><p>在全量备份的基础上进行增量备份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">xtrabackup --backup --target-dir=/data/mysql/增量备份文件夹的名字（自定义）--incremental-basedir=/全量备份文件路径</span></span><br><span class="line">[root@ax mysql]# xtrabackup --backup --target-dir=/data/backup/mysql/mysql_increment1 --incremental-basedir=/data/backup/mysql</span><br><span class="line">191221 14:00:43  version_check Connecting to MySQL server with DSN 'dbi:mysql:;mysql_read_default_group=xtrabackup' as 'backuper'  (using password: YES).</span><br><span class="line">191221 14:00:43  version_check Connected to MySQL server</span><br><span class="line">191221 14:00:43  version_check Executing a version check against the server...</span><br><span class="line">191221 14:00:43  version_check Done.</span><br><span class="line">191221 14:00:43 Connecting to MySQL server host: localhost, user: backuper, password: set, port: not set, socket: not set</span><br><span class="line">Using server version 5.5.64-MariaDB</span><br><span class="line">xtrabackup version 2.3.10 based on MySQL server 5.6.24 Linux (x86_64) (revision id: bd0d4403f36)</span><br><span class="line">incremental backup from 8622624 is enabled.</span><br><span class="line">xtrabackup: uses posix_fadvise().</span><br><span class="line">xtrabackup: cd to /var/lib/mysql</span><br><span class="line">xtrabackup: open files limit requested 0, set to 65535</span><br><span class="line"><span class="meta">#</span><span class="bash">省略....</span></span><br><span class="line">xtrabackup: Stopping log copying thread.</span><br><span class="line">.191221 14:00:45 &gt;&gt; log scanned up to (8622624)</span><br><span class="line"></span><br><span class="line">191221 14:00:45 Executing UNLOCK TABLES</span><br><span class="line">191221 14:00:45 All tables unlocked</span><br><span class="line">191221 14:00:45 Backup created in directory '/data/backup/mysql/mysql_increment1/'</span><br><span class="line">MySQL binlog position: filename 'mysql-bin.000001', position '245'</span><br><span class="line">191221 14:00:45 [00] Writing backup-my.cnf</span><br><span class="line">191221 14:00:45 [00]        ...done</span><br><span class="line">191221 14:00:45 [00] Writing xtrabackup_info</span><br><span class="line">191221 14:00:45 [00]        ...done</span><br><span class="line">xtrabackup: Transaction log of lsn (8622624) to (8622624) was copied.</span><br><span class="line">191221 14:00:45 completed OK!#代表增量备份成功</span><br></pre></td></tr></table></figure></li><li><p>在增量备份的基础上继续增量备份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在第一次增量备份后，以后的每一次增量备份都是以上一次增量备份为基准</span></span><br><span class="line"><span class="meta">#</span><span class="bash">xtrabackup --backup --target-dir=增量备份文件路径 --incremental-basedir=上次增量备份的文件位置</span></span><br><span class="line">[root@ax ~]# xtrabackup --backup --target-dir=/data/backup/mysql_increment2 --incremental-basedir=/data/backup/mysql/mysql_increment1</span><br><span class="line">191221 18:39:28  version_check Connecting to MySQL server with DSN 'dbi:mysql:;mysql_read_default_group=xtrabackup' as 'backuper'  (using password: YES).</span><br><span class="line">191221 18:39:28  version_check Connected to MySQL server</span><br><span class="line">191221 18:39:28  version_check Executing a version check against the server...</span><br><span class="line">191221 18:39:28  version_check Done.</span><br><span class="line">191221 18:39:28 Connecting to MySQL server host: localhost, user: backuper, password: set, port: not set, socket: not set</span><br><span class="line">Using server version 5.5.64-MariaDB</span><br><span class="line">xtrabackup version 2.3.10 based on MySQL server 5.6.24 </span><br><span class="line"><span class="meta">#</span><span class="bash">省略...</span></span><br><span class="line">191221 18:39:32 Executing UNLOCK TABLES</span><br><span class="line">191221 18:39:32 All tables unlocked</span><br><span class="line">191221 18:39:32 Backup created in directory '/data/backup/mysql_increment2/'</span><br><span class="line">MySQL binlog position: filename 'mysql-bin.000001', position '245'</span><br><span class="line">191221 18:39:32 [00] Writing backup-my.cnf</span><br><span class="line">191221 18:39:32 [00]        ...done</span><br><span class="line">191221 18:39:32 [00] Writing xtrabackup_info</span><br><span class="line">191221 18:39:32 [00]        ...done</span><br><span class="line">xtrabackup: Transaction log of lsn (8622624) to (8622624) was copied.</span><br><span class="line">191221 18:39:32 completed OK!#代表成功</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用xtrabackup恢复"><a href="#使用xtrabackup恢复" class="headerlink" title="使用xtrabackup恢复"></a>使用xtrabackup恢复</h2><ul><li><p>语法：</p><ul><li><p>xtrabackup –prepare –apply-log-only –target-dir=全量备份文件路径</p><ul><li>–prepare  表示还原</li><li>–apply-log-only 表示不回滚事务，因为后面有基于全备的增量备份，所以不需要回滚，如果没有增量备份则可以不添加。</li></ul></li><li><p>将第一次增量备份加载至全备中（增量备份多每次都要以上一次加载的备份文件为基准，命令相同，只需修改增量备份文件的路径即可。）</p></li><li><p>在加载最后一次的增量备份文件时，不需要添加–apply-log-only，因为增量备份都加载完成了，所以需要事务回滚。</p></li><li><p>如果恢复的是增量备份，需要先执行<code>xtrabackup --prepare --apply-log-only --target-dir=全量备份文件路径</code> 准备好全量基准</p></li><li><p>在全量备份准备好的基础上在将增量加载至全量备份 <code>xtrabackup --prepare --apply-log-only --target-dir=全量备份文件路径 --incremental-dir=增量备份文件路径</code></p></li><li><p>最后一次的增量加载至全量备份。不需要添加apply-log-only<code>xtrabackup --prepare  --target-dir=全量备份文件路径 --incremental-dir=增量备份文件路径</code> 这样就可以还原了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">xtrabackup --prepare --apply-log-only --target-dir=全量备份文件路径 --incremental-dir=增量备份文件路径</span></span><br><span class="line">[root@ax ~]# xtrabackup --prepare --apply-log-only --target-dir=/data/backup/mysql --incremental-dir=/data/backup/mysql_increment1</span><br><span class="line">xtrabackup version 2.3.10 based on MySQL server 5.6.24 Linux (x86_64) (revision id: bd0d4403f36)</span><br><span class="line">incremental backup from 8622624 is enabled.</span><br><span class="line">xtrabackup: cd to /data/backup/mysql/</span><br><span class="line">xtrabackup: This target seems to be already </span><br><span class="line"><span class="meta">#</span><span class="bash">省略...</span></span><br><span class="line">191221 18:56:43 [01]        ...done</span><br><span class="line">191221 18:56:43 [01] Copying /data/backup/mysql_increment1/mysql/db.MYD to ./mysql/db.MYD</span><br><span class="line">191221 18:56:43 [01]        ...done</span><br><span class="line">191221 18:56:43 [00] Copying /data/backup/mysql_increment1//xtrabackup_binlog_info to ./xtrabackup_binlog_info</span><br><span class="line">191221 18:56:43 [00]        ...done</span><br><span class="line">191221 18:56:43 [00] Copying /data/backup/mysql_increment1//xtrabackup_info to ./xtrabackup_info</span><br><span class="line">191221 18:56:43 [00]        ...done</span><br><span class="line">191221 18:56:43 completed OK!#代表成功</span><br><span class="line"><span class="meta">#</span><span class="bash">最后一加载增量备份到全量备份</span></span><br><span class="line">[root@ax ~]# xtrabackup --prepare --target-dir=/data/backup/mysql --incremental-dir=/data/backup/mysql_increment2</span><br><span class="line"><span class="meta">#</span><span class="bash">返回也上面最后一行的结果代表成功</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>恢复</p><ul><li><p>停止mysql服务</p></li><li><p>清空mysql的数据目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [(none)]&gt; show variables like &apos;datadir&apos;; #查询数据目录</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| datadir       | /var/lib/mysql/ |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">#cd到指定目录 rm -rf ./*  这是模拟数据库损坏</span><br></pre></td></tr></table></figure></li><li><p>恢复 <code>xtrabackup --copy-back --target-dir=/data/backup/mysql</code>  –copy-back 将备份的数据目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@ax ~]# xtrabackup --copy-back --target-dir=/data/backup/mysql</span><br><span class="line">xtrabackup version 2.3.10 based on MySQL server 5.6.24 Linux (x86_64) (revision id: bd0d4403f36)</span><br><span class="line">191221 19:23:55 [01] Copying ib_logfile0 to /var/lib/mysql/ib_logfile0</span><br><span class="line">191221 19:23:55 [01]        ...done</span><br><span class="line">191221 19:23:55 [01] Copying ib_logfile1 to /var/lib/mysql/ib_logfile1</span><br><span class="line">191221 19:23:55 [01]        ...done</span><br><span class="line">191221 19:23:55 [01] Copying ibdata1 to /var/</span><br></pre></td></tr></table></figure></li><li><p>恢复后的数据目录下的文件及文件夹，用户数属于root的,mysql用户是没有权限使用的，所以需要重新赋予权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@ax mysql]# ll</span><br><span class="line">total 36896</span><br><span class="line">drwx------ 2 root root     4096 Dec 21 19:23 exam</span><br><span class="line">-rw-r----- 1 root root 27262976 Dec 21 19:23 ibdata1</span><br><span class="line">-rw-r----- 1 root root  5242880 Dec 21 19:23 ib_logfile0</span><br><span class="line">-rw-r----- 1 root root  5242880 Dec 21 19:23 ib_logfile1</span><br><span class="line">drwx------ 2 root root     4096 Dec 21 19:23 mysql</span><br><span class="line">drwx------ 2 root root     4096 Dec 21 19:23 nextcloud</span><br><span class="line">drwx------ 2 root root     4096 Dec 21 19:23 performance_schema</span><br><span class="line">drwx------ 2 root root     4096 Dec 21 19:23 siyouyun</span><br><span class="line">drwx------ 2 root root     4096 Dec 21 19:23 text</span><br><span class="line">-rw-r----- 1 root root       23 Dec 21 19:23 xtrabackup_binlog_pos_innodb</span><br><span class="line">-rw-r----- 1 root root      548 Dec 21 19:23 xtrabackup_info</span><br><span class="line"><span class="meta">#</span><span class="bash">重新赋予权限，所属者和所属组改为mysql</span></span><br><span class="line">[root@ax mysql]# chown -R mysql:mysql ../mysql</span><br><span class="line">[root@ax mysql]# ll</span><br><span class="line">total 36896</span><br><span class="line">drwx------ 2 mysql mysql     4096 Dec 21 19:23 exam</span><br><span class="line">-rw-r----- 1 mysql mysql 27262976 Dec 21 19:23 ibdata1</span><br><span class="line">-rw-r----- 1 mysql mysql  5242880 Dec 21 19:23 ib_logfile0</span><br><span class="line">-rw-r----- 1 mysql mysql  5242880 Dec 21 19:23 ib_logfile1</span><br><span class="line">drwx------ 2 mysql mysql     4096 Dec 21 19:23 mysql</span><br><span class="line">drwx------ 2 mysql mysql     4096 Dec 21 19:23 nextcloud</span><br><span class="line">drwx------ 2 mysql mysql     4096 Dec 21 19:23 performance_schema</span><br><span class="line">drwx------ 2 mysql mysql     4096 Dec 21 19:23 siyouyun</span><br><span class="line">drwx------ 2 mysql mysql     4096 Dec 21 19:23 text</span><br><span class="line">-rw-r----- 1 mysql mysql       23 Dec 21 19:23 xtrabackup_binlog_pos_innodb</span><br><span class="line">-rw-r----- 1 mysql mysql      548 Dec 21 19:23 xtrabackup_info</span><br></pre></td></tr></table></figure></li><li><p>重新启动mysql服务查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@ax mysql]# systemctl restart mariadb</span><br><span class="line">[root@ax mysql]# mysql -uroot -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MariaDB monitor.  Commands end with ; or \g.</span><br><span class="line">Your MariaDB connection id is 2</span><br><span class="line">Server version: 5.5.64-MariaDB MariaDB Server</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.</span><br><span class="line"></span><br><span class="line">Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| exam               |</span><br><span class="line">| mysql              |</span><br><span class="line">| nextcloud          |</span><br><span class="line">| performance_schema |</span><br><span class="line">| siyouyun           |</span><br><span class="line">| text               |</span><br><span class="line">+--------------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; </span><br><span class="line"><span class="meta">#</span><span class="bash">恢复成功</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>单表/单库备份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单表：xtrabackup --backup --datadir=数据目录路径 --tables='库名.表名' --target-dir=备份文件路径</span><br><span class="line"></span><br><span class="line">--tables:单引号中填写databases.tables</span><br><span class="line"></span><br><span class="line">单库：trabackup --backup  --databases=数据库名 --target-dir=备份文件路径 </span><br><span class="line">--databases:库名（database）</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@ax ~]# xtrabackup --backup --datadir=/var/lib/mysql --target-dir=/data/backup/mysql --tables='exam.a1';</span><br><span class="line"><span class="meta">#</span><span class="bash">还原也需要进行事务回滚</span></span><br><span class="line">[root@ax exam]# xtrabackup --prepare --target-dir=单表或单库备份文件</span><br><span class="line"><span class="meta">#</span><span class="bash">停止数据库</span></span><br><span class="line"><span class="meta">#</span><span class="bash">数据目录中的原表删除，复制备份文件中单表或单库文件到数据目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash">重置所属用户和组到mysql</span></span><br><span class="line"><span class="meta">#</span><span class="bash">重启数据库</span></span><br><span class="line"><span class="meta">#</span><span class="bash">成功</span></span><br></pre></td></tr></table></figure></li></ul><p>##使用innobackupex的备份与恢复</p><ul><li><p>innobackupex封装了xtrabackup，支持Myisam的数据表</p></li><li><p>innobackupex完整备份后生成的几个重要文件：</p><ul><li>记录当前最新的Log position</li><li>xtrabackup_binlog_pos_innodb:innodb log position</li><li>xtrabackup_checkpoints:存放备份的起始LSN（beginlsn），和结束的位置LSN（endlsn）</li><li>增量备份需要上次备份的endlsn</li></ul></li><li><p>innobackupex命令相当于冷备份，复制数据目录的索引，数据结构文件，为保证数据一致，需要短暂的锁表（时间的长短依赖于Myisam表的大小。）</p></li><li><p>参数解释（同样适用于xtrabackup）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--defaults-file：指定my.cnf参数文件的位置[此配置文件里必须指定datadir]</span></span><br><span class="line"><span class="comment">#--apply-log：同xtrabackup的--prepare参数,一般情况下,在备份完成后，数据尚且不能用于恢复操作，因为备份的数据中可能会包含尚未提交的事务或已经提交但尚未同步至数据文件中的事务。因此，此时数据 文件仍处理不一致状态。--apply-log的作用是通过回滚未提交的事务及同步已经提交的事务至数据文件使数据文件处于一致性状态。</span></span><br><span class="line"><span class="comment">#--copy-back：做数据恢复时将备份数据文件拷贝到MySQL服务器的datadir</span></span><br><span class="line"><span class="comment">#--remote-host=HOSTNAME： 通过ssh将备份数据存储到进程服务器上</span></span><br><span class="line"><span class="comment">#--stream=[tar]：备份文件输出格式, 该文件可在XtarBackup binary文件中获得. 在使用参数stream=tar备份的时候,你的xtrabackup_logfile可能会临时放在/tmp目录下,如果你备份的时候并发写入较大的话,xtrabackup_logfile可能会很大(5G+),很可能会撑满你的/tmp目录,可以通过参数--tmpdir指定目录来解决这个问题.</span></span><br><span class="line"><span class="comment">#--tmpdir=DIRECTORY：当有指定--remote-host or --stream时, 事务日志临时存储的目录, 默认采用MySQL配置文件中所指定的临时目录tmpdir</span></span><br><span class="line"><span class="comment">#--redo-only --apply-log：强制备份日志时只redo,跳过rollback,这在做增量备份时非常必要</span></span><br><span class="line"><span class="comment">#--use-memory=*：该参数在prepare的时候使用,控制prepare时innodb实例使用的内存</span></span><br><span class="line"><span class="comment">#--databases=LIST：列出需要备份的databases,如果没有指定该参数,所有包含MyISAM和InnoDB表的database都会被备份</span></span><br><span class="line"><span class="comment">#--slave-info：备份从库, 加上--slave-info备份目录下会多生成一个xtrabackup_slave_info 文件, 这里会保存主日志文件以及偏移, 文件内容类似于:CHANGE MASTER TO MASTER_LOG_FILE='', MASTER_LOG_POS=0</span></span><br><span class="line"><span class="comment">#--socket=SOCKET：指定mysql.sock所在位置，以便备份进程登录mysql.</span></span><br></pre></td></tr></table></figure></li><li><p>全量备份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@ax backup]# innobackupex --user=备份账户 --password=密码 备份文件存储路径</span><br><span class="line">191223 10:08:18 innobackupex: Starting the backup operation</span><br><span class="line"></span><br><span class="line">IMPORTANT: Please check that the backup run completes successfully.</span><br><span class="line">           At the end of a successful backup run innobackupex</span><br><span class="line">           prints "completed OK!".</span><br><span class="line"><span class="meta">#</span><span class="bash">省略...</span></span><br><span class="line">191223 10:08:20 completed OK!#代表成功</span><br></pre></td></tr></table></figure></li><li><p>全量恢复</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">执行innobackupex --apply-log --use-memory=size（可加可不加） 备份文件路径    这一步是准备操作。apply-only在上面介绍过。</span></span><br><span class="line">[root@ax backup]# innobackupex --apply-only --use-memory=4G /data/backup/2019-12-23_10-08-18</span><br><span class="line">191223 10:16:02 innobackupex: Starting the backup operation</span><br><span class="line"></span><br><span class="line">IMPORTANT: Please check that the backup run completes successfully.</span><br><span class="line">           At the end of a successful backup run innobackupex</span><br><span class="line">           prints "completed OK!".</span><br><span class="line"><span class="meta">#</span><span class="bash">省略...</span></span><br><span class="line">191223 10:16:04 completed OK!#代表成功</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">接下来是恢复</span></span><br><span class="line"><span class="meta">#</span><span class="bash">关闭mysql服务,模拟数据库损坏，清空数据目录（不清空会报错）</span></span><br><span class="line"><span class="meta">#</span><span class="bash">执行 innobackupex --copy-back 备份文件路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash">给予mysql数据目录下所有文件的操作权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash">启动mysql</span></span><br></pre></td></tr></table></figure></li><li><p>增量备份（所有的增量备份都是在全量备份的基础上进行的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">执行 innobackupex --incremental 指定增量文件存储路径 --incremental-basedir=第一次是全量备份的文件路径/在增量的备份的基础上继续增量这里就需要填写上次增量备份文件的路径</span></span><br><span class="line">[root@ax backup]# innobackupex --incremental /data/backup/ --incremental-basedir=/data/backup/2019-12-23_11-25-13/</span><br><span class="line">xtrabackup: Transaction log of lsn (8626208) to (8626208) was copied.</span><br><span class="line">191223 11:34:20 completed OK!#代表成功</span><br></pre></td></tr></table></figure></li><li><p>恢复：（将各个增量备份的数据文件合并到全量备份的目录下，最终是从全量备份的这个目录上进行恢复的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">准备工作</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innobackupex --apply-log --redo-only 全被文件路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innobackupex --apply-log --redo-only 全备路径 --incremental-dir=第一次增备路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innobackupex --apply-log --redo-only 全备文件路径 --incremental-dir=第二次增备路径 <span class="comment">#多次增备执行多次</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">innobackupex --apply-log 全备路径 --incremental-dir=最后一次增备路径 最后一次不需要填加--redo-only参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash">恢复</span></span><br><span class="line"><span class="meta">#</span><span class="bash">关闭mysql服务,模拟数据库损坏，清空数据目录（不清空会报错）</span></span><br><span class="line"><span class="meta">#</span><span class="bash">innobackupex --copy-back 全量备份路径 </span></span><br><span class="line"><span class="meta">#</span><span class="bash">给予mysql数据目录下所有文件的操作权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash">启动mysql</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用xtrabackup备份mysql&quot;&gt;&lt;a href=&quot;#使用xtrabackup备份mysql&quot; class=&quot;headerlink&quot; title=&quot;使用xtrabackup备份mysql&quot;&gt;&lt;/a&gt;使用xtrabackup备份mysql&lt;/h1&gt;&lt;h2 id=&quot;简介（Percona-XtraBackup-）简称PXB&quot;&gt;&lt;a href=&quot;#简介（Percona-XtraBackup-）简称PXB&quot; class=&quot;headerlink&quot; title=&quot;简介（Percona XtraBackup ）简称PXB&quot;&gt;&lt;/a&gt;简介（&lt;a href=&quot;https://www.percona.com/software/mysql-database/percona-xtrabackup&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Percona XtraBackup&lt;/a&gt; ）简称PXB&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Xtrabackup是由percona开源的免费数据库热备份软件，它能对Innodb数据库和Xtradb存储引擎的数据库非阻塞地备份。（对于Myisam的备份同样需要加表锁），mysqldump备份方式是采用的逻辑备份，其最大的缺陷是备份和恢复速度较慢，如果数据库大于50G，mysqldump备份就不太适合。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="MYSQL" scheme="https://cy-blogs.cn/categories/MYSQL/"/>
    
    
      <category term="使用xtrabackup备份mysql" scheme="https://cy-blogs.cn/tags/%E4%BD%BF%E7%94%A8xtrabackup%E5%A4%87%E4%BB%BDmysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis 事务、乐观锁、分布式锁、信号量</title>
    <link href="https://cy-blogs.cn/redis%E4%BA%8B%E5%8A%A1%EF%BC%8C%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%8C%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>https://cy-blogs.cn/redis事务，乐观锁，分布式锁，信号量/</id>
    <published>2019-12-24T06:34:30.367Z</published>
    <updated>2019-12-24T10:45:41.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><blockquote><p>Redis是一款内存高速缓存数据库，该软件使用C语言编写，</p><p>Redis是一个key - value 存储系统，它支持丰富的数据类型，</p><p>如：String、List、Set、Hash。</p><p>是为了解决高并发、高扩展，大数据存储等问题！</p></blockquote><a id="more"></a><ul><li>读写效率高，持久化、丰富的特性</li></ul><blockquote><p>读写效率高：读写速度最高可达 <code>10万次/s+</code>。</p><p>持久化：断电或重启后，数据也不会丢失。因为 Redis 的存储分为内存存储、磁盘存储和 log 文件三部分，中启后，Redis可以从磁盘将数据加载到内存中。</p><p>丰富的特性：建空间、事务、订阅发布功能、计数。</p></blockquote><h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><ul><li><p>回顾Mysql 数据库事务</p><ul><li>什么是事务，事务是原子操作，里面的操作，要么都成功，要么都不成功。</li></ul></li><li><p>原子性</p><ul><li>整个事务的操作，要么都成功，要么都不成功，如果在执行的过程中，发生了错误，就回滚到开始的状态。</li></ul></li><li><p>一致性</p><ul><li>在事务的开始前，和结束后，数据的完整性约束，没有被破坏。</li></ul></li><li><p>隔离性</p><ul><li>使得同一时间，只有一个请求同一数据。</li></ul></li><li><p>持久性</p><ul><li>事务成功之后，对数据库的操作会，永远的保存在数据库当中。</li></ul></li><li><p><strong>Redsi</strong>事务</p><blockquote><p>Redis 事务的本质：</p><p>​        是将一组操作放入队列中，批量执行，过程中如果产生了某个命令错误，不会回滚，其他正确的命令，仍然会继续执行</p></blockquote></li><li><p>与 mysql 对比</p><ul><li><p>redis 是  ：</p><p>​    开始事务   multi（）</p><p>​    提交事务  execute（）</p><p>​    放弃事务  reset（）</p></li></ul></li></ul><h3 id="什么时候用到锁"><a href="#什么时候用到锁" class="headerlink" title="什么时候用到锁"></a>什么时候用到锁</h3><ul><li>锁的生命周期<ul><li>任务通过竞争获取锁才能对资源进行操作 （竞争锁）</li><li>当任务在对资源进行操作时！（占有锁）</li><li>其它任务都不可以对这个资源操作 （任务阻塞）</li><li>直到该任务完成更新 （释放锁）</li></ul></li></ul><h3 id="redis-乐观锁的使用"><a href="#redis-乐观锁的使用" class="headerlink" title="redis 乐观锁的使用"></a>redis 乐观锁的使用</h3><ul><li><p>乐观锁：</p><blockquote><p>每次去拿数据的时候都任务别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去跟新这个数据</p></blockquote></li><li><p>redis 中的乐观锁：</p><blockquote><p>可以使用 watch（）方法来实现，可以监控一个或多个键，再事务执行的过程中，其中的一个键发生了改变，那么这个事务，就不会执行</p></blockquote></li></ul><h3 id="redis-实现分布式锁"><a href="#redis-实现分布式锁" class="headerlink" title="redis 实现分布式锁"></a>redis 实现分布式锁</h3><ul><li><p>什么是分布式锁：</p><blockquote><p>控制分布式系统有序的去对共享资源进行操作，通过互斥来保持一致性。</p></blockquote><p><a href="https://v.qq.com/x/page/n3026r8xhil.html" target="_blank" rel="noopener">https://v.qq.com/x/page/n3026r8xhil.html</a></p></li><li><p>SETNX（）</p><blockquote><p>这个命令会在键不存在的情况下为键设置值，如果存在的情况下则不作任何操作！</p></blockquote></li><li><p>获取锁</p><blockquote><p>如果程序在尝试获取锁的过程中失败，那么他将不断的进行重试，直到成功的取到锁，或者超过锁的过期时间</p></blockquote></li><li><p>删除锁</p><blockquote><p>删除锁之前会先判断，是否是该线程加的锁，如果是，则执行delete 进行删除。</p></blockquote></li></ul><h3 id="分布式锁应该具备哪些条件"><a href="#分布式锁应该具备哪些条件" class="headerlink" title="分布式锁应该具备哪些条件"></a>分布式锁应该具备哪些条件</h3><ul><li>互斥性，在任意时刻，只有一个客户端能持有锁</li><li>高可用的获取锁和释放锁</li><li>具备锁失效机制，避免死锁</li><li>具备非阻塞锁特性，即没有获取到锁直接返回获取锁失败</li><li>释放锁</li></ul><h3 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量"></a>计数信号量</h3><blockquote><p>何为计数信号量？<br>简单来说就是控制对共享资源的访问。<br>实现方法： Semaphore （）<br>Semaphore 是一个计数信号量。<br>常用于限制可以访问某些资源的线程数量</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class=&quot;headerlink&quot; title=&quot;Redis简介&quot;&gt;&lt;/a&gt;Redis简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Redis是一款内存高速缓存数据库，该软件使用C语言编写，&lt;/p&gt;
&lt;p&gt;Redis是一个key - value 存储系统，它支持丰富的数据类型，&lt;/p&gt;
&lt;p&gt;如：String、List、Set、Hash。&lt;/p&gt;
&lt;p&gt;是为了解决高并发、高扩展，大数据存储等问题！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://cy-blogs.cn/categories/Redis/"/>
    
    
      <category term="Redis 事务、乐观锁、分布式锁、信号量" scheme="https://cy-blogs.cn/tags/Redis-%E4%BA%8B%E5%8A%A1%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL定时备份任务shell脚本</title>
    <link href="https://cy-blogs.cn/Mysql%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BDshell%E8%84%9A%E6%9C%AC/"/>
    <id>https://cy-blogs.cn/Mysql定时备份shell脚本/</id>
    <published>2019-12-23T11:42:53.388Z</published>
    <updated>2019-12-24T11:05:07.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MYSQL定时备份任务shell脚本"><a href="#MYSQL定时备份任务shell脚本" class="headerlink" title="MYSQL定时备份任务shell脚本"></a>MYSQL定时备份任务shell脚本</h1><h2 id="备份的必要性"><a href="#备份的必要性" class="headerlink" title="备份的必要性"></a>备份的必要性</h2><ul><li>每个公司的业务都是基于数据进行的，数据的存储基本都是数据库</li><li>保证了数据的安全，稳定，也就可以做到防范于未然。</li></ul><h2 id="冷备和热备"><a href="#冷备和热备" class="headerlink" title="冷备和热备"></a>冷备和热备</h2><a id="more"></a><ul><li>冷备份：(读写均不可进行)<ul><li>冷备份，off，快，时间点上恢复</li><li>冷备份发生在数据库已经正常关闭的情况下，当正常关闭时会提供给我们一个完整的数据库，冷备份是将关键性文件拷贝的另外位置的一种说法，对于备份数据库信息而言，冷备份是最快和最安全的方法。</li><li>冷备份的优点：<ul><li>低度维护，安全</li><li>容易归档，拷贝文件</li><li>速度快</li><li>恢复简单</li></ul></li><li>冷备份的缺点：<ul><li>不能按表或按用户恢复</li><li>若磁盘空间有限，只能拷贝到磁带等其他外部存储设备上，速度会很慢。</li><li>恢复限制，在备份期间，数据库不能做写入操作。</li></ul></li></ul></li><li>热备份：（读写皆可进行）<ul><li>在数据库运行时，直接进行备份，对运行的数据库没有影响。</li><li>热备份的优点：<ul><li>可在表空间或数据文件级备份，备份时间段。</li><li>灵活，备份时不影响数据库的使用。</li><li>秒级恢复，能够恢复到某一时间点上。</li></ul></li><li>热备份的缺点：<ul><li>严谨性，尽量不要出错，否则后果很严重。</li><li>维护困难</li></ul></li></ul></li><li>温备：（只能读，不可写）<ul><li>上锁（考虑持锁的长久）<h2 id="MYSQL备份数据的几种方式"><a href="#MYSQL备份数据的几种方式" class="headerlink" title="MYSQL备份数据的几种方式"></a>MYSQL备份数据的几种方式</h2></li></ul></li></ul><h3 id="into-outfile"><a href="#into-outfile" class="headerlink" title="into outfile"></a>into outfile</h3><ul><li><p>利用<code>select语句 into outfile table +指定的路径</code> 实现指定表数据的备份 备份完的文件是文本文件</p><ul><li><p>在使用<code>select into outfile</code> 使用默认的用户是mysql在操作，使用<code>show variables like &#39;datadir&#39;</code>会显示所属mysql用户的文件件具有一切权限</p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [exam]&gt; show variables like 'datadir';</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| Variable_name | Value           |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">| datadir       | /var/lib/mysql/ |</span><br><span class="line">+---------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>指定路径可以直接放在mysql所属的文件夹下</p></li><li><p>如果指定文件备份位置，会报错<code>ERROR 1 (HY000): Can&#39;t create/write to file &#39;/data/test.txt&#39; (Errcode: 13)</code> 这是代表mysql没有文件目录的操作权限。</p><ul><li>解决办法 <ul><li>直接更改文件目录的所属用户为mysql让mysql拥有一切权限，<code>clown mysql:mysql +指定文件夹的路径</code></li><li>修改文件夹其它用户可以有写的权限。(不建议)</li><li>先备份至mysql所属文件夹内 进行mv</li></ul></li></ul></li><li><p>可以使用<code>load data infile +备份完数据的路径 into table +表名</code> 进行恢复。</p></li></ul></li></ul><h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><ul><li><p>mysqldump 常用来做温备 （所以需要先对备份的数据施加锁，只能读不能写）本质上就是将指定数据库中的数据已sql语句的方式输出 使用重定向到指定的文件</p></li><li><p>施加读锁的方式：</p><ul><li>flush tables with read lock 施加锁，表示把位于内存上的表统统都同步到磁盘上，然后去施加读锁。</li><li>unlock tables 释放锁。</li></ul></li><li><p>全量备份</p><ul><li><p>使用mysqldump工具进行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ax mysql]# mysqldump -uroot -pxieyang --single-transaction --master-data=2 --databases 表名 &gt;/data/mysql/a1_`date +%F`.sql</span><br></pre></td></tr></table></figure><ul><li>–single-transaction 通过在一个事务中导出所有表从而创建一个一致性的快照，（只支持innodb，myisam不支持事务），从而有效的保证了dump文件，即正确的表内容和二进制日志位置。</li><li>–master-data=2 选项开启式默认会打开lock-all-tables 一个是加锁，一个是获取log信息 =1和=2的在于log信息前者不注释，后者注释。</li><li>lock-all-tables 在dump执行的时候会在表上加上读锁，保证数据一致性，innodb不需加上此参数，而使用 –single-tansaction</li><li>–all-databases  导出所有的数据库 也可以指定表名</li></ul></li><li><p>恢复</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ax mysql]# mysql -uroot -p &lt; 备份文件路径/备份文件名</span><br></pre></td></tr></table></figure></li></ul></li><li><p>增量备份</p><ul><li><p>使用mysqlbinlog工具进行，本质上就是指定备份文件的log开始偏移量和结束日志的偏移量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ax mysql]# mysqlbinlog --start-position=3210 /var/lib/mysql/mysql-bin.000009 &gt; /data/mysql/a1_2019-12-19_17.sql</span><br></pre></td></tr></table></figure><ul><li><p>–start-position=开始的偏移量</p></li><li><p>–stop-position=结束的偏移量</p></li><li><p>可以先使用<code>show master status</code> 来查看日志版本</p></li><li><p>通过find / -name 日志版本名来查找到路径</p></li><li><p>使用<code>mysqlbinlog --start-position=上次同步的结束位置 查询到的路径</code> 来查看需要同步的结束偏移量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@ax mysql]# mysqlbinlog --start-position=0 /var/lib/mysql/mysql-bin.000010</span><br><span class="line">SET TIMESTAMP=1576755138/*!*/;</span><br><span class="line">insert into a1 values (4,'赵六'),(5,'冯七')</span><br><span class="line">/*!*/;</span><br><span class="line"><span class="meta">#</span><span class="bash"> at 423</span></span><br><span class="line"><span class="meta">#</span><span class="bash">191219 19:32:18 server id 1  end_log_pos 450 Xid = 919</span></span><br><span class="line">COMMIT/*!*/;</span><br><span class="line"><span class="meta">#</span><span class="bash"> at 450</span></span><br><span class="line"><span class="meta">#</span><span class="bash">191219 19:32:32 server id 1  end_log_pos 531 Querythread_id=334exec_time=0error_code=0</span></span><br><span class="line">SET TIMESTAMP=1576755152/*!*/;</span><br><span class="line">drop database exam</span><br><span class="line">/*!*/;</span><br><span class="line"><span class="meta">#</span><span class="bash"> at 531</span></span><br><span class="line"><span class="meta">#</span><span class="bash">191219 19:50:53 server id 1  end_log_pos 574 Rotate to mysql-bin.000011  pos: 4</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="meta">#</span><span class="bash"> End of <span class="built_in">log</span> file</span></span><br><span class="line">ROLLBACK /* added by mysqlbinlog */;</span><br><span class="line">/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;</span><br><span class="line">/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;</span><br></pre></td></tr></table></figure></li><li><p>其中end_log_pos就是结束的偏移量</p></li><li><p>或者直接使用<code>show master status</code> 中查询出来的偏移量，备份到操作该库的最后一次位置</p></li></ul></li><li><p>恢复，和全量恢复是相同的  </p><ul><li>[root@ax mysql]# mysql -uroot -p &lt; 备份文件路径/增量备份名备份文件名</li><li>恢复前先关闭二进制日志 <code>set sql_log_bin=0</code></li><li>滚动日志 <code>flush logs</code></li></ul></li></ul></li></ul><h3 id="利用lvm快照备份和恢复"><a href="#利用lvm快照备份和恢复" class="headerlink" title="利用lvm快照备份和恢复"></a>利用lvm快照备份和恢复</h3><ul><li>LVM（Logical Volume Manager）是一个应用于Linux的内核的逻辑卷管理器，是Linux环境下对磁盘进行分区管理的一种机制。相关名词：<ul><li>PV（物理卷）可以是一个磁盘，一个分区。由PE（物理盘区）组成，多个PV可以组成一个VG（卷组）<ul><li>VG（卷组）多个物理卷组成的一个组，卷组不可以直接使用，需要在上面创建LV（逻辑卷）才可以使用。VG上可以创建多个LV。</li><li>PE（物理盘区），默认是4MB,像磁盘的block块</li><li>LV（逻辑卷）是建立在卷组之上的一个可用空间，有物理边界和逻辑边界两种边界。</li></ul></li></ul></li><li>LVM扩展<ul><li><a href="https://www.jb51.net/LINUXjishu/105937.html" target="_blank" rel="noopener">连接</a></li><li>LVM是一种将一个或多个硬盘的分区在逻辑上的集合，相当于一个大硬盘来使用，当空间不够使用时，可以继续将其它硬盘的分区加入其中，这样可以实现一种磁盘空间的动态管理，相对于普通的磁盘分区有很大的灵活性，使用普通的磁盘分区，当一个磁盘的分区空间不够使用的时候，可能就会带来很大的麻烦，使用LVM在一定程度就可以解决普通磁盘分区带来的问题。LVM通常用于装备大量磁盘的系统，但他它同样适于仅有一，两块硬盘的小系统。</li></ul></li></ul><h3 id="Mysql定时备份shell脚本"><a href="#Mysql定时备份shell脚本" class="headerlink" title="Mysql定时备份shell脚本"></a>Mysql定时备份shell脚本</h3><ul><li><p>利用的都是mysqldump，利用Crontab设置定时任务，来自动执行备份命令。直接上代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下配置信息请自己修改</span></span><br><span class="line">mysql_user="root" #MySQL备份用户</span><br><span class="line">mysql_password="password" #MySQL备份用户的密码</span><br><span class="line">mysql_host="localhost"</span><br><span class="line">mysql_port="3306"</span><br><span class="line">mysql_charset="utf8" #MySQL编码</span><br><span class="line">backup_db_arr=("db1" "db2") #要备份的数据库名称，多个用空格分开隔开 如("db1" "db2" "db3")</span><br><span class="line">backup_location=/data/mysql #备份数据存放位置，末尾请不要带"/",此项可以保持默认，程序会自动创建文件夹</span><br><span class="line">expire_backup_delete="ON" #是否开启过期备份删除 ON为开启 OFF为关闭</span><br><span class="line">expire_days=3 #过期时间天数 默认为三天，此项只有在expire_backup_delete开启时有效</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本行开始以下不需要修改</span></span><br><span class="line">backup_time=`date +%F:%T` #定义备份详细时间</span><br><span class="line">backup_Ymd=`date +%Y-%m-%d` #定义备份目录中的年月日时间</span><br><span class="line">backup_3ago=`date -d '3 days ago' +%Y-%m-%d` #3天之前的日期</span><br><span class="line">backup_dir=$backup_location/$backup_Ymd #备份文件夹全路径</span><br><span class="line">welcome_msg="Welcome to use MySQL backup tools!" #欢迎语</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断MYSQL是否启动,mysql没有启动则备份退出</span></span><br><span class="line">mysql_ps=`ps -ef |grep mysql |wc -l`</span><br><span class="line">mysql_listen=`netstat -an |grep LISTEN |grep $mysql_port|wc -l`</span><br><span class="line">if [ [$mysql_ps == 0] -o [$mysql_listen == 0] ]; then</span><br><span class="line">echo "`date +%F:%T` --ERROR:MySQL is not running! backup stop!"</span><br><span class="line">exit</span><br><span class="line">else</span><br><span class="line">echo "备份时间-- `date +%F:%T`"</span><br><span class="line">echo `date +%F:%T` -- $welcome_msg</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 连接到mysql数据库，无法连接则备份退出</span></span><br><span class="line">mysql -h$mysql_host -P$mysql_port -u$mysql_user -p$mysql_password &lt;&lt;end</span><br><span class="line">use mysql;</span><br><span class="line">select host,user from user where user='root' and host='localhost';</span><br><span class="line">exit</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">flag=`echo $?`</span><br><span class="line">if [ $flag != "0" ]; then</span><br><span class="line">echo "`date +%F:%T` --ERROR:Can't connect mysql server! backup stop!"</span><br><span class="line">exit</span><br><span class="line">else</span><br><span class="line">echo "`date +%F:%T` --MySQL connect ok! Please wait......"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断有没有定义备份的数据库，如果定义则开始备份，否则退出备份</span></span><br><span class="line">if [ "$backup_db_arr" != "" ];then</span><br><span class="line"><span class="meta">#</span><span class="bash">dbnames=$(cut -d <span class="string">','</span> -f1-5 <span class="variable">$backup_database</span>)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> <span class="string">"arr is (<span class="variable">$&#123;backup_db_arr[@]&#125;</span>)"</span></span></span><br><span class="line">for dbname in $&#123;backup_db_arr[@]&#125;</span><br><span class="line">do</span><br><span class="line">echo "`date +%F:%T` --database $dbname backup start..."</span><br><span class="line">`mkdir -p $backup_dir`</span><br><span class="line">`mysqldump -h$mysql_host -P$mysql_port -u$mysql_user -p$mysql_password $dbname --default-character-set=$mysql_charset | gzip &gt; $backup_dir/$dbname-$backup_time.sql.gz`</span><br><span class="line">flag=`echo $?`</span><br><span class="line">if [ $flag == "0" ];then</span><br><span class="line">echo "`date +%F:%T` --database $dbname success backup to $backup_dir/$dbname-$backup_time.sql.gz"</span><br><span class="line">else</span><br><span class="line">echo "`date +%F:%T` --database $dbname backup fail!"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line">else</span><br><span class="line">echo "`date +%F:%T` --ERROR:No database to backup! backup stop"</span><br><span class="line">exit</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果开启了删除过期备份，则进行删除操作</span></span><br><span class="line">if [ "$expire_backup_delete" == "ON" -a "$backup_location" != "" ];then</span><br><span class="line"><span class="meta">#</span><span class="bash">`find <span class="variable">$backup_location</span>/ -<span class="built_in">type</span> d -o -<span class="built_in">type</span> f -ctime +<span class="variable">$expire_days</span> -<span class="built_in">exec</span> rm -rf &#123;&#125; \;`</span></span><br><span class="line">`find $backup_location/ -type d -mtime +$expire_days | xargs rm -rf`</span><br><span class="line">echo "`date +%F:%T` --Expired backup data delete complete!"</span><br><span class="line">fi</span><br><span class="line">echo "`date +%F:%T` --All database backup success! Thank you!"</span><br><span class="line">echo ""</span><br><span class="line">exit</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在非linux界面下操作，sh脚本中每行都会多个\r，导致linux无法执行脚本。解决办法，使用vim编辑shell脚本文件，执行::set ff=unix。文件即使unix文件了。可以使用::set ff? 查看文件的类型。dos就是在ATOM操作后保存的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fileformat=unix </span><br><span class="line">fileformat=dos</span><br></pre></td></tr></table></figure></li><li><p>文件的创建默认UGO权限为 -rw-r–r– 代表的这个文件没有执行权限，所以需要给文件增加权限。</p><ul><li><p>文件创建者拥有所有权限，用户组和其他组只有执行权限</p><p><code>chmod 711 备份文件</code></p></li><li><p>r=4 w=2 x=1 </p></li></ul></li><li><p>拥有了执行权限后，该shell脚本就可以执行了，可以执行一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@ax auto_backup]# ./Backup.sh </span><br><span class="line">备份时间-- 2019-12-20:17:09:40</span><br><span class="line">2019-12-20:17:09:40 -- Welcome to use MySQL backup tools!</span><br><span class="line">hostuser</span><br><span class="line">localhostroot</span><br><span class="line">2019-12-20:17:09:40 --MySQL connect ok! Please wait......</span><br><span class="line">2019-12-20:17:09:40 --database exam backup start...</span><br><span class="line">2019-12-20:17:09:40 --database exam success backup to /data/mysql/2019-12-20/exam-2019-12-20:17:09:40.sql.gz</span><br><span class="line">2019-12-20:17:09:40 --database shiyouyun backup start...</span><br><span class="line">mysqldump: Got error: 1049: "Unknown database 'shiyouyun'" when selecting the database</span><br><span class="line">2019-12-20:17:09:40 --database shiyouyun success backup to /data/mysql/2019-12-20/shiyouyun-2019-12-20:17:09:40.sql.gz</span><br><span class="line">2019-12-20:17:09:40 --Expired backup data delete complete!</span><br><span class="line">2019-12-20:17:09:40 --All database backup success! Thank you!</span><br></pre></td></tr></table></figure></li><li><p>执行成功说明shell没有问题，只剩下写入定时任务了</p></li></ul><h4 id="Crontab"><a href="#Crontab" class="headerlink" title="Crontab"></a>Crontab</h4><ul><li><p>linux下使用crontab命令来提交和管理用户需要定时、周期性的执行任务。</p></li><li><p>linux下默认会安装此服务工具，并且会自动启动crond进程，crond进程会每分钟定期检查是否有要执行的任务。如果有要执行的任务，则自动执行该任务。</p></li><li><p>命令语法：</p><ul><li>crontab（选项） （参数）</li><li>选项：<ul><li>-e  编辑该用户的计时设置</li><li>-l   列出该用户的计时器设置</li><li>-r   删除该用户的计时器设置</li><li>-u   用户名称   指定要设定计时器的用户名称</li></ul></li><li>参数：<ul><li>crontab文件   指定包含待执行任务的crontab文件</li></ul></li></ul></li><li><p>直接在/etc/crontab文件中添加shell脚本任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00 3 * * * root /data/auto_backup/Backup.sh &gt;&gt; /data/mysql/backup.log</span><br></pre></td></tr></table></figure><ul><li>上面代表每天在凌晨3点运行Backup.sh脚本 并将输出重定向追加到backup.log文件中。</li><li>从左往右依次代表<ul><li>分 可取0-59的整数 加/数字 代表每分钟执行多少次</li><li>时 可取0-23的整数  </li><li>天  可取1-31的整数 ，必须是指定月份的有效日期</li><li>月 可取1-12的整数，也可写英文简写</li><li>周几 可取1-7的整数，描述周几</li><li>执行的用户  指定用户</li><li>shell脚本的路径</li><li>log日志的路径</li></ul></li></ul></li><li><p>添加完后保存，重启crond服务。一切ok</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>ax mysql]# ls</span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>  backup.log</span><br><span class="line">[<span class="symbol">root@</span>ax mysql]# cd <span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>/</span><br><span class="line">[<span class="symbol">root@</span>ax <span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>]# ls</span><br><span class="line">exam<span class="number">-201912201600.</span>sql.gz  exam<span class="number">-201912201613.</span>sql.gz         exam<span class="number">-2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">31</span>:<span class="number">01.</span>sql.gz  shiyouyun<span class="number">-201912201608.</span>sql.gz  shiyouyun<span class="number">-2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">21</span>:<span class="number">01.</span>sql.gz</span><br><span class="line">exam<span class="number">-201912201601.</span>sql.gz  exam<span class="number">-201912201614.</span>sql.gz         exam<span class="number">-2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">32</span>:<span class="number">01.</span>sql.gz  shiyouyun<span class="number">-201912201609.</span>sql.gz  shiyouyun<span class="number">-2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">22</span>:<span class="number">01.</span>sql.gz</span><br><span class="line">[<span class="symbol">root@</span>ax mysql]# cat backup.log </span><br><span class="line">备份时间-- <span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">30</span>:<span class="number">01</span></span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">30</span>:<span class="number">01</span> -- Welcome to use MySQL backup tools!</span><br><span class="line">hostuser</span><br><span class="line">localhostroot</span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">30</span>:<span class="number">01</span> --MySQL connect ok! Please wait......</span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">30</span>:<span class="number">01</span> --database exam backup start...</span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">30</span>:<span class="number">01</span> --database exam success backup to /data/mysql/<span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>/exam<span class="number">-2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">30</span>:<span class="number">01.</span>sql.gz</span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">30</span>:<span class="number">01</span> --database shiyouyun backup start...</span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">30</span>:<span class="number">01</span> --database shiyouyun success backup to /data/mysql/<span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>/shiyouyun<span class="number">-2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">30</span>:<span class="number">01.</span>sql.gz</span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">30</span>:<span class="number">01</span> --Expired backup data delete complete!</span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">30</span>:<span class="number">01</span> --All database backup success! Thank you!</span><br><span class="line"></span><br><span class="line">备份时间-- <span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">31</span>:<span class="number">01</span></span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">31</span>:<span class="number">01</span> -- Welcome to use MySQL backup tools!</span><br><span class="line">hostuser</span><br><span class="line">localhostroot</span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">31</span>:<span class="number">01</span> --MySQL connect ok! Please wait......</span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">31</span>:<span class="number">01</span> --database exam backup start...</span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">31</span>:<span class="number">01</span> --database exam success backup to /data/mysql/<span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>/exam<span class="number">-2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">31</span>:<span class="number">01.</span>sql.gz</span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">31</span>:<span class="number">01</span> --database shiyouyun backup start...</span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">31</span>:<span class="number">01</span> --database shiyouyun success backup to /data/mysql/<span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>/shiyouyun<span class="number">-2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">31</span>:<span class="number">01.</span>sql.gz</span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">31</span>:<span class="number">01</span> --Expired backup data delete complete!</span><br><span class="line"><span class="number">2019</span><span class="number">-12</span><span class="number">-20</span>:<span class="number">16</span>:<span class="number">31</span>:<span class="number">01</span> --All database backup success! Thank you!</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MYSQL定时备份任务shell脚本&quot;&gt;&lt;a href=&quot;#MYSQL定时备份任务shell脚本&quot; class=&quot;headerlink&quot; title=&quot;MYSQL定时备份任务shell脚本&quot;&gt;&lt;/a&gt;MYSQL定时备份任务shell脚本&lt;/h1&gt;&lt;h2 id=&quot;备份的必要性&quot;&gt;&lt;a href=&quot;#备份的必要性&quot; class=&quot;headerlink&quot; title=&quot;备份的必要性&quot;&gt;&lt;/a&gt;备份的必要性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;每个公司的业务都是基于数据进行的，数据的存储基本都是数据库&lt;/li&gt;
&lt;li&gt;保证了数据的安全，稳定，也就可以做到防范于未然。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;冷备和热备&quot;&gt;&lt;a href=&quot;#冷备和热备&quot; class=&quot;headerlink&quot; title=&quot;冷备和热备&quot;&gt;&lt;/a&gt;冷备和热备&lt;/h2&gt;
    
    </summary>
    
    
      <category term="MYSQL" scheme="https://cy-blogs.cn/categories/MYSQL/"/>
    
    
      <category term="MYSQL定时备份任务shell脚本" scheme="https://cy-blogs.cn/tags/MYSQL%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%E4%BB%BB%E5%8A%A1shell%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Redis 持久化之RDB和AOF</title>
    <link href="https://cy-blogs.cn/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://cy-blogs.cn/redis持久化/</id>
    <published>2019-12-23T09:16:38.222Z</published>
    <updated>2019-12-23T09:12:42.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-持久化之RDB和AOF"><a href="#Redis-持久化之RDB和AOF" class="headerlink" title="Redis 持久化之RDB和AOF"></a>Redis 持久化之RDB和AOF</h1><p>Redis 有两种持久化方案，RDB （Redis DataBase）和 AOF （Append Only File）。如果你想快速了解和使用RDB和AOF，可以直接跳到文章底部看总结。本章节通过配置文件，触发快照的方式，恢复数据的操作，命令操作演示，优缺点来学习 Redis 的重点知识<strong>持久化</strong>。</p><a id="more"></a><h2 id="RDB-详解"><a href="#RDB-详解" class="headerlink" title="RDB 详解"></a>RDB 详解</h2><p>RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。</p><h3 id="从配置文件了解RDB"><a href="#从配置文件了解RDB" class="headerlink" title="从配置文件了解RDB"></a>从配置文件了解RDB</h3><p>打开 redis.conf 文件，找到 SNAPSHOTTING 对应内容<br>1 RDB核心规则配置（重点）</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"># save <span class="string">""</span></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>解说：save &lt;指定时间间隔&gt; &lt;执行指定次数更新操作&gt;，满足条件就将内存中的数据同步到硬盘中。官方出厂配置默认是 900秒内有1个更 改，300秒内有10个更改以及60秒内有10000个更改，则将内存中的数据快照写入磁盘。<br>若不想用RDB方案，可以把 save “” 的注释打开，下面三个注释。</p><p>2 指定本地数据库文件名，一般采用默认的 dump.rdb</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dbfilename</span> <span class="selector-tag">dump</span><span class="selector-class">.rdb</span></span><br></pre></td></tr></table></figure><p>3 指定本地数据库存放目录，一般也用默认配置</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span> ./</span><br></pre></td></tr></table></figure><p>4 默认开启数据压缩</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rdbcompression</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><p>解说：配置存储至本地数据库时是否压缩数据，默认为yes。Redis采用LZF压缩方式，但占用了一点CPU的时间。若关闭该选项，但会导致数据库文件变的巨大。建议开启。</p><h3 id="触发RDB快照"><a href="#触发RDB快照" class="headerlink" title="触发RDB快照"></a>触发RDB快照</h3><p>1 在指定的时间间隔内，执行指定次数的写操作<br>2 执行save（阻塞， 只管保存快照，其他的等待） 或者是bgsave （异步）命令<br>3 执行flushall 命令，清空数据库所有数据，意义不大。<br>4 执行shutdown 命令，保证服务器正常关闭且不丢失任何数据，意义…也不大。</p><h3 id="通过RDB文件恢复数据"><a href="#通过RDB文件恢复数据" class="headerlink" title="通过RDB文件恢复数据"></a>通过RDB文件恢复数据</h3><p>将dump.rdb 文件拷贝到redis的安装目录的bin目录下，重启redis服务即可。在实际开发中，一般会考虑到物理机硬盘损坏情况，选择备份dump.rdb 。可以从下面的操作演示中可以体会到。</p><h3 id="RDB-的优缺点"><a href="#RDB-的优缺点" class="headerlink" title="RDB 的优缺点"></a>RDB 的优缺点</h3><p>优点：<br>1 适合大规模的数据恢复。<br>2 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。</p><p>缺点：<br>1 数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。<br>2 备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。<br>所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。</p><h3 id="操作演示"><a href="#操作演示" class="headerlink" title="操作演示"></a>操作演示</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[root@itdragon bin]<span class="comment"># vim redis.conf</span></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">120</span> <span class="number">5</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br><span class="line">[root@itdragon bin]<span class="comment"># ./redis-server redis.conf</span></span><br><span class="line">[root@itdragon bin]<span class="comment"># ./redis-cli -h 127.0.0.1 -p 6379</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> keys *</span><br><span class="line">(empty list <span class="keyword">or</span> set)</span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> set key1 value1</span><br><span class="line">OK</span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> set key2 value2</span><br><span class="line">OK</span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> set key3 value3</span><br><span class="line">OK</span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> set key4 value4</span><br><span class="line">OK</span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> set key5 value5</span><br><span class="line">OK</span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> set key6 value6</span><br><span class="line">OK</span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> SHUTDOWN</span><br><span class="line"><span class="keyword">not</span> connected&gt; QUIT</span><br><span class="line">[root@itdragon bin]<span class="comment"># cp dump.rdb dump_bk.rdb</span></span><br><span class="line">[root@itdragon bin]<span class="comment"># ./redis-server redis.conf</span></span><br><span class="line">[root@itdragon bin]<span class="comment"># ./redis-cli -h 127.0.0.1 -p 6379</span></span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> FLUSHALL </span><br><span class="line">OK</span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> keys *</span><br><span class="line">(empty list <span class="keyword">or</span> set)</span><br><span class="line"><span class="meta">127.0.0.1:6379&gt;</span> SHUTDOWN</span><br><span class="line"><span class="keyword">not</span> connected&gt; QUIT</span><br><span class="line">[root@itdragon bin]<span class="comment"># cp dump_bk.rdb  dump.rdb</span></span><br><span class="line"><span class="symbol">cp:</span> overwrite <span class="string">`dump.rdb'? y</span></span><br><span class="line"><span class="string">[root@itdragon bin]# ./redis-server redis.conf</span></span><br><span class="line"><span class="string">[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6379</span></span><br><span class="line"><span class="string">127.0.0.1:6379&gt; keys *</span></span><br><span class="line"><span class="string">1) "key5"</span></span><br><span class="line"><span class="string">2) "key1"</span></span><br><span class="line"><span class="string">3) "key3"</span></span><br><span class="line"><span class="string">4) "key4"</span></span><br><span class="line"><span class="string">5) "key6"</span></span><br><span class="line"><span class="string">6) "key2"</span></span><br></pre></td></tr></table></figure><p>第一步：vim 修改持久化配置时间，120秒内修改5次则持久化一次。<br>第二步：重启服务使配置生效。<br>第三步：分别set 5个key，过两分钟后，在bin的当前目录下会自动生产一个dump.rdb文件。（set key6 是为了验证shutdown有触发RDB快照的作用）<br>第四步：将当前的dump.rdb 备份一份（模拟线上工作）。<br>第五步：执行FLUSHALL命令清空数据库数据（模拟数据丢失）。<br>第六步：重启Redis服务，恢复数据…..咦？？？？( ′◔ ‸◔`)。数据是空的？？？？这是因为FLUSHALL也有触发RDB快照的功能。<br>第七步：将备份的 dump_bk.rdb 替换 dump.rdb 然后重新Redis。</p><p>注意点：SHUTDOWN 和 FLUSHALL 命令都会触发RDB快照，这是一个坑，请大家注意。</p><p>其他命令：</p><ul><li>keys * 匹配数据库中所有 key</li><li>save 阻塞触发RDB快照，使其备份数据</li><li>FLUSHALL 清空整个 Redis 服务器的数据(几乎不用)</li><li>SHUTDOWN 关机走人（很少用）</li></ul><hr><h2 id="AOF-详解"><a href="#AOF-详解" class="headerlink" title="AOF 详解"></a>AOF 详解</h2><p>AOF ：Redis 默认不开启。它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个<strong>写操作</strong>，并<strong>追加</strong>到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><h3 id="从配置文件了解AOF"><a href="#从配置文件了解AOF" class="headerlink" title="从配置文件了解AOF"></a>从配置文件了解AOF</h3><p>打开 redis.conf 文件，找到 APPEND ONLY MODE 对应内容<br>1 redis 默认关闭，开启需要手动把no改为yes</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">appendonly</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><p>2 指定本地数据库文件名，默认值为 appendonly.aof</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">appendfilename</span> <span class="string">"appendonly.aof"</span></span><br></pre></td></tr></table></figure><p>3 指定更新日志条件</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta"># appendfsync no</span></span><br></pre></td></tr></table></figure><p>解说：<br>always：同步持久化，每次发生数据变化会立刻写入到磁盘中。性能较差当数据完整性比较好（慢，安全）<br>everysec：出厂默认推荐，每秒异步记录一次（默认值）<br>no：不同步</p><p>4 配置重写触发机制</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto</span>-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line"><span class="built_in">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb</span><br></pre></td></tr></table></figure><p>解说：当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。一般都设置为3G，64M太小了。</p><h3 id="触发AOF快照"><a href="#触发AOF快照" class="headerlink" title="触发AOF快照"></a>触发AOF快照</h3><p>根据配置文件触发，可以是每次执行触发，可以是每秒触发，可以不同步。</p><h3 id="根据AOF文件恢复数据"><a href="#根据AOF文件恢复数据" class="headerlink" title="根据AOF文件恢复数据"></a>根据AOF文件恢复数据</h3><p>正常情况下，将appendonly.aof 文件拷贝到redis的安装目录的bin目录下，重启redis服务即可。但在实际开发中，可能因为某些原因导致appendonly.aof 文件格式异常，从而导致数据还原失败，可以通过命令redis-check-aof –fix appendonly.aof 进行修复 。从下面的操作演示中体会。</p><h3 id="AOF的重写机制"><a href="#AOF的重写机制" class="headerlink" title="AOF的重写机制"></a>AOF的重写机制</h3><p>前面也说到了，AOF的工作原理是将写操作追加到文件中，文件的冗余内容会越来越多。所以聪明的 Redis 新增了重写机制。当AOF文件的大小超过所设定的阈值时，Redis就会对AOF文件的内容压缩。</p><p>重写的原理：Redis 会fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中。并没有读取旧文件（你都那么大了，我还去读你？？？ o(ﾟДﾟ)っ傻啊！）。最后替换旧的aof文件。</p><p>触发机制：当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。这里的“一倍”和“64M” 可以通过配置文件修改。</p><h3 id="AOF-的优缺点"><a href="#AOF-的优缺点" class="headerlink" title="AOF 的优缺点"></a>AOF 的优缺点</h3><p>优点：数据的完整性和一致性更高<br>缺点：因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢。</p><h3 id="操作演示-1"><a href="#操作演示-1" class="headerlink" title="操作演示"></a>操作演示</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>itdragon bin]# vim appendonly.aof</span><br><span class="line">appendonly yes</span><br><span class="line">[<span class="symbol">root@</span>itdragon bin]# ./redis-server redis.conf</span><br><span class="line">[<span class="symbol">root@</span>itdragon bin]# ./redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6379</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line">(empty list <span class="keyword">or</span> <span class="keyword">set</span>)</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">set</span> keyAOf valueAof</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; FLUSHALL </span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SHUTDOWN</span><br><span class="line"><span class="keyword">not</span> connected&gt; QUIT</span><br><span class="line">[<span class="symbol">root@</span>itdragon bin]# ./redis-server redis.conf</span><br><span class="line">[<span class="symbol">root@</span>itdragon bin]# ./redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6379</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">"keyAOf"</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SHUTDOWN</span><br><span class="line"><span class="keyword">not</span> connected&gt; QUIT</span><br><span class="line">[<span class="symbol">root@</span>itdragon bin]# vim appendonly.aof</span><br><span class="line">fjewofjwojfoewifjowejfwf</span><br><span class="line">[<span class="symbol">root@</span>itdragon bin]# ./redis-server redis.conf</span><br><span class="line">[<span class="symbol">root@</span>itdragon bin]# ./redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6379</span></span><br><span class="line">Could <span class="keyword">not</span> connect to Redis at <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>: Connection <span class="built_in">ref</span>used</span><br><span class="line"><span class="keyword">not</span> connected&gt; QUIT</span><br><span class="line">[<span class="symbol">root@</span>itdragon bin]# redis-check-aof --fix appendonly.aof </span><br><span class="line"><span class="string">'x              3e: Expected prefix '</span>*<span class="string">', got: '</span></span><br><span class="line">AOF analyzed: size=<span class="number">92</span>, ok_up_to=<span class="number">62</span>, diff=<span class="number">30</span></span><br><span class="line">This will shrink the AOF <span class="keyword">from</span> <span class="number">92</span> bytes, with <span class="number">30</span> bytes, to <span class="number">62</span> bytes</span><br><span class="line">Continue? [y/N]: y</span><br><span class="line">Successfully truncated AOF</span><br><span class="line">[<span class="symbol">root@</span>itdragon bin]# ./redis-server redis.conf</span><br><span class="line">[<span class="symbol">root@</span>itdragon bin]# ./redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6379</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">"keyAOf"</span></span><br></pre></td></tr></table></figure><p>第一步：修改配置文件，开启AOF持久化配置。<br>第二步：重启Redis服务，并进入Redis 自带的客户端中。<br>第三步：保存值，然后模拟数据丢失，关闭Redis服务。<br>第四步：重启服务，发现数据恢复了。（额外提一点：有教程显示FLUSHALL 命令会被写入AOF文件中，导致数据恢复失败。我安装的是redis-4.0.2没有遇到这个问题）。<br>第五步：修改appendonly.aof，模拟文件异常情况。<br>第六步：重启 Redis 服务失败。这同时也说明了，RDB和AOF可以同时存在，且优先加载AOF文件。<br>第七步：校验appendonly.aof 文件。重启Redis 服务后正常。</p><p>补充点：aof 的校验是通过 redis-check-aof 文件，那么rdb 的校验是不是可以通过 redis-check-rdb 文件呢？？？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Redis 默认开启RDB持久化方式，在指定的时间间隔内，执行指定次数的写操作，则将内存中的数据写入到磁盘中。</li><li>RDB 持久化适合大规模的数据恢复但它的数据一致性和完整性较差。</li><li>Redis 需要手动开启AOF持久化方式，默认是每秒将写操作日志追加到AOF文件中。</li><li>AOF 的数据完整性比RDB高，但记录内容多了，会影响数据恢复的效率。</li><li>Redis 针对 AOF文件大的问题，提供重写的瘦身机制。</li><li>若只打算用Redis 做缓存，可以关闭持久化。</li><li>若打算使用Redis 的持久化。建议RDB和AOF都开启。其实RDB更适合做数据的备份，留一后手。AOF出问题了，还有RDB。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-持久化之RDB和AOF&quot;&gt;&lt;a href=&quot;#Redis-持久化之RDB和AOF&quot; class=&quot;headerlink&quot; title=&quot;Redis 持久化之RDB和AOF&quot;&gt;&lt;/a&gt;Redis 持久化之RDB和AOF&lt;/h1&gt;&lt;p&gt;Redis 有两种持久化方案，RDB （Redis DataBase）和 AOF （Append Only File）。如果你想快速了解和使用RDB和AOF，可以直接跳到文章底部看总结。本章节通过配置文件，触发快照的方式，恢复数据的操作，命令操作演示，优缺点来学习 Redis 的重点知识&lt;strong&gt;持久化&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://cy-blogs.cn/categories/Redis/"/>
    
    
      <category term="Redis 持久化之RDB和AOF" scheme="https://cy-blogs.cn/tags/Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB%E5%92%8CAOF/"/>
    
  </entry>
  
  <entry>
    <title>Redis 发布者与订阅者,键空间事件</title>
    <link href="https://cy-blogs.cn/Redis%E5%8F%91%E5%B8%83%E8%80%85%E4%B8%8E%E8%AE%A2%E9%98%85%E8%80%85%EF%BC%8C%E9%94%AE%E7%A9%BA%E9%97%B4%E4%BA%8B%E4%BB%B6/"/>
    <id>https://cy-blogs.cn/Redis发布者与订阅者，键空间事件/</id>
    <published>2019-12-21T08:26:57.446Z</published>
    <updated>2019-12-23T09:16:15.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="发布者与订阅者（pub-sub）"><a href="#发布者与订阅者（pub-sub）" class="headerlink" title="发布者与订阅者（pub/sub）"></a>发布者与订阅者（pub/sub）</h2><p>发布和订阅<code>pub/sub</code>，订阅者负责订阅频道，发送者负责像频道发送二进制字符串消息，每当有消息发布到订阅的这个频道，那么所有的订阅者都可以收到这个消息，发布订阅也是像是我们生活中的电台，订阅者可以订阅收听多个电台，而发送者可以再任何电台发送消息</p><a id="more"></a><h3 id="发布，订阅常用命令"><a href="#发布，订阅常用命令" class="headerlink" title="发布，订阅常用命令"></a>发布，订阅常用命令</h3><table><thead><tr><th>指令</th><th>解释</th></tr></thead><tbody><tr><td>SUBSCRIBE CHANNLE</td><td>订阅给定的一个或多个频道</td></tr><tr><td>UNSUBSCRIBE CHANNLE</td><td>退订一个或多个频道，如果没有指定具体退订的频道，那么是全部退订</td></tr><tr><td>PSUBSCRIBE PATTERN</td><td>订阅与给定模式相匹配的所有频道</td></tr><tr><td>PUNSUBSCRIBE PATTERN</td><td>退订给定的模式相匹配的频道，未指定，则退订所有</td></tr><tr><td>PUBLISH CHANNLE MESSAGE</td><td>向给定频道发送消息</td></tr></tbody></table><h2 id="键空间事件"><a href="#键空间事件" class="headerlink" title="键空间事件"></a>键空间事件</h2><h3 id="键空间事件通知"><a href="#键空间事件通知" class="headerlink" title="键空间事件通知"></a>键空间事件通知</h3><p>在<code>Redis</code>里面有一些事件，比如键<strong>到期</strong>、键被<strong>删除</strong>等。可以通过打开<code>redis</code>键空间事件通知来让 Redis 一旦触发这些事件的时候就往特定的<code>Channel</code>推一条消息</p><h3 id="键事件通知配置"><a href="#键事件通知配置" class="headerlink" title="键事件通知配置"></a>键事件通知配置</h3><ul><li>默认在<code>redis</code>中，键事件通知是不打开的，需要我们手动配置，具体的选项如下，默认他是个空字符串，代表关闭状态</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notify-keyspace-<span class="keyword">events</span> <span class="string">""</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选项字符</th><th>解释</th></tr></thead><tbody><tr><td>K</td><td>键空间通知，所有通知以<code>__keyspace@&lt;db&gt;__</code> 为前缀</td></tr><tr><td>E</td><td>键事件通知，所有通知以<code>__keyevent@&lt;db&gt;__</code> 为前缀</td></tr><tr><td>g</td><td><code>DEL</code>、<code>EXPIRE</code>、<code>RENAME</code>等类型无关的通用命令的通知</td></tr><tr><td>$</td><td>字符串命令的通知</td></tr><tr><td>l</td><td>列表命令的通知</td></tr><tr><td>s</td><td>集合命令的通知</td></tr><tr><td>h</td><td>哈希命令的通知</td></tr><tr><td>z</td><td>有序集合命令的通知</td></tr><tr><td>x</td><td>过期事件：每当有过期键被删除时发送</td></tr><tr><td>e</td><td>驱逐<code>(evict)</code>事件：每当有键因为<code>maxmemory</code>政策而被删除时发送</td></tr><tr><td>A</td><td>参数<code>g$lshzxe</code>的别名</td></tr></tbody></table><p>注意，该选项的值中至少需要包含K或者E，否则不会发布任何事件。比如，如果需要开启针对列表的keyspace事件通知，则该选项需要配置为“Kl”； </p><h3 id="键空间和键事件"><a href="#键空间和键事件" class="headerlink" title="键空间和键事件"></a>键空间和键事件</h3><blockquote><p>对于每个修改数据库的操作，键空间通知都会发送两种不同类型的事件</p><p>比如说，对<code>0</code>号数据库的键<code>mykey</code>执行<code>DEL</code>命令时， 系统将分发两条消息， 相当于执行以下两个<code>PUBLISH</code>命令</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH <span class="symbol">__keyspace@</span><span class="number">0</span>__:mykey del</span><br><span class="line">PUBLISH <span class="symbol">__keyevent@</span><span class="number">0</span>__:del mykey</span><br></pre></td></tr></table></figure><ul><li><code>__keyspace@0__:mykey</code>：接收<code>0</code>号数据库中所有修改键<code>mykey</code>的事件</li><li><code>__keyevent@0__:del</code>：接收<code>0</code>号数据库中所有执行<code>del</code>命令的键</li></ul><blockquote><p><code>keyspace</code>为前缀的频道被称为键空间通知<code>key-space notification</code></p></blockquote><blockquote><p><code>keyevent</code>为前缀的频道则被称为键事件通知<code>key-event notification</code></p></blockquote><ul><li>订阅<strong>键空间频道</strong>，监控被执行事件的键，如监控<code>mykey</code>；那么此时将接收到该键所对应的事件：<code>del</code></li><li>订阅<strong>键事件频道</strong>，监控某个事件，如<code>del</code>；那么<code>del</code>事件触发时，订阅者收到：<code>mykey</code></li></ul><h3 id="过期的键事件通知"><a href="#过期的键事件通知" class="headerlink" title="过期的键事件通知"></a>过期的键事件通知</h3><ul><li>过期的键事件通知常用在订单过期通知等场景下，此时只需要订阅对应<strong>过期事件</strong>的频道，当某键触发过期事件时，即可接受到对应<strong>过期键</strong>的消息</li><li><code>redis</code>配置如下：</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notify-keyspace-<span class="keyword">events</span> <span class="string">"Ex"</span></span><br></pre></td></tr></table></figure><ul><li><code>Python</code>代码的简单示范，订阅过期频道</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">redis = redis.Redis(host=<span class="string">'123.57.61.168'</span>, port=<span class="number">6379</span>)</span><br><span class="line">pubsub = redis.pubsub()</span><br><span class="line">pubsub.psubscribe(<span class="string">'__keyevent@0__:expired'</span>) <span class="comment"># 订阅过期事件频道</span></span><br><span class="line">print(<span class="string">'Starting message loop'</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        message = pubsub.get_message()</span><br><span class="line">        <span class="keyword">if</span> message:</span><br><span class="line">            print(message)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            time.sleep(<span class="number">0.01</span>)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="comment"># CTRL + C</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><ul><li>那么当此时执行此段代码，另起<code>redis</code>客户端，设置一个可以过期的<code>key</code>值，来看一下效果</li></ul><p><img src="/Redis发布者与订阅者，键空间事件/%E9%94%AE%E8%BF%87%E6%9C%9F%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5.gif" alt="键过期事件通知"></p><h3 id="不同命令产生的事件通知"><a href="#不同命令产生的事件通知" class="headerlink" title="不同命令产生的事件通知"></a>不同命令产生的事件通知</h3><p>​            DEL 命令为每个被删除的键产生一个 del 事件；</p><pre><code>RENAME 产生两个事件：为源键产生一个 rename_from 事件，并为目标键产生一个 rename_to 事件；EXPIRE命令，在设置键的过期时间时产生一个 expire事件；当键因过期而被删除时，产生一个 expired事件；SORT命令，在带有 STORE 参数时产生一个 sortstore事件。如果 STORE 指示的用于保存排序结果的键已经存在，则原键会被删除，因此还会产生一个 del 事件；SET 以及它的所有变种(SETEX、SETNX和GETSET)都产生set事件。另外，SETEX命令还会产生expire 事件；MSET 命令，为每个键产生一个 set 事件；SETRANGE 产生一个 setrange 事件；INCR 、DECR、INCRBY和DECRBY都产生 incrby 事件；INCRBYFLOAT产生incrbyfloat事件；APPEND产生append事件；LPUSH和LPUSHX都产生单个 lpush 事件，即使有多个输入元素时，也是如此；RPUSH 和 RPUSHX 都产生单个rpush事件，即使有多个输入元素时，也是如此；RPOP 产生 rpop 事件，如果被弹出的元素是列表的最后一个元素，那么还会产生一个 del 事件；LPOP 产生 lpop 事件，如果被弹出的元素是列表的最后一个元素，那么还会产生一个 del 事件；LINSERT 产生一个 linsert 事件；LSET 产生一个 lset 事件；LREM产生一个lrem事件，如果该命令执行之后，列表键被清空，则还会产生一个 del 事件；LTRIM 产生一个ltrim事件，如果该命令执行之后，列表键被清空，则还会产生一个 del 事件；RPOPLPUSH 和 BRPOPLPUSH 产生一个 rpop 事件，以及一个 lpush 事件。两个命令都保证rpop事件在 lpush 事件之前发出。如果弹出元素之后，列表键被清空，则还会产生一个 del 事件；HSET 、 HSETNX 和 HMSET 都只产生一个 hset 事件；HINCRBY 产生一个 hincrby 事件；HINCRBYFLOAT 产生一个 hincrbyfloat 事件；HDEL 产生一个 hdel 通知。如果执行该命令之后，哈希键被清空，则还会产生一个del事件；SADD 产生一个 sadd 事件，即使有多个输入元素时，也是如此；SREM 产生一个 srem 事件，如果执行该命令之后，集合键被清空，则还会产生一个 del 事件；SMOVE 为源键产生一个 srem 事件，并为目标键产生一个sadd 事件；SPOP 产生一个 spop 事件。如果执行该命令之后，集合键被清空，则还会产生一个 del 事件；SINTERSTORE、SUNIONSTORE和SDIFFSTORE分别产生 sinterstore、sunionostore和sdiffstore 三种事件。如果用于保存结果的键已经存在，则还会产生一个 del 事件；ZINCR产生一个 zincr 事件；ZADD 产生一个 zadd事件，即使有多个输入元素时，也是如此；ZREM 产生一个 zrem 通知，即使有多个输入元素时，也是如此。如果执行 ZREM 之后，有序集合键被清空，则还会产生一个 del 事件；ZREMEBYSCORE 产生一个 zrembyscore事件，如果用于保存结果的键已经存在，则还会产生一个 del 事件。ZREMBYRANK 产生一个 zrembyrank事件，如果用于保存结果的键已经存在，则还会产生一个 del 事件。ZINTERSTORE 和 ZUNIONSTORE 分别产生 zinterstore 和 zunionstore 两种事件。如果用于保存结果的键已经存在，那么还会产生一个 del 事件。每当一个键因为过期而被删除时，产生一个 expired 事件。每当一个键因为 maxmemory策略而被删除并回收内存时，产生一个 evicted 事件。注意：所有命令都只在键真的被改动了之后，才会产生事件通知。比如，当srem命令试图删除不存在于集合的元素时，删除操作执行失败，因为没有真正的改动键，所以这一操作不会发送通知。</code></pre><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>1：Redis发布所有通知，客户端A订阅所有消息：</p><p>127.0.0.1:6379&gt; config set notify-keyspace-events KEA<br>OK<br>127.0.0.1:6379&gt; psubscribe <strong>key*@0</strong>:*<br>Reading messages… (press Ctrl-C to quit)</p><p>1) “psubscribe”<br>2) “<strong>key*@0</strong>:*”<br>3) (integer) 1<br>         然后，在客户端B上执行set和del命令：</p><p>127.0.0.1:6379&gt; set msg “hello”<br>OK<br>127.0.0.1:6379&gt; del msg<br>(integer) 1<br>127.0.0.1:6379&gt; del msg<br>(integer) 0<br>         然后客户端A的打印如下：</p><p>1) “pmessage”<br>2) “<strong>key*@0</strong>:*”<br>3) “<strong>keyspace@0</strong>:msg”<br>4) “set”</p><p>1) “pmessage”<br>2) “<strong>key*@0</strong>:*”<br>3) “<strong>keyevent@0</strong>:set”<br>4) “msg”</p><p>1) “pmessage”<br>2) “<strong>key*@0</strong>:*”<br>3) “<strong>keyspace@0</strong>:msg”<br>4) “del”</p><p>1) “pmessage”<br>2) “<strong>key*@0</strong>:*”<br>3) “<strong>keyevent@0</strong>:del”<br>4) “msg”<br>         可见，针对每一个操作，客户端A都收到了两种消息，分别是keyspace和keyevent消息。</p><p>2：使Redis仅发布keyspace通知，而客户端A订阅所有消息类型：</p><p>127.0.0.1:6379&gt; config set notify-keyspace-events KA<br>OK<br>127.0.0.1:6379&gt; psubscribe <strong>key*@0</strong>:*<br>Reading messages… (press Ctrl-C to quit)</p><p>1) “psubscribe”<br>2) “<strong>key*@0</strong>:*”<br>3) (integer) 1<br>         在客户端B上执行，与上面同样的步骤。此时，客户端A上的打印：</p><p>1) “pmessage”<br>2) “<strong>key*@0</strong>:*”<br>3) “<strong>keyspace@0</strong>:msg”<br>4) “set”</p><p>1) “pmessage”<br>2) “<strong>key*@0</strong>:*”<br>3) “<strong>keyspace@0</strong>:msg”<br>4) “del”<br>         可见，尽管客户端A订阅了所有消息，但是Redis仅发布了keyspace事件。而且，在客户端B上执行了两次del操作，而只有第一个del成功执行了，从而产生了一个事件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;发布者与订阅者（pub-sub）&quot;&gt;&lt;a href=&quot;#发布者与订阅者（pub-sub）&quot; class=&quot;headerlink&quot; title=&quot;发布者与订阅者（pub/sub）&quot;&gt;&lt;/a&gt;发布者与订阅者（pub/sub）&lt;/h2&gt;&lt;p&gt;发布和订阅&lt;code&gt;pub/sub&lt;/code&gt;，订阅者负责订阅频道，发送者负责像频道发送二进制字符串消息，每当有消息发布到订阅的这个频道，那么所有的订阅者都可以收到这个消息，发布订阅也是像是我们生活中的电台，订阅者可以订阅收听多个电台，而发送者可以再任何电台发送消息&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://cy-blogs.cn/categories/Redis/"/>
    
    
      <category term="Redis 发布者与订阅者,键空间事件" scheme="https://cy-blogs.cn/tags/Redis-%E5%8F%91%E5%B8%83%E8%80%85%E4%B8%8E%E8%AE%A2%E9%98%85%E8%80%85-%E9%94%AE%E7%A9%BA%E9%97%B4%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Redis 心跳检测</title>
    <link href="https://cy-blogs.cn/redis%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B/"/>
    <id>https://cy-blogs.cn/redis心跳检测/</id>
    <published>2019-12-20T03:23:07.031Z</published>
    <updated>2019-12-20T03:22:12.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-心跳检测"><a href="#Redis-心跳检测" class="headerlink" title="Redis 心跳检测"></a>Redis 心跳检测</h1><blockquote><p>在命令传播阶段，<strong>从服务器默认以每秒一次的频率</strong>，向主服务器发送命令：</p><p>*<em>REPLCONF ACK *</em> //replication_offset是从服务器当前的复制偏移量。</p><p>心跳检测的作用：检测主服务器的网络连接状态；辅助实现min-slaves选项；检测命令丢失。</p><p>检测主从服务器的网络连接状态</p><p>通过向主服务器发送INFO replication命令，可以列出从服务器列表，可以看出从最后一次向主发送命令距离现在过了多少秒。</p><p><img src="https://img-blog.csdn.net/20170829110005938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemxmcHJvZ3JhbQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p>lag的值应该在0或1之间跳动，如果超过1则说明主从之间的连接有故障。</p><p>辅助实现min-slaves选项</p><p>Redis可以通过配置<strong>防止主服务器在不安全的情况下执行写命令</strong>；</p><p>min-slaves-to-write 3</p><p>min-slaves-max-lag 10</p><p>上面的配置表示：从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时，主服务器将拒绝执行写命令。这里的延迟值就是上面INFOreplication命令的lag值。</p><p>检测命令丢失</p><p>如果因为网络故障，主服务器传播给从服务器的<strong>写命令在半路丢失</strong>，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将发觉从服务器当前的<strong>复制偏移量</strong>少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器。</p><p>主服务器向从服务器<strong>补发缺失数据</strong>这一操作的原理和部分重同步操作的原理非常相似，它们的区别在于：补发缺失数据操作在主从服务器没有断线的情况下执行，而部分重同步操作则在主从服务器断线并重连之后执行。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis-心跳检测&quot;&gt;&lt;a href=&quot;#Redis-心跳检测&quot; class=&quot;headerlink&quot; title=&quot;Redis 心跳检测&quot;&gt;&lt;/a&gt;Redis 心跳检测&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在命令传播阶段，&lt;strong&gt;从服务器默认以每秒
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://cy-blogs.cn/categories/Redis/"/>
    
    
      <category term="Redis 心跳检测" scheme="https://cy-blogs.cn/tags/Redis-%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis哨兵机制</title>
    <link href="https://cy-blogs.cn/Redis%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/"/>
    <id>https://cy-blogs.cn/Redis哨兵机制/</id>
    <published>2019-12-20T03:23:07.006Z</published>
    <updated>2019-12-20T08:41:29.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-哨兵机制"><a href="#Redis-哨兵机制" class="headerlink" title="Redis 哨兵机制"></a>Redis 哨兵机制</h1><h3 id="什么是哨兵机制？"><a href="#什么是哨兵机制？" class="headerlink" title="什么是哨兵机制？"></a>什么是哨兵机制？</h3><ul><li><p>Redis 的哨兵（sentinel）系统用于管理多个 Redis 服务器，<strong>哨兵是redis集群架构中非常重要的一个组件</strong>，该系统执行以下三个任务：</p><ul><li><strong>监控（Monitoring）</strong>：哨兵（sentinel）会不断地检查你的 Master 和Slave 是否运作正常。</li><li><strong>提醒（Notification）</strong>：当别监控的某个 Redis 出现问题时，哨兵（sentinel）可以通过 API 向管理员或者其他应用程序发送通知。</li><li><strong>自动故障迁移（Automatic failover）</strong>：当一个Master 不能正常工作时，哨兵（sentinel）会开始一次自动故障迁移操作，它会将失效 Master 的其中一个 Slave 升级为新的 Master，并让失效 Master 的其他 Slave 改为复制新的 Master；当客户端视图连接失败的 Master时，集群也会向客户端返回新 Master 的地址，使得集群可以使用 Master 代替失效 Master。</li></ul></li><li><p><strong>哨兵（sentinel）是一个分布式系统，作为一个哨兵集群去运行的，相互协同工作，你可以在一个架构中运行多个哨兵（sentinel）进程</strong></p><blockquote><p>​        (1)故障转移时，判断一个master node宕机了，需要大部分哨兵都同意才行，涉及到分布式选举问题。<br>​         (2)及时部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身就是单点，那么就不靠谱。        </p><p>​        这些进程使用留言协议（gossipprotocols）来接收关于Master 是否下线的信息，并使用投票协议 （agreementprotocols）来决定是否执行自动故障迁移，以及选择哪个 Slave 作为新的 Master。</p><p>​        每个哨兵（sentinel）会向其它哨兵（sentinel）、master、slave<strong>定时</strong>发送消息，以确认对方是否 <strong>“活“ **着，如果发现对方在指定时间（可配置）内未响应，则暂时认为对方已挂（所谓的</strong>”主观认为冗机“**Subjective Down,简称sdown)）</p><p>​        若<strong>“哨兵群”</strong>中的多数据sentinel，都报告某一 master 没响应，系统才认为该 master <strong>“彻底死亡”</strong>(即:客观上的真正down机,Objective Down,简称odown),通过一定的vote算法,从剩下的slave节点中,选一台提升为master,然后自动修改相关配置。</p><p>​         虽然<strong>哨兵(sentinel) *<em>释出为一个单独的可执行文件 *</em>redis-sentinel **,但实际上它只是一个运行在特殊模式下的 Redis 服务器，你可以在启动一个普通 Redis 服务器时通过给定</strong> –sentinel** 选项来启动<strong>哨兵(sentinel)</strong>。</p></blockquote><p>​         哨兵(sentinel) 的一些设计思路和zookeeper非常类似</p><p><img src="/Redis哨兵机制/20171004163652928.jpg" alt="哨兵"></p></li></ul><a id="more"></a><h3 id="哨兵的核心知识"><a href="#哨兵的核心知识" class="headerlink" title="哨兵的核心知识"></a>哨兵的核心知识</h3><hr><ul><li><p>哨兵至少需要3个实例，来保证自己的健壮性。</p></li><li><p>哨兵+redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用性</p></li><li><p>对于哨兵+redis主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充分的测试和演练。</p></li></ul><h3 id="redis哨兵主备切换的数据丢失问题"><a href="#redis哨兵主备切换的数据丢失问题" class="headerlink" title="redis哨兵主备切换的数据丢失问题"></a>redis哨兵主备切换的数据丢失问题</h3><hr><p>两种丢失情况：</p><ul><li><p>异步复制导致的数据丢失</p><blockquote><p>​        因为master-&gt;slave的复制是异步的，所 以可能有部分数据还没复制到slave，master就宕机了，这些数据就丢失了。</p></blockquote></li><li><p>脑裂导致的数据丢失</p><blockquote><p>​        脑裂，也就是说，某个master所在机器 突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着<br> ​        这个时候，集群中就会出现两个master。<br> ​        此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续写向旧master数据可能就会丢失。<br> ​        因此master在恢复的时候，会被作为一个slave挂到新的master上，自己的数据会被清空，从新的master复制数据</p></blockquote></li></ul><h3 id="解决异步复制和脑裂导致的数据丢失"><a href="#解决异步复制和脑裂导致的数据丢失" class="headerlink" title="解决异步复制和脑裂导致的数据丢失"></a>解决异步复制和脑裂导致的数据丢失</h3><hr><p>min-slaves-to-write 1<br> min-slaves-max-lag 10<br> 要求至少有1个slave，数据复制和同步的延迟不能超过10秒<br> 如果说一旦所有slave，数据复制和同步的延迟都超过了10秒钟，那么这个时候，master就不会再接收任何请求了。<br> （1）减少异步复制的数据丢失<br> 有了min-slaves-max-lag这个配置，就可以确保说，一旦slave复制数据和ack延时太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求，这样可以把master宕机时由于部分数据未同步到slave导致的数据丢失降低的可控范围内<br> （2）减少脑裂的数据丢失<br> 如果一个master出现了脑裂，跟其他slave丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的slave发送数据，而且slave超过10秒没有给自己ack消息，那么就直接拒绝客户端的写请求<br> 这样脑裂后的旧master就不会接受client的新数据，也就避免了数据丢失<br> 上面的配置就确保了，如果跟任何一个slave丢了连接，在10秒后发现没有slave给自己ack，那么就拒绝新的写请求<br> 因此在脑裂场景下，最多就丢失10秒的数据</p><p><img src="/Redis哨兵机制/%E8%84%91%E8%A3%82%E9%97%AE%E9%A2%98.jpg" alt></p><p>集群脑裂导致的数据丢失问题.png</p><p><img src="/Redis哨兵机制/160983038536.jpg" alt="img"></p><p>脑裂导致数据丢失的问题如何降低损失.png</p><p><img src="/Redis哨兵机制/16098303.jpg" alt="img"></p><p>异步复制导致的数据丢失问题.png</p><p><img src="/Redis哨兵机制/16098303d31754.jpg" alt="img"></p><h3 id="哨兵模式的配置修改"><a href="#哨兵模式的配置修改" class="headerlink" title="哨兵模式的配置修改"></a>哨兵模式的配置修改</h3><hr><ul><li>实现步骤<ul><li>拷贝到etc目录<ul><li><strong>cp sentinel.conf /usr/local/redis/etc</strong></li></ul></li><li>修改sentinel.conf配置文件<ul><li><strong>sentinel monitor mymast 192.168.110.133 6379 1</strong> #主节点 名称 IP 端口号 选举次数</li><li>#配置主服务器的密码(如没设置密码，可以省略)<br>  <strong>sentinel auth-pass mymaster 123456</strong> </li></ul></li><li>修改心跳检测 5000毫秒<ul><li><strong>sentinel down-after-milliseconds mymaster 5000</strong></li></ul></li><li>做多多少合格节点<ul><li><strong>sentinel parallel-syncs mymaster 2</strong></li></ul></li><li>启动哨兵模式<ul><li><strong>./redis-server /usr/local/redis/etc/sentinel.conf –sentinel &amp;</strong></li></ul></li></ul></li></ul><blockquote><p>注意：</p><p>1.当启动哨兵模式之后，如果你的master服务器宕机之后，哨兵自动会在从redis服务器里面 投票选举一个master主服务器出来；这个主服务器也可以进行<strong>读写</strong>操作！</p><p>2.如果之前宕机的主服务器已经修好，可以正式运行了。那么这个服务器只能进行<strong>读</strong>的操作，会自动跟随由哨兵选举出来的新服务器！</p><p>3.大家可以进入./redis-cli，输入<strong>info，</strong>查看你的状态信息；</p></blockquote><p><img src="/Redis哨兵机制/20171004170405127.jpg" alt></p><h3 id="哨兵-Sentinel-总结"><a href="#哨兵-Sentinel-总结" class="headerlink" title="哨兵(Sentinel)总结"></a>哨兵(Sentinel)总结</h3><blockquote><p>1、<strong>Sentinel</strong>的作用：</p><p>A、Master 状态监测</p><p>B、如果Master 异常，则会进行Master-slave 转换，将其中一个Slave作为Master，将之前的Master作为Slave </p><p>C、Master-Slave切换后，master_redis.conf、slave_redis.conf和sentinel.conf的内容都会发生改变，即master_redis.conf中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换 </p><p>2、<strong>Sentinel</strong>的工作方式<strong>:</strong></p><p>1)：每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令。</p><p>2)：如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。 </p><p>3)：如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。 </p><p>4)：当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 。</p><p>5)：在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 。</p><p>6)：当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 。</p><p>7)：若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。 </p><p>若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</p><p>最后，如果大家看不太懂，推荐大家看两个博客，就明白了！</p><p>1.<a href="http://blog.csdn.net/zbw18297786698/article/details/52891695" target="_blank" rel="noopener">http://blog.csdn.net/zbw18297786698/article/details/52891695</a><br>2.<a href="http://blog.csdn.net/candy_rainbow/article/details/52842402" target="_blank" rel="noopener">http://blog.csdn.net/candy_rainbow/article/details/52842402</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-哨兵机制&quot;&gt;&lt;a href=&quot;#Redis-哨兵机制&quot; class=&quot;headerlink&quot; title=&quot;Redis 哨兵机制&quot;&gt;&lt;/a&gt;Redis 哨兵机制&lt;/h1&gt;&lt;h3 id=&quot;什么是哨兵机制？&quot;&gt;&lt;a href=&quot;#什么是哨兵机制？&quot; class=&quot;headerlink&quot; title=&quot;什么是哨兵机制？&quot;&gt;&lt;/a&gt;什么是哨兵机制？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Redis 的哨兵（sentinel）系统用于管理多个 Redis 服务器，&lt;strong&gt;哨兵是redis集群架构中非常重要的一个组件&lt;/strong&gt;，该系统执行以下三个任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;监控（Monitoring）&lt;/strong&gt;：哨兵（sentinel）会不断地检查你的 Master 和Slave 是否运作正常。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提醒（Notification）&lt;/strong&gt;：当别监控的某个 Redis 出现问题时，哨兵（sentinel）可以通过 API 向管理员或者其他应用程序发送通知。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动故障迁移（Automatic failover）&lt;/strong&gt;：当一个Master 不能正常工作时，哨兵（sentinel）会开始一次自动故障迁移操作，它会将失效 Master 的其中一个 Slave 升级为新的 Master，并让失效 Master 的其他 Slave 改为复制新的 Master；当客户端视图连接失败的 Master时，集群也会向客户端返回新 Master 的地址，使得集群可以使用 Master 代替失效 Master。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;哨兵（sentinel）是一个分布式系统，作为一个哨兵集群去运行的，相互协同工作，你可以在一个架构中运行多个哨兵（sentinel）进程&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;​        (1)故障转移时，判断一个master node宕机了，需要大部分哨兵都同意才行，涉及到分布式选举问题。&lt;br&gt;​         (2)及时部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身就是单点，那么就不靠谱。        &lt;/p&gt;
&lt;p&gt;​        这些进程使用留言协议（gossipprotocols）来接收关于Master 是否下线的信息，并使用投票协议 （agreementprotocols）来决定是否执行自动故障迁移，以及选择哪个 Slave 作为新的 Master。&lt;/p&gt;
&lt;p&gt;​        每个哨兵（sentinel）会向其它哨兵（sentinel）、master、slave&lt;strong&gt;定时&lt;/strong&gt;发送消息，以确认对方是否 &lt;strong&gt;“活“ **着，如果发现对方在指定时间（可配置）内未响应，则暂时认为对方已挂（所谓的&lt;/strong&gt;”主观认为冗机“**Subjective Down,简称sdown)）&lt;/p&gt;
&lt;p&gt;​        若&lt;strong&gt;“哨兵群”&lt;/strong&gt;中的多数据sentinel，都报告某一 master 没响应，系统才认为该 master &lt;strong&gt;“彻底死亡”&lt;/strong&gt;(即:客观上的真正down机,Objective Down,简称odown),通过一定的vote算法,从剩下的slave节点中,选一台提升为master,然后自动修改相关配置。&lt;/p&gt;
&lt;p&gt;​         虽然&lt;strong&gt;哨兵(sentinel) *&lt;em&gt;释出为一个单独的可执行文件 *&lt;/em&gt;redis-sentinel **,但实际上它只是一个运行在特殊模式下的 Redis 服务器，你可以在启动一个普通 Redis 服务器时通过给定&lt;/strong&gt; –sentinel** 选项来启动&lt;strong&gt;哨兵(sentinel)&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​         哨兵(sentinel) 的一些设计思路和zookeeper非常类似&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Redis哨兵机制/20171004163652928.jpg&quot; alt=&quot;哨兵&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://cy-blogs.cn/categories/Redis/"/>
    
    
      <category term="Redis哨兵机制" scheme="https://cy-blogs.cn/tags/Redis%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
</feed>

{"meta":{"title":"哼着自己旳小调调","subtitle":"Happy hum their own small tune","description":null,"author":"哼着自己旳小调调","url":"https://cy-blogs.cn","root":"/"},"pages":[{"title":"[404]","date":"2019-10-01T14:53:28.099Z","updated":"2019-10-01T14:53:28.099Z","comments":true,"path":"404.html","permalink":"https://cy-blogs.cn/404.html","excerpt":"","text":""},{"title":"关于个人","date":"2019-10-13T09:46:28.000Z","updated":"2019-10-21T06:01:26.819Z","comments":true,"path":"about/index.html","permalink":"https://cy-blogs.cn/about/index.html","excerpt":"","text":"个人信息："},{"title":"分类","date":"2016-03-24T16:00:00.000Z","updated":"2019-10-21T03:46:43.274Z","comments":true,"path":"categories/index.html","permalink":"https://cy-blogs.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-21T03:40:22.000Z","updated":"2019-10-21T06:01:32.661Z","comments":true,"path":"tags/index.html","permalink":"https://cy-blogs.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Ansible","slug":"Ansible","date":"2019-12-10T12:35:38.500Z","updated":"2019-12-10T12:35:24.192Z","comments":true,"path":"Ansible/","link":"","permalink":"https://cy-blogs.cn/Ansible/","excerpt":"Ansible ansible基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能在使用时，ansible不需要在被控制安装客户端，ansible工作基于ssh，只要被控制端服务器有ssh服务，加上一个Python环境，就可以使用ansible另外，ansible在15年的时候，以1.5亿美元被RedHat公司收购，新版的RedHat操作系统内置ansible软件，很厉害的","text":"Ansible ansible基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能在使用时，ansible不需要在被控制安装客户端，ansible工作基于ssh，只要被控制端服务器有ssh服务，加上一个Python环境，就可以使用ansible另外，ansible在15年的时候，以1.5亿美元被RedHat公司收购，新版的RedHat操作系统内置ansible软件，很厉害的 ##Ansible部署 ansible安装可以通过源码，yum源以及python所提供的pip管理工具进行安装 使用pip管理工具进行安装 1pip3 install ansible 使用yum进行安装 12yum install epel-release # 安装扩展源yum install ansible Ansible配置 安装之后，默认ansible工具的配置文件在/etc/ansible下 如通过pip命令安装，是没有这个目录的，需要我们手动创建，其中所需主要配置文件如下 ansible.cfg：ansible主配置文件 hosts：被管理主机IP或者主句名列表文件，也是比较重要的一个文件 roles：角色或插件目录（默认为空） 此外除了默认的ansible的配置文件路径，关于ansible的配置文件路径选择还有如下几种，按照序列表示优先级 export ANSIBLE_CONFI：指定的全局变量 ./ansible.cfg：当前目录下的配置文件 ~/.ansible.cfg：当前用户目下的配置文件 /ext/ansible/ansible.cfg：etc目录下的配置文件 如果以上四个路径下均没有cfg配置文件，则使用默认配置 如果通过源码进行安装，那么在/etc/ansible目录下会自动包含ansible.cfg文件 也可以通过访问在线的配置文件地址进行获取 https://raw.githubusercontent.com/ansible/ansible/devel/examples/ansible.cfg ansible配置文件中可以进行ansible的各项参数的设置，包括并发线程数量、用户、模块路径、调优等等 defaluts：默认的配置项，一般不需要修改 privilege_escalation：执行命令的用户权限设置 paramiko_connection：paramiko插件设置 ssh_connection：ssh连接设置 默认ansible使用hosts文件列举监控主句，格式为ini，可以进行IP的分组以及IP规则设置，比如如下的例子 12[webserver]192.168.1.1001:22 ansible支持很多模块来进行对被控制主机的管理，包括：command、shell、script、yum、copy、File、async、docker、cron、mysql_user、ping、sysctl、user、acl、add_host、easy_install、haproxy等。默认在执行命令时，使用模块为、command，接下来会进行介绍 Ansible使用参数 ansible在工作时，需要使用我们安装好的、ansible来执行命令 经常在使用、ansible模块进行工作时，可能还需要额外提供一些参数来辅助工作，下面是常用参数 命令参数 解释 -v 打印详细信息 -m 指定使用的模块，默认为 command模块 -k 要求输入远程主机密码 -a 将参数或命令传入模块 -c 测试执行过程，但不真正执行 -sudo 基于 sudo用户执行 --list-hosts 列举命令生效的主机 -l 限制匹配规则的主机数 -i 指定 hosts文件路径 -u SSH 连接所使用用户 现在看到这些命令参数你可能有一些懵，不过不要着急，结合模块使用，你将很快了解这些参数的实际意义 配置免密登陆 由于 ansible是通过 ssh 服务进行命令下达执行，那避免不了用户认证 但是在批量执行时，多次的重复认证会导致我们的效率极其低下，这里可以通过配置主控端与被控端知己之间 SSH 免密登陆来实现用户认证的跳过，可谓是一次配置，轻松很久 在主控服务器 192.168.1.104 下生成密钥 12ssh-keygen -t rsa# -t 指定加密的方式，默认为rsa 进行秘钥的分布 1ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.1.101 输入对应远程主机的 ssh 账号密码之后，接下来在主控服务器就可以不进行 SSH 的用户认证也可以访问到被控制端，这里测试主机为 192.168.1.104 （主控）， 192.168.1.101 （被控） 定义主机及组规则 ansible 通过定义好的主句以组规则（Inventory） 在执行命令时通过匹配进行远程操作 这个文件默认就是我们上面所说的 /etc/ansible/hosts 文件，其中定义的几种方式如下 直接 IP 写入 1192.168.1.101 规则分组 123[webserver]192.168.1.101:2333www.example.com 可以在规则的 IP 后指定端口 规则命名 123myhost ansible_ssh_host=192.168.1.101[webservers]myhost 在使用时，直接利用myhost即可 除去示例中的指定方式，还有如下一些参数可以利用 ansible_ssh_host：目标主机地址 ansible_ssh_port：目标主机ssh服务端口 ansible_ssh_user：目标主机ssh登录用户 ansible_ssh_pass：目标主机ssh登录密码 ansible_connection：连接类型：local、ssh、paramiko ansible_ssh_priveate_key_file：连接所需ssh私钥文件； ansible_shell_type：目标主机的shell类型：ash、bash（默认使用的shell，可以结合help查看帮助文档）、ksh（支持42个内部命令）、csh、zsh（最庞大的shell，支持84个内部命令） 正则规则 1[webservers][a:z]bc.example.com192.168.1.10[1:5] 在主机处填写对应的正则规则，可以更加方便的映射某个网段下的ip地址 Ping模块 ping模块可以判断被控主机是否在线， 返回值为changed和ping 首先在/etc/ansible/hosts文件下添加被控主机，并建立分组为webservers 1[webservers]192.168.1.101:22 ping命令的用法，要进入到python安装目录下，找到对应的ansible可执行文件 1./ansible all -m ping 返回值ping如果为pong则代表可以ping通 ansible命令行第二个参数可以是一个主机的正则规则，all代表所有hosts文件下IP，也可以指定使用某个分组 1./ansible webservers -m ping Command模块 通过ansible执行命令时，默认使用command模块，该模块主要用于执行linux基础命令 注意：对比之后的Shell及Script功能模块，Command模块不支持管道 command支持的额外参数 1./ansible-doc -s command# 文档 参数 解释 chdir 执行命令时，先进入到该目录下 creates 给定文件存在时，不执行该命令 free_form 需要执行的脚本 removes 给定文件存在，则执行该命令 对远程主机执行命令 1./ansible webservers -m command -a \"ifconfig\" 执行命令时更改工作目录 1./ansible webservers -m command -a \"ls chdir=/home/\" Shell模块 shell使用远程主机下的/bin/sh进行命令执行，支持比command模块更多的命令，常用参数如下 1./ansible-doc -s shell# 文档 额外参数 参数 解释 chdir 执行命令时，先进入到该目录下 creates 给定文件存在时，不执行该命令 free_form 需要执行的脚本 removes 给定文件存在，则执行该命令 executable 更换执行命令所使用的shell环境 远程主机编写sh脚本，向屏幕输出hello 1echo \"hello\" 执行远程主机的shell脚本 1./ansible webservers -m shell -a \"sh ~/test.sh\" Script模块 该模块可以方便运行当前管理机上的脚本直接到远程被控端，而不需要先将脚本拷贝到远程主机后在执行 在主控制home目录下创建sh脚本 1echo \"this is Control\" 将这个sh脚本通过script模块执行到远程被控端 1./ansible webservers -m script -a \"/root/test.sh\" Copy模块 copy模块可以方便的将当前主机下文件拷贝到远程主机，类似scp命令等 1./ansible-doc -s copy# 文档地址 支持的参数 参数 解释 src 将本地路径复制到远程服务器; 可以是绝对路径或相对的。如果是一个目录，它将被递归地复制。如果路径以/结尾，则只有该目录下内容被复制到目的地，如果没有使用/来结尾，则包含目录在内的整个内容全部复制 content 当用content代替src参数的时候，可以把文档的内容设置到特定的值 dest 目标绝对路径。如果src是一个目录，dest也必须是一个目录。如果dest是不存在的路径，并且如果dest以/结尾或者src是目录，则dest被创建。如果src和dest是文件，如果dest的父目录不存在，任务将失败 backup 如果文件修改，则在覆盖之前将原文件备份，备份文件包含时间信息 directory_mode 设定目录的权限，在新建时使用，不会影响已存在的目录 force 当目标内容不同于源时，将替换远程文件。设置为no时，只有在目标文件不存在的情况下才会传输文件 group 设置文件/目录的所属组 mode 设置文件权限 owner 设置文件/目录的所属用户 Copy前备份1./ansible all -m copy -a \"src=/root/ansible_copy_file backup=yes dest=/home/\" 在第一次拷贝时，由于目标主机还并没有这个文件， 备份动作不生效 在对文件内容进行修改后重新执行该命令拷贝文件 此时目标主机下，不光会有我们上传的拷贝文件，还有之前文件的一个备份 覆盖内容 直接通过content参数指定内容，并对目标主机上已存在的test_copy文件进行覆盖 1./ansible all -m copy -a \"content='这是命令修改\\n' dest=/home/test_copy\" 这条命令将会把远程主机home目录下的test_copy文件覆盖为我们的content内容 Stat模块 该模块可以获取远程主机下的文件信息，需要使用path参数指明文件路径 1./ansible all -m stat -a \"path=/home/test_copy\" Yum模块 该模块可以对远程主机上的软件安装、卸载进行管理 1./ansible-doc -s copy# 文档 支持参数 参数 解释 name 必须参数，用于指定需要管理的软件包，比如nginx state 用于指定软件包的状态，默认值为present，表示确保软件包已经安装 除了present，其他可用值有installed、latest、absent、removed 其中installed与present等效，latest表示安装yum中最新的版本，absent和removed等效，表示删除对应的软件包 在远程主机下安装nginx 1./ansible all -m yum -a \"name=nginx state=installed\" 查看nginx服务状态 1systemctl status nginx Service模块 该模块主要用于远程服务器上对应的服务管理，比如开启或关闭apache服务等 1./ansible-doc -s yum# 文档 支持参数 参数 解释 name 需要管理的服务名称，如nginx state 此参数用于指定服务的状态 比如，我们想要启动远程主机中的nginx，则可以将state的值设置为started 如果想要停止远程主机中的服务，则可以将state的值设置为stopped 此参数的可用值有started、stopped、restarted、reloaded enabled 此参数用于指定是否将服务设置为开机启动项，设置为yes表示将对应服务设置为开机启动，设置为no表示不会开机启动 将远程主机下的httpd服务开启 1./ansible all -m service -a \"name=httpd state=started\" File模块 file模块可以帮助我们完成一些对文件的基本操作 比如，创建文件或目录、删除文件或目录、修改文件权限等 1./ansible-doc -s yum# 文档 支持参数 参数 解释 path 指明需要操作的文件或目录路径 state 此参数非常灵活，其对应的值需要根据情况设定。比如，我们想要在远程主机上创建/testdir/a/b目录，那么则需要设置path=/testdir/a/b，但是，我们无法从/testdir/a/b这个路径看出b是一个文件还是一个目录，ansible也同样无法单单从一个字符串就知道你要创建文件还是目录，所以，我们需要通过state参数进行说明 当我们想要创建的/testdir/a/b是一个目录时，需要将state的值设置为directory，directory为目录之意，当它与path结合，ansible就能知道我们要操作的目标是一个目录 当我们想要操作的/testdir/a/b是一个文件时，则需要将state的值设置为touch 当我们想要创建软链接文件时，需将state设置为link；想要创建硬链接文件时，需要将state设置为hard 当我们想要删除一个文件时（删除时不用区分目标是文件、目录、还是链接），则需要将state的值设置为absent，absent为缺席之意，当我们想让操作的目标”缺席”时，就表示我们想要删除目标 src src参数：当state设置为link或者hard时，表示我们想要创建一个软链或者硬链 所以，我们必须指明软链或硬链链接的哪个文件，通过src参数即可指定链接源 force 当state=link的时候，可配合此参数强制创建链接文件，当force=yes时，表示强制创建链接文件。不过强制创建链接文件分为三种情况 情况一：当要创建的链接文件指向的源文件并不存在时，使用此参数，可以先强制创建出链接文件 情况二：当要创建链接文件的目录中已经存在与链接文件同名的文件时，将force设置为yes，会将同名文件覆盖为链接文件，相当于删除同名文件，创建链接文件 情况三：当要创建链接文件的目录中已经存在与链接文件同名的文件，并且链接文件指向的源文件也不存在，这时会强制替换同名文件为链接文件 owner 指定文件所属用户 group 指定文件所属组 mode 指定文件权限 将远程主机下的Python3创建软连接到home目录 1./ansible all -m file -a \"path=/home/python3 state=link src=/usr/local/python3/bin/python3\"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://cy-blogs.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cy-blogs.cn/tags/Linux/"}]},{"title":"GitHub操作","slug":"Git","date":"2019-12-09T11:56:21.542Z","updated":"2019-12-09T11:58:51.734Z","comments":true,"path":"Git/","link":"","permalink":"https://cy-blogs.cn/Git/","excerpt":"GitHub操作起来真的是太简单啦！Git Git是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务。 Git易于学习， 占地面积小，具有闪电般快速的性能。它超越了Subversion，CVS，Perforce和ClearCase等SCM工具，具有廉价本地分支，便捷的临时区域和多个工作流程等功能","text":"GitHub操作起来真的是太简单啦！Git Git是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务。 Git易于学习， 占地面积小，具有闪电般快速的性能。它超越了Subversion，CVS，Perforce和ClearCase等SCM工具，具有廉价本地分支，便捷的临时区域和多个工作流程等功能 git流程 workspace：工作区 Index/Stage：暂存区 Repository：仓库区/本地仓库 Remote：远程仓库 SVN与Git的区别 SVN SVN是集中式版本控制系统，版本库是集中放在中央服务器的、而干活的时候，用的都是自己的电脑 首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器 集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了 Git Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库 这工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了 Git在本地磁盘上就保存着所有有关当前项目的历史更新，并且Git中的绝大多数操作都只需要访问本地文件和资源，不用连网，所以处理起来速度飞快 用SVN的话，没有网络或者断开VPN你就无法做任何事情 但用Git的话，就算你在飞机或者火车上，都可以非常愉快地频繁提交更新，等到了有网络的时候再上传到远程的镜像仓库。换作其他版本控制系统，这么做几乎不可能，抑或是非常麻烦 安装git Windows：https://git-scm.com/downloads Linux： Git配置 git config --global：全局git配置，这台机器所有的Git仓库均会使用这个配置 12git config --global user.name \"eastside\" # 你的名字git config --global user.email \"..@xx.com\" # 你的邮箱 git操作创建版本库 什么是版本库？ 版本库又名仓库，英文名repository 你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件还原 选择，进入某个目录 1mkdir projectcd project 初始化目录为本地仓库 1git init 初始化之后，目录下会多一个隐藏目录.git，该目录是git用来管理版本的， 添加项目文件 以创建django项目为例，在git本地仓库开启一个django项目 1django-admin startproject testpro 添加项目文件或目录至暂存区 1git add testpro 将暂存区内容提交至本地仓库 12git commit -m \"a django project\"$ git commit -m \"a django project\"[master (root-commit) adb00b3] a django project 5 files changed, 172 insertions(+) create mode 100644 testpro/manage.py create mode 100644 testpro/testpro/__init__.py create mode 100644 testpro/testpro/settings.py create mode 100644 testpro/testpro/urls.py create mode 100644 testpro/testpro/wsgi.py -m参数指定提交注释 查看此时仓库状态 12git statuslienze@DESKTOP-BIDA1PF MINGW64 ~/Desktop/project (master)$ git statusOn branch masternothing to commit, working tree clean 文件修改提交 如果在开发过程中，对其中的某个文件进行了修改，那么git在对比文件指纹的过程中发现了差异，此时也需要将新修改的文件进行提交 修改settings.py文件配置 1ALLOWED_HOSTS = [\"*\",]# ALLOWED_HOSTS = [] 查看仓库状态 12git status$ git statusOn branch masterChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: settings.pyno changes added to commit (use \"git add\" and/or \"git commit -a\") 此时仓库说，modified: settings.py，我们对其中某个文件进行了修改 将修改之后的文件加入暂存区 1git add -A 此时查看状态 12git status$ git statusOn branch masterChanges to be committed: (use \"git reset HEAD &lt;file&gt;...\" to unstage) modified: settings.py 将暂存区的内容提交至本地仓库 12git commit -m 'change settings'On branch masternothing to commit, working tree clean 丢弃修改，可以丢弃工作区对于文件的修改 1git checkout -- settings.py 注意：命令git checkout -- settings.py中的--很重要，如果没有--的话，那么命令变成创建分支了 文件删除提交 在django项目的隔壁创建一个1.py文件 1touch 1.py 添加该文件 1git add -Agit commit -m \"add 1.py\" 删除该文件 1rm 1.py 恢复删除文件 1git checkout -- 1.py 提交至本地工作区 1git commit -a -m \"rm 1.py\" git commit -a：提交全部修改 git远程仓库 在团队开发中，我们需要每个开发者彼此配合，对同一款项目代码进行编写，此时需要我们借助线上仓库 github：https://github.com gitee：https://gitee.com 由于网络环境，此处选择gitee 将远程仓库添加到本地 1git remote add edu git@gitee.com:eastside/edu.git 添加一个远程库，库名为edu，地址是git@gitee.com:eastside/edu.git 列举当前所有的远程库 1git remote 删除某个远程库 1git remote remove edu 将本地的仓库推到名为edu的远程仓库中 1# 仓库地址：https://gitee.com/eastside/edu.gitgit push edu master 将远程仓库的代码拉取到本地，在第一次拉取时，可能因为缺少远程服务器上的README.txt文件，而导致远程和本地的分支不一样，通过以下命令 12git pull --rebase origin master # 新建 README文件git pull edu master --allow-unrelated-histories 将远程仓库克隆到本地 1git clone https://gitee.com/eastside/edu.git 这是一个已经和远程仓库master分支关联的本地仓库 git全局配置多个用户名冲突时 1$ git config --global --replace-all user.email \"输入你的邮箱\" $ git config --global --replace-all user.name \"输入你的用户名\" GIT分支 每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支 截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支 我们可以通过checkout命令进行分支的创建及切换 git checkout -b：创建并切换分支 git branch branchname：创建分支 git checkout branchname：切换分支 创建一个测试分支 1git checkout -b testbranch 删除一个分支 1git branch -d testbranch 提交分支代码 1git push --all 合并分支 1git merge testbranch GIT冲突 常见git冲突造成，是由于在多个分支下，或多个仓库中，对同一个文件修改，或添加了新的文件之后 由于某一方对于文件的修改没有及时在另一方生效，当另一方或另一分支在进行提交时，即会出现冲突 在testbranch分支下，修改1.py文件，并提交到云仓库 在master分支下，也修改1.py文件，并尝试提交 此时冲突出现，使用git status命令查看当前仓库状态 查看被修改的文件1.py Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt; testbranch是指fenzhi1上修改的内容，我们可以将差异部分的标注删掉重新提交，或是与对方协商，另行拷贝文件内容，重新clone仓库，将拷贝过的内容添加至内 之后再进行提交 1git add 1.pygit commit -m \"conflict fixed\" 这样就可以搞定了","categories":[{"name":"Git","slug":"Git","permalink":"https://cy-blogs.cn/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://cy-blogs.cn/tags/Git/"}]},{"title":"Vue-Cli","slug":"Vue-Cli","date":"2019-12-09T11:52:36.348Z","updated":"2019-12-09T11:54:42.448Z","comments":true,"path":"Vue-Cli/","link":"","permalink":"https://cy-blogs.cn/Vue-Cli/","excerpt":"组件开发自动化工具 Node.js是一个新的后端(后台)语言，它的语法和JavaScript类似，所以可以说它是属于前端的后端语言 运行环境：后端语言一般运行在服务器端，前端语言运行在客户端的浏览器上 功能：后端语言可以操作文件，可以读写数据库，前端语言不能操作文件，不能读写数据库。 Node.js如果安装成功，可以查看Node.js的版本,在终端输入如下命令","text":"组件开发自动化工具 Node.js是一个新的后端(后台)语言，它的语法和JavaScript类似，所以可以说它是属于前端的后端语言 运行环境：后端语言一般运行在服务器端，前端语言运行在客户端的浏览器上 功能：后端语言可以操作文件，可以读写数据库，前端语言不能操作文件，不能读写数据库。 Node.js如果安装成功，可以查看Node.js的版本,在终端输入如下命令 12node -vnpm 全局安装vue脚手架，vue-cli，这玩意儿可以自动生成项目模板 12vue-clicnpm install --global vue-cli 单页应用 SPWA 单页Web应用（single page web application，SPWA），就是将系统所有的操作交互限定在一个web页面中。 单页应用程序 (SPA)是加载单个HTML页面，系统的不同功能通过加载不同功能组件的形式来切换，不同功能组件全部封装到了js文件中，这些文件在应用开始访问时就一起加载完； 整个系统在切换不同功能时，页面的地址是不变的，系统切换可以做到局部刷新，也可以叫做无刷新，这么做的目的是为了给用户提供更加流畅的用户体验 通过vue-cli脚手架开启一个项目： 1vue init webpack myproject 12345678910111213141516171819202122232425262728- Project name: 项目名称，如果不需要就直接回车。注：此处项目名不能使用大写。- Project description: 项目描述，直接回车- Author：作者- vue build: 构建方式 默认即可- install vue-router? 是否安装vue的路由插件- Use ESLint to lint your code? 是否使用ESLint检测你的代码？ （ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。） - Pick an ESLint preset:选择分支风格 1.standard(https://github.com/feross/standard) js的标准风格 2.Airbnb(https://github.com/airbnb/javascript) JavaScript最合理的方法，这个github 地址说是JavaScript最合理的方法 3.none (configure it yourself) 自己配置 - Setup unit tests? 是否安装单元测试- Pick a test runner 选择一个单元测试运行器 1.Jest（Jest是由Facebook发布的开源的、基于Jasmine的JavaScript单元测试框架） 2.Karma and Mocha 3.none - Setup e2e tests with Nightwatch(Y/n)?是否安装E2E测试框架NightWatch （E2E，也就是End To End，就是所谓的“用户真实场景”。） - Should we run 'npm install' for you after the project has been created?项目创建后是否要为你运行“npm install”? yes,use npm(使用npm) yes,use yarn(使用yarn) no,I will handle that myself(自己操作) 启动开发服务器： 123cd myproject # 进入目录cnpm install # 安装依赖cnpm run dev # 开启服务 vue启动服务之后，是通过一个小型的express服务进行测试开发环境部署，在这个服务中，主要是通过webpack-dev-middleware和webpack-hot-middleware这两个中间件完成，并且会在每次代码对于src目录下的代码进行修改时，服务端会动态检测并让浏览器自动刷新 项目目录介绍 123456- src # 主开发目录，所有的单文件组件都会放在这个目录下- static # 项目静态目录，所有的css、js都会放在这个文件夹下- dist # 项目打包发布文件夹，最后要上线单文件夹项目都在这个文件夹中- node_modules # node的包目录- config # 配置目录，主要用于区分开发环境，测试环境，线上环境的不同- build # 项目打包时依赖的目录 组件开发 将一个组件相关的html结构，css样式，以及交互的JavaScript代码从html文件中剥离出来，合成一个文件，这种文件就是单文件组件，相当于一个组件具有了结构、表现和行为的完整功能，方便组件之间随意组合以及组件的重用，这种文件的扩展名为.vue，比如：menu.vue 组件文件一般定义在src目录下的components文件夹里 template标签定义HTML部分 12345678&lt;teamplate&gt; &lt;div class=&quot;&quot; @click=&quot;&quot;&gt; &lt;label&gt; 账号 &lt;input type=&quot;text&quot;&gt; &lt;/label&gt; &lt;/div&gt;&lt;/teamplate&gt; js写成模块导出的形式 123456789// 使用export default命令，为模块指定默认输出export default&#123; data: function()&#123; return &#123; name:&quot;张三&quot;, age:16, &#125; &#125;&#125; 样式中的编写，如果含有scope关键字，表示这些样式是组件局部的， 12345678&lt;style scoped&gt;.beauty&#123; width:100px; line-height:50px; border-bottom:1px solid #ddd; margin:0px auto;&#125;&lt;/style&gt; 路由配置 当拥有一个组件文件时，要在项目的src目录下的router目录下的index.js文件下 进行组件的路由加载配置 在导入组件文件时，可以使用@符号，代表从src目录起 比如：import index from ‘@/components/index’ 123456789101112131415161718192021import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import HelloWorld from &apos;@/components/HelloWorld&apos;import first from &apos;@/components/first&apos; // 从组件目录下导入组件文件，不需要加后缀import index from &apos;@/components/index&apos;Vue.use(Router)export default new Router(&#123; mode: &apos;history&apos;, routes: [ &#123; path: &apos;/&apos;, component: index, &#125;, &#123; path: &apos;/first&apos;, // 访问路径 component: first &#125; ] &#125;) 当配置好路由之后，需要在最主要的App.Vue文件下进行连接引入 通过&lt;router-link to=&quot;连接地址&quot;&gt;首页&lt;/router-link&gt;标签进行连接引入 通过&lt;router-view&gt;&lt;/router-view&gt;标签进行路由加载，可以简写为：&lt;router-view/&gt; 12345678910111213&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/first&quot;&gt;第一个页面&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在App.Vue文件下的template标签处如果已经引入了其他跳转连接； 那么在子组件的template部分不需要在进行引入 总结 编写components组件 index.js配置路由 在主入口App.vue中加载路由组件&lt;router-view/&gt;，一般默认已经写好","categories":[{"name":"Vue","slug":"Vue","permalink":"https://cy-blogs.cn/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://cy-blogs.cn/tags/Vue/"}]},{"title":"Vue","slug":"Vue","date":"2019-12-09T11:52:36.346Z","updated":"2019-12-09T11:54:39.026Z","comments":true,"path":"Vue/","link":"","permalink":"https://cy-blogs.cn/Vue/","excerpt":"VUE Vue.js是前端三大新框架：Angular.js、React.js、Vue.js之一，Vue.js目前的使用和关注程度在三大框架中稍微胜出，并且它的热度还在递增 Vue的核心库只关注视图层，Vue的目标是通过尽可能简单的API实现响应的数据绑定，在这一点上Vue.js类似于后台的模板语言 Vue也可以将界面拆分成一个个的组件，通过组件来构建界面，然后用自动化工具来生成单页面(SPA - single page application)系统","text":"VUE Vue.js是前端三大新框架：Angular.js、React.js、Vue.js之一，Vue.js目前的使用和关注程度在三大框架中稍微胜出，并且它的热度还在递增 Vue的核心库只关注视图层，Vue的目标是通过尽可能简单的API实现响应的数据绑定，在这一点上Vue.js类似于后台的模板语言 Vue也可以将界面拆分成一个个的组件，通过组件来构建界面，然后用自动化工具来生成单页面(SPA - single page application)系统 Vue.js官方文档： https://cn.vuejs.org/v2/guide/ vue.js下载地址： https://cn.vuejs.org/v2/guide/installation.html npm配置cnpm windows下配置cnmp环境： 默认的使用NPM可能会因为网络问题而导致无法使用或延迟居高，可以使npm升级为cnpm，从国内淘宝镜像中加载所需的npm软件源 1npm install -g cnpm --registry=https://registry.npm.taobao.org 设置安装包缓存路径 1cnpm config set cache \"C:\\nodejs\\node_cache\" 设置安装包位置 1cnpm config set prefix \"C:\\nodejs\\node_global\" 之后使用命令安装的模块存储在C:\\nodejs\\node_global\\node_modules里 请按照个人需求设置你的文件位置 1npm config set cache \"C:\\nodejs\\node_cache\" Vue部署 安装Vue 1cnpm install vue -g 安装vue脚手架 1cnpm install vue-cli -g -g参数代表全局位置安装，这样可以在环境变量生效的情况下直接在命令行等工具下使用vue命令行进行项目的开启 vue-devtools调试工具 vue-devtools可以方便开发者进行Vue中变量等信息的调试跟踪 下载vue-devtools 1git clone https://github.com/vuejs/vue-devtools 进入到vue-devtools目录下安装依赖包 123cd vue-devtools-devcnpm install cnpm run build 注意：在进行调试工具安装时，首先需要修改shells&gt;chrome文件夹下的mainifest.json中的persistent为true 将插件目录下的chrome文件夹拖入到chrome浏览器的扩展程序下，记得打开调试模式 扩展程序可以通过浏览器访问 1chrome://extensions/ Vue-CDN 除去通过npm安装的方式来使用vue，还可以直接使用cdn中的vue.js文件 vue.js：开发版本，包含了有帮助的命令行警告 1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; vue.min.js：生产环境版本，优化了尺寸和速度 1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; Vue语法 每个vue应用都是通过实例化一个新的vue对象开始的 创建第一个模板语法： 1234&lt;div id=\"content\"&gt; &#123;&#123; message &#125;&#125; &lt;!-- 这个也叫做插值表达式 --&gt;&lt;/div&gt; 1234567var vm = new Vue(&#123; // vm这个变量不允许使用连字符，可以使用下划线，比如vm-data是不允许的 el: &quot;#content&quot;, // 对应document中的一个标签，当vue对象创建后，这个标签内的区域就被接管 data: &#123; message: &quot;这是vue里的变量&quot; &#125;&#125;) 当一个vue实例被创建时，vue的响应式系统中加入了对其data对象中能找到的所有属性 当这些属性值被改变时，视图也会发生相应，并将对应属性更新为新的值 也可以通过定义函数来改变实例中data对象中的数据，数据改变，视图中的数据也将改变 12345&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;ChangeMsg&quot;&gt;改变&lt;/button&gt; &lt;!-- 绑定点击事件为定义好的vue函数 --&gt;&lt;/div&gt; 1234567891011121314window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &quot;我对应的是message的变量&quot; &#125;, methods:&#123; // 定义一个函数 并绑定在按钮的点击事件上 ChangeMsg:function()&#123; this.message = &quot;我被改变了&quot;; // 修改当前实例中的message变量 &#125; &#125; &#125;)&#125; 这里的代码，将在点击按钮时，使当前的message变量发生变化 ``这样的语法有点类似一些Web框架，比如django的模板语言中的模板变量 返回值 除了直接定义某个变量的固定值进行页面渲染，模板变量还支持通过函数的返回值进行赋值 12345&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123; classType &#125;&#125;学习&lt;/h1&gt; &lt;p&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt; &lt;span&gt;&#123;&#123; describe() &#125;&#125;&lt;/span&gt;&lt;/div&gt; 1234567891011121314window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#app&quot;, // getElementById(&apos;app&apos;) data: &#123; classType: &quot;vue&quot;, content: &quot;这是vue的一个测试&quot;, &#125;, methods:&#123; describe:function()&#123; return &quot;这是一个函数的返回值&quot; &#125;, &#125; &#125;)&#125; Vue模板指令 模板语法指的是如何将数据放入html中 Vue.js使用了基于HTML的模板语法，允许开发者声明式地将DOM绑定至底层 Vue 实例的数据 所有 Vue.js的模板都是合法的 HTML ，所以能被遵循规范的浏览器和HTML 解析器解析 插入值，模板变量 数据绑定最常见的形式就是使用Mustache语法(双大括号) 的文本插值，也就是上面示例中的`` 内容绑定v-html 将内容按照html格式进行插入 123&lt;div id=&quot;app&quot;&gt; &lt;p v-html=&quot;contetn&quot;&gt;&lt;/p&gt;&lt;/div&gt; 123456var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; content: &quot;&lt;b&gt;段落标签&lt;/b&gt;文本内容&quot; &#125;,&#125;) 在网站上动态渲染任意HTML是非常危险的，因为容易导致XSS攻击 v-html一般只用在可信内容中，永不用在用户提交的内容上 v-text 将内容按照文本格式进行插入，但会覆盖原有标签内的内容，不会有加载的闪烁问题 12345678&lt;div id=&quot;app&quot;&gt; &lt;p v-text=&quot;contetn&quot;&gt;&lt;/p&gt; &lt;p&gt; &#123;&#123; gender ? &apos;男&apos; : &apos;女&apos; &#125;&#125; &lt;!-- ok? true:false --&gt; &lt;/p&gt; &lt;/div&gt; 1234567var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; gender: true, // 变量值为true时，显示模板变量中左边的值 content: &quot;&lt;b&gt;段落标签&lt;/b&gt;文本内容&quot; &#125;,&#125;) v-cloak 解决使用差值表达式时页面渲染过程，由于变量没有初始化而导致的闪烁问题 通俗的来说，比如变量的实际内容没有被创建，那么此时页面只会展示出这样的效果，之后当变量初始化之后，``将变化为实际的值，此时变化的过程我们称作闪烁 这个指令可以隐藏未编译的标签直到实例准备完毕 123456789101112&lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &quot;#app&quot;, data:&#123; message: &quot;测试&quot;, &#125; &#125;)&lt;/script&gt; 在上面的代码中，如果网速够慢的清空下，页面首先加载显示出的内容是`` 解决办法：通过v-clock指令，在使用到模板变量的标签上写入，并设置一个v-clock的类样式 12345&lt;style type=&quot;text/css&quot;&gt; [v-cloak]&#123; display: none; &#125;&lt;/style&gt; 123&lt;div v-cloak id=&quot;app&quot;&gt; &lt;p v-cloak&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt; 属性绑定v-bind 如果我们需要设置的模板变量是一个属性，比如a标签的href属性 12345&lt;div id=&quot;app&quot;&gt; &lt;a v-bind:href=&quot;message&quot;&gt;连接&lt;/a&gt; &lt;a :href=&quot;message +&apos;abc&apos;&quot;&gt;连接&lt;/a&gt; &lt;!-- 属性内的模板变量写法已被移除，使用v-bind:attr 或 :attr --&gt;&lt;/div&gt; 123456var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &quot;https://www.baidu.com&quot; &#125;&#125;) 可以通过v-bind指令或者:的简写对某个dom元素的属性进行绑定 在下面还有更加详细的属性绑定示例 事件绑定v-on 给元素绑定对应事件，以下是对于点击事件的绑定 1234&lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;show&quot;&gt;按钮&lt;/button&gt; &lt;button @click=&quot;show&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt; 12345678new Vue(&#123; el: &quot;#app&quot;, method: &#123; show: function()&#123; alert(&quot;弹一下&quot;) &#125; &#125;&#125;) 跑马灯效果 这里有一个跑马灯效果可以玩耍 12345&lt;div id=&quot;app&quot;&gt; &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt; &lt;button @click=&quot;start&quot;&gt;开始&lt;/button&gt; &lt;button @click=&quot;stop&quot;&gt;停止&lt;/button&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &quot;这是一个跑马灯&quot;, sT: null, // 定时器实例 &#125;, methods:&#123; work()&#123; this.message = this.message.substring(1) + this.message[0] // 循环定时器所作的事情 &#125;, start()&#123; if (this.sT==null) &#123; // 判断此时是否已有定时器开启 console.log(&quot;开启定时器&quot;) this.sT = setInterval(this.work,400) &#125; else &#123; console.log(&quot;已经开启 不在开启&quot;) &#125; &#125;, stop()&#123; // 关闭定时器 设置定时器变量为null console.log(&quot;关闭定时器&quot;) clearInterval(this.sT) this.sT = null &#125; &#125; 绑定事件修饰符阻止冒泡 比如一个按钮在一个div中，并且按钮和div均有自己的事件，那么此时点击按钮，事件会像冒泡一样从按钮开始一直到div进行触发，.stop修饰符用来阻止默认的事件触发行为 123&lt;div id=&quot;fDiv&quot; @click=&quot;divClick&quot;&gt; &lt;button id=&quot;fBtn&quot; @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt; 12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#fDiv&quot;, // 控制区域 data: &#123;&#125;, methods: &#123; divClick()&#123; console.log(&quot;div被点击了&quot;) &#125;, btnClick()&#123; console.log(&quot;按钮被点击了&quot;) &#125; &#125;, &#125;) &#125;&lt;/script&gt; 通过.stop修饰阻止冒泡 123&lt;div id=&quot;fDiv&quot; @click=&quot;divClick&quot;&gt; &lt;button id=&quot;fBtn&quot; @click.stop=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt; 阻止默认行为 比如像a标签这样的，在点击时他有默认的跳转动作，可以通过.prevent阻止该默认行为 123&lt;div id=&quot;fDiv&quot;&gt; &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent=&quot;aLink&quot;&gt;去百度&lt;/a&gt;&lt;/div&gt; 12345678var vm = new Vue()&#123; el: &quot;#fDiv&quot;, methods:&#123; aLink()&#123; console.log(&quot;连接被点击&quot;) &#125; &#125; &#125; 捕获事件 默认的事件触发处理机制是冒泡机制，capture代表具有该修饰的事件，会优先触发，脱离冒泡顺序； 也可理解为谁有该修饰符，先触发谁的事件 123&lt;div id=&quot;fDiv&quot; @click.capture=&quot;divClick&quot;&gt; &lt;button id=&quot;fBtn&quot; @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt; 12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#fDiv&quot;, // 控制区域 data: &#123;&#125;, methods: &#123; divClick()&#123; console.log(&quot;div被点击了&quot;) &#125;, btnClick()&#123; console.log(&quot;按钮被点击了&quot;) &#125; &#125;, &#125;) &#125;&lt;/script&gt; 自身事件 与capture和冒泡不同，.self只有是自身触发的当前的事件才真正执行处理的回调函数 并且.self只会阻止当前元素的事件触发行为 123&lt;div id=&quot;fDiv&quot; @click.self=&quot;divClick&quot;&gt; &lt;button id=&quot;fBtn&quot; @click.self=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt; 1// 与上同 单次事件 使用.once只触发一次事件函数 1234&lt;div id=&quot;fDiv&quot;&gt; &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent.once=&quot;aLink&quot;&gt;去百度&lt;/a&gt; &lt;!-- 连接无法跳转的阻止事件 只会出现一次 --&gt;&lt;/div&gt; 12345678var vm = new Vue()&#123; el: &quot;#fDiv&quot;, methods:&#123; aLink()&#123; console.log(&quot;连接被点击&quot;) &#125; &#125; &#125; 表单双向绑定v-model 使用v-model指令可以在表单input、textarea以及select元素上创建双向数据绑定 根据表单上的值，自动更新模板变量中的值 v-model会忽略表单的初始值，比如：checked、value、selected，如果需要的话，应该在javascript中首先声明初始值 text1234&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;&lt;/div&gt; 12345678910&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; message: &quot;这是个表单内容&quot;, &#125;, &#125;) &#125;&lt;/script&gt; textarea1234&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt; &lt;textarea v-model=&quot;message&quot;&gt;&lt;/textarea&gt;&lt;/div&gt; 1// 同上 checkbox 单个复选框：数据为绑定为true和false的布尔值 1234&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;checked&quot;&gt;&lt;/h3&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;&lt;/div&gt; 12345678910&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; checked: true, &#125;, &#125;) &#125;&lt;/script&gt; 多个复选框：选中的结果会绑定到同一个数组，将保存的v-model变量创建为数组 123456&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;checked&quot;&gt;&lt;/h3&gt; &lt;input name=&quot;fruit&quot; type=&quot;checkbox&quot; value=&quot;apple&quot; v-model=&quot;checked&quot;&gt;苹果 &lt;input name=&quot;fruit&quot; type=&quot;checkbox&quot; value=&quot;banana&quot; v-model=&quot;checked&quot;&gt;香蕉 &lt;input name=&quot;fruit&quot; type=&quot;checkbox&quot; value=&quot;orange&quot; v-model=&quot;checked&quot;&gt;橘子&lt;/div&gt; 12345678910&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; checked: new Array, &#125;, &#125;) &#125;&lt;/script&gt; radio12345&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;picked&quot;&gt;&lt;/h3&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;junior&quot; v-model=&quot;picked&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;girl&quot; v-model=&quot;picked&quot;&gt;女&lt;/div&gt; 12345678910&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; picked: &quot;哈哈哈哈&quot;, &#125;, &#125;) &#125;&lt;/script&gt; select123456789&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;selected&quot;&gt;&lt;/h3&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option disabled value=&quot;&quot;&gt;你想去哪&lt;/option&gt; &lt;option value=&quot;山西&quot;&gt;山西&lt;/option&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 12345678910&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; selected: &quot;&quot;, &#125;, &#125;) &#125;&lt;/script&gt; selects 设置select标签的multiple属性即可设置为多选下拉菜单，按着ctrl键可以多选 12345678&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;selecteds&quot;&gt;&lt;/h3&gt; &lt;select multiple v-model=&quot;selecteds&quot;&gt; &lt;option value=&quot;上衣&quot;&gt;上衣&lt;/option&gt; &lt;option value=&quot;裤子&quot;&gt;裤子&lt;/option&gt; &lt;option value=&quot;鞋&quot;&gt;鞋&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 12345678910&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; selecteds: new Array, // 多重数据一般都要保存成数组 &#125;, &#125;) &#125;&lt;/script&gt; 修饰符.lazy 默认情况下，v-model在input和textarea表单中进行同步输入框的改动 添加了.lazy修饰符之后，对应的v-model绑定事件触发机制将变为change事件，只有在光标失去焦点时会触发 1234&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt; &lt;input type=&quot;text&quot; v-model.lazy=&quot;message&quot;&gt;&lt;/div&gt; 12345678910&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; message: &quot;这是个表单内容&quot;, &#125;, &#125;) &#125;&lt;/script&gt; .number 如果用户希望将输入表单的内容处理为Number类型，可以使用.number给v-model进行修饰；如果表单字符串无法被处理为数字，则返回原始的值 1234&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;typeof message&quot;&gt;&lt;/h3&gt; &lt;input type=&quot;text&quot; v-model.number=&quot;message&quot;&gt;&lt;/div&gt; .trim 使用.trim可以自动过滤输入框的首尾空格 123456&lt;div id=&quot;container&quot;&gt; &lt;input type=&quot;text&quot; v-model.trim=&quot;message&quot;&gt; &lt;br&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &lt;!-- 通过查看另一个表单中同步的缩进 --&gt;&lt;/div&gt; 动态绑定 当某些情况下，无法确定表单中所代表的属性值，可以使用v-bind进行动态绑定，v-model获取到的表单输入此时则是我们定义的v-bind属性值 12345&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt; &lt;input type=&quot;radio&quot; v-model=&quot;message&quot; :value=&quot;choiceA&quot;&gt; A &lt;input type=&quot;radio&quot; v-model=&quot;message&quot; :value=&quot;choiceB&quot;&gt; B&lt;/div&gt; 12345678910111213&lt;script&gt; window.onload = function () &#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; message: &quot;&quot;, // 表单绑定变量 choiceA: &quot;Yes!&quot;, // 属性绑定变量，未来不需要修改标签中的value值即可动态修改 choiceB: &quot;No!&quot;, &#125;, &#125;) &#125;&lt;/script&gt; 计算属性 关键词：computed 模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的 在模板中放入太多的逻辑会让模板过重且难以维护 也就是说，某些时候页面中的模板变量如果需要复杂的运算处理，应该使用计算属性，而不是直接在模板位置进行计算。 1234567891011121314151617181920&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; String1:&quot;这是一个字符串&quot;, &#125;, methods: &#123; MreverseString()&#123; return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125; // 定义一个函数进行字符串逆置 &#125;, computed: &#123; CreverseString()&#123; return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125; // 定义一个计算属性进行字符串逆置 &#125; &#125;) &#125;&lt;/script&gt; 12345678&lt;div v-cloak id=&quot;container&quot;&gt; &lt;p&gt;这是一个字符串:&#123;&#123; String1 &#125;&#125; &lt;/p&gt; &lt;p&gt;他的逆置:&#123;&#123; String1.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125;&#125; &lt;/p&gt; &lt;p&gt;他的逆置:&#123;&#123; CreverseString &#125;&#125; &lt;/p&gt; &lt;!-- 计算属性直接写入函数名 --&gt; &lt;p&gt;他的逆置:&#123;&#123; MreverseString() &#125;&#125; &lt;/p&gt; &lt;!-- 普通methods函数调用需加括号 --&gt;&lt;/div&gt; 注意：虽然计算属性和函数都可以达成同样的目的，但是computed会缓存结果，计算属性如果发现依赖的属性message未发生改变，再次访问计算属性不会重复运算函数，而是直接利用已有结果；如果依赖数据发生改动，计算属性函数才会重新运算。 在函数及计算属性中添加日志输出即可看到这个效果： 123456789101112methods: &#123; MreverseString() &#123; console.log(&quot;MreverseString被运算了&quot;) return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125;&#125;,computed: &#123; CreverseString() &#123; console.log(&quot;CreverseString被运算了&quot;) return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125;&#125; 在终端下进行计算属性以及函数的访问即可看到效果。 计算属性SetAttr 默认的计算属性只有获取getattr的方式，我们可以手动为他添加一个setter 1234567891011computed:&#123; CreverseString: &#123; get: function()&#123; return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125; set: function(val)&#123; this.String1 = val.split(&quot;&quot;).reverse().join(&quot;&quot;) // 如果当前的逆置之后字符串为val，那么原本的字符串需要再颠倒一次 &#125; &#125;&#125; 侦听属性 侦听属性的作用是侦听某些属性的变化，从而做相应的操作，进行对数据变化的相应， 侦听属性是一个对象（字典），key值是要监听的元素，值是当监听的元素发生改变时要执行的函数； 监听函数有两个参数，一个是当前值，另一个是变化后的值 比如监听一个变量的变化 1234567891011121314151617&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data:&#123; content: &quot;&quot;, // 表单内容 count: 0, // 记录表单内用户敲了多少次 &#125;, watch:&#123; content:function (oldVal,newVal)&#123; // 只要在文本框输入内容影响到了age数据发生改变，就会触发 this.count += 1 &#125;， &#125;， &#125;) &#125;&lt;/script&gt; 1234&lt;div id=&quot;container&quot;&gt; &lt;p&gt;&lt;label&gt;你敲了:&#123;&#123; count &#125;&#125;次&lt;/label&gt;&lt;/p&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入你的年纪&quot; v-model=&quot;content&quot;&gt;&lt;/div&gt; 属性绑定 使用v-bind:class指令来设置元素的class属性； 属性表达式的类型可以是字符串、对象或数组 数组属性 可以通过为元素绑定一个数组，用来为元素设置单个或多个样式，类名在数组中用单引号 12345678&lt;style type=&quot;text/css&quot;&gt; .fontBold &#123; font-weight: bold; &#125; .fontRed &#123; color: red; &#125;&lt;/style&gt; 123&lt;div id=&quot;container&quot;&gt; &lt;p :class=&quot;[&apos;fontBold&apos;,&apos;fontRed&apos;]&quot;&gt;这是一个段落&lt;/p&gt;&lt;/div&gt; 动态属性 可以通过为元素绑定一个对象，对象的key是样式类，对象的value是true或false来动态切换class 1234567891011121314151617181920&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; flag: true, &#125;, methods: &#123; toggle() &#123; if (this.flag)&#123; // 判断当前toggle变量的属性，对称变换 this.flag = false &#125;else&#123; this.flag = true &#125; &#125; &#125; &#125;) &#125;&lt;/script&gt; 12345&lt;div id=&quot;container&quot;&gt; &lt;p :class=&quot;&#123;fontBold: flag&#125;&quot; @click=&quot;toggle&quot;&gt;这是一个段落&lt;/p&gt; &lt;p :class=&quot;&#123;flag? fontBold:&apos;&apos;&#125;&quot; @click=&quot;toggle&quot;&gt;这是一个段落&lt;/p&gt; &lt;!-- 三元表达式 --&gt;&lt;/div&gt; 样式绑定 使用v-bind:style语法，为元素绑定样式 123&lt;p :style=\"&#123;color:'red','font-weight':'bold'&#125;\"&gt; 一段文字&lt;/p&gt; 也可以在vue的data中定义一个对象，用来描述样式，其中带有连字符的样式属性要加引号 123&lt;div id=&quot;container&quot;&gt; &lt;p :style=&quot;styleObj&quot;&gt;一段文字&lt;/p&gt;&lt;/div&gt; 123456data: &#123; styleObj: &#123; color:&apos;red&apos;, &apos;font-weight&apos;:&apos;bold&apos;, &#125;&#125;, data中的对象也可以通过数组类型绑定到元素上 1234&lt;div id=&quot;container&quot;&gt; &lt;p :style=&quot;[styleObj1,styleObj2]&quot;&gt;一段文字&lt;/p&gt; &lt;!-- 对于js的样式绑定不需要加引号，因为就是一个变量 --&gt;&lt;/div&gt; 12345678styleObj1: &#123; border: &apos;1px solid gray&apos;, width: &apos;100px&apos;,&#125;,styleObj2:&#123; background: &apos;black&apos;, color: &apos;blue&apos;,&#125; 条件渲染 通过条件指令可以控制元素的显示及隐藏，或者说叫做创建和销毁 v-if v-if指令用于条件性的渲染一块内容。这块内容只会在指令的表达式返回truthy值的时候渲染 1234567&lt;div v-cloak id=&quot;container&quot;&gt; &lt;h3 v-if=&quot;oh3&quot;&gt;h3标题&lt;/h3&gt; &lt;p v-if=&quot;gender === &apos;girl&apos;&quot;&gt;你是女的&lt;/p&gt; &lt;p v-else-if=&quot;gender === &apos;boy&apos;&quot;&gt;你是男的&lt;/p&gt; &lt;p v-else&gt;不男不女&lt;/p&gt;&lt;/div&gt; 123456789101112&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data:&#123; oh3:&quot;a&quot;, gender: &apos;other&apos; &#125;, &#125;) &#125;&lt;/script&gt; truthy和ture的区别： 隐含有true属性的变量不可以认为它是true，它不是boolean类型 v-show 与v-if不同的是，v-show 的元素始终会被渲染并保留在DOM中 v-show 只是简单地切换元素的CSS属性 display 1234&lt;div v-cloak id=&quot;container&quot;&gt; &lt;h3 v-if=&quot;oh3&quot;&gt;h3标题&lt;/h3&gt; &lt;h4 v-show=&quot;oh4&quot;&gt;h4标题&lt;/h4&gt;&lt;/div&gt; 123456789101112&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data:&#123; oh3:&quot;1&quot;, // v-if 在该变量不为真时直接消失在document中 oh4:&quot;1&quot;, // v-show 处理不为真的变量条件 绑定元素不会消失 &#125;, &#125;) &#125;&lt;/script&gt; 列表渲染v-for 把一个数组对应为一组元素 用 v-for 指令根据一组数组的选项列表进行渲染 v-for 指令需要使用 item in items 形式的特殊语法，items 是源数据数组并且 item 是数组元素迭代的别名 12345&lt;ol id=&quot;container&quot;&gt; &lt;li v-for=&quot;user in users&quot;&gt; &lt;span&gt;&#123;&#123; user.name &#125;&#125;&lt;/span&gt; &lt;/li&gt;&lt;/ol&gt; 123456789101112131415&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data:&#123; users: [ &#123;name:&quot;张三&quot;,age:18&#125;, &#123;name:&quot;李四&quot;,age:20&#125;, &#123;name:&quot;王五&quot;,age:19&#125;, ] &#125;, &#125;) &#125;&lt;/script&gt; v-for还可以支持将当前循环索引作为渲染时的第二个参数，第二个参数为访问索引位置 123&lt;p v-for=&quot;(user,index) in users&quot;&gt; &#123;&#123; index &#125;&#125;:&#123;&#123; user.age &#125;&#125;&lt;/p&gt; 1234567data:&#123; users: [ &#123;name:&quot;张三&quot;,age:18&#125;, &#123;name:&quot;李四&quot;,age:20&#125;, &#123;name:&quot;王五&quot;,age:19&#125;, ]&#125;, 使用v-for迭代访问一个对象 1234&lt;p v-for=&quot;key in myself&quot;&gt; &#123;&#123; key &#125;&#125; &lt;!-- 当v-for渲染时只有一个参数，此时参数为value值 --&gt;&lt;/p&gt; 1234myself : &#123; name:&quot;赵六&quot;, age:&quot;17&quot;,&#125; v-for支持最多三个参数，同时获取遍历对象的key和value值，以及index索引位置 要注意的是，此时的key和value和python中的顺序是颠倒的，key在后，value在前 123&lt;p v-for=&quot;(value,key,index) in myself&quot;&gt; &#123;&#123; index &#125;&#125;: &#123;&#123; key &#125;&#125; - &#123;&#123; value &#125;&#125;&lt;/p&gt; 1234myself : &#123; name:&quot;孙七&quot;, age:&quot;17&quot;,&#125; v-for进行一段取值 123456&lt;div&gt; &lt;p v-for=&quot;n in 8&quot;&gt; &#123;&#123; n &#125;&#125; &lt;/p&gt; &lt;!-- 1 2 3 4 5 6 7 8 --&gt;&lt;/div&gt; 选项卡练习12345678910&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; choicId: null, &#125; &#125;) &#125;&lt;/script&gt; 12345678910111213141516&lt;style&gt; li&#123; list-style-type: none; border: 3px outset lightgreen; width: 100px; background:lightblue; margin:5px; &#125; li:hover&#123; border: 3px inset gray; cursor: pointer; &#125; [v-cloak]&#123; display: none; &#125;&lt;/style&gt; 123456789101112&lt;div v-cloak id=&quot;container&quot;&gt; &lt;ol list&gt; &lt;li @click=&quot;choicId = 1&quot;&gt;A&lt;/li&gt; &lt;li @click=&quot;choicId = 2&quot;&gt;B&lt;/li&gt; &lt;li @click=&quot;choicId = 3&quot;&gt;C&lt;/li&gt; &lt;li @click=&quot;choicId = 4&quot;&gt;D&lt;/li&gt; &lt;/ol&gt; &lt;p v-show=&quot;choicId == 1&quot;&gt;aaaaaaaaaa&lt;/p&gt; &lt;p v-show=&quot;choicId == 2&quot;&gt;bbbbbbbbbb&lt;/p&gt; &lt;p v-show=&quot;choicId == 3&quot;&gt;cccccccccc&lt;/p&gt; &lt;p v-show=&quot;choicId == 4&quot;&gt;dddddddddd&lt;/p&gt;&lt;/div&gt; js中两个等号和三个等号的区别： ==表示： 如果两边值的类型不同的时候，是要先先进行类型转换后，才能做比较；equality等同 ===表示：不需要做类型转换，如果两边值的类型不同，就表示一定是不等的identity恒等 注意 Vue无法检测到对于数组的索引设置及长度修改以及对于对象属性的删除或添加 但是可以通过以下方式进行属性添加触发状态更新 123Vue.set($vm.Object,&quot;key&quot;,&quot;val&quot;) // 对于对象 这样的添加方式可以触发状态更新Vue.set($vm.Array, index, newVal) // 对于数组 添加元素 触发状态更新// vm.items.splice(newLength) // 设置数组长度 javascript.splice(where, num, [additem1,additem2...] )：删除或添加元素 此外，当v-for与v-if同时使用时，v-for有更高的优先级，这会造成重复遍历得到的元素都要在做一次v-if的判断，如果我们是为了有目的判断当前是否需要渲染这个元素，或是跳过这个循环，可以将v-if放在外层元素，比如template标签中，(template标签无实际意义，默认不展示，但是可以起到包裹作用) 过滤器 Vue.js允许你自定义过滤器，可被用于一些常见的文本，对它们进行格式化 过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持) 过滤器应该被添加在JavaScript表达式的尾部，由管道符号指示 语法 12345&lt;p&gt; &#123;&#123; message | filter &#125;&#125;&lt;/p&gt;&lt;p v-bind:type=&quot;message | filter&quot;&gt; &lt;/p&gt; 过滤器本质上是一个函数，比如我们定义一个将表单输入的内容中所有的字母变大写的过滤器 123456&lt;body&gt; &lt;div v-cloak id=&quot;container&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &lt;p&gt;展示: &#123;&#123; message | toUpper &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 1234567891011121314151617&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; message: &quot;&quot;, &#125;, filters: &#123; toUpper: function (value) &#123; if (!value) return &apos;&apos; // 字符串内容为空 直接返回 console.log(&quot;正在变大小&quot;) return String(value).toUpperCase() &#125; &#125; &#125;) &#125;&lt;/script&gt; 过滤器函数也可以有多个参数 1234&#123;&#123; message | filter(arg1, arg2) &#125;&#125;// message 第一个参数// arg1 第二个参数// arg2 第三个参数 1234&lt;div v-cloak id=&quot;container&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &lt;p&gt;展示: &#123;&#123; message | toLong(&quot;| &quot;,&quot; |&quot;) &#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456filters: &#123; toLong(value,arg1,arg2)&#123; if (!value) return &apos;&apos; return arg1 + value + arg2 &#125;&#125; Vue实例生命周期 每个Vue实例在被创建时都要经过一系列的初始化过程 例如：需要设置数据监听、编译模板、将实例挂载到DOM并在数据变化时更新DOM等 同时在这个过程中会自动运行一些叫做生命周期钩子的函数，我们可以使用这些函数，在实例的不同阶段加上我们需要的代码，实现特定的功能 beforeCreate：数据还没有监听，没有绑定到vue对象实例，同时也没有挂载对象 created：数据已经绑定到了对象实例，但是还没有挂载对象 beforeMount：模板已经编译好了，根据数据和模板已经生成了对应的元素对象，将数据对象关联到了对象的$el属性 $el属性是一个HTMLElement对象，也就是这个阶段，vue实例通过原生的createElement等方法来创建这个html片段，准备注入到我们vue实例指明的el属性所对应的挂载点 mounted： 将$el的内容挂载到了el，相当于我们在jQuery执行了$(el).html($el)，生成页面上真正的dom 上面我们就会发现页面的元素和我们$el的元素是一致的；在此之后，我们能够用方法来获取到el元素下的dom对象，并进行各种操作 beforeUpdate：数据发生变化时调用 updated：由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子 beforeDestroy：Vue实例销毁前 destroyed：Vue实例销毁后 window.$vm.$destroy() 一大段代码进行钩子函数的调用过程监控 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; function showData(process, vm) &#123; console.log(process) console.log(&quot;vue数据:&quot;, vm.message) // 当前Vue中的数据 console.log(&quot;Vue挂载el:&quot;) // Vue接管的元素 console.log(vm.$el) console.log(&quot;真实Dom:&quot;) console.log(document.getElementById(&quot;container&quot;).innerHTML) console.log(&apos;-----------------&apos;) &#125; // 这个函数用来输出相关信息的 new Vue(&#123; el: &quot;#container&quot;, data: &#123; message: &quot;aaaaa&quot;, &#125;, beforeCreate: function () &#123; showData(&quot;创建Vue实例前&quot;, this) &#125;, created: function () &#123; showData(&quot;创建Vue实例后&quot;, this) &#125;, beforeMount: function () &#123; showData(&quot;挂载到Dom前&quot;, this) &#125;, mounted: function () &#123; showData(&quot;挂载到Dom后&quot;, this) &#125;, beforeUpdate: function () &#123; showData(&quot;数据发生变化时&quot;, this) &#125;, updated: function () &#123; showData(&quot;数据发生变化后&quot;, this) &#125;, beforeDestroy: function () &#123; showData(&quot;Vue实例销毁前&quot;, this) &#125;, destroyed: function () &#123; showData(&quot;Vue实例销毁后&quot;, this) &#125; &#125;)&#125;&lt;/script&gt; 123&lt;div id=&quot;container&quot;&gt; &lt;p v-html=&quot;message&quot;&gt;&lt;/p&gt;&lt;/div&gt; 组件ES6语法 ES6是JavaScript语言的新版本，它也可以叫做ES2015，之前学习的JavaScript属于ES5，ES6在它的基础上增加了一些语法 ES6是未来JavaScript的趋势，而且vue组件开发中会使用很多的ES6的语法，所以掌握这些常用的ES6语法是必须的 变量声明 let：定义封闭作用域的变量，并且变量只能声明一次 const：定义封闭作用域的常量，并且变量只能声明一次 let和const是新增的声明变量的开头的关键字，在这之前，变量声明是用var关键字 这两个关键字和var的区别是，它们声明的变量没有预解析，无法脱离定义空间使用 let和const的区别是，let声明的是一般变量，const申明的常量，不可修改 12345678910console.log(a) // undefinedconsole.log(b) // b is not definedconsole.log(c) // c is not definedvar a = 1var a = 2let b = 2// let b = 3 // Identifier &apos;b&apos; has already been declaredconst c = 3// const c = 4 // Identifier &apos;c&apos; has already been declaredc = 4 // Assignment to constant variable 箭头函数 可以把箭头函数理解成匿名函数的第二种写法，箭头函数的作用是可以在对象中绑定this 解决了JavaScript中this指定混乱的问题 定义函数的一般方式 123function func()&#123; ...&#125; 匿名赋值创建函数 123var func = function()&#123; ...&#125; 箭头函数的写法 123456var func = (a, b) =&gt; &#123; // 这样的函数在嵌套时，会自动绑定外部作用域下的this&#125;var func = a =&gt; &#123; // 一个参数时，可以省略参数&#125; 123456789101112131415window.onload = function () &#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; message: &quot;abcdef&quot;, &#125;, methods: &#123; show() &#123; console.log(&quot;这是show函数:&quot;, this.message), func = () =&gt; &#123; console.log(&quot;我是内部函数:&quot;, this.message) &#125;, func(), // 调用一下这个内部函数 &#125; &#125; &#125;)&#125; 123&lt;div id=&quot;container&quot;&gt; &lt;button @click=&quot;show&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt; Vue组件 组件Component是Vue.js最强大的功能之一 组件可以扩展HTML元素，封装可重用的代码 所有的Vue组件同时也都是Vue的实例，所以可接受相同的选项对象（除了一些根级特有的选项）并提供相同的生命周期钩子 注册全局组件 注册一个全局组件语法格式如下 123Vue.component(tagName, options)// tagName：组件名// options：配置选项 比如这样一个全局组件 123456789Vue.component(&apos;button_show&apos;, &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;, // 当前组件会需要的数据，定义为函数的返回值 template: &apos;&lt;button @click=&quot;count++&quot;&gt;按钮:&#123;&#123; count &#125;&#125;&lt;/button&gt;&apos; // 组件的标签模板&#125;) 接下来可以在任何Vue接管的元素中使用该组件， 123&lt;div id=&quot;container&quot;&gt; &lt;button_show&gt;&lt;/button_show&gt;&lt;/div&gt; 12345window.onload = function () &#123; var vm = new Vue(&#123; el: &quot;#container&quot;, &#125;)&#125; data必须是函数 组件就是vue的实例，所有vue实例中属性和方法，组件中也可以用 其中data属性必须是一个函数，因为组件会重复使用在多个地方，为了使用在多个地方的组件数据相对独立，data属性需要用一个函数的返回值来将数据处理为不同的每个个体 Prop传递数据 Prop是你可以在组件上注册的一些自定义特性 当一个值传递给一个prop特性的时候，它就变成了那个组件实例的一个属性 为了给组件传递数据，我们可以用一个 props 选项将一些特性值列举在其中 12345678910111213141516171819202122232425&lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&quot;myp&quot;,&#123; props: [&quot;content&quot;,&quot;like&quot;], // 需要两个外界传入的值 template: &quot;&lt;p :class=&apos;like&apos;&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt;&quot; // 组件绑定未来要接受的变量，要用到v:bind &#125;) window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; content: &apos;这是p段落的文本&apos;, like: &apos;beauty&apos;, // 要传递的变量 &#125; &#125;) &#125;&lt;/script&gt;.beauty&#123; width: 100px; color: red; background: green;&#125;&lt;div id=&quot;container&quot;&gt; &lt;myp :like=&quot;like&quot; :content=&quot;content&quot;&gt;&lt;/myp&gt; &lt;!-- 传递到组件中 --&gt;&lt;/div&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://cy-blogs.cn/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://cy-blogs.cn/tags/Vue/"}]},{"title":"Vue-路由组件","slug":"Vue-路由组件","date":"2019-12-09T11:52:36.344Z","updated":"2019-12-09T11:54:44.642Z","comments":true,"path":"Vue-路由组件/","link":"","permalink":"https://cy-blogs.cn/Vue-路由组件/","excerpt":"Vue-Router Vue-router做路径匹配时支持动态片段、全匹配片段以及查询参数（片段指的是URL中的一部分） 对于解析过的路由，这些信息都可以通过路由上下文对象（从现在起，我们会称其为路由对象）访问。 在使用了vue-router的应用中，路由对象会被注入每个组件中，赋值为this.$route，并且当路由切换时，路由对象会被更新","text":"Vue-Router Vue-router做路径匹配时支持动态片段、全匹配片段以及查询参数（片段指的是URL中的一部分） 对于解析过的路由，这些信息都可以通过路由上下文对象（从现在起，我们会称其为路由对象）访问。 在使用了vue-router的应用中，路由对象会被注入每个组件中，赋值为this.$route，并且当路由切换时，路由对象会被更新 Vue的两种模式 一般单页面应用是(SPA)不会请求页面而是只更新视图 vue-router提供了两种方式来实现前端路由：Hash模式和History模式,可以用mode参数来决定使用哪一种方式 1234export default new Router(&#123; mode: &apos;history&apos;, ...&#125;) hash模式：vue-router默认使用Hash模式，使用 url的hash来模拟一个完整的url；此时url变化时，浏览器是不会重新加载的；Hash(即#)是url的锚点，代表的是网页中的一个位置，仅仅改变#后面部分，浏览器只会滚动对应的位置，而不会重新加载页面。#仅仅只是对浏览器进行指导，而对服务端是完全没有作用的！它不会被包括在http请求中，故也不会重新加载页面。同时hash发生变化时，url都会被浏览器记录下来，这样你就可以使用浏览器的后退了 History模式：如果你不喜欢hash这种#样式，可以使用history模式。这种模式利用了HTML5 History新增的pushState()和replaceState()方法。除了之前的back，forward，go方法；这两个新方法可以应用在浏览器历史记录的增加替换功能上。使用History模式，通过历史记录修改url。但它不会立即向后端发送请求。 注意：虽然History模式可以丢掉不美观的#，也可以正常的前进后退，但是刷新f5后，此时浏览器就会访问服务器，在没有后台支持的情况下，此时就会得到一个404！ 官方文档给出的描述是：不过这种模式要玩好；还需要后台配置支持 因为我们的应用是单个客户端应用，如果后台没有正确的配置，当用户直接访问时,就会返回404，所以，要在服务端增加一个覆盖所有情况的的候选资源。如果url匹配不到任何静态资源；则应该返回同一个index.html页面 路由属性 路由对象this.$route支持属性 $route.path：字符串，等于当前路由对象的路径，会被解析为绝对路径 1/aaa/bbb $route.params：包含路由中的动态片段和全匹配片段的键值对 $route.query：获取连接中查询参数的键值对 123/foo?user=1// 可以获取到$route.query.user == 1 $route.router：路由规则所属的路由器以及其所属的组件 $route.matched：数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象 $route.name：当前路径的名字 路由中设置自定义参数 123456router.map(&#123; &apos;/a&apos;: &#123; component: &#123; ... &#125;, auth: true // 这里 auth 是一个自定义字段 &#125;&#125;) 当 /a 被匹配时，$route.auth 的值将会是 true。我们可以利用这个特性在全局的钩子函数中进行身份验证 12345router.beforeEach(function (transition) &#123; if (transition.to.auth) &#123; // 对用户身份进行验证... &#125;&#125;) 动态路由（:号通配符） 路由中的动态片段使用以冒号开头的路径片段定义 类比django中的路由传参 1path(&apos;&lt;int:name&gt;/&apos;,views.xx), 1234path: &apos;/user/:username&apos;,component: &#123; template: &apos;&lt;p&gt;用户名是&#123;&#123;$route.params.username&#125;&#125;&lt;/p&gt;&apos;&#125; 一条路径中可以包含多个动态片段，每个片段都会被解析成 $route.params 的一个键值对 解析模式 模式 匹配的路径 $route.params /user/:username /user/evan { username: &#39;evan&#39; } /user/:username/post/:post_id /user/evan/post/123 { username: &#39;evan&#39;, post_id: 123 } 全匹配路由（*号通配符） 动态片段只能匹配路径中的一个部分，而全匹配片段则基本类似于它的贪心版 例如 /foo/*bar 会匹配任何以 /foo/ 开头的路径 当使用一个通配符时，$route.params内会自动添加一个名为pathMatch的参数，其中包含了在连接中通过通配符所匹配到的部分 12345&#123; path: &apos;/user/*/cc&apos;, name: &apos;User&apos;, component: User,&#125;, 访问的URL如下 1http://127.0.0.1:8080/user/1231/aaa/cc 那么此时*通配符拿到的部分为 1&#123; \"pathMatch\": \"1231/aaa\" &#125; 具名路径（命名路由） 类似django的路由命名，vue路由映射中也可以为某一个路由通过name属性设置命名 12345&#123; path: &apos;/user/:userid&apos;, name: &apos;User&apos;, component: User,&#125;, 在使用v-link标签进行路由跳转时，就可以更加方便啦 1&lt;router-link :to=&quot;&#123;name: &apos;User&apos;, params: &#123;userid: &apos;zhangsan&apos; &#125;&#125;&quot;&gt;user&lt;/router-link&gt; 也可以在js代码中使用router.go切换到该路径下 1router.go(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;) V-link v-link 是一个用来让用户在vue-router应用的不同路径间跳转的指令。该指令接受一个JavaScript表达式，并会在用户点击元素时用该表达式的值去调用 router.go 12345678&lt;!-- 字面量路径 --&gt;&lt;a v-link=&quot;&apos;home&apos;&quot;&gt;Home&lt;/a&gt;&lt;!-- 效果同上 --&gt;&lt;a v-link=&quot;&#123; path: &apos;home&apos; &#125;&quot;&gt;Home&lt;/a&gt;&lt;!-- 具名路径 --&gt;&lt;a v-link=&quot;&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/a&gt; 应该使用 v-link 而不是 href 来处理浏览时的跳转。原因如下 它在HTML5 history模式和hash模式下的工作方式相同，所以如果你决定改变模式，或者IE9浏览器退化为hash模式时，都不需要做任何改变 在HTML5 history模式下，v-link 会监听点击事件，防止浏览器尝试重新加载页面 在HTML5 history模式下使用 root 选项时，不需要在 v-link 的URL中包含root路径 V-Link其他选项 replace 一个带有 replace: true 的链接被点击时将会触发 router.replace() 而不是 router.go()。由此产生的跳转不会留下历史记录 1&lt;router-link :to=&quot;&#123;name: &apos;User&apos;, params: &#123;userid: &apos;zhangsan&apos; &#125;, replace: true &#125;&quot;&gt;replace&lt;/router-link&gt; append 带有 append: true 选项的相对路径链接会确保该相对路径始终添加到当前路径之后。举例来说，从 /a 跳转到相对路径 b 时，如果没有 append: true 我们会跳转到 /b，但有 append: true 则会跳转到 /a/b 1&lt;router-link :to=&quot;&#123;name: &apos;User&apos;, append: true &#125;&quot;&gt;append&lt;/router-link&gt; 路由钩子 全局的钩子 beforeEach(to, from, next) 添加一个全局的前置钩子函数，这个函数会在路由切换开始时调用。调用发生在整个切换流水线之前。如果此钩子函数拒绝了切换，整个切换流水线根本就不会启动 123const router = new Router(&#123; ...export default router 123456789router.beforeEach((to, from, next) =&gt; &#123; // to and from are both route objects. must call `next`. console.log(to) // to: Route: 即将要进入的目标 路由对象 console.log(&apos;-------------&apos;) console.log(from) // from: Route: 当前导航正要离开的路由 console.log(&apos;-------------&apos;) console.log(next) // 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 &#125;) 路由解析流程 1234567891011121.导航被触发。2.在失活的组件里调用离开守卫。3.调用全局的 beforeEach 守卫。4.在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。5.在路由配置里调用 beforeEnter。6.解析异步路由组件。7.在被激活的组件里调用 beforeRouteEnter。8.调用全局的 beforeResolve 守卫 (2.5+)。9.导航被确认。10.调用全局的 afterEach 钩子。11.触发 DOM 更新。12.用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 使用beforeEach控制路由跳转，拦截路由 1234567891011121314151617router.beforeEach((to, from, next) =&gt; &#123; // to and from are both route objects. must call `next`. let toQuery = JSON.parse(JSON.stringify(to.query)); console.log(toQuery) // 获取连接参数 if(to.meta.requiredAuth == true)&#123; // 如果要进入的路由需要用户登陆 if(window.localStorage.getItem(&apos;username&apos;))&#123; // 获取存储的用户名 next() &#125; else&#123; // 没有获取到，则跳转到登陆页面 next(&#123; path: &apos;/&apos;, query: toQuery, &#125;) &#125; &#125;else&#123; next() &#125;&#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://cy-blogs.cn/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://cy-blogs.cn/tags/Vue/"}]},{"title":"Django-DBrouter","slug":"Django数据库路由器","date":"2019-12-09T11:29:54.640Z","updated":"2019-12-09T11:29:55.065Z","comments":true,"path":"Django数据库路由器/","link":"","permalink":"https://cy-blogs.cn/Django数据库路由器/","excerpt":"DB-router 通过编写db-router可以灵性连接mysql主从复制等情况下的多数据库 假设你已经配置好了类似MYSQL主从复制的服务，如果没有可以参照这里 配置Django数据库连接 settings.py 123456789101112131415161718DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'HOST': '192.168.1.101', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123456', 'NAME': 'test1' &#125;, 'slave': &#123; 'ENGINE': 'django.db.backends.mysql', 'HOST': '192.168.1.102', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123456', 'NAME': 'test1' &#125;&#125;DATABASE_ROUTERS = ['pro.utils.MasterSlaveDBRouter']","text":"DB-router 通过编写db-router可以灵性连接mysql主从复制等情况下的多数据库 假设你已经配置好了类似MYSQL主从复制的服务，如果没有可以参照这里 配置Django数据库连接 settings.py 123456789101112131415161718DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'HOST': '192.168.1.101', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123456', 'NAME': 'test1' &#125;, 'slave': &#123; 'ENGINE': 'django.db.backends.mysql', 'HOST': '192.168.1.102', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123456', 'NAME': 'test1' &#125;&#125;DATABASE_ROUTERS = ['pro.utils.MasterSlaveDBRouter'] 编写db-router 1234567891011121314class MasterSlaveDBRouter: \"\"\"数据库主从读写分离路由\"\"\" def db_for_read(self, model, **hints): \"\"\"读数据库\"\"\" return \"slave\" def db_for_write(self, model, **hints): \"\"\"写数据库\"\"\" return \"default\" def allow_relation(self, obj1, obj2, **hints): \"\"\"是否运行关联操作\"\"\" return True 如出现以下错误，修改主库binlog日志格式 1django.db.utils.InternalError: (1665, 'Cannot execute statement: impossible to write to binary log since BINLOG_FORMAT = STATEMENT and at least one table uses a storage engine limited to row-based logging. InnoDB is limited to row-logging when transaction isolation level is READ COMMITTED or READ UNCOMMITTED.') 1binlog_format=mixed 打开日志用以分析 可以通过配置mysql日志记录，用以查看主从在读写情况下的效果 12general_log=1general_log_file=/var/lib/mysql/general.log","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[]},{"title":"Django-DBrouter","slug":"Django-DBrouter","date":"2019-12-09T09:11:32.684Z","updated":"2019-12-09T11:26:02.817Z","comments":true,"path":"Django-DBrouter/","link":"","permalink":"https://cy-blogs.cn/Django-DBrouter/","excerpt":"DB-router 通过编写db-router可以灵性连接mysql主从复制等情况下的多数据库 假设你已经配置好了类似MYSQL主从复制的服务，如果没有可以参照这里 配置Django数据库连接 settings.py 123456789101112131415161718DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'HOST': '192.168.1.101', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123456', 'NAME': 'test1' &#125;, 'slave': &#123; 'ENGINE': 'django.db.backends.mysql', 'HOST': '192.168.1.102', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123456', 'NAME': 'test1' &#125;&#125;DATABASE_ROUTERS = ['pro.utils.MasterSlaveDBRouter']","text":"DB-router 通过编写db-router可以灵性连接mysql主从复制等情况下的多数据库 假设你已经配置好了类似MYSQL主从复制的服务，如果没有可以参照这里 配置Django数据库连接 settings.py 123456789101112131415161718DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'HOST': '192.168.1.101', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123456', 'NAME': 'test1' &#125;, 'slave': &#123; 'ENGINE': 'django.db.backends.mysql', 'HOST': '192.168.1.102', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123456', 'NAME': 'test1' &#125;&#125;DATABASE_ROUTERS = ['pro.utils.MasterSlaveDBRouter'] 编写db-router 1234567891011121314class MasterSlaveDBRouter: \"\"\"数据库主从读写分离路由\"\"\" def db_for_read(self, model, **hints): \"\"\"读数据库\"\"\" return \"slave\" def db_for_write(self, model, **hints): \"\"\"写数据库\"\"\" return \"default\" def allow_relation(self, obj1, obj2, **hints): \"\"\"是否运行关联操作\"\"\" return True 如出现以下错误，修改主库binlog日志格式 1django.db.utils.InternalError: (1665, 'Cannot execute statement: impossible to write to binary log since BINLOG_FORMAT = STATEMENT and at least one table uses a storage engine limited to row-based logging. InnoDB is limited to row-logging when transaction isolation level is READ COMMITTED or READ UNCOMMITTED.') 1binlog_format=mixed 打开日志用以分析 可以通过配置mysql日志记录，用以查看主从在读写情况下的效果 12general_log=1general_log_file=/var/lib/mysql/general.log","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"WebSSH","slug":"WebSSH","date":"2019-12-09T09:03:24.475Z","updated":"2019-12-09T11:26:56.071Z","comments":true,"path":"WebSSH/","link":"","permalink":"https://cy-blogs.cn/WebSSH/","excerpt":"WebSSH webssh从而SSH无需Xshell之类的模拟终端工具进行SSH连接，将SSH这一比较低层的操作也从C/S架构扭转成为B/S架构 这样的架构常用在运维制作开发一些堡垒机等系统，或者目前比较新型的在线教育方式，通过WebSSH向学生提供一个可以直接使用浏览器进行相关Linux操作或代码编写的学习方式 WebSSh主要是建立客户端与服务端的即时通信","text":"WebSSH webssh从而SSH无需Xshell之类的模拟终端工具进行SSH连接，将SSH这一比较低层的操作也从C/S架构扭转成为B/S架构 这样的架构常用在运维制作开发一些堡垒机等系统，或者目前比较新型的在线教育方式，通过WebSSH向学生提供一个可以直接使用浏览器进行相关Linux操作或代码编写的学习方式 WebSSh主要是建立客户端与服务端的即时通信 实现方案 此种WebSSH实现方式，将通过结合WebSocket以及逐步的Paramiko来进行实现，所需要的技术栈如下 1234＃前端vue websocket xterm.js 12345# 后端djangodwebsocketparamikothreading 技术介绍 xterm 前端通过xterm插件进行shell黑窗口环境的构建，这个插件会自动解析由后台paramiko返回的带有标记样式的命令结果，并渲染到浏览器中，非常酷炫 websocket 这里通过websocket进行浏览器与django的数据交通同轴，Websocket是什么 paramiko paramiko此时的角色采取承担django与Linux环境的互动，将前端发来的命令发送给后台，将后端发来的命令结果返回到前端的xterm组件中 前端实现 前端xterm组件使用：简单 安装xterm 1cnpm安装xterm --save vue框架中约会xterm的样式文件 1234567891011121314151617// main.js// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from &apos;vue&apos;import App from &apos;./App&apos;import router from &apos;./router&apos;import &apos;xterm/dist/xterm.css&apos; // 看这里，添加xterm css文件样式Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: &apos;#app&apos;, router, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;) 初始化xterm组件并添加两个插件：attach可以将终端附加到websocket流中，fit可以调整终端的大小以及行和列适应父级元素 12345678// index.vueimport &#123; Terminal &#125; from &apos;xterm&apos;import * as attach from &apos;xterm/lib/addons/attach/attach&apos;import * as fit from &apos;xterm/lib/addons/fit/fit&apos;Terminal.applyAddon(attach)Terminal.applyAddon(fit) 构建websocket并绑定到终端，websocket地址为ws协议链接，此时使用的是即将在django中配置Websocket后台视图的路由，这一系列行为将挂载到钩子函数下进行 12345678910111213141516171819mounted () &#123; let terminalContainer = document.getElementById('terminal') this.term = new Terminal(this.terminal) this.term.open(terminalContainer) // open websocket this.terminalSocket = new WebSocket('ws://127.0.0.1:8000/webssh/') this.terminalSocket.onopen = function()&#123; console.log('websocket is Connected...') &#125; this.terminalSocket.onclose = function()&#123; console.log('websocket is Closed...') &#125; this.terminalSocket.onerror = function()&#123; console.log('damn Websocket is broken!') &#125; this.term.attach(this.terminalSocket) // 绑定xterm到ws流中 &#125;, 当浏览器关闭时，也代表着客户端关闭，此时主动插入连接，交给vue的钩子函数来处理这个问题 1234beforeDestroy () &#123; this.terminalSocket.close() this.term.destroy()&#125; 后端实现 django这里使用dwebsocket模块进行ws的服务端编写与通信 首先确定路由，也是前端的ws连接地址 123＃urls.py ... path（'webssh /'，webssh） 定义函数，初始化SSH连接对象 1234567#views.py def _ssh(host,username,password,port=22): sh = paramiko.SSHClient() sh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) sh.connect(host, username=username, password=password) channle = sh.invoke_shell(term='xterm') return channle 由于在SSH通道中，服务端可能返回结果的方式并不与客户端发起的命令一唱一和，可能是一唱多和，类似类似top的命令，一次命令输入之后，服务端会返回N次结果，此时在django首先中采用多线程，专门处理命令结果的返回；以下是这个任务线程函数的定义 123456789101112def recv_ssh_msg(channle,ws): ''' channle: 建立好的SSH连接通道 这个函数会不停的接收ssh通道返回的命令 返回到前端的ws套接字里 ''' while not channle.exit_status_ready(): try: buf = channle.recv(1024) # 接收命令的执行结果 ws.send(buf) # 向Websocket通道返回 except: break 剩余的就是视图函数的调用和线程开启部分了！ 1234567891011121314151617181920@accept_websocketdef webssh(request): ''' 1: 接收前端(ws)的命令，发给后台(ssh) 2: 接收后台的返回结果，给到前端 ''' if request.is_websocket: channle = _ssh(host, username=username, password=password) ws = request.websocket t = threading.Thread(target=recv_ssh_msg,args=(channle,ws)) t.setDaemon(True) t.start() # 线程开启 while 1: cmd = ws.wait() # 阻塞接收前端发来的命令 if cmd: channle.send(cmd) # 由SSH通道转交给Linux环境 else: # 连接断开 跳出循环 break ws.close() # 释放对应套接字资源 channle.close() 效果展示 如下","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Websocket","slug":"Websocket","date":"2019-12-09T09:00:08.693Z","updated":"2019-12-09T11:26:53.607Z","comments":true,"path":"Websocket/","link":"","permalink":"https://cy-blogs.cn/Websocket/","excerpt":"Websocket WebSocket实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端可以主动向客户端发送数据。 传统的HTTP协议是无状态的，种客户端是主动方，服务端是被动方的；对于涉及实时信息的Web应用带来了很大的不便，如带有即时通信、实时数据、订阅推送等功能的应用。在之前有两种办法解决这个问题","text":"Websocket WebSocket实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端可以主动向客户端发送数据。 传统的HTTP协议是无状态的，种客户端是主动方，服务端是被动方的；对于涉及实时信息的Web应用带来了很大的不便，如带有即时通信、实时数据、订阅推送等功能的应用。在之前有两种办法解决这个问题 轮询是最原始的实现实时Web应用的解决方案。轮询技术要求客户端以设定的时间间隔周期性地向服务端发送请求，频繁地查询是否有新的数据改动。这种方法会导致过多不必要的请求，浪费流量和服务器资源。 Comet技术又可以分为长轮询和流技术；长轮询改进了上述的轮询技术，减小了无用的请求。它会为某些数据设定过期时间，当数据过期后才会向服务端发送请求；这种机制适合数据的改动不是特别频繁的情况。流技术通常是指客户端使用一个隐藏的窗口与服务端建立一个HTTP长连接，服务端会不断更新连接状态以保持HTTP长连接存活；这样的话，服务端就可以通过这条长连接主动将数据发送给客户端；流技术在大并发环境下，可能会考验到服务端的性能。 WebSocket真正实现了Web的实时通信，使B/S模式具备了C/S模式的实时通信能力 WebSocket的工作流程是这样的：浏览器通过JavaScript向服务端发出建立WebSocket连接的请求，在WebSocket连接建立成功后，客户端和服务端就可以通过 TCP连接传输数据。因为WebSocket连接本质上是TCP连接，不需要每次传输都带上重复的头部数据，所以它的数据传输量比轮询和Comet技术小了很多 Websocket在建立连接之前有一个Handshake（Opening Handshake）过程，在关闭连接前也有一个Handshake（Closing Handshake）过程，建立连接之后，双方即可双向通信 HTML的Websocket 初始化websocket 1var ws = new WebSocket(url, [protocol] ); url：指定连接的websocket protocol：可接受的子协议 响应事件 当ws套接字初始化成功之后，我们可以通过定义回调函数在某些事件触发时执行，以下是常见响应事件 当ws连接建立时触发 123ws.onopen = function()&#123; // 连接开启&#125; 当ws连接接收到数据时触发 123ws.onmessage = function(evt)&#123; // evt.data即是接收到的数据对象&#125; 当ws连接发生通信错误时触发 123ws.onerror = function()&#123; // 连接出错&#125; 当连接关闭时触发 123ws.onclose = function()&#123; // 连接关闭&#125; 初次之外，还可以通过一些方法函数进行数据的传输或连接的关闭 方法 通过ws连接发送数据 1ws.send(str) 关闭连接 1ws.close() 简单的示例12345678910111213141516171819var ws = new WebSocket('ws://127.0.0.1:3000')ws.onopen = function()&#123; console.log('连接建立')&#125;ws.onmessage = function(ev)&#123; console.log('server:',ev.data)&#125;ws.onerror = function()&#123; console.log('连接建立') ws.close()&#125;ws.onclose = function()&#123; console.log('连接关闭') ws.close()&#125; Django的Websocket dwebsocket是一个在django用来实现websocket服务端的三方模块，使用上手非常简单，安装方式如下 1pip install dwebsocket git地址 https://github.com/duanhongyi/dwebsocket 方法 在后台中，通过该三方模块可以让我们在django的视图中实现对于websocket的操作 首先是两个基本的装饰器，用来限定过滤websocket的连接 dwebsocket.accept_websocket 允许http与websocket连接 dwebsocket.require_websocke 只允许websocket连接 除去两种装饰器方法进行过滤判断，还可以通过在视图函数中的request进行websocket的判断 request.is_websocket 如果是个websocket请求返回True，如果是个普通的http请求返回False 可以用这个方法区分普通连接与websocket request.websocket 在一个websocket请求建立之后，这个请求将会有一个websocket属性，用来给客户端提供一个简单的api通讯，如果request.is_websocket()是False，这个属性将是None request.websocket.wait 接收客户端发来的一条消息；如果在收到消息或客户端关闭连接之前，它不会有任何返回，只会返回None request.websocket.read 如果从客户端接收到新消息，read函数返回这条消息；如果没有新消息，则返回None 这是一个替代wait的非阻塞读取数据的方法 request.websocket.count_messages() 返回消息队列数量 request.websocket.has_messages() 如果有新消息返回True，否则返回False request.websocket.send(message) 向客户端发送消息 requqest.websocket.__iter__ websocket迭代器 关于Django的Demo将会在下一章节结合paramiko以及xterm.js来进行一个webssh的实现","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Tinymce富文本编辑器","slug":"Tinymce富文本编辑器","date":"2019-12-09T08:53:20.976Z","updated":"2019-12-09T11:28:03.240Z","comments":true,"path":"Tinymce富文本编辑器/","link":"","permalink":"https://cy-blogs.cn/Tinymce富文本编辑器/","excerpt":"图文混排 在某些富文本编辑器中，我们可以支持文件与图片的同时编写，将文字与图片混合排列 在django中可以使用TimyMce富文本编辑器进行图文混排功能的实现 TinyMce TinyMCE：是一个轻量级的基于浏览器的所见即所得编辑器，支持目前流行的各种浏览器，由JavaScript写成 功能配置灵活简单，两行代码就可以将编辑器嵌入网页中，并且支持AJAX，加载速度非常快 最重要的是，TinyMCE是一个根据LGPL license发布的自由软件，你可以把它用于商业应用。下图是此编辑器的界面","text":"图文混排 在某些富文本编辑器中，我们可以支持文件与图片的同时编写，将文字与图片混合排列 在django中可以使用TimyMce富文本编辑器进行图文混排功能的实现 TinyMce TinyMCE：是一个轻量级的基于浏览器的所见即所得编辑器，支持目前流行的各种浏览器，由JavaScript写成 功能配置灵活简单，两行代码就可以将编辑器嵌入网页中，并且支持AJAX，加载速度非常快 最重要的是，TinyMCE是一个根据LGPL license发布的自由软件，你可以把它用于商业应用。下图是此编辑器的界面 配置上传路径 首先配置整个项目的上传文件路径，为了区别与自身的static静态目录 这里的上传文件我们将另外保存至upload文件夹 12#settings.pyUPLOAD_ROOT = os.path.join(BASE_DIR,'upload') 配置模板页面 首先需要在使用到tinymce富文本编辑器的html页面下导入必备js文件 1234&lt;script src=\"&#123;% static 'js/jquery-1.10.2.min.js' %&#125;\" &gt;&lt;/script&gt;&lt;script src=\"&#123;% static 'js/tinymce_setup.js' %&#125;\"&gt;&lt;/script&gt;&lt;script src=\"&#123;% static 'tinymce/js/tinymce/tinymce.min.js' %&#125;\"&gt;&lt;/script&gt; 接下来，在模板页面中加入一个id为content的输入表单，这里我们以一个文章数据为例 首先是模型层文件定义 12345#models.py class Article(models.Model): title = models.CharField(max_length=100,verbose_name='标题') author = models.CharField(max_length=100,verbose_name='作者') content = models.TextField(verbose_name='内容') 这里的content内容要用到富文本编辑器 接着是模板页面的主要部分 12345678910&lt;form method=\"POST\" action='/' enctype=\"multipart/form-data\"&gt; &#123;% csrf_token %&#125; &lt;input type=\"text\" placeholder=\"文章标题\"&gt; &lt;br&gt; &lt;input type=\"text\" placeholder=\"文章作者\"&gt; &lt;br&gt; &lt;input id=\"rich_content\" name=\"content\" value=\" \"&gt; &lt;br&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt;&lt;/form&gt; 修改插件配置 这里搭配了一个tinymce_setup.js文件，用来控制富文本编辑器所使用的插件等 全文配置如下 123456789101112131415161718192021222324252627282930313233343536tinymce.init(&#123; // 选择id为content的标签作为编辑器 selector: '#rich_content', // 方向从左到右 directionality:'ltr', // 语言选择中文 language:'zh_CN', // 高度为400 宽度为一半 height:300, width: '50%', // 工具栏上面的补丁按钮 plugins: [ 'advlist autolink link image lists charmap print preview hr anchor pagebreak spellchecker', 'searchreplace wordcount visualblocks visualchars code fullscreen insertdatetime media nonbreaking', 'save table contextmenu directionality template paste textcolor', 'codesample imageupload', ], // 工具栏的补丁按钮 toolbar: 'insertfile undo redo | \\ styleselect | \\ bold italic | \\ alignleft aligncenter alignright alignjustify | \\ bullist numlist outdent indent | \\ link image | \\ print preview media fullpage | \\ forecolor backcolor emoticons |\\ codesample fontsizeselect fullscreen |\\ imageupload', // 字体大小 fontsize_formats: '10pt 12pt 14pt 18pt 24pt 36pt', // 按tab不换行 nonbreaking_force_tab: true, imageupload_url: \"/upload_img/\", // 上传后图片保存为绝对路径 relative_urls : false,&#125;); 注释已经很清晰 要注意的是imageupload_url配置用来确定当前图片上传所对应的视图路由 上传视图配置 接下来编写富文本编辑器的上传图片路由函数及对应的路由配置 路由映射tinymce_setup.js与中的imageupload_url配置路由相同 这里还要注意，由于此时tinymce的上传图片表单并不是和本身所容纳的form表单一起上传，所以并不会具备csrf_token值，需要我们将上传图片的函数额外进行装饰器装饰，取消csrf_token验证 1234567891011121314151617181920212223#views.pyfrom django.views.decorators.csrf import csrf_exemptdef md5(str_): import time m = hashlib.md5() m.update(str(time.time()).encode()) filename = m.hexdigest() return filename + '.' + str_.split('.')[-1]@csrf_exemptdef upload_img(request): if request.method == 'POST': img = request.FILES.get('file') if img: file_name_md5 = md5(img.name) with open(os.path.join(UPLOAD_ROOT,file_name_md5), 'wb') as fp: for buf in img.chunks(): fp.write(buf) # 迭代读取文件并写入到本地 response = &#123;&#125; response['path'] = '/upload/' + file_name_md5 response['error'] = False return HttpResponse(json.dumps(response)) 视图函数还是老样子去接收上传文件并保存即可 这里还使用了md5的方式进行文件名保存，避免重名文件上传互相覆盖 路由配置 12#urls.pypath('upload_img/',views.upload_img), 表单接收视图 以上的视图函数只能处理上传图片的内容接收 我们的模板页面中还有作者及标题两样表单内容会被POST提交到后台 并且要主要的是，富文本编辑器里除了图片的内容，还有文字等其他内容，这里也需要我们保存下来 这里还需要一个视图函数去接管处理 12345678910111213def index(request): if request.method == 'GET': return render(request, 'index.html') if request.method == 'POST': title = request.POST.get('title') author = request.POST.get('author') content = request.POST.get('content') models.Article.objects.create( title = title, author = author, content = content, ) return redirect('/show/') 表单路由 12#urls.pypath('',views.index), 这里上传之后，保存在后台的content数据是这个样子 1&lt;p&gt;&lt;img src=\"/upload/ec8f8c9a56ed32464a6727741fd58d8d.png\" /&gt;&lt;/p&gt;&lt;p&gt;今天&lt;em&gt;一切&lt;/em&gt;都是&lt;strong&gt;美丽&lt;/strong&gt;的，哈哈哈&lt;/p&gt; 图片访问路由 当有了上传图片的视图函数及所有内容的接收视图函数 这里还有一个特殊的问题，现在如果在富文本编辑器中选择上传图片，你会发现图片已经在选择时就已经存储到了后台upload文件夹下，这也是为什么我们的图片上传视图函数要单独编写，并且还需要取消csrf_token的验证的原因 除了这个问题你还会发现，在富文本编辑器中，上传的图片是看不到的，是一个坏掉的图片； 使用F12开发者工具你可以看到，这里的图片展示为一个img标签，而标签的src属性内容正是通过上传视图函数返回的response中的path值 想让这个path值在访问时，能获取到实际的图片效果，需要我们在路由文件中继续配置，配置专门的upload/xxxx.jpg的图片路由访问，让图片真正展示出来 123#urls.pyfrom django.views.static import servere_path('^upload/(?P&lt;path&gt;.*)/$',serve,&#123;'document_root':UPLOAD_ROOT&#125;), 上传后图片的访问路径是/upload/，那么这里的路由也是upload/，之后通过静态文件映射函数serve查找upload文件夹下的同路径同名图片资源 当有了这条路由配置之后，再次再富文本编辑器中加入图片，你就会发现图片出现啦 上传并展示 最后，我们将测试上传图片及文字 并且上传成功之后，重定向到show视图函数 这个视图函数用来提取当前最新的上传数据并返回到模板页面 12345#views.pydef show(request): if request.method == 'GET': article = models.Article.objects.all().last() return render(request,'show.html',locals()) 展示的模板页面 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;展示文章&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;% if article %&#125; &lt;h3&gt;&#123;&#123; article.title &#125;&#125;&lt;/h3&gt; &lt;h4&gt;&#123;&#123; article.author &#125;&#125;&lt;/h4&gt; &lt;div&gt;&#123;&#123; article.content|safe &#125;&#125;&lt;/div&gt; &#123;% endif %&#125;&lt;/body&gt;&lt;/html&gt; 其实本身富文本编辑器上传的文本内容就已经在一个p标签中，所以这里没有用段落标签 另外由于保存在数据库的文本为html格式，而后台传递来的模板变量django出于安全考虑会自动进行转义，直接观看到的效果不会html样式，只是一些普通字符串； 这里可以使用safe过滤器将内容认定为安全，展示为原始的html效果，其实还不错 总结 富文本编辑器其实就是将用户输入的内容变为html代码 这里的图文混排，只是在图片加入时，单独将图片上传保存，并且回调获取到上传的路径 之后只需要服务端后台配置好相关的上传图片访问路由配置即可","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"HayStack全文检索在Django中应用","slug":"HayStack全文检索在Django中应用","date":"2019-12-09T08:41:45.776Z","updated":"2019-12-09T11:26:38.345Z","comments":true,"path":"HayStack全文检索在Django中应用/","link":"","permalink":"https://cy-blogs.cn/HayStack全文检索在Django中应用/","excerpt":"全文检索官方文档 全文检索就是针对所有内容进行动态匹配搜索的概念 针对特定的关键词进行建立索引并精确匹配取出搜索结果，并且达到性能优化的目的 为啥要有全文检索 最常见的全文检索就是我们在数据库中进行的模糊查询 但是模糊查询是针对整体内容的一个动态匹配过程，在数据量较大的情况下匹配效率极低 常规项目中数据量一般都比较多并且内容繁杂，所以正常的项目搜索功能中很少会使用模糊查询进行操作 如果你开发的项目用户量较少并且项目数据较少，那么此时模糊查询可以是你值得考虑的选项","text":"全文检索官方文档 全文检索就是针对所有内容进行动态匹配搜索的概念 针对特定的关键词进行建立索引并精确匹配取出搜索结果，并且达到性能优化的目的 为啥要有全文检索 最常见的全文检索就是我们在数据库中进行的模糊查询 但是模糊查询是针对整体内容的一个动态匹配过程，在数据量较大的情况下匹配效率极低 常规项目中数据量一般都比较多并且内容繁杂，所以正常的项目搜索功能中很少会使用模糊查询进行操作 如果你开发的项目用户量较少并且项目数据较少，那么此时模糊查询可以是你值得考虑的选项 django使用啥进行全文检索 Python提供了各种模块进行全文检索，最常见的是haystack模块 该模块设计为支持whoosh、solr、Xapian、Elasticsearch四种全文检索引擎后端 使用haystack模块，不用更改代码，直接切换引擎，可以极大的减少代码量 haystack属于一种全文检索的框架 whoosh 纯Python编写的全文搜索引擎，是目前最快的python所编写的检索引擎，虽然性能比不上solr、Xapian、Elasticsearch等；但是无二进制包，程序不会莫名其妙的崩溃，对于小型的站点，whoosh已经足够使用 solr Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎 Lucene：不是一个完整的全文检索引擎，是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能 Xapian 12&gt; Xapian`是一个用`C++`编写的全文检索程序，他的作用类似于`Java`的`lucene&gt; Elasticsearch ElasticSearch是一个基于Lucene的搜索服务器它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口 Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。该引擎常设计用于云计算中；能够达到实时搜索，稳定，可靠，快速，安装使用方便 中文分词 whoosh作为一个全文搜索引擎模块 分词功能和检索功能已经非常强大，但是针对中文的处理还是比较欠缺 可以通过Jieba模块重写分词操作，支持whoosh对中文的强大操作 安装中文分词模块 1pip install jieba 除了jieba分词，现在还有很多付费的中文分词模块 中科院计算所NLPIR ansj分词器 哈工大的LTP 清华大学THULAC 斯坦福分词器 Hanlp分词器 结巴分词 KCWS分词器(字嵌入+Bi-LSTM+CRF) ZPar IKAnalyzer 安装 首先安装HayStack框架以及whoosh搜索引擎 12pip install django-haystackpip install whoosh settings配置 添加haystack应用到项目的settings文件下的app部分 12345INSTALLED_APPS = [ 'django.contrib.admin', ... 'haystack',] 添加搜索引擎，这里使用whoosh引擎 1234567HAYSTACK_CONNECTIONS = &#123; 'default': &#123; 'ENGINE': 'haystack.backends.whoosh_cn_backend.WhooshEngine', 'PATH': os.path.join(BASE_DIR, 'whoosh_index'), &#125;&#125;#这里使用django的信号机制，在数据表发生改动时自动更新whoosh的查询索引HAYSTACK_SIGNAL_PROCESSOR = 'haystack.signals.RealtimeSignalProcessor' 这里要注意的是，我们使用的引擎为whoosh_cn_backend 本身的whoosh引擎名为：whoosh_backend whoosh_cn_backend将在接下来我们对安装目录下的引擎文件复制修改得来 在项目的路由文件下配置查询的路由映射 12345from django.urls import include,re_pathurlpatterns = [ path('admin/', admin.site.urls), re_path('^search/',include('haystack.urls')),] 当查询条件被提交时，会跳转至search路由 并且查询条件会作为get请求时的连接参数传入，参数key值为q 创建索引文件 接下来，在需要被搜索的app下建立search_indexes.py文件，该文件名不许变更 1234567891011#app.models.pyclass User(models.Model): # 用户表 name = models.CharField( max_length=50, verbose_name='昵称' ) account = models.CharField(max_length=50,verbose_name='账号',unique=True) passwd = models.CharField(max_length=50,verbose_name='密码') def __str__(self): return self.name 1234567891011#app.search_indexes.pyfrom haystack import indexesfrom . import modelsclass UserIndex(indexes.SearchIndex, indexes.Indexable): text = indexes.CharField(document=True, use_template=True) def get_model(self): return models.User # 当前模型文件下需要被检索的模型类 def index_queryset(self, using=None): return self.get_model().objects.all() 该类为索引类，类名为模型类的名称+Index：比如模型类为People,则这里类名为PeopleIndex get_model函数用来获取当前索引类所关联的模型类，这里我们关联上面的User 类对象 text=indexes.CharField语句指定了将模型类中的哪些字段建立索引，而use_template=True说明后续我们将通过一个数据模板文件来指明需要检索的字段 12&gt; document=True&gt; 为什么要创建索引：索引就像是一本书的目录，可以为读者提供更快速的导航与查找 创建模板数据文件 创建数据模板文件 数据模板文件路径：templates/search/indexes/yourapp/note_text.txt 放在任何一个你的Django能搜索到的模板文件夹template下面均可，这个文件主要确定要检索的字段，为他们建立索引 文件名必须为要索引的类名_text.txt，比如这里我们检索的类名是User，那么对应的数据模板文件名为user_text.txt，文件名小写即可 1234#template.search.indexes.people.user_text.txt&#123;&#123; object.name &#125;&#125;&#123;&#123; object.account &#125;&#125;&#123;&#123; object.online_time &#125;&#125; 在数据模板文件中使用模板语法，写入需要建立索引的字段，这里我们将模型类中name、account以及online_time字段设置索引，当检索时会对这三个字段去做全文检索 接下来创建一个搜索结果展示页面 检索结果模板页面 创建检索结果展示页面 检索结果展示页面，需要在固定的目录路径下进行模板页面的编写 路径为：templates/search/ 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#123;% if query %&#125; &lt;h3&gt;搜索结果如下：&lt;/h3&gt; &#123;% for result in page.object_list %&#125; &#123;&#123; result.object.name &#125;&#125; &lt;br&gt; &#123;&#123; result.object.account &#125;&#125; &lt;br&gt; &#123;&#123; result.object.online_time &#125;&#125; &lt;br&gt; &#123;% empty %&#125; &lt;p&gt;没找到&lt;/p&gt; &#123;% endfor %&#125; &#123;% if page.has_previous or page.has_next %&#125; &lt;div&gt; &#123;% if page.has_previous %&#125; &lt;a href=\"?q=&#123;&#123; query &#125;&#125;&amp;amp;page=&#123;&#123; page.previous_page_number &#125;&#125;\"&gt; 上一页 &lt;/a&gt; &#123;% endif %&#125; &#123;% if page.has_next %&#125; &lt;a href=\"?q=&#123;&#123; query &#125;&#125;&amp;amp;page=&#123;&#123; page.next_page_number &#125;&#125;\"&gt; 下一页 &lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% endif %&#125;&#123;% endif %&#125;&lt;/body&gt;&lt;/html&gt; 这个模板页面中已经自带了分页功能，可以按照需求修改 创建检索模板页面内容 还需要有一个表单，提交检索信息 1234&lt;form method='get' action=\"/search/\" &gt; &lt;input type=\"text\" name=\"q\"&gt; &lt;input type=\"submit\" value=\"查询\"&gt;&lt;/form&gt; 这部分检索的模板页面内容可以在你的项目中进行添加，查询方式为get，并且检索输入的表单框name属性必须为q 中文分词配置 接下来，需要创建有关中文检索的配置文件，这里的配置文件创建为全局 进入到python的安装目录下，比如我的目录为：C:\\Python37\\Lib\\site-packages\\haystack\\backends 在该路径下创建名为ChineseAnalyzer.py的中文分词文件 1234567891011121314151617181920import jiebafrom whoosh.analysis import Tokenizer, Tokenclass ChineseTokenizer(Tokenizer): def __call__(self, value, positions=False, chars=False, keeporiginal=False, removestops=True,start_pos=0, start_char=0, mode='', **kwargs): t = Token(positions, chars, removestops=removestops, mode=mode, **kwargs) seglist = jieba.cut(value, cut_all=True) for w in seglist: t.original = t.text = w t.boost = 1.0 if positions: t.pos = start_pos + value.find(w) if chars: t.startchar = start_char + value.find(w) t.endchar = start_char + value.find(w) + len(w) yield tdef ChineseAnalyzer(): return ChineseTokenizer() 在这个文件中，定义了一个ChineseAnalyzer的函数，这个函数将替代搜索引擎配置文件中的分词方式 复制引擎文件，修改分词方式为中文 同样在该文件夹下C:\\Python37\\Lib\\site-packages\\haystack\\backends，复制whoosh_backend.py文件，创建一个新的文件名为whoosh_cn_backend.py，这里复制出一份文件也是为了之后如果不需要使用中文分词，可以直接在settings配置文件中修改引擎为&#39;ENGINE&#39;:&#39;haystack.backends.whoosh_backend.WhooshEngine&#39;, 修改该引擎配置文件中的：analyzer=StemmingAnalyzer()变为analyzer=ChineseAnalyzer() 并且要记得在头部引入刚才所编写的中文分词文件 12#whoosh_cn_backend.pyfrom .ChineseAnalyzer import ChineseAnalyzer 初始化索引 最后，初始化索引数据 1python manage.py rebuild_index","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Admin","slug":"Django中的Admin组件","date":"2019-12-09T08:29:50.000Z","updated":"2019-12-09T11:26:35.571Z","comments":true,"path":"Django中的Admin组件/","link":"","permalink":"https://cy-blogs.cn/Django中的Admin组件/","excerpt":"Admin Django-admin界面是框架为我们提供的Web-APP的管理工具 在之前的练习中，我们已经多次使用它进行APP中表的DML语句操作 接下来，我们可以继续来学习，如何将Admin界面进行优化扩展，更加方便我们后台管理 admin注册设置 在admin界面中，我们可以通过继承admin.ModelAdmin类进行自定义admin类的编写，用作控制展示后台所显示的数据，以及排序规则等等属性，基本语法像是下面这样","text":"Admin Django-admin界面是框架为我们提供的Web-APP的管理工具 在之前的练习中，我们已经多次使用它进行APP中表的DML语句操作 接下来，我们可以继续来学习，如何将Admin界面进行优化扩展，更加方便我们后台管理 admin注册设置 在admin界面中，我们可以通过继承admin.ModelAdmin类进行自定义admin类的编写，用作控制展示后台所显示的数据，以及排序规则等等属性，基本语法像是下面这样 123456# models.pyclass User(models.Model): name = models.CharField(max_length=20) age = models.IntegerField() def __str__(self): return self.name 12345#admin.pyclass UserAdmin(admin.ModelAdmin): fields = ('name','age') # 控制admin界面模型类展示字段admin.site.register(User, UserAdmin) 常用字段 list_display：在admin控制台数据列表页面展示更多的字段 list_display_links：用来设置当前列表中由list_display所设置的字段哪些可以点击 fieldsets：将admin界面下的表单输入栏进行分块 1234567891011121314class UserAdmin(admin.ModelAdmin): fields = ('name','age') fieldsets = ( ('第一个区域'， &#123; 'fields': ('name',) &#125; ) ('第二个区域'， &#123; 'fields': ('age',) &#125; ) ) search_fields：在admin数据展示页，设置一个搜索框，设置的分段是可查找的属性 1search_fields =（'name'，） list_filter：以什么分解进行过滤，在admin页面上方展示 ordering：数据列表可以通过某些细分进行排序 利用现有用户系统 from django.contrib.auth.models import User 用户字段 username 必选。少于等于30个字符。用户名可以包含字母，数字，_， ，@，。+状语从句：-字符 first_name 任选。等于等于30个字符 last_name 可选。可以输入30个字符 email 任选。邮箱地址 password 必选。密码的哈希及元数据。（Django不保存原始密码）。原始密码可以无限长而且可以包含任意字符 is_staff 布尔值。指示用户是否可以访问Admin站点 is_active 布尔值。用户的账号是否激活。长使用这个标志为False来代替删除账号 is_superuser 布尔值。指定这个用户拥有所有的权限而不需要给他们分配明确的权限 last_login 用户最后一次登录的时间。如果这个用户没有登录过，这个细分将会是null 之前版本默认设置为的当前的datetime date_joined 帐户创建的时间。当账号创建时，替代设置为当前的datetime 用户实例方法 get_username() 获取到当前的用户的用户名属性 is_authenticated() 检查用户是否已通过认证 is_anonymous() 检查用户是否未通过认证 set_password(password) 设置保存用户的密码，和会负责密码的哈希加密工作 通常修改密码之后还需要调用save()方法进行数据更新 用户表方法 create_user(username, email=None, password=None, **extra_fields) django的用户创建需要使用User表管理器中的create_user函数进行 该函数可以创建并保存一个用户 create_superuser(username, email, password, **extra_fields) 与上一个创建用户函数功能相同，但是额外会设置用户的is_staff及is_superuser属性为True 创建一个admin后台超级用户 其他方法 authenticate(username,password) 验证是否为合法用户，如果用户存在合法则返回一个用户对象 logout() 清除当前浏览器下用户session login(request,user) 登录并保存当前用户session 接受参数为HttpRequest请求及一个User用户对象 参数user必须为使用authenticate验证过后的用户对象 用户登录 登陆所需表单类 12345678910111213141516171819#forms.pyfrom django import formsfrom django.contrib.auth.models import Userimport reclass LoginForm(forms.Form): username = forms.CharField(label=\"用户名\",required=True,) password = forms.CharField( widget=forms.PasswordInput(), label='密码', required=True, ) def clean_username(self): username = self.cleaned_data.get(\"username\").strip() try: User.objects.get(username=username) except User.DoesNotExist: raise forms.ValidationError(\"用户名 %s 不存在\" % username) else: return username 登录所需模板页面 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action='/login/' method=\"POST\"&gt; &#123;% csrf_token %&#125; &#123;&#123; errors &#125;&#125; &#123;% for field in form %&#125; &lt;label&gt; &#123;% if field.errors %&#125; &lt;ul&gt; &#123;% for error in field.errors%&#125; &lt;li&gt;&#123;&#123; error &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &#123;% endif %&#125; &lt;/label&gt; &lt;p&gt;&#123;&#123; field.label &#125;&#125;: &#123;&#123; field &#125;&#125;&lt;/p&gt; &#123;% endfor %&#125; &lt;input type=\"submit\" value=\"登录\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 登陆主要视图逻辑 12345678910111213141516#views.pyfrom django.contrib.auth import authenticate,logout as auth_logout,login as auth_logindef login(request): if request.method == 'GET': form = userForm() return render(request, \"login.html\",&#123;'form':form&#125;) form = userForm(request.POST) username = form.data['username'] password = form.data['password'] user = authenticate(username=username,password=password) # 验证当前账号密码是否匹配合法 if user and user.is_active: auth_login(request, user) return redirect('/') else: return render(request, \"login.html\",&#123;'form':form,'errors':'用户名或密码错误'&#125;) 在用户登录成功之后，将会重新进入主页，主页展示当前登录用户 登录用户可以直接在request.user属性中获取到，主页的模板内容如下 主页模板 123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;主页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 欢迎你: &#123;&#123; user &#125;&#125;&lt;/body&gt;&lt;/html&gt; 主页视图函数可以通过装饰器@login_required或判断is_authenticated状态来查看用户是否登录 只有登录用户可以访问该站点 使用当装饰器@login_required时，在需要settings下设置LOGIN_URL = &#39;/login/&#39; 引入属性设置为登录路由 首页视图函数 1234567from django.contrib.auth.decorators import login_required#@login_requireddef index(request): if request.user.is_authenticated(): return render(request, \"index.html\") else: return redirect('/login/') 注册功能 注册所需表单 123456789101112131415161718192021222324252627282930313233#forms.pyclass RegisterForm(forms.Form): username = forms.CharField(label=\"用户名\", max_length=30, required=True, error_messages=&#123;'max_length':'账号长度最长为30'&#125;, ) password = forms.CharField(label=\"密码\", min_length=6, max_length=30, widget=forms.PasswordInput(), required=True, error_messages=&#123;'min_length':'密码长度最短为6'&#125;, ) check_password = forms.CharField(label=\"重复密码\", min_length=6, max_length=30, widget=forms.PasswordInput(), required=True, error_messages=&#123;'min_length':'密码长度最短为6'&#125;, ) def clean_check_password(self): password = self.cleaned_data.get('password') check_password = self.cleaned_data.get('check_password') if password != check_password and password and check_password: raise ValidationError(\"重复输入密码错误\") def clean_username(self): username = self.cleaned_data.get('username') if username[:1] == '_': raise forms.ValidationError(\"用户名不能以下划线打头\") try: User.objects.get(username=username) except User.DoesNotExist: return username raise forms.ValidationError(\"用户名已存在\") 表单中，将对用户两次输入的密码进行校验和判断是否为空，而且分开下划线作为用户名的开头字符 注册主要视图函数逻辑 1234567891011121314#views.pydef register(request): if request.method == 'POST': form = RegisterForm(request.POST) if form.is_valid(): username = form.cleaned_data['username'] password = form.cleaned_data['password'] User.objects.create_user(username=username,password=password) user = authenticate(username=username,password=password) auth_login(request, user) return redirect('/') else : form = RegisterForm() return render(request, \"register.html\",&#123;'form':form&#125;) 通过表单验证，并获取到对应的用户账号密码，创建成功之后，验证并登录，并重定向到首页 主页模板页面 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;注册&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;% if request.user.is_authenticated %&#125; &lt;p&gt;您已登录:&lt;/p&gt; &#123;&#123; user &#125;&#125; &#123;% else %&#125; &lt;form action='/register/' method=\"POST\"&gt; &#123;% csrf_token %&#125; &#123;% for field in form %&#125; &lt;label&gt; &#123;% if field.errors %&#125; &lt;ul&gt; &#123;% for error in field.errors%&#125; &lt;li&gt;&#123;&#123; error &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &#123;% endif %&#125; &lt;/label&gt; &lt;p&gt;&#123;&#123; field.label &#125;&#125;: &#123;&#123; field &#125;&#125;&lt;/p&gt; &#123;% endfor %&#125; &lt;input type=\"submit\" value=\"注册\"&gt; &lt;/form&gt; &#123;% endif %&#125;&lt;/body&gt;&lt;/html&gt; 当用户已经登录时，显示当前登录用户，反之则展示表单，以供用户填写 重载admin用户系统 django自带的admin模块下的用户系统主要负责用户帐户，组，权限和基于cookie的会话等业务 认证系统由以下部分组成： 用户：包含用户数据细分，是实现业务功能逻辑的基础 权限：控制用户进入否可以执行某项任务的二进制（是/否）标志。 组：一种为多个用户加上标签和权限的常用方式。 消息：一种为指定用户生成简单消息嵌入的方式 默认字段 username 必选项，小于等于30个字符；只能是字母数字（字母，数字和下划线） first_name 可选项，等于等于30个字符 last_name 可选项，等于等于30个字符 email 可选项。电子邮件地址 password 必选，密码（哈希值，元数据） Django不储存原始密码 原始密码可以是任意长度的，包含任何字符 密码由哈希类型，盐值和哈希值组成，用美元符合分隔 is_staff 布尔值，指明这个用户是否可以进入管理站点的权限 is_active 布尔值，指明这个用户帐户是否是活动的 我们建议把这个标记设置为False来代替删除用户帐户，这样就不会影响指向用户的外键 这个属性不控制用户是否可以登录。登录验证时不会核查is_active标志。 因此，如果在登录时需要检查is_active标志，需要你在自己的登录视图中实现 用于login()视图的AuthenticationForm会执行这个检查，判断用户是否是活跃账户 is_superuser 布尔值，规范用户拥有所有权限（包括显式赋予和非显式赋予的） last_login 预期情况下设置为用户最后一次登录的日期时间 date_joined 预期情况下设置为用户帐户创建的日期时间 默认方法 在项目中，我们将使用电子邮件作为用户的用户名，那么可以在自带用户表中写明 USERNAME_FIELD = &#39;email&#39; 该属性设置当前表的登陆细分 描述我们自定义用户模型上作的唯一标识符分割名称的字符串，分段必须是唯一的，在定义中设置unique=True REQUIRED_FIELDS = [&#39;username&#39;] 设置当前该基线为必填细分 is_authenticated() 判断用户是否已通过身份验证的方法，不意味任何权限，而且不检查用户的活动状态 get_username() 返回由USERNAME_FIELD制定的细分的值 get_full_name（） 返回first_name加上last_name 中间加上一个空格，由于我们重新设置了表分区，那么这个变量函数需要我们重新给定返回值 get_short_name() 一个短的且非正式用户的标识符，返回first_name 当你的项目重写该静态或直接去掉了first_name，所以我们必须重新给定这个函数的返回值 set_password() 将用户的密码设置为给定的字符串 has_perm(perm, obj=None) 用户是否具有某个权限，如果给定obj，则需要根据特定对象实例检查权限 has_module_perms(app_label) 如果用户有权访问给定应用中的模型，则返回True 这里我们这两个分区都设置为True，可以让用户访问任一APP is_staff()@property 如果用户允许访问管理网站，则返回True 这里我们返回is_admin的随机属性即可 关于细分属性，如果需要进行高度扩展 可以使用继承AbstractBaseUser这个类 这个类中只含有password， ，last_login以及is_active三个字段属性 重载管理器 由于已经覆盖了替代的admin用户表，现在需要将其对应的管理器函数进行编写 编写时主要关注一下两个父类函数的重写 123456create_user(username_field,password_filed=None,**other_fields) normalize_email()将邮件地址规范化的类方法 user.save(using=self._db)create_superuser(username, email, password) #用户创建，is_admin设置为True即可 user.save(using=self._db) 12345678910111213141516171819202122232425262728from django.contrib.auth.models import BaseUserManagerclass MyUserManager(BaseUserManager): def create_user(self, username, email, password=None): if not email : raise ValueError('Users must have an email address') if not username: raise ValueError('Users must have an username') #判断邮件和用户名是否具有 now = timezone.now() #获取当前django的时间 user = self.model( username=username, email=self.normalize_email(email), date_joined=now, last_login=now, ) user.set_password(password) user.save(using=self._db) return user def create_superuser(self, username, email, password): user = self.create_user(username, email, password=password, ) user.is_admin = True user.save(using=self._db) return user 重新定义新用户表的管理器之后，想要生效，还需要在对应的模型类表中覆盖objects属性 objects = MyUserManager() 重载表 下面是一个真实的重载自带用户表的模型类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677from django.contrib.auth.models import AbstractBaseUserclass Member(AbstractBaseUser): #AbstractBaseUser中只含有3个field: password, last_login和is_active. email = models.EmailField(verbose_name='邮箱',max_length=255,unique=True,) username = models.CharField(verbose_name=\"用户名\", max_length=16, unique=True) weibo_id = models.CharField(verbose_name=\"新浪微博\", max_length=30, blank=True) blog = models.CharField(verbose_name=\"个人网站\", max_length=200, blank=True) location = models.CharField(verbose_name=\"城市\", max_length=10, blank=True) profile = models.CharField(verbose_name=\"个人简介\", max_length=140, blank=True) avatar = models.CharField(verbose_name=\"头像\", max_length=128, blank=True) au = models.IntegerField(verbose_name=\"用户活跃度\", default=0) last_ip = models.IPAddressField(verbose_name=\"上次访问IP\", default=\"0.0.0.0\") email_verified = models.BooleanField(verbose_name=\"邮箱是否验证\", default=False) date_joined = models.DateTimeField(verbose_name=\"用户注册时间\", default=timezone.now) topic_num = models.IntegerField(verbose_name=\"帖子数\", default=0) comment_num = models.IntegerField(verbose_name=\"评论数\", default=0) is_active = models.BooleanField(default=True) is_admin = models.BooleanField(default=False) objects = MyUserManager() #objects就是我们之前一直使用的管理器 #管理器用来维护我们的增删改查 USERNAME_FIELD = 'email' REQUIRED_FIELDS = ['username'] def __str__(self): return self.username #标签中的数据实例 def is_email_verified(self): return self.email_verified #我们可以在模板中，通过实例出来的对象数据进行这个函数的调取，获取他是否验证过 def get_weibo(self): return self.weibo_id def get_username(self): return self.username #方法的圆括号在templates标签中必需省略！！ def get_email(self): return self.email #方法的圆括号在templates标签中必需省略！！ def get_full_name(self): # The user is identified by their email address return self.email #get_full_name本来是获取first_name和last_name的 #但是由于我们重新设置了表结构，那么这个函数必须自定义 #方法的圆括号在templates标签中必需省略！！ def get_short_name(self): # The user is identified by their email address return self.username def has_perm(self, perm, obj=None): \"Does the user have a specific permission?\" return True def has_module_perms(self, app_label): \"Does the user have permissions to view the app `app_label`?\" return True def calculate_au(self): \"\"\" 计算活跃度 公式：Topic * 5 + Comment * 1 \"\"\" self.au = self.topic_num * 5 + self.comment_num * 1 return self.au @property #类中函数可以直接做为属性使用 def is_staff(self): \"Is the user a member of staff?\" # Simplest possible answer: All admins are staff return self.is_admin 重载Admin表单 由于修改了默认的django表结构，此时在admin界面修改密码或添加用户数据已经不能再按照之前的表单系统啦 需要在app的admin.py中重写UserCreationForm和UserChangeForm 123456789101112131415161718192021222324252627282930313233# 用户创建表单from django import formsfrom django.contrib import adminfrom django.contrib.auth.admin import UserAdminfrom django.contrib.auth.forms import ReadOnlyPasswordHashFieldfrom people.models import Member, Followerclass UserCreationForm(forms.ModelForm): \"\"\"A form for creating new users. Includes all the required fields, plus a repeated password.\"\"\" password1 = forms.CharField(label='密码', widget=forms.PasswordInput) password2 = forms.CharField(label='确认密码', widget=forms.PasswordInput) class Meta: model = Member fields = ('email', 'username') def clean_password2(self): password1 = self.cleaned_data.get(\"password1\") password2 = self.cleaned_data.get(\"password2\") if password1 and password2 and password1 != password2: raise forms.ValidationError(\"两次输入验证失败\") return password2 #在form中的clean__field函数会在is_valid()函数验证时自动调用 def save(self, commit=True): user = super(UserCreationForm, self).save(commit=False) user.set_password(self.cleaned_data[\"password1\"]) #set_password将会采用django的加密算法将密码设置到对应的模型实例中 #在内存中创建的好的对象只有通过commit=True才被真正执行到数据库上 if commit: user.save() return user 123456789# 密码改变时的展示表单class UserChangeForm(forms.ModelForm): password = ReadOnlyPasswordHashField() class Meta: model = Member fields = ('email', 'password', 'username', 'is_active', 'is_admin',) def clean_password(self): return self.initial[\"password\"] #使用默认的save函数即可 1234567891011121314151617181920212223242526# 真正的用户admin界面管理方式class MyUserAdmin(UserAdmin): form = UserChangeForm add_form = UserCreationForm list_display = ('id', 'email', 'username', 'email_verified', 'last_login','is_active','is_admin','last_ip') list_display_links = ('id', 'email', 'username') list_filter = ('email', 'email_verified',) fieldsets = ( (None, &#123;'fields': ('username', 'email', 'date_joined', 'password','is_active','is_admin','avatar')&#125;), ('状态', &#123;'fields': ('email_verified', 'last_ip', 'au', 'topic_num', 'comment_num')&#125;), ('社交网络', &#123;'fields': ('weibo_id', 'blog')&#125;), ) add_fieldsets = ( (None, &#123; 'classes': ('wide',), #admin样式设置 #Fieldsets 使用 wide 样式将会有额外的水平空格. 'fields': ('email', 'username', 'password1', 'password2','is_active','is_admin')&#125; ), ) search_fields = ('id', 'email', 'username') ordering = ('id', 'email', 'email_verified') filter_horizontal = () #这个字段为了设置与groups关联的多选框admin.site.register(Member, MyUserAdmin)admin.site.register(Follower) 最终 还需要在settings.py文件下进行设置，覆盖最小的User模型 AUTH_USER_MODEL = &#39;people.Member&#39;","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Django邮件发送及华丽呼哨的邮件格式","slug":"Django邮件发送及华丽呼哨的邮件格式","date":"2019-12-09T08:19:22.320Z","updated":"2019-12-09T11:26:32.354Z","comments":true,"path":"Django邮件发送及华丽呼哨的邮件格式/","link":"","permalink":"https://cy-blogs.cn/Django邮件发送及华丽呼哨的邮件格式/","excerpt":"发送邮件 django中内置了许多方法可以使开发者方便的进行邮件发送 邮件配置 发送邮件，首先需要在项目的settings.py文件下配置邮件服务器连接等信息 123456EMAIL_USE_SSL = True # Secure Sockets Layer 安全套接层, 取决于邮件服务器是否开启加密协议EMAIL_HOST = 'smtp.qq.com' # 邮件服务器地址EMAIL_PORT = 465 # 邮件服务器端口 EMAIL_HOST_USER = 'account@qq.com' # 登陆邮件服务器的账号EMAIL_HOST_PASSWORD = 'password' # 登陆邮件服务器的密码DEFAULT_FROM_EMAIL = EMAIL_HOST_USER # 邮件的发送者","text":"发送邮件 django中内置了许多方法可以使开发者方便的进行邮件发送 邮件配置 发送邮件，首先需要在项目的settings.py文件下配置邮件服务器连接等信息 123456EMAIL_USE_SSL = True # Secure Sockets Layer 安全套接层, 取决于邮件服务器是否开启加密协议EMAIL_HOST = 'smtp.qq.com' # 邮件服务器地址EMAIL_PORT = 465 # 邮件服务器端口 EMAIL_HOST_USER = 'account@qq.com' # 登陆邮件服务器的账号EMAIL_HOST_PASSWORD = 'password' # 登陆邮件服务器的密码DEFAULT_FROM_EMAIL = EMAIL_HOST_USER # 邮件的发送者 注意：EMAIL_HOST_PASSWORD所设置的登陆邮件服务器的密码为邮件客户端后台所设置的第三方客户端登陆密码，这个值并非直接账号密码 如：QQ邮箱的该值密码在网页版QQ邮件客户端的设置-&gt;帐户-&gt;开启POP3/SMTP服务|IMAP/SMTP服务 发送文本邮件 发送普通邮件可以使用django.core.mail模块下的send_mail函数进行 send_mail(subject, message, from_email, recipient_list, fail_silently=False, html_message=None) 将邮件发送至recipient_list中的每一个收件人处 subject：发送邮件标题 message：发送邮件正文 from_email：发件人邮箱地址 recipient_list：一个字符串列表，每一个数据为接收者的邮箱地址 html_message：如果指定该值，则发送的内容类型为text/html为一个html邮件内容 发送普通邮件视图函数 1234567891011from django.core.mail import send_maildef send_email(request): subject = '邮件测试' message = '&lt;a href=\"http://www.python.org\"&gt;学习Python，我很快乐&lt;/a&gt;' send_mail( subject = subject, message = message, from_email = 'from@qq.com', recipient_list = ['recv@qq.com','recv1@qq.com'] ) return HttpResponse('Down') 发送HTML邮件 发送这里的邮件内容为一个HTML的a标签，但是真正接收者接到该邮件时，a标签并不会解释称为真正的a标签，只是一个普通的字符串，这是因为当前发送邮件的类型为text/plain，可以使用html_message参数进行HTML内容的发送 123456789101112from django.core.mail import send_maildef send_email(request): subject = '邮件测试' message = '&lt;a href=\"http://www.python.org\"&gt;学习Python，我很快乐&lt;/a&gt;' send_mail( subject = subject, message = '', # 该参数为必须参数，必须填写 html_message = message, from_email = 'from@qq.com', recipient_list =['recv@qq.com','recv1@qq.com'] ) return HttpResponse('Down') 发送html格式邮件还可以使用django.core.mail模块下的EmailMultiAlternatives类进行邮件体的构造，然后进行邮件发送 EmailMultiAlternatives(subject=&#39;&#39;, body=&#39;&#39;, from_email=None, to=None) subject：邮件标题 body：邮件内容 from_email：邮件发送者 to：邮件接收人列表 EmailMultiAlternatives.attach_alternative(content, mimetype) 向EmailMultiAlternatives实例中添加mimetype支持的邮件内容 content：添加的邮件内容 mimetype：添加内容的mime类型 EmailMultiAlternatives.send() 发送邮件 1234567891011121314from django.core.mail import EmailMultiAlternativesdef send_email(request): subject = '邮件测试' text_message = '学习Python，我很快乐' html_message = '&lt;a href=\"http://www.python.org\"&gt;学习Python，我很快乐&lt;/a&gt;' email = EmailMultiAlternatives( subject = subject, body = text_message, from_email = '1747266529@qq.com', to = ['recv@qq.com','recv1@qq.com'] ) email.attach_alternative(html_message,'text/html') # 添加HTML邮件部分 email.send() # 发送邮件 return HttpResponse('Down') 发送富文本邮件 经常需要我们在邮件中加入图片等静态资源 需要用到python中email.mime.image模块下的MIMEImage类进行图片内容的构造 这里发送邮件使用EmailMessage类，来自于django.core.mail模块下 并在使用对应该类实例的attach添加图片资源数据 最后使用实例的send函数发送邮件 EmailMessage(subject=&#39;&#39;, body=&#39;&#39;, from_email=None, to=None) ``subject`：邮件标题 body：邮件内容 from_email：邮件发送者 to：邮件接收人列表 12345678910111213141516171819202122232425262728293031323334from sendmailpro.settings import STATICFILES_DIRSimport osfrom email.mime.image import MIMEImagefrom django.core.mail import EmailMessagedef send_email(request): subject = '图片邮件测试' file_1 = os.path.join(STATICFILES_DIRS[0],'img/1.png') with open(file_1, 'rb') as fp: # 打开第一张图片 image_1 = MIMEImage(fp.read()) file_2 = os.path.join(STATICFILES_DIRS[0],'img/2.png') with open(file_2, 'rb') as fp: # 打开第二张图片 image_2 = MIMEImage(fp.read()) body = \"&lt;img src='cid:first_id'&gt;&lt;br&gt;&lt;img src='cid:sec_id'&gt;\" # 发送邮件主体内容 image_1.add_header('Content-ID','&lt;%s&gt;' % 'first_id') # 通过 CID 对称图片在邮件内容中的位置 image_2.add_header('Content-ID','&lt;%s&gt;' % 'sec_id') message = EmailMessage( # 构建发送的邮件主体 subject=subject, body=body, from_email='from@qq.com', to=['recv@qq.com','recv1@qq.com'] ) message.content_subtype = 'html' message.attach(image_1) # 添加两张图片 message.attach(image_2) message.send() # 发送邮件 return HttpResponse('Down') 发送附件邮件 发送附件，也可以使用django.core.mail模块下的EmailMessage类进行附件邮件体构造 通过EmailMessage实例的attach|attach_file两个函数在邮件主体中添加附件内容 attach_file添加邮件附件直接加入路径即可，但是attach添加附件内容需要提供附件内容 attach(filename=None, content=None, mimetype=None) 添加附件内容 filename：附件文件名称 content：附件内容 mimetype：附件的MIME类型 attach_file(path, mimetype=None) 直接通过路径添加附件 path：附件路径 mimetype：附件的MIME类型 123456789101112131415161718192021from sendmailpro.settings import STATICFILES_DIRSimport osfrom email.mime.image import MIMEImagefrom django.core.mail import EmailMessagedef send_email(request): subject = '附件邮件测试' email = EmailMessage( subject=subject, body='这是一封具有图片附件的邮件', from_email='from@qq.com', to=['recv@qq.com','recv1@qq.com'] ) file_1 = os.path.join(STATICFILES_DIRS[0],'img/1.png') image_1 = open(file_1,'rb').read() email.attach('1.png',image_1,'image/png') # 使用attach实例函数添加附件内容 file_2 = os.path.join(STATICFILES_DIRS[0],'img/2.png') email.attach_file(file_2,mimetype='image/png') # 使用attach_file实例函数添加附件路径 email.send() return HttpResponse('Down')","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Django缓存系统","slug":"Django缓存系统","date":"2019-12-09T08:16:28.960Z","updated":"2019-12-09T11:26:29.098Z","comments":true,"path":"Django缓存系统/","link":"","permalink":"https://cy-blogs.cn/Django缓存系统/","excerpt":"缓存 Django 是动态Web后台框架，需要实时生成用户访问的页面，进行多次的数据库操作，但是多次的数据库访问操作对于整个Web系统来说，会影响效率，尤其是当访问量增大时，数据库的压力也会越来越大。 相对于磁盘及内存操作，数据库的访问操作付出的成本要大的多 浏览器第一次请求时，cache会缓存单个变量或整个网页等内容到硬盘或者内存中，同时设置response头部 当浏览器再次发起请求时，会与缓存中的过期时间相比较，如果缓存时间比较新，则会重新请求数据，并缓存起来然后返回response给客户端，如果缓存没有过期，则直接从缓存中提取数据，返回给response给客户端","text":"缓存 Django 是动态Web后台框架，需要实时生成用户访问的页面，进行多次的数据库操作，但是多次的数据库访问操作对于整个Web系统来说，会影响效率，尤其是当访问量增大时，数据库的压力也会越来越大。 相对于磁盘及内存操作，数据库的访问操作付出的成本要大的多 浏览器第一次请求时，cache会缓存单个变量或整个网页等内容到硬盘或者内存中，同时设置response头部 当浏览器再次发起请求时，会与缓存中的过期时间相比较，如果缓存时间比较新，则会重新请求数据，并缓存起来然后返回response给客户端，如果缓存没有过期，则直接从缓存中提取数据，返回给response给客户端 Cache-Control HTTP协议头Cache-Control，Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires 在python中使用memcached需要我们额外安装memcached作为memcache客户端的支持 1pip3 install python-memcached -i https://pypi.tuna.tsinghua.edu.cn/simple Cache设置memcached 安装memcached 1234apt-get install memcached# debianyum install memcached # centos 配置文件：/etc/memcached.conf 配置文件中有两个可能需要修改的参数 12-m 64 #memcached所能使用的内存大小-l 127.0.0.1 #监听的IP地址 开启|关闭memcached服务 12systemctl start memcached # 开启systemctl stop memcached # 关闭 查看服务状态 1systemctl status memcached settings配置 使用memcached缓存，首先需要在项目的settings文件下进行配置 12345678CACHES = &#123; 'default': &#123; 'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache', # 指定缓存使用的引擎 'LOCATION':'172.16.19.26:11211', # 指定缓存服务器地址，常为本机地址 &#125;&#125; 视图缓存 可以只为某些视图函数进行缓存 使用django.views.decorators.cache下的装饰器cache_page进行视图函数装饰即可 模型类的表代码 12class People(models.Model): name = models.CharField(max_length=20,verbose_name='名字') 视图函数代码 1234567from django.views.decorators.cache import cache_page@cache_page(10) # 缓存10秒def index(request): print('视图函数被调用') ss = models.People.objects.all() return render(request, 'index.html', locals()) 模板页面代码 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;展示数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;% for s in ss %&#125; &lt;li&gt;&#123;&#123; s.name &#125;&#125; &lt;/li&gt; &#123;% endfor %&#125;&lt;/body&gt;&lt;/html&gt; 在第一次刷新浏览器之后， 立即在数据库中添加一个新的数据对象 接着继续刷新浏览器，前端页面将会读取缓存中的结果，而不会显示刚才添加的用户 除了在视图函数上使用装饰器进行缓存设置，还可以在路由匹配部分使用相同装饰器函数进行设置 全站缓存 将整站所有视图设置缓存，需要在配置文件的中间件设置首尾部分添加如下内容 12345678MIDDLEWARE = [ 'django.middleware.cache.UpdateCacheMiddleware', # 首部要添加的中间件 # 将response缓存起来 'django.middleware.security.SecurityMiddleware', ... 'django.middleware.cache.FetchFromCacheMiddleware',# 尾部要添加的中间件 # 将缓存的response取出来] 以及搭配设置当前全站缓存有效时间的全局变量 1CACHE_MIDDLEWARE_SECONDS = 10 # 每页页面缓存的秒数，默认为600 局部缓存 局部缓存主要为在模板页面，选择某个区域进行缓存，当用户再次访问相同页面时，如设置缓存未过期，则渲染时局部缓存不会重新生成 12345&#123;% load cache %&#125; 局部缓存首先需要加载cache标签 &#123;% cache sec key %&#125;&#123;% endcache %&#125; 以时间模板变量为例，做一个简单的测试，后台视图函数每次在访问时，返回当前时间 12import time now = time.strftime('%H:%M:%S', time.localtime()) 模板页面在使用时的代码 123456&#123;% load cache %&#125;&lt;p&gt;这里是未缓存的时间:&#123;&#123; now &#125;&#125;&lt;/p&gt;&#123;% cache 10 time %&#125;&lt;p&gt;这里是缓存的时间:&#123;&#123; now &#125;&#125;&lt;/p&gt;&#123;% endcache %&#125; 手动缓存 除了以上应用于各个业务中的缓存方式，还可以使用django所提供的cache接口进行缓存设置以及获取 设置缓存 1234from django.core.cache import cache#存储缓存数据cache.set('cache_key',data,60*15)#cache_key为存储在缓存中的唯一值，data为存储的数据，60*15为缓存有效时间 获取缓存 123#获取缓存数据cache.get('cache_key','获取不到的默认值')#cache_key为储存缓存数据的唯一值 避免key值重复导致更新缓存，可以使用cache.add函数，基本用法与set相同 123status = cache.add('add_key', 'New value')# 当指定key值的缓存存在，add方法不会尝试更新缓存# 返回值status为True时，代表存储成功，False代表存储失败 清除缓存，通过cache.delete方法，该方法接收一个缓存key值 1cache.delete('cache_key') 清空缓存，通过cache.clear方法，直接从缓存中清除所有 1cache.clear() 注意 memcached不允许使用超过250个字符或包含空格或控制字符的缓存键值 使用这样的键值将会导致异常","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Django的消息框架(message)与Django分页组件(paginator)","slug":"Django的消息框架(message)与Django分页组件(paginator)","date":"2019-12-09T08:11:25.363Z","updated":"2019-12-09T11:26:22.907Z","comments":true,"path":"Django的消息框架(message)与Django分页组件(paginator)/","link":"","permalink":"https://cy-blogs.cn/Django的消息框架(message)与Django分页组件(paginator)/","excerpt":"Messages消息框架 在网页应用中，你经常需要在处理完表单或其它类型的用户输入后。显示一个通知消息（也叫做flash message给用户 对于这个功能，Django提供基于Cookie 和会话的消息，无论是匿名用户还是认证的用户。 其消息框架允许你临时将消息存储在请求中，并在接下来的请求（通常就是下一个请求）中提取它们并显示。每个消息都带有一个特定level 标签，表示其优先级（例如info、warning 或error）","text":"Messages消息框架 在网页应用中，你经常需要在处理完表单或其它类型的用户输入后。显示一个通知消息（也叫做flash message给用户 对于这个功能，Django提供基于Cookie 和会话的消息，无论是匿名用户还是认证的用户。 其消息框架允许你临时将消息存储在请求中，并在接下来的请求（通常就是下一个请求）中提取它们并显示。每个消息都带有一个特定level 标签，表示其优先级（例如info、warning 或error） django-admin startproject 创建的默认settings.py 已经包含启用消息框架功能需要的所有的设置 INSTALLED_APPS 中的&#39;django.contrib.messages&#39;。 MIDDLEWARE_CLASSES 中的&#39;django.contrib.sessions.middleware.SessionMiddleware&#39; 和&#39;django.contrib.messages.middleware.MessageMiddleware&#39; 默认的后端存储 依赖[sessions] 所以MIDDLEWARE_CLASSES 中必须启用SessionMiddleware 并出现在MessageMiddleware 之前 TEMPLATES 设置中定义的DjangoTemplates 的&#39;context_processors&#39; 选项包含&#39;django.contrib.messages.context_processors.messages&#39; 消息级别 12&gt; from django.contrib import messages&gt; messages.debug messages.info messages.success messages.warning messages.error 使用消息框架 视图函数只需要创建messages消息对象即可 12messages.warning(request,'登陆失败，用户名或密码无效')return render(request,'login.html',locals()) 前端模板中判断是否含有messages消息，遍历取出即可 也可以结合bootstrap框架让提示消息变得更加美丽 1234567&#123;% if messages %&#125; &#123;% for message in messages %&#125; &lt;div class=\"alert alert-&#123;&#123; message.tags &#125;&#125; fade in\"&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125;&#123;% endif %&#125; 注意：messages对象是一个数据集，并不是单独的一条消息，需要我们在使用时，必须通过for循环进行访问 Paginator分页组件 12&gt; from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger&gt; 1Paginator ：创建分页对象 分页对象内置属性 1234567891011121314all_ = models.objects.all()p = Paginator(all_, 10)# 分页all_数据，每页显示10条数据p.count# 总数据量p.num_pages() # 分页数p.page_range() # 列表形式返回当前可有的页数 [1,2,3]page_1 = p.page(1) # 选择第一页，返回第一页数据对象page_1.object_list# 返回第一页所有数据for var in page_1: print(var)ABC... 某一页内置属性12345678910111213141516page_1.number # 当前页的页码page_1.has_next() # 是否有下一页page_1.has_previous()# 是否有上一页page_1.has_other_pages()# 是否含有其他页page_1.next_page_number() # 下一页的页码page_1.previous_page_number()# 上一页的页码page_1.start_index() # 该页第一个数据的索引page_1.end_index()# 该页最后一个数据的索引 EmptyPage：取不到页面数据，抛出该异常 1234567all_ = models.objects.all()p = Paginator(all_, 10)try: list_ = p.page(page_num) except EmptyPage: #没有第page_num页 list_ = paginator.page(1) # 取不到该也数据，直接返回第一页数据 PageNotAnInteger：当页数是一个非整数类型时，抛出该异常 模板页面基本使用方式123456789&#123;% if topic_list.has_previous %&#125;&lt;!-- 当前页是否含有上一页 --&gt; &lt;a href=\"?page=&#123;&#123; list_.previous_page_number &#125;&#125;\"&gt;上一页&lt;/a&gt; &lt;!-- 连接传参形式传递上一页的页码ID --&gt;&#123;% endif %&#125;&#123;% if topic_list.has_next %&#125;&lt;!-- 当前页是否含有下一页 --&gt; &lt;a href=\"?page=&#123;&#123; list_.next_page_number &#125;&#125;\"&gt;下一页&lt;/a&gt;&lt;!-- 连接传参形式传递下一页的页码ID --&gt;&#123;% endif %&#125;","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Django的CBV类视图","slug":"Django的CBV类视图","date":"2019-12-09T08:07:02.109Z","updated":"2019-12-09T11:26:26.250Z","comments":true,"path":"Django的CBV类视图/","link":"","permalink":"https://cy-blogs.cn/Django的CBV类视图/","excerpt":"CBV CBV（class base views） 就是在视图里使用类处理请求 之前的代码中，我们的视图函数都是通过函数来进行request的响应以及response的返回，并且通常我们需要判断的请求方式get或是post都需要我们在代码中通过if进行条件判断，这样的视图功能编写就叫做FBV 但现在在django中还提供了一种方式叫做CBV，在类中编写视图功能， 并且将传统的get、post判断设置为了类中函数，这样当用户发起不同的请求，会自动进入到对应的类中函数上，像是下面这样","text":"CBV CBV（class base views） 就是在视图里使用类处理请求 之前的代码中，我们的视图函数都是通过函数来进行request的响应以及response的返回，并且通常我们需要判断的请求方式get或是post都需要我们在代码中通过if进行条件判断，这样的视图功能编写就叫做FBV 但现在在django中还提供了一种方式叫做CBV，在类中编写视图功能， 并且将传统的get、post判断设置为了类中函数，这样当用户发起不同的请求，会自动进入到对应的类中函数上，像是下面这样 1234567891011from django.views import Viewclass ArticleView(View): def get(self,request): raise Http404 def post(self,request): if request.is_ajax(): id_ = request.POST.get('id_') result = models.Article.objects.get(id=id_).content data = result.replace('\\r\\n','&lt;br&gt;') return HttpResponse(json.dumps(data,ensure_ascii=False) ) raise Http404 通过将请求类型定义为函数，可以更加方便进行请求方式判断 用户访问时，会经由View基类中的as_view -&gt; dispatch进行判断，通过请求类型分发到不同对应请求的函数名下；也就是通过get方式访问，那么对应会调用到名为get的函数 此外，类中函数必须为小写， 对应路由此时设置为，需要使用试图类的as_view函数进行实例化 12#url.pypath('article/',ajaxviews.ArticleView.as_view()) 通过类视图可以方便我们进行请求条件的判断 并且可以在进行接口开发时，实现同一资源路由在使用不同请求访问时的功能解耦和 意思就是不用再把所有的功能都堆到一个视图函数里啦。多方便！ 并且，在Django-Restframework框架中，也将频繁使用CBV形式进行视图编写 类视图装饰器 在类视图中使用为函数视图准备的装饰器时，不能直接添加装饰器 需要使用method_decorator将其转换为适用于类视图方法的装饰器 12&gt; from django.utils.decorators import method_decorator&gt; 全部装饰 123456789101112131415from django.views import Viewfrom django.utils.decorators import method_decoratordef my_decorator(func): def nei(request): # dispatch函数有参数request print('这是装饰器在调用') return func(request) return nei@method_decorator(my_decorator, name='dispatch')# 为全部请求方法添加装饰器class DemoView(View): def get(self, request): print('get方法') return HttpResponse('ok') def post(self, request): print('post方法') return HttpResponse('ok') 为部分装饰，只需要通过method_decorator方法的name参数选择装饰的函数名即可 12345678@method_decorator(my_decorator, name='post')class DemoView(View): def get(self, request): print('get方法') return HttpResponse('ok') def post(self, request): print('post方法') return HttpResponse('ok') 为特定的多个类视图函数进行装饰，只需要在每个函数上使用method_decorator装饰器即可 123456789class DemoView(View): @method_decorator(my_decorator) # 为get方法添加了装饰器 def get(self, request): return HttpResponse('ok') @method_decorator(my_decorator) # 为post方法添加了装饰器 def post(self, request): return HttpResponse('ok') 类视图csrf_token装饰 当类视图需要允许跨站提交数据时，使用csrf_exempt装饰器装饰函数可以被跨域访问 但是使用上面的方法进行csrf_exempt是不行的，需要在类视图基类的dispatch函数上进行装饰 12345678910111213from django.views.decorators.csrf import csrf_exempt#@method_decorator(csrf_exempt,name='dispatch')# 直接加载类视图上也是可以修饰的class DemoView(View): @method_decorator(csrf_exempt) def dispatch(self, request, *args, **kwargs): return super(DemoView,self).dispatch(request, *args, **kwargs) def get(self, request): print('get方法') return HttpResponse('ok') def post(self, request): print('post方法') return HttpResponse('ok') csrf装饰只能在类视图的dispatch函数上才能被生效 除了在类视图的dispatch函数上进行装饰，在路由映射处使用csrf_exempt函数修饰路由规则也是可以的 123456#urls.pyfrom django.views.decorators.csrf import csrf_exempturlpatterns = [ ... path('',csrf_exempt(ajaxviews.DemoView.as_view()))]","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Django初识","slug":"Django初识","date":"2019-12-09T07:48:31.829Z","updated":"2019-12-09T11:35:21.463Z","comments":true,"path":"Django初识/","link":"","permalink":"https://cy-blogs.cn/Django初识/","excerpt":"开始玩耍Django Django是一个开放源代码的Web应用框架，由Python写成。采用了MVT的框架模式；最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件 框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的 django安装","text":"开始玩耍Django Django是一个开放源代码的Web应用框架，由Python写成。采用了MVT的框架模式；最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件 框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的 django安装 pip install django==2.0.4(版本号) pip install django默认安装最新版本 创建项目 12&gt; django-admin startproject myproject&gt; 开启开发服务器 cd myproject：进入项目目录 python manage.py runserver：开启服务 python manage.py runserver 7000：改变服务监听端口 python manage.py runserver 0:8000：改变服务监听IP:端口 项目文件夹1234manage.py：用来管理当前项目的一个命令行工具myproject/： 项目主文件夹myproject/__init__.py：空文件，用来指明当前的myproject为一个可导入的模块包myproject/settings.py：项目主要配置文件myproject/urls.py：项目主要路由配置文件myproject/wsgi.py：项目部署WSGI并发服务器时所需要的配置文件 Settings.py 该文件是整个项目的主控文件，其中相关配置选项如下 https://docs.djangoproject.com/zh-hans/2.0/ref/settings/ 123456789101112131415161718192021222324- BASE_DIR: 当前项目工作目录，用来在每一次开启项目时动态找到相关资源路径- SECRET_KEY: 加密的hash值以及保护某些签名数据的关键密钥- DEBUG: 调试模式- ALLOWED_HOSTS: 有哪些主机或域名可以访问当前django站点，如设置为*代表全部可访问。- INSTALL_APPS: django项目中所有使用的应用名称，自创建子应用也要加到这里，不然ORM数据库无法被识别到！- MIDDLEWARE: django中间件，用来在request或reponse过程中添加功能，比如确保安全性，传输保存Session等- SecurityMiddleware: xss脚本过滤，一些安全设置 - SessionMiddleware: session支持中间件，在每次用户访问django项目时，添加session对每一个浏览器- CommonMiddleware: 通用组件，比如为路由添加末尾斜杠- CsrfViewMiddleware: 防跨站请求伪造令牌，为客户端添加csrf_token密钥，在表单提交时需提交该值- AuthenticationMiddleware: admin用户组件，每个request对象都会被添加admin下的user属性- MessageMiddleware: 消息中间件 展示一些后台消息给前端- XFrameOptionsMiddleware: 防止欺骗点击攻击出现；自身页面被嵌入到他人页面中，点击欺骗- ROOT_URLCONF: 主路由配置文件，字符串填写url.py文件路径- TEMPLATES: 模板文件配置项- WSGI_APPLICATION: WSGI服务器配置项，找到当前django下的wsgi引入APP文件- DATABASES: 数据库配置项，默认使用SQLite3，一个本地文件数据库- AUTH_PASSWORD_VALIDATORS: 检查用户密码强度的验证程序列表，不过是针对admin界面下的用户，而非自定义- LANGUAGE_CODE: django所使用语言文件- TIME_ZONE: django所使用时区- USE_I18N: 国际化支持 18表示Internationalization这个单词首字母I和结尾字母N之间的字母有18个- USE_L10N: 是localization的缩写形式，意即在l和n之间有10个字母- USE_TZ:开启了Time Zone功能，则所有的存储和内部处理，包括print显示的时间将是是UTC时间格式- STATIC_URL: URL访问静态资源时的路径 来搞个Hello worlddjango创建子应用 项目和应用有啥区别？ 应用是一个专门做某件事的网络应用程序：比如博客系统，或者公共记录的数据库，或者简单的投票程序 项目则是一个网站使用的配置和应用的集合。项目可以包含很多个app应用，应用可以被很多个项目使用 python manage.py startapp myapp 创建子应用 app目录1234- admin.py: app在admin注册展示时需要的文件- views.py: app的功能视图函数文件- models.py: app需要使用数据库时的文件- urls.py: 当使用include路由分发时，每个app应该有他自己的子路由文件，这个是默认没有创建好的 视图函数 打开app下的views.py文件 Web访问起始就是通过一个URL连接地址访问到服务器上的一个函数 在views.py中我们通过编写函数的形式，接收用户请求的request并返回一个response 12345# 每一个视图函数都需要有一个必须参数 request,用来接收用户访问时的请求内容from django.http import HttpResponsedef index(request): return HttpResponse(\"&lt;h1&gt;Hello world&lt;/h1&gt;\") HttpResponse函数用来向用户返回一个字符串 路由配置 创建好了一个可以在请求时返回H1标签的视图函数，但是现在通过浏览器还是访问不到 需要我们为这个app下的函数进行路由配置 第一种简单的路由配置，直接在主控路由文件下，找到这个视图函数 12345678910#myproject/urls.pyfrom django.contrib import adminfrom django.urls import pathfrom myapp import viewsurlpatterns = [ path('admin/', admin.site.urls), #admin控制界面路由 path('',views.index) #path函数第一个参数为访问地址，空字符串代表：当用户直接访问首页时 #第二个参数代表访问该地址时对应的视图函数，我们引入了app下的views中的index视图函数 ] 接下来访问127.0.0.1:8000，那么你会看到一个非常大的Hello world 以上将视图函数的查找直接写到主控路由并不是最好的办法 我们的项目通常会有非常多的路由配置项，如果都堆到这个文件中肯定是非常乱的，难以维护 我们可以在对应app下创建一个子路由控制文件，并在其中设置视图的路由配置 1234#myapp/urls.pyfrom django.urls import pathfrom . import viewsurlpatterns = [ path(\"\",views.index)] 现在虽然配置了app下的路由文件，但是访问时，是看不到对应视图的结果 这是因为默认的url查找动作将会从主控路由文件开始，我们还需要在主控路由文件下进行路由分发设置 让主控路由可以找到子app下的路由映射文件 123456789#myproject/urls.pyfrom django.contrib import adminfrom django.urls import path,includefrom myapp import viewsurlpatterns = [ path('admin/', admin.site.urls), #path('',views.index) path('',include(\"myapp.urls\")), # 函数 include() 允许引用其它 URLconfs ] 接下来再次尝试，在浏览器中访问主机域名；如果可以看到的话，恭喜你，效果已经很棒了！ 路由查找流程 查找主控路由文件下的urlpatterns全局变量，这是一个序列数据类型，其中每一个元素都是对应的一个路由匹配规则 如果在规则中查找到符合匹配规则的，则执行其中的对应执行函数 如果对应的不是一个执行函数，而是一个include路由包含，那么截断与此项匹配的URL的部分，并将剩余的路由字符串发送到include所包含的子路由文件中以供进一步处理 如果没有匹配到的任何结果，django默认抛出Page not found (404) 注意：Django的路由不考虑HTTP请求方式，仅根据URL进行路由，即，只要URL相同，无论POST、GET等哪种请求方式都指向同一个操作函数 path path函数用来处理一个路由对应的视图映射 path(route, view, name) route： 匹配规则，是一个字符串 view：对应的视图函数 name：未来我们会用到他，用来为匹配规则命名，这样方便日后修改路由而不影响全局下的路由使用 re_path re_path是path函数的加强版 可以在re_path函数的第一个位置的字符串参数，是一个标准Python正则表达式，其余参数与path相同 注意：匹配模式的最开头不需要添加/，因为默认情况下，每个url都带一个最前面的/，既然大家都有的部分，就不用浪费时间特别写一个了，所以一定要注意在写路由映射关系时，记得加末尾的/ 模板页面 返回一个字符串这肯定是不行的，太low了，也不好看，现在来返回一个正式的HTML页面 并在HTML页面中加入模板变量，由视图函数动态传递值； 配置django中模板页面的保存路径，在项目目录下的settings.py文件中 12345678910111213141516#myproject/settings.pyTEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR,'template')], # 就是这一行 设置静态模板路径 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 创建template目录并在其中创建index.html文件 1234567&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;hi&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 在HTML页面中，我们并没有明确指出H1标签的内容；通过一个``来等待接收视图函数传来的数据，在HTML页面中这样的变量也叫做模板变量，双大括号为使用语法 接下来修改之前的视图函数，由视图函数传递变量给到HTML页面 12345678#myapp/views.pyfrom django.shortcuts import renderdef index(request): #return HttpResponse(\"&lt;h1&gt;Hello world&lt;/h1&gt;\") content = &#123; \"message\":\"你好，世界\" #此处的key值message对应页面中我们写的&#123;&#123; message &#125;&#125; &#125; return render(request,'index.html',content) render render函数用来返回一个模板页面，并将一个字典组合成的模板变量传递到模板页面上，完成页面的渲染 render(request, template_name, context=None) 返回一个HTTP响应 request： 固定接收request请求 template_name： 为一个可以找到的模板页面 context： 模板页面所需模板变量 模板变量 在django中的HTML页面，不光可以编写原本的标签等内容，还可以像Vue一样在页面中使用双大括号，来提前定义一些模板变量，之后动态的渲染到HTML模板页面中 模板变量可以由后台视图函数构建一个字典数据类型传递， 字典的key是模板变量名，value值该模板变量对应的数据 当然，模板变量的内容远不止此，还会再后面继续为大家叙述 静态文件 虽然有了模板页面，可以来展示一些标签的效果，但是整个HTML还是感觉很丑陋 我们还要继续引入一些类似css、img这样的静态资源，来装饰我们的页面 在django中模板页面的静态资源使用，不能像之前写HTML代码直接引入 需要我们首先在项目中创建目录保存对应的静态资源，该目录名常为static 在settings中配置静态文件保存目录，添加如下内容 12STATICFILES_DIRS = ( os.path.join(BASE_DIR, 'static'),)# STATICFILES_DIRS 该配置项用来告诉django在查找静态资源时，应该访问哪个目录 在项目中创建static目录，static目录下创建专门保存图片的img目录，在里面存一张图片1.jpg 1#此时的目录结构myproject/ myproject/ myapp/ template/ static/ img/ 1.jpg 有了图片，接下来在模板页面中去引入并使用它，打开index.html进行修 123456789&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &#123;% load staticfiles %&#125;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;hi&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt; &lt;img src='&#123;% static \"img/1.jpg\" %&#125;' alt=\"图片\"&gt; &lt;/body&gt;&lt;/html&gt; 12345&gt; 这里用到了一个特殊语法：&#123;% tag %&#125; 这个叫静态标签，静态标签不同于模板变量，静态标签经常用来加载数据，或创建逻辑，比如之后我们要学到的&#123;% if %&#125;，使用静态标签可以方便我们在模板页面上实现某些只有在后台代码中才可以实现的逻辑功能&gt; 在页面中要引入静态资源：图片，`CSS`，`JS`文件在引入时都需要通过&#123;% static “path” %&#125;来进行引入&gt;&gt; 最后，需要使用静态标签`static`前使用&#123;% load staticfiles %&#125;标签进行静态资源路径的加载 模型数据库 有了以上内容的修饰，现在感觉还是缺少一些什么，我们在视图函数中为前端页面返回的是一个提前定义好的变量，这显然在真正开发中是很少出现的，我们的数据大都来自于数据库中，那么现在需要我们在项目中加入数据库，并且在视图函数中通过对数据库的访问来拿到数据 创建数据库，这里使用项目自带的SQLite3数据库，默认已经是配置好的，接下来需要我们进入到app下的models.py文件中，编写一个类，这个类就对应数据库中的一张表 123456789#myapp/models.pyfrom django.db import models# Create your models here.class Weather(models.Model): weather = models.CharField(max_length=100,verbose_name=\"天气\") class Meta: verbose_name_plural = \"天气\" # 设置当前表名的一个可读的性更好的名字 def __str__(self): return self.weather 在这里我们使用到了django的orm映射关系用来创建数据库表，继承自django的models.Model类， 一个类用来表示一张表，类中的一个属性代表一个字段， 这里我们定义了一个类型为CharField，长度为100的字段，用来存储天气 12&gt; models.CharField(max_length=100,verbose_name=\"天气\")&gt; 下面的class Meta是模型类的元类，用来设置当前表的一些属性； 这里我们使用verbose_name_plural属性设置当前表在admin后台查看时的名字 在这里我们还定义了一个属于实例的函数__str__，用来描述当前数据在返回时的默认展示结果，为weather字段的值 12&gt; django`在创建模型类对应的数据表时，默认使用 `应用名`加`下划线`加`模型类名`作为表的名字；比如当前`Weather`表名为：`myapp_Weather&gt; orm映射关系，是django与数据库之间的一个桥梁，可以使开发者不再关注如何去编写SQL语句，直接通过一套ORM所提供的API接口即可方便对各种数据库进行交互 当某个子应用APP涉及到了数据库的使用时，要记得在settings文件中进行配置 12345678910#myproject/settings.pyINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'myapp',] 接下来通过manage.py命令行管理工具提供的两条，创建我们所需要的数据 注意：默认django本身就已经需要一些数据的创建，所以我们在初次执行以下两条命令时可能会看到很多数据表和字段的创建，不要惊讶，这是正常的 python manage.py migrate：根据数据库迁移文件生成对应SQL语句并执行 初次执行是为了先把默认django需要的数据库创建出来 python manage.py makemigrations：创建数据库迁移文件 这次执行是为了创建APP中Weather模型类的迁移文件 12&gt; python manage.py migrate&gt; 将新添加的模型类迁移文件生成对应SQL，实际创建出对应的Weather表 如果提示结果正常，那么代表相应的数据表已经创建好了，接下来就需要我们去到django为我们提供的admin（数据库管理界面）来进行相关表的操作了！ admin控制台 admin控制台是django为我们提供的一个非常便捷的用来管理数据库的界面 在主控路由文件下，其实你已经看到了它对应的路由设置：path(&#39;admin/&#39;, admin.site.urls), 进入admin界面，初次访问连接：127.0.0.1/admin，会提示我们输入账号密码，这是因为django的admin界面是需要一个超级管理员来登陆访问的，所以还需要我们创建对应的admin界面下的超级用户 创建admin超级用户，使用manage.py命令行工具执行如下命令 12python manage.py createsuperuserUsername (leave blank to use 'lienze'): rootEmail address:Password:Password (again):This password is too short. It must contain at least 8 characters.This password is too common.This password is entirely numeric.Password:Password (again):This password is too common.This password is entirely numeric.Password:Password (again):Superuser created successfully. 以上是我们创建超级用户的过程，非常坎坷； 可以看到，在输入太短（不满足8位），或是只包含数字的简单密码，超级用户的创建都是被拒绝的 所以我们把用户账号创建为root，而密码创建为a1234567， 接下来开启测试服务器，并通过创建好的超级用户登陆访问，如果幸运的话，你已经可以看到后台的admin界面啦 admin界面已经展示出了默认django所使用的两张表，用户表和组表，用来保存当前管理后台的用户以及对应权限分组，可以点入用户表查看其中我们刚创建的root。 admin注册表 问题还是有的，虽然admin界面已经可以登入，但是为什么看不到刚才创建的Weather表呢 这是因为默认的表创建之后，还需要通过对应app下的admin.py文件进行admin后台注册，只有注册在这个文件中的模型类对应的表才可以在admin界面所看到 在app下的admin.py文件中进行模型类的注册 12345#myapp/admin.pyfrom django.contrib import adminfrom myapp import modelsadmin.site.register(models.Weather)#使用register函数接收模型类作为参数即可完成注册 注册成功之后，在服务器，通过浏览器访问admin界面，就可以看到创建好的Weather表了 鼠标点击进去之后，就可以看到对应的表数据界面；右上角提供了可以添加功能的选项，试试给这个表来一些数据吧，这里我们添加了三条数据 1阴天，晴天，打雷了 视图操作模型 最终我们希望可以在视图函数中通过orm接口来访问到表中的数据，那么来打开视图文件吧：views.py 123456789#myapp/views.pyfrom django.shortcuts import renderfrom myapp import modelsdef index(request): weathers = models.Weather.objects.all() content = &#123; \"weathers\":weathers, &#125; return render(request, 'index.html', content) 光返回是不行的，虽然我们绑定到了模板版变量的字典中，但是还得修改一下对应的要渲染的HTML页面哦： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &#123;% load staticfiles %&#125; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;hi&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &#123;% for weather in weathers %&#125; &lt;p&gt;&#123;&#123; weather &#125;&#125;&lt;/p&gt; &#123;% empty %&#125; &lt;p&gt;没有任何天气&lt;/p&gt; &#123;% endfor %&#125; &lt;/body&gt;&lt;/html&gt; 12345&gt; 模板标签&#123;% for xxx in xxxs %&#125;可以用来在模板页面出迭代访问取出每一个数据&gt;&gt; 具体对于不同序列数据的访问我们会在后面详细为大家介绍&gt;&gt; &#123;% empty %&#125;标签用来判断当循环访问数据为空时要做的事情，最后循环标签要有&#123;% endfor %&#125;标签进行结束；因为`HTML`中并没有像`Python`缩进这样的方式来控制代码块。 总结 至此，我们的HELLO WORLD项目已经涵盖了django框架中的大部分常用的组件； 路由、视图、模板、静态、模型，admin 那么其中每一部分都还有很多内容等着我们去了解，在接下来的章节中我们会继续详细给大家介绍！","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Django-Views-视图层","slug":"Django-Views-视图层","date":"2019-12-09T07:43:24.816Z","updated":"2019-12-09T11:26:17.262Z","comments":true,"path":"Django-Views-视图层/","link":"","permalink":"https://cy-blogs.cn/Django-Views-视图层/","excerpt":"视图层 视图函数一般用来接收一个Web请求HttpRequest，之后返回一个Web响应HttpResponse HttpRequest 一个视图函数用来响应用户的Request请求，每个视图函数默认的第一个位置参数request用来接收用户发起请求的HttpRequest信息。 视图函数的返回值，为一个HttpResponse值，包括我们要返回给用户的HTML页面或者字符串等等，以及对应的头部字段信息","text":"视图层 视图函数一般用来接收一个Web请求HttpRequest，之后返回一个Web响应HttpResponse HttpRequest 一个视图函数用来响应用户的Request请求，每个视图函数默认的第一个位置参数request用来接收用户发起请求的HttpRequest信息。 视图函数的返回值，为一个HttpResponse值，包括我们要返回给用户的HTML页面或者字符串等等，以及对应的头部字段信息 123from django.http import HttpResponsedef index(request): return HttpResponse('Hello world') 常见请求方式 POST和GET是HTTP协议定义的与服务器交互的方法。 GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。另外，还有PUT和DELETE方法 get 常用来从指定地址请求数据； 如果需要在请求时提交某些数据，则以路由形式传递参数，查询Query字符串如下格式所示： 1https://www.baidu.com/?key=abc&amp;pos=shanxi get请求可被浏览器缓存，保存在历史记录中 get不应在使用敏感数据时使用，明文包路在请求地址中 get有长度限制 post 向指定的资源提交要被处理的数据 使用POST，提交的数据保存在HTTP协议中的消息主体部分 post请求不会被浏览器缓存 post提交数据长度无限制 post比get更加安全 request 如果说urls.py是Django中前端页面和后台程序桥梁，那么request就是桥上负责运输的小汽车，可以说后端接收到的来至前端的信息几乎全部来自于requests中 request.method 获取当前用户请求方式， 请求方式字符串为纯大写：&#39;GET&#39;、&#39;POST&#39; 如用户以get方式发起请求，对应代码中获取到的结果以及在判断时像是这样 123def index(request): if request.method == 'GET': … request.GET 当用户通过get方式请求站点，并在路由中提供了查询参数，可以通过该属性获取到对应提交的值 123456789def index(request): print(request.GET) # &lt;QueryDict: &#123;'name': ['jack'], 'id': ['1']&#125;&gt; print(type(request.GET)) # &lt;class 'django.http.request.QueryDict'&gt; name_ = request.GET.get('name') id_ = request.GET.get('id') content = '%s:%s' % (name_,id_) return HttpResponse(content) 12&gt; request.GET`是一个类似字典的数据类型：`QueryDict&gt; 其中也支持类似对字典的get或直接dict.[key]键值访问方式，当然使用get方式进行对应key获取会更好，因为get在访问不到时不会报错 如果定义了如上所示的视图函数，那么在访问连接时，我们可以通过路由传参： 1http://127.0.0.1:8000/?name=jack&amp;id=1 这里对应页面会显示的结果： 1jack:1 注意：使用GET方法在连接中进行参数提交，后台接收到的数据类型均是字符串 request.POST 获取用户以post形式提交的数据并保存在后台，为类字典数据，这里和request.GET是一个东西； 在网页中，一般我们通过html的表单进行数据的提交，POST方式可以提交空数据 因为涉及到了表单页面，所以我们先来弄一个HTML页面 12345678910&lt;body&gt; &lt;div&gt;这是一个关于POST的测试&lt;/div&gt; &lt;form action=\"/\" method=\"POST\"&gt; &#123;% csrf_token %&#125; 账号:&lt;input type=\"text\" name=\"account\"&gt; &lt;br&gt; 密码:&lt;input type=\"password\" name=\"passwd\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;/body&gt; 在模板页面中，一旦涉及到了表单提交，那么一定要注意在表单区域添加csrf_token标签进行防跨站伪造令牌的加载，否则表单数据的将被认为是无效的。 在接下来的视图函数中会使用到input标签中的name属性； name值属性维护了post的数据传入到后台时的标示，会与表单的数据组合成类字典格式 如name属性为account的输入框中输入了test，那么后台数据接收到的值类似：{&#39;account&#39;:&#39;test&#39;} 写一个视图函数用来捕获当前表单使用POST形式提交的数据： 123456789def index(request): if request.method=\"POST\": print(request.POST) print(type(request.POST)) account = request.POST.get(\"account\") passwd = request.POST.get(\"passwd\") content = \"%s:%s\" % (account,passwd) return HttpResponse(content) return render(request,\"index.html\") #在使用get形式请求时，返回表单页面 如果在表单页面中账号填写为test，密码为123456；在视图函数中捕捉到的结果为： 1&lt;QueryDict: &#123;'csrfmiddlewaretoken': ['EmyGwsVcrXI2LDkYLS9qflkUH4N7bM1nfTQxr3fsOsZlI4vJFwci7TargtYRAGl2'], 'account': ['test'], 'passwd': ['123456']&#125;&gt; 表单多值提交 在request.POST中需要注意，某些情况下，使用POST提交数据的表单数据可能是多个值，类似复选框CheckBox，直接使用request.POST.get()进行获取是有一些问题的，比如修改模板页面如下所示 1234567&lt;form action=\"/\" method=\"POST\"&gt; &#123;% csrf_token %&#125; &lt;input type=\"checkbox\" name=\"taste\" value=\"eat\"&gt;吃 &lt;input type=\"checkbox\" name=\"taste\" value=\"sleep\"&gt;睡 &lt;input type=\"checkbox\" name=\"taste\" value=\"play\"&gt;耍 &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 这是一个name值为taste的兴趣爱好采集的多选框，value值将会作为选中时，提交到后台的值，比如现在我们全选这些表单数据，那么后台接收到的值是这样的 1&lt;QueryDict: &#123;'csrfmiddlewaretoken': ['nuaLzxc2E0artYKUZiefMPv5iHTX5gLFY1sCu8wi1vrKqpVFTWh7EnlCR64Hua5k'], 'taste': ['eat', 'sleep', 'play']&#125;&gt; 但是问题接踵而至，我们发现使用get函数获取不到对应全选的整个结果，而是只拿到了选中的最后一项 request.POST.get(key, default=None) 返回对应key值的数据中的最后一个数据单独返回；key值不存在，取default 要想真正拿出所有的结果，应该使用getlist函数 request.POST.getlist(key, default=None) 将对应key值的所有数据以一个列表形式返回；key值不存在，取default request.META request.MATE获取的是一个标准的python字典。它包含了所有的HTTP请求信息 比如用户IP地址和用户Agent（通常是浏览器的名称和版本号）。 注意，Header信息的完整列表取决于用户所发送的Header信息和服务器端设置的Header信息 CONTENT_LENGTH：请求的正文的长度，字符串类型 CONTENT_TYPE：请求的正文的MIME 类型 HTTP_ACCEPT：响应可接收的Content-Type HTTP_ACCEPT_ENCODING：响应可接收的编码 HTTP_ACCEPT_LANGUAGE：响应可接收的语言 HTTP_HOST：客服端发送的HTTP Host头部 HTTP_REFERER：请求前的连接地址 HTTP_USER_AGENT：客户端的user-agent字符串 QUERY_STRING：单个字符串形式的查询字符串（未解析过的形式） REMOTE_ADDR：客户端的IP 地址 REMOTE_HOST：客户端的主机名 REMOTE_USER：服务器认证后的用户 REQUEST_METHOD：一个字符串，例如GET 或POST SERVER_NAME：服务器的主机名 SE0RVER_PORT：服务器的端口，字符串类型 request.FILES 接收用户上传文件及相关信息。同样类似于request.POST，提取到的数据为一个类字典的数据类型，包含所有文件上传的信息 f = request.FILES.get(&#39;upload_file&#39;) file_data = f.read()：读取整个上传文件的内容，适合小文件上传 yiled = f.chunks()：返回一个类似生成器（）的数据，每一次读取按块返回文件，可以通过for迭代访问其中数据；适合上传大文件到服务器。 f.multiple_chunks()：返回文件大小，当文件大小大于2.5M时，返回True，反之返回False，可以通过该函数来选择是否使用chunks方法或read直接存储。 如果想要修改这个文件判定的默认值，可以通过：FILE_UPLOAD_MAX_MEMORY_SIZE在settings文件下进行设置 f.content_type：上传文件时头部中的Content-Type字段值，参考MIME类型 f.name：上传文件名字 f.charset：上传文件编码 f.size： 上传文件大小，字节为单位：byte 创建好静态资源目录，并在下面创建一个img文件夹，保存我们即将上传的图片； 完成上传文件的HTML表单页面 123456&lt;form action=\"/\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &#123;% csrf_token %&#125; &lt;input type=\"file\" name=\"upload_file\" /&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; &lt;img src=\"&#123;% static 'img/1.jpg' %&#125;\" alt=\"这是一张图片\"&gt;&lt;!-- 这里使用的是即将要上传的文件名字，只做文件是否上传成功的简单测试 --&gt; 注意：上传文件的页面表单，一定要记得设置属性enctype=&quot;multipart/form-data&quot; 视图函数如下编写，接收上传图片，并保存在静态目录下刚才创建好的img目录中 12345678910111213def index(request): if request.method == \"POST\": f = request.FILES.get(\"upload_files\") path = os.path.join(settings.STATICFILES_DIRS[0],'img/'+f.name) # 上传文件本地保存路径 with open(path,'wb') as fp: if f.multiple_chunks: #判断到上传文件为大于2.5MB的大文件 for buf in f.chunks(): #迭代写入文件 fp.write(buf) else: fp.write(f.read()) return HttpResponse(\"Success!\") return render(request, 'index.html') 测试上传一个名为1.jpg的图片，如果成功上传，那么后台static目录下会出现该图片，并且模板页面也可以展示对应图片效果 HTTPResponse 一个视图的返回值经常是为了向用户返回一个HttpResponse响应， 有如下常用的可以返回HttpResponse的函数 response HttpResponse(content=b&#39;&#39;) 返回一个字符串内容 from django.http import HttpResponse render(request,template_name,context=None,content_type=None,status=None) 返回一个可渲染HTML页面，状态码为200 from django.shortcuts import render request：固定参数，响应的request请求，来自于参数部分接收的HttpRequest template_name：返回的模板页面路径 context：模板页面渲染所需的数据，默认为字典格式 content_type：生成之后的结果使用的MIME类型 status：响应的状态码，默认为200 redirect(to, permanent=False) 一个重定向，浏览器通过该状态码自动跳转到一个新的路由地址，默认返回响应状态码302 from django.shortcuts import redirect to：可以是一个django项目中视图函数的路由映射，也可以是一个reverse的反向路由解析 permanent：如果设置为True，将返回301状态码，代表永久重定向 1302：临时重定向，旧地址资源临时不能用了，搜索引擎只会暂时抓取新地址的内容而保存旧的地址。301：永久重定向，旧地址资源已经不复存在，搜索引擎不光会抓取新地址的内容，还会替换旧地址为新地址 视图错误处理 为了方便我们开发，django提供了一个异常叫做Http404异常，我们可以在视图函数的代码中按照需求进行抛出，抛出之后django项目会自动捕获该异常，并会展示默认的404页面 1234from django.http import Http404def index(request): if request.GET.get(\"id\") == \"1\": raise Http404 在settings中的debug配置项为false时，访问http://127.0.0.1:8000/?id=1，可以看到django为我们提供的错误页面； 除了django默认提供的，我们还可以可以在模板目录下定义全局404.html进行错误页面的定制 1&lt;h1&gt; 抱歉，找不到你要的东西&lt;/h1&gt; 自定义错误处理视图 除去404错误的自定义，django还提供了覆盖默认错误行为处理的办法； 有些时候，django自动的错误处理可能不能满足我们的需求，那么我们可以重新定义一些新的视图函数， 来覆盖掉django所提供的错误处理视图函数，最后在urls.py路由配置文件下通过定义全局变量来重新设置默认的错误处理视图函数 1234567891011handler404：覆盖page_not_found()视图。handler500：覆盖server_error()视图。handler403：覆盖permission_denied()视图。handler400：覆盖bad_request()视图from django.contrib import adminfrom django.urls import path,includeurlpatterns = [ path('admin/', admin.site.urls), path('', include(\"viewapp.urls\")),]handler404 = \"viewapp.views.error_404\"# APP.模块.视图函数handler500 = \"viewapp.views.error_500\" 相关定义好的错误处理视图函数 123456def error_404(request): return HttpResponse(\"这是404错误\")def error_403(request): return HttpResponse(\"这是403错误\")def error_500(request): return HttpResponse(\"这是500错误\")","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Django-Urls-路由层","slug":"Django-Urls-路由层","date":"2019-12-09T05:56:43.065Z","updated":"2019-12-09T11:26:14.411Z","comments":true,"path":"Django-Urls-路由层/","link":"","permalink":"https://cy-blogs.cn/Django-Urls-路由层/","excerpt":"路由层 路由是Web服务的入口，就好像办事大厅有各个服务窗口一样 Django奉行DRY主义，提倡使用简洁、优雅的URL： 可以不用.html、.php或.cgi之类后缀 尽量不要单独使用无序随机数字这样无意义的东西 让你随心所欲设计你的URL，不受框架束缚 路由urlpatterns urlpatterns是路由文件中的一个全局变量，用来存放路由及视图函数的映射关系 用户发起的请求URL都会首先进入主控制目录下的这个urls.py文件中进行查找匹配","text":"路由层 路由是Web服务的入口，就好像办事大厅有各个服务窗口一样 Django奉行DRY主义，提倡使用简洁、优雅的URL： 可以不用.html、.php或.cgi之类后缀 尽量不要单独使用无序随机数字这样无意义的东西 让你随心所欲设计你的URL，不受框架束缚 路由urlpatterns urlpatterns是路由文件中的一个全局变量，用来存放路由及视图函数的映射关系 用户发起的请求URL都会首先进入主控制目录下的这个urls.py文件中进行查找匹配 首先找到urls.py下的urlpatterns全局变量，这是一个路由规则实例的列表数据。 按照先后定义顺序，进行路由匹配。 找到第一个匹配项时停止匹配，执行匹配到的视图函数。 遍历完全，未发现匹配，django进行异常处理 其中urlpatterns中的每一个路由映射规则可以由path或re_path进行构造 注意：Django的路由不考虑HTTP请求方式，仅根据URL进行路由；即，只要URL相同，无论POST、GET等哪种请求方式都指向同一个操作函数 path path(regex, view, kwargs=None, name=None) regex：一个匹配对应url地址的规则字符串。 view：路由对应的视图函数，并且会自动封装HttpRequest作为第一个参数给这个视图函 kwargs：视图函数的关键字参数。 name：该路由的全局命名，可以让我们方便的在django项目中任意部分显示的使用，相当于为url取变量名，接下来全局使用该命名值即可；当对应url路由改变之后，结合路由反向解析使用的地方不需要更改路由 此外，django还提供了一个兼容老版本url路由配置函数的re_path函数；re_path：第一个参数部分为一个正则匹配规则，其他与path同 静态路由 静态路由用来映射对应视图函数，以下是一个简单的例子 123456from django.http import HttpResponsedef index(request): return HttpResponse('Hello Worlds!')from django.urls import path,re_pathfrom urlapp import viewsurlpatterns = [ path('',views.index), re_path(r\"^\",views.index),] 路由传参 有的时候，我们的路由设置不能一直维持一个一成不变的状态； 比如遇到一些内容翻页的场景，那么我们的连接可能是：xx.com/airticle_list/1/、xx.com/airticle_list/2/ 那么这样的路由其实对应的都应该是一个视图函数，用以展示页面内容，那么如何设计这样的路由，就要涉及到动态路由及路由传参 123def index(request,x,y): content = \"x:%s\\ny:%s\" % (x,y) return HttpResponse(content) 定义如上函数，将会接收连接中的后两部份path值作为参数，分别依次给到x和y 1234567from django.urls import path,re_pathfrom urlapp import viewsurlpatterns = [ path('&lt;int:x&gt;/&lt;str:y&gt;/',views.index), #指明类型 path(\"&lt;x&gt;/&lt;y&gt;/\",views.index) #不指明类型 re_path(r\"^(?P&lt;x&gt;\\d+)/(?P&lt;y&gt;[a-zA-Z]+)/$\"), # (?P&lt;name&gt;pattern) 正则分组 re_path(r\"^(\\d+)/([a-zA-Z]+)/$\"),] 路由通过尖括号进行分组匹配，使用int以及str内置转换器将连接对应部分的值进行转换；并将匹配到的结果传递到视图函数对应的参数位置上； 访问：http://127.0.0.1:8000/1/abc/ 其中1将作为x的参数值，abc将作为y的参数 但如果访问连接是：http://127.0.0.1:8000/abc/abc/，这会匹配到第二个路由，第二个路由没有对传递参数的类型进行限定 内置Path转换器： 1str：匹配除了路径分隔符（`/`）之外的非空字符串，这是默认的形式int：匹配正整数，包含0slug：匹配字母、数字以及横杠、下划线组成的字符串uuid：匹配格式化的uuid，如 075194d3-6885-417e-a8a8-6c931e272f00path：匹配任何非空字符串，包含了路径分隔符 自定义转换器 除了以上django所提供的path转换器，如果还觉得无法实现我们想要的功能，我们可以通过编写一个类进行自定义path转换器 定义转换器类，类名随意 定义类中必须属性 regex：一个字符串形式的正则表达式，也是对应的路由规则 to_python(self, value)：用于将匹配到的路由字符串转换为Python中的数据类型，并传递给视图函数，如果转换失败，必须抛出ValueError，路由映射视图函数时使用 to_url(self, value)：将Python数据类型转换为一段url的方法，to_python方法的反向操作，反向解析时使用 通过django.urls模块中的register_converter函数进行注册 12函数第一个参数为转换器类函数第二个参数为转换器别名 以下定义一个路由参数只能是三位字符的路由规则 12345678910111213#先将转换器类定义class ThreeChar: regex = \"[a-zA-Z]&#123;3&#125;\" def to_python(self,value): print(\"to_python\") return str(value) def to_url(self,value): # 当通过反向路由解析时，将会调用该函数 print('to_url') return str(value)[:3] #此处切片操作是为了当反向路由解析传参字符串长于3时，可以将其截断，符合转换器正则规则#注册转换器 from django.urls import register_converterregister_converter(ThreeChar,'tc')urlpatterns = [ path('&lt;tc:x&gt;/&lt;tc:y&gt;/',views.index)]#127.0.0.1:8000/aaa/bbb/ 接下里，通过路由进行访问该视图映射时，一定是三个字符所组成的路由才可以，否则是访问不到的 123456#urls.pyapp_name = \"app\"path('&lt;tc:x&gt;/&lt;tc:y&gt;/', views.index, name=\"threechr\")#views.pyreturn redirect(reverse(\"app:threechr\",args=('aaaa','bbbb')))#此时会调用three路由规则中的tc转换器中的to_url反向合成路由，并切片只取参数前三位 路由分发 我们的路由编写都是在项目主要目录下的urls.py文件中，但是如果app有很多的话，这么多路由都写到一起，明显是一件很不方便管理的事情 其实在之前的练习中，我们使用的方式均是路由分发，每个子app都拥有自己独立的urls.py路由映射文件，而主控路由文件里只需要使用include函数导入子app下路由文件即可，这就是路由分发 123456from django.contrib import adminfrom django.urls import path,includeurlpatterns = [ path('admin/', admin.site.urls), path('',include(\"urlapp.urls\")) # 使用include 实现路由分发，找到子app下的路由文件 ] 路由分发为我们带来的好处有很多，可以让我们在多个app的项目中更加方便有效的管理每一个路由 并且也可以让我们的用户在访问时看到浏览器中的URL地址更加赏心悦目 路由反向解析 到了这里，思考一下，之前我们已经设置过了很多路由； 但是现在会出现一个问题，比如我们把其中某个路由规则进行了修改，把aaa换成了aba，那么现在我们需要回到每一个使用到这个路由的地方进行同步修改，这显然非常麻烦的，如果修改的路由更多，这甚至是一个灾难 django也为我们提供了一个解决办法，通过为路由映射使用name参数，来为每一个路由映射设置一个独立唯一的变量名 12345path('left/&lt;str:x&gt;/',views.left, name=\"left\"),path('right/&lt;int:x&gt;/',views.right, name=\"right\"),# 通过正则命名分组方式re_path(r'^left/([a-zA-Z]+)/$',views.left,name=\"left\"),re_path(r'^right/(?P&lt;x&gt;\\d+)/$',views.right, name=\"right\") 两个视图函数对应如下： 12345678def left(request,x): # x: str content = &#123; 'message':x, &#125; return render(request, \"left.html\", content)def right(request,x): # x: int content = &#123; 'message':x, &#125; return render(request, \"right.html\",content) 两个HTML页面 1234567&lt;p&gt;我是左页面&lt;/p&gt;&lt;p&gt;路由参数: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;a href=\"&#123;% url 'right' 123 %&#125;\"&gt;右页面&lt;/a&gt;&lt;!-- ------另一个页面------ --&gt;&lt;p&gt;我是右页面&lt;/p&gt;&lt;p&gt;路由参数: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;a href=\"&#123;% url 'left' 'abc' %&#125;\"&gt;右页面&lt;/a&gt; 1&gt; 在模板页面中，对于已命名路由可以通过&#123;% url “name” “arg” %&#125;模板标签进行反向解析 参数以空格隔开，在标签后传入 视图函数反向解析 12def index(request): return redirect(reverse(\"left\",args=('aaa',) )) 在视图函数中需要使用到路由命名时，进行反向解析需要我们通过django.shortcuts模块下的reverse函数 reverse(viewname,args=None,kwargs=None) 1参数介绍viewname：视图函数、命名路由映射、或视图函数路径的字符串args：元组形式路由传参。kwargs：字典形式路由传参 命名空间 如果想在多个app下使用相同的name路由命名，那么我们可以通过路由分发过程中的include函数来指定不同app所属的命名空间 ​123456from django.contrib import adminfrom django.urls import path,includeurlpatterns = [ path('admin/', admin.site.urls), path('app1/',include((\"app1.urls\",'app1'))), #直接传递一个元祖，元祖第一个值为分发路由地址，第二个值为命名空间 path('app2/',include((\"app2.urls\",'app2')))] 当为每个app的路由分发映射设置了命名空间，接下来在模板页面以及视图函数对路由的反向解析将是如下所示的样子，路由解析前加冒号指明命名空间 123def index(request): return redirect(reverse(\"app1:left\"))&lt;a href=\"&#123;% url 'app2:left' %&#125;\"&gt;app2:left&lt;/a&gt; 应用命名空间：app_name 使用app_name指明命名空间，在子app的urls.py文件下配置全局变量app_name，这个值是唯一的 在这个路由文件中定义的其他映射关系，将具有命名空间app1 1app_name = \"app1\" # 这个值应该是唯一的urlpatterns = [ ...] 实例命名空间：namespace 当有多个子app同时引入同一个子路由映射文件，比如这样 12345from django.contrib import adminfrom django.urls import path,includeurlpatterns = [ path('admin/', admin.site.urls), path('app1/',include(\"app1.urls\")), path('app2/',include(\"app1.urls\"))] 这就会出现一个问题，不同的路由访问在做路由反向解析时，会造成混淆， 此时需要给每一个路由分发的规则设置namespace属性，为实例进行命名空间 123from django.contrib import adminfrom django.urls import path,includeurlpatterns = [ path('admin/', admin.site.urls), path('app1/',include(\"app1.urls\",namespace=\"app1\")), path('app2/',include(\"app1.urls\",namespace=\"app2\"))] 这样做的好处，可以在不同路由导向同一app下时，为他们的不同命名空间； 虽然看起来到最后执行的视图函数功能是一样的，但可以分清楚究竟是哪个路由引起视图函数在工作 接下来视图及模板页面中使用namespace的值 12345678910111213141516&lt;p&gt; 我是左页面&lt;/p&gt;&lt;p&gt; 路由参数: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;a href=\"&#123;% url 'app1:right' 123 %&#125;\"&gt;app1的右页面&lt;/a&gt;&lt;p&gt;我是右页面&lt;/p&gt;&lt;p&gt;路由参数: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;a href=\"&#123;% url 'app1:left' 'abc' %&#125;\"&gt;app1的左页面&lt;/a&gt;&lt;!-- ----------------------------------------- --&gt;&lt;p&gt;我是左页面&lt;/p&gt;&lt;p&gt;路由参数: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;a href=\"&#123;% url 'app2:right' 123 %&#125;\"&gt;app2的右页面&lt;/a&gt;&lt;p&gt;我是右页面&lt;/p&gt;&lt;p&gt;路由参数: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;a href=\"&#123;% url 'app2:left' 'abc' %&#125;\"&gt;app2的左页面&lt;/a&gt;","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Django-Models-模型层","slug":"Django-Models-模型层","date":"2019-12-03T08:05:23.931Z","updated":"2019-12-09T11:26:11.153Z","comments":true,"path":"Django-Models-模型层/","link":"","permalink":"https://cy-blogs.cn/Django-Models-模型层/","excerpt":"模型层 该层开发的首要任务就是定义模型类以及属性 每个模型都可以被映射为数据库中的一个数据表，而类属性被映射为为数据字段 配置Mysql数据库 在确保mysql数据库可以连接使用的情况下； 首先在数据库中创建专为django使用的库django_data 1create database django_data;","text":"模型层 该层开发的首要任务就是定义模型类以及属性 每个模型都可以被映射为数据库中的一个数据表，而类属性被映射为为数据字段 配置Mysql数据库 在确保mysql数据库可以连接使用的情况下； 首先在数据库中创建专为django使用的库django_data 1create database django_data; 配置django的settings.py文件中的DATABASES属性如下 12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', # 数据库引擎 'NAME': \"django_data\", # 使用的库名 \"USER\": \"root\", # 用户名 \"PASSWORD\": \"123456\", # 数据库密码 \"HOST\": \"localhost\", # 数据库主机地址 \"PORT\": \"3306\" &#125;&#125; 由于使用django的Python版本为3+； 此时对于mysql的支持已经变为pymysql，而对于django加载数据库引擎时还需要使用2版本的mysqldb名称 现在先需要我们安装pymysql之后在项目中重申mysql引擎 首先安装pymysql 1pip install pymysql -i https://pypi.tuna.tsinghua.edu.cn/simple 项目主目录下的__init__文件中添加如下内容 12import pymysqlpymysql.install_as_MySQLdb() 现在整个项目的数据库使用已经切换到了mysql 模型层字段 在模型层类中的字段即是数据库中表的字段，表的字段设计非常重要 每一个字段都是Field基类的一个实例（Field类用来建立字段与数据库之间的映射） 模型字段定义不能以下划线结尾 django会根据在模型类中定义的字段属性来确定以下几点工作 数据库中使用的数据类型 模型类对应的表单类渲染时使用的表单类型及HTML部件 必填字段等最低限度的验证要求检查，包括admin界面下自动生成的表单 BooleanField BooleanField(**options)：True/False字段，默认值为None 表单类型：CheckboxInput，`` CharField CharField(max_length=None)：字符串字段 含有一个必须参数：max_length设置最大的字符数长度限制； 表单类型：TextInput，`` DateField DateField(auto_now=False, auto_now_add=False,**options)：以 datetime.date实例表示的日期 含有两个可选参数：auto_now、auto_now_add auto_now：该值为True时，每次在保存数据对象时，自动设置该字段为当前时间，也可以理解为自动更新最后一次修改时间 auto_now_add：该值为True时，该字段设置在第一次数据对象创建时，可以记录当前字段创建的时间值 注意：避免矛盾，auto_now，auto_now_add，default不能同时出现，一个字段属性只能有其中一条设置，当设置了auto_now，或auto_now_add时，也会让该字段默认具有blank=True（字段可以为空）属性 表单类型：TextInput，`` DatetimeField DatetimeField(auto_now=False, auto_now_add=False,**options)：以datetime.datetime实例表示的日期和时间 和DateField具有相同的字段属性 DecimalField DecimalField(max_digits=None,decimal_places=None, **options)：以Decimal实例标示的十进制浮点数类型 含有两个可选参数：max_digits、decimal_places max_digits：位数总数，包括小数点后的位数，必须大于decimal_places参数 decimal_places：小数点后的数字数量，精度 表单类型：TextInput，`` EmailField EmailField(max_length=254, **option)：CharField子类，表示Email字段，并会检查是否为合法邮箱地址 默认参数：max_length，表示邮箱地址长度，默认为254 表单类型：TextInput，`` FloatField FloatField(**options)：使用float实例来表示的浮点数 表单类型：TextInput，`` IntegerField 12&gt; IntegerField(**options)`：一个整数，范围由`-2147483648`到`2147483647&gt; GenericIPAddressField GenericIPAddressField(protocol=both, unpack_ipv4=False, **options)：一个IPV4或IPV6地址的字符串 默认参数：protocol、unpack_ipv4 protocol：IP协议，ipv4或ipv6，默认both为全选 unpack_ipv4：解析IP地址，只有当协议为both时才可以使用 表单类型：TextInput，`` SlugField SlugField(max_length=50, **option)：只包含字母、数字、下划线的字符串，常用来表示连接中的path部分或者一些其他短标题类型数据 TextField TextField(**options)：大文本字段 表单类型：Textarea，... URLField URLField(max_length=200, **options)：CharField的子类，存储URL的字段 表单类型：TextInput，`` 字段属性 以上所介绍的字段，均支持以下属性 null 如果该值为True，Django将在数据库中将控制存储为NULL 字符串字段CharField与TextField要避免使用null，因为空值字符串将存储空字符串（””）,而不是null值。 对于字符串类型的数据字段，大多数情况下，django使用空字符串代表空值 blank 如果该值为True，则在验证时该字段值可以为空； null为数据库存储层面可以为空，而blank为表单验证层面可以填写空值 choices 一个二元组的列表或元组； 元组中第一个值为真正在数据库中存储的值，第二个值为该选项的描述 该值一旦被设定，表单样式会显示选择框，而不是标准的文本框，选择框内的选项为choices中的元组 1234567class TestTable(models.Model): CHAR_CHOICE = [ ('H',\"非常苦难\"), ('M',\"中等难度\"), ('S',\"非常简单\"), ] choicechar = modesl.CharField(max_length=1,choices=CHAR_CHOICE) choices字段也支持分类的写法 1234567891011CHAR_CHOICE = [ ('A', ( ('H',\"Hard\"), ) ), ('B', ( ('M',\"Medium\"), ) ), … ] 分类的名称作为元组中的第一个值， 元组的第二个值为该分类下的一个新的二元组序列数据 db_column 数据库中用来表示该字段的名称，如果未指定，那么Django将会使用Field名作为字段名 db_index 当该值为True时，为该字段创建索引 default 该字段默认值，可以是一个值或是一个回调函数 当是一个函数对象时，在创建新对象时，函数调用 editable 如果设置该值为False，那么这个字段将不允许被编辑 不会出现在admin后台界面下，以及其他ModelForm表单中，同时也会跳过模型验证 primary_key 设置该值为True时，该字段成为模型的主键字段，一个模型类同时只能有一个主键 如果一个表中不存在任意一个设置好的主键字段，django会自动设置一个自增的AutoField字段来充当主键，该值可以用pk，id方式获取。主键的设置还意味着，null=False，unique=True unique 如果该值为True，代表这个数据在当前的表中有唯一值 这个字段还会在模型层验证存储的数据是否唯一 unique的设置也意味着当前字段具备索引的创建 ManyToManyField、OneToOneField与FileField字段不可以使用该属性 verbose_name 对于字段的一个可读性更高的名称 如果没有设置该值，django将字段名中的下换线转换成空格，作为当前字段的数据库中名称 模型元属性 在模型类的Meta类中，可以提供一系列的元选项，可以方便对该模型类进行属性设置或约束等 12345class TestTable(models.Model): … class Meta: ordering = [Fields] … abstract 代表当前模型类为抽象基类，不会创建真正的数据表，只是为了其他模型类继承使用 1abstract = True app_label 当模型类被定义在了其他app下，这个属性用来描述当前表属于哪个app应用 1app_label = \"MyApp\" db_table 当前模型类所对应的表名，未设置时，django默认将表名与app名由下划线组成，作为表名 需要注意这个表名为真实在数据库中所使用的，所以该元选项的使用应在数据表创建之前 如果在表已经存在的情况下去修改，会导致数据库内表与模型类表名不一致而查找不到报错 ordering 当前表中的数据存储时的排序规则，这是一个字段名的字符串，可以是一个列表或元组； 每一个字符串前可以使用”-“来倒序排序，使用”?“随机排序 ordering排序规则的添加，也会增加数据库的开销 12ordering = ['-birthday', 'age']#先按照birthday倒序排序，再按照age字段进行排序。 unique_together 用来设置表中的不重复字段组合 格式为一个元组，元组中的每个数据都是一个元组，用来描述不重复的组合字段 如果只处理单一字段组合，可以是一个一维的元组 联合约束 1unique_together = (('name','phone'),) verbose_name 一般设置该表展示时所用的名称，名称被自动处理为复数，字符串后加一个”s” verbose_name_plural 与verbose_name功能相同，但是不会自动在字符串后加”s“以表复数 设置表的复数名称 模型操作 在进行模型操作的学习之前，可以先创建一个测试的数据库模型类，如下所示 123class Person(models.Model): name = models.CharField(max_length=10,verbose_name=\"姓名\") age = models.IntegerField(verbose_name=\"年龄\") 创建对象 django自带了一个数据库测试的shell工具 这是一个非常方便可以让我们对django代码进行测试的环境 可以直接通过python manage.py shell命令行管理工具来打开 实例save创建数据 通过模型类的关键词参数实例化一个对象来进行数据的创建 123&gt;&gt;&gt; from app.models import Person&gt;&gt;&gt; p1 = Person(name='张三',age=15)&gt;&gt;&gt; p1.save() 以上的代码，在为字段赋予值之后，通过实例的save函数进行该数据的保存 在数据库底层执行了SQL语句中的insert操作，并且，在我们显示调用save之前，django不会访问数据库，实例数据只存在于内存中 注意：save函数没有返回值 create方法创建数据1&gt;&gt;&gt; P1 = Person.objects.create(name='李四',age=20) 这条语句创建一条数据，并且返回一个数据在内存中的实例P1 之后可以通过这个实例字段P1对数据库中该条数据进行修改或删除操作 create 方法一步到位，save方式可以慢悠悠的赋予字段值，最后赋予结束再save 查找对象 接下来，我们将通过模型类中的管理器进行数据的查询； 管理器（Manager）是每一个模型类所具有的，默认名为objects 模型类通过模型类调用orm数据接口，其实就是在对数据表进行操作。 注意，具体的某一条数据无法访问这个管理器 all() 获取一个表中的所有数据，返回QuerySet数据对象 1all_person = Person.objects.all() filter(**kwargs) 返回一个包含数据对象的集合，满足参数中所给的条件 12res = Person.objects.all().filter(age__lt=16)res = Person.objects.filter(age__lt=16) 我们在查询过程中，除了直接使用字段属性进行验证 还可以在字段名之后使用双下化线来标明更加详细的字段筛选条件（在下一节会有详细的字段筛选条件介绍），也叫做链式过滤 这也是为什么表单类字段不可以以下换线结尾的原因 exclude(**kwargs) 返回一个包含数据对象的集合，数据为不满足参数中所给的条件 filter()查询会始终返回一个结果集，哪怕只有一个数据。 但是有些时候，我们对于一些在数据表中的唯一数据进行查询时，可以使用更加合适的get方法 注意：创建结果集的过程不涉及任何数据库的操作，查询工作是惰性的，在上面的查询方式中，查询代码不会实际访问数据库，只有查询集在真正使用时，django才会访问数据库 get(**kwargs) 获取唯一单条数据 get获取数据只会返回一条匹配的结果，获取的数据只能在数据库中有一条 如果返回多个结果，会引发MultipleObjectsReturned异常 如果没有任何匹配到的结果也会引发DoesNotExist异常 1Person.objects.get(pk=1) order_by(*field) 默认情况下，数据表使用模型类中的Meta中指定的ordering选项进行排序 现在也可以通过使用order_by函数进行查询结果的排序 1Person.objects.order_by('age') 1Person.objects.all().order_by('-age') count() 返回数据库中对应字段的个数，并且该函数永远不会引发异常 1models.Person.objects.filter(age=20).count()Person.objects.count() 使用count函数时，还需要对数据表进行迭代访问 所以有时使用已生产好的结果集，通过len函数获取长度，这种方式效率会更高 count方法的调用会导致额外的数据库查询 values(*fields) 返回一个查询集结果，但是迭代访问时返回的是字典，而不是数据实例对象 1models.Person.objects.all().values()models.Person.objects.values() 链式过滤条件 exact 如果在查询过程中，没有提供查询类型（没有双下划线），那么查询类型就会被默认指定为exact，这是一种严格查找的方式，用来在数据库中查找和查询时的关键词参数完全一致的内容 12&gt;&gt;&gt; Person.objects.filter(account='root')&gt;&gt;&gt; Person.objects.filter(account__exact='root') iexact 忽略大小写的匹配 12&gt;&gt;&gt; Person.objects.filter(account__iexact='root')#匹配到的结果可能是Root，ROot，ROOt，ROOT startswith、endswith 分别匹配开头和结尾，区分大小写 12&gt;&gt;&gt; Person.objects.filter(passwd__startswith='admin')#匹配以admin开头的数据 istartswith、iendswith 分别匹配开头和结尾，忽略大小写 1&gt;&gt;&gt; Person.objects.filter(passwd__istartswith='admin')匹配以不区分大小写的字符串admin为开头的数据 gte 大于或等于 1&gt;&gt;&gt; Person.objects.filter(reg_data__gte=datetime.date.today) lte 小于或等于 1&gt;&gt;&gt; Person.objects.filter(reg_data__lte=datetime.date.today) 修改对象 获取到对应的数据实例之后，通过.的方式访问数据实例中的属性，进行数据的字段修改 1p = models.Person.objects.get(pk=1)p.age = 21p.save() 对过滤出的结果链式调用update()函数，这样的修改，类似批量修改，update函数会返回成功修改的个数 1models.Person.objects.filter(age__gt=100).update(age=25)# 将所有年纪小于100的人的年纪改为20 删除对象 对于普通的单表数据删除，获取到数据实例对象后调用内置的delete()函数即可 1models.Person.objects.get(pk=1).delete() 需要注意的是，删除一条数据之后，默认占有的主键ID值并不会被下一个新插入的值所占用 比如 1，2，3，4；删除掉3之后，剩下：1，2，4；下一个值存储时，id是5，3不会被复用 字段关系 字段关系是django维护表关系的方式；其中主要有一对一，多对一以及多对多， 现在的一对一及多对一关系中需要设置on_delete属性用来描述当关联数据被删除时的操作，有如下一些 models.CASCADE：删除关联数据,与之关联也删除 models.PROTECT：删除关联数据,引发错误ProtectedError models.SET_NULL：与之关联的值设置为null（前提FK字段需要设置为可空） models.SET_DEFAULT： 删除关联数据,与之关联的值设置为默认值（前提FK字段需要设置默认值） models.DO_NOTHING：删除关联数据,什么也不做 一对一关系 模型类使用OneToOneField用来定义一对一关系； 比如当你拥有一个老师表时，紧接着你还需要一个教授表，那么教授表可能拥有老师表的一系列属性，那么你还不想把老师表中的字段直接复制到教授表那么可以通过OnToOneField来实现教授表继承老师表。 其实，在使用模型类继承时，也隐含有一个一对一关系 OneToOneField(to, on_delete, parent_link=False, options) 12345678class Teacher(models.Model): name = models.CharField(max_length=50) age = models.CharField(max_length=50) def __str__(self): return self.nameclass Professor(models.Model): teacher = models.OneToOneField(Teacher,primary_key=True,on_delete=models.CASCADE) big_project = models.CharField(max_length=50) def __str__(self): return self.teacher.name 在manage.py shell下进行数据库操作 1234567&gt;&gt;&gt; t1 = Teacher.objects.create(name='Jack',age='22')&gt;&gt;&gt; t2 = Teacher.objects.create(name='Bob',age='17')&gt;&gt;&gt; p1 = Professor.objects.create(teacher=t1,big_project='雾霾净化术')&gt;&gt;&gt; p1.teacher&lt;Teacher: Jack&gt;&gt;&gt;&gt; p1.teacher = t2&gt;&gt;&gt; p1.save()&gt;&gt;&gt; p1.teacher&lt;Teacher: Bob&gt; 在上面的测试中，看似已经将p1对应的教授变成了Bob； 但是在数据库中之前t1老师所对应的教授信息还存在，此时的赋值操作并不会覆盖掉教授他之前的教授数据，只是重新创建了一条。 正确的做法应该是将某一条数据的一对一关系通过delete关系先删除之后再重新赋予 多对一关系 Django使用django.db.models.ForeignKey定义多对一关系。 ForeignKey需要一个位置参数：与该模型关联的类 生活中的多对一关系：班主任，班级关系。一个班主任可以带很多班级，但是每个班级只能有一个班主任 12345678910111213class Headmaster(models.Model): name = models.CharField(max_length=50) def __str__(self): return self.nameclass Class(models.Model): class_name = models.CharField(max_length=50) teacher = models.ForeignKey(Headmaster,null=True,on_delete=models.SET_NULL) def __str__(self): return self.class_name&gt;&gt;&gt; H1 = Headmaster(name='渔夫')&gt;&gt;&gt; H1.save()&gt;&gt;&gt; H1&lt;Headmaster: 渔夫&gt;&gt;&gt;&gt; H2 = Headmaster(name='农夫')&gt;&gt;&gt; H2.save()&gt;&gt;&gt; Headmaster.objects.all()[&lt;Headmaster: 渔夫&gt;, &lt;Headmaster: 农夫&gt;] 以上创建了两条老师数据 由于我们设置外键关联可以为空null=True,所以此时在班级表创建时，可以直接保存，不需要提供老师数据 12345678&gt;&gt;&gt; C1 = Class(class_name='一班')&gt;&gt;&gt; C2 = Class(class_name='二班')#如果外键设置不为空时，保存会引发以下错误# IntegrityError: NOT NULL constraint failed: bbs_class.teacher_id&gt;&gt;&gt; C1.teacher = H1&gt;&gt;&gt; C2.teacher = H2&gt;&gt;&gt; C1.save()&gt;&gt;&gt; C2.save() 将老师分配个班级之后，由于班级表关联了老师字段，我们可以通过班级找到对应老师 虽然老师表中没有关联班级字段，但是也可以通过老师找到他所带的班级，这种查询方式也叫作关联查询 通过模型类名称后追加一个’_set’，来实现反向查询 1&gt;&gt;&gt; H1.class_set.all()&lt;QuerySet [&lt;Class: 一班&gt;]&gt; 由于我们这是一个多对一的关系，也就说明我们的老师可以对应多个班级 我们可以继续给H1老师分配新的班级 1234&gt;&gt;&gt; C3 = Class(class_name='三班')&gt;&gt;&gt; C3.teacher = H1&gt;&gt;&gt; C3.save()&gt;&gt;&gt; H1.class_set.all()[&lt;Class: 一班&gt;, &lt;Class: 三班&gt;] 一个班级只能对应一个老师，外键是唯一的，那么你在继续给C1班级分配一个新的老师时，会覆盖之前的老师信息，并不会保存一个新的老师 123456&gt;&gt;&gt; H3 = Headmaster(name='伙夫')&gt;&gt;&gt; H3.save()&gt;&gt;&gt; C1.teacher&lt;Headmaster: 渔夫&gt;&gt;&gt;&gt; C1.teacher=H3&gt;&gt;&gt; C1.save()&gt;&gt;&gt; C1.teacher&lt;Headmaster: 伙夫&gt; 把这个班级的老师删除，由于设置了外键字段可以为null，此时班级的老师选项为null 12345678910&gt;&gt;&gt; t1 = Headmaster.objects.all().first()&gt;&gt;&gt; t1&gt;&gt;&gt; c1 = Class.objects.all().first()&lt;Headmaster: 渔夫&gt;&gt;&gt;&gt; c1&lt;Class: 一班&gt;&gt;&gt;&gt; c1.teacher&lt;Headmaster: 渔夫&gt;&gt;&gt;&gt; t1.delete()(1, &#123;'modelsapp.Headmaster': 1&#125;)&gt;&gt;&gt; c1 = Class.objects.all().first()&gt;&gt;&gt; c1&lt;Class: 一班&gt;&gt;&gt;&gt; c1.teacher&gt;&gt;&gt; #这里什么都没有，因为此时C1的老师已经是个None了 要记得删除之后要重新获取一次数据，否则查看到的结果中还是之前获取到的有老师的班级数据 多对多关系 多对多关系在模型中使用ManyToManyField字段定义 多对多关系可以是具有关联，也可以是没有关联，所以不需要明确指定on_delete属性 生活中，多对多关系：一个音乐家可以隶属于多个乐队，一个乐队可以有多个音乐家 12345678class Artist(models.Model): artist_name = models.CharField(max_length=50) def __str__(self): return self.artist_nameclass Band(models.Model): band_name = models.CharField(max_length=50) artist = models.ManyToManyField(Artist) def __str__(self): return self.band_name 创建音乐家以及乐队 12345&gt;&gt;&gt; from bbs.models import Artist,Band&gt;&gt;&gt; A1 = Artist.objects.create(artist_name='Jack')&gt;&gt;&gt; A2 = Artist.objects.create(artist_name='Bob')&gt;&gt;&gt; B1 = Band.objects.create(band_name='FiveMonthDay')&gt;&gt;&gt; B2 = Band.objects.create(band_name='SHE') 创建出两个乐队之后对其进行音乐家的添加 多对多字段添加时，可以使用add函数进行多值增加 12&gt;&gt;&gt; B1.artist.add(A1,A2)&gt;&gt;&gt; B2.artist.add(A2) B1乐队含有A1,A2两名成员 B2乐队含有A1成员 12&gt;&gt;&gt; B1.artist.all()[&lt;Artist: Bob&gt;, &lt;Artist: Jack&gt;]&gt;&gt;&gt; B2.artist.all() [&lt;Artist: Jack&gt;] 可以在音乐家表中查找某个乐家属于哪些乐队 12345&gt;&gt;&gt; Band.objects.filter(artist=A1) # 这里使用的是我们模型类来进行查找。[&lt;Band: SHE&gt;, &lt;Band: FiveMonthDay&gt;] # A1乐家属于，SHE以及FiveMonthDay&gt;&gt;&gt; Band.objects.filter(artist=A2)[&lt;Band: SHE&gt;] 也可以查找这音乐家在哪个乐队 1234&gt;&gt;&gt; A1.band_set.all() # 直接通过具体数据对象进行查找[&lt;Band: SHE&gt;, &lt;Band: FiveMonthDay&gt;]&gt;&gt;&gt; A2.band_set.all()[&lt;Band: SHE&gt;] 多对多关联字段的删除，要使用remove来进行关系的断开 而不是直接使用delete，remove只会断开数据之间的联系，但是不会将数据删除 现在在B1乐队中删除A1乐家 12&gt;&gt;&gt; B1.artist.remove(A1)&gt;&gt;&gt; B1.artist.all()&lt;QuerySet [&lt;Artist: Bob&gt;]&gt; 关联表的查询 如果想要查询的字段在关联表，则使用表名小写__字段来进行跨表查询操作 创建一个多对一关系的父子表，一个父亲可能有多个儿子 123456789class Father(models.Model): name = models.CharField(max_length=30) age = models.CharField(max_length=30) def __str__(self): return self.nameclass Son(models.Model): father = models.ForeignKey(Father,on_delete=models.CASCADE) name = models.CharField(max_length=30) def __str__(self): return self.name 创建数据 12345&gt;&gt;&gt; f1 = Father.objects.create(name='Jack',age='30')&gt;&gt;&gt; s1 = Son.objects.create(name='Json',father=f1)&gt;&gt;&gt; s2 = Son.objects.create(name='Json2',father=f1)&gt;&gt;&gt; f2 = Father.objects.create(name='Bob',age='40')&gt;&gt;&gt; s3 = Son.objects.create(name='Json3',father=f2) 查询所有父亲名字是jack的孩子 1&gt;&gt;&gt; Son.objects.filter(father__name__exact='Jack')[&lt;Son: Json&gt;, &lt;Son: Json2&gt;] 查询所有儿子名开头为J的父亲 1&gt;&gt;&gt; Father.objects.filter(son__name__startswith='J')[&lt;Father: Jack&gt;, &lt;Father: Jack&gt;, &lt;Father: Bob&gt;] 获取到某一个父亲的所有孩子，通过某一条数据的小写表名_set反向查询 1&gt;&gt;&gt; f1.son_set.all()&gt;&gt;&gt; [&lt;Son: Json&gt;, &lt;Son: Json2&gt;] 数据的反向查询 默认的，当有某一条数据获取到之后，我们可以通过模型类名称加上一个 _set，来实现反向查询 现在设计两个表为军队和士兵表，并且士兵多对一关联军队 12345678class Aramy(models.Model): name = models.CharField(max_length=30) def __str__(self): return self.nameclass Soldier(models.Model): aramy = models.ForeignKey(Aramy,on_delete=models.CASCADE) name = models.CharField(max_length=30) def __str__(self): return self.name 创建一些数据 1&gt;&gt;&gt; a1 = Aramy(name='一军')&gt;&gt;&gt; a1.save()&gt;&gt;&gt; s1 = Soldier(name='张三',aramy=a1)&gt;&gt;&gt; s1.save()&gt;&gt;&gt; s2 = Soldier(name='李四',aramy=a1)&gt;&gt;&gt; s2.save() 通过soldier_set我们就可以关联到对应的士兵表 并且对应返回结果可以执行我们常用的filter，exclude等查询操作 12&gt;&gt;&gt; a1.soldier_set.all()[&lt;Soldier: 张三&gt;, &lt;Soldier: 李四&gt;]&gt;&gt;&gt; a1.soldier_set.filter(name='张三')[&lt;Soldier: 张三&gt;] 也可以通过定义关联字段中的related_name值，来实现自定义的反向查询名字 且related_name的值必须唯一 1234567class Aramy(models.Model): name = models.CharField(max_length=30) def __str__(self): return self.nameclass Soldier(models.Model): aramy = models.ForeignKey(Aramy,on_delete=models.CASCADE,related_name='soldier') name = models.CharField(max_length=30) def __str__(self): return self.name 接下来通过某条数据反向查询 123&gt;&gt;&gt; a1 = Aramy.objects.all()[0]&gt;&gt;&gt; s1 = Soldier.objects.get(name='张三')&gt;&gt;&gt; a1.soldier.all()[&lt;Soldier: 张三&gt;, &lt;Soldier: 李四&gt;] 注意：related_name一定是一个唯一的值，否则反向查找时会出现二异性错误 也可以将related_name初始化为+，来取消反向查询","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Cookie和Session","slug":"Cookie和Session","date":"2019-10-26T03:24:15.603Z","updated":"2019-12-09T11:25:59.925Z","comments":true,"path":"Cookie和Session/","link":"","permalink":"https://cy-blogs.cn/Cookie和Session/","excerpt":"Cookie和Session Cookie及Session一直以来都是Web开发中非常关键的一环，因为HTTP协议本身为无状态，每一次请求之间没有任何状态信息保持，往往我们的Web服务无法在客户端访问过程中得知用户的一些状态信息，比如是否登录等等；那么这里通过引入Cookie或者Seesion来解决这个问题。","text":"Cookie和Session Cookie及Session一直以来都是Web开发中非常关键的一环，因为HTTP协议本身为无状态，每一次请求之间没有任何状态信息保持，往往我们的Web服务无法在客户端访问过程中得知用户的一些状态信息，比如是否登录等等；那么这里通过引入Cookie或者Seesion来解决这个问题。 当客户端访问时，服务端会为客户端生成一个Cookie键值对数据，通过Response响应给到客户端。当下一次客户端继续访问相同的服务端时，浏览器客户端就会将这个Cookie值连带发送到服务端。 Cookie值存储在浏览器下，一般在你的浏览器安装目录的Cookie目录下，我们也可以通过F12或者各种浏览器的开发者工具来获取到 因为cookie是保存在浏览器中的一个纯明文字符串，所以一般来说服务端在生成cookie值时不建议存储敏感信息比如密码 Cookie 在django的代码中，我们可以使用一些提供Response响应的类，如：HttpResponse，redirect等实例的内置set_cookie函数来进行django项目中的Cookie设置 set_cookie(key, value=&#39;&#39;, max_age=None, expires=None, path=&#39;/&#39;,domain=None, secure=False, httponly=False) key：Cookie的key值，未来通过该key值获取到对应设置好的Cookie。 value=&#39;&#39;：对应Cookie的key值的value，比如：set_cookie(key=&#39;value&#39;,value=&#39;shuai&#39;) max_age=None：Cookie生效的时间，单位为秒，如果Cookie值只持续在客户端浏览器的会话时长，那么这个值应该为None。存在该值时，expires会被计算得到。 expires=None：Cookie具体过期日期，是一个datetime.datetime对象，如果该值存在，那么max_age也会被计算得到 1234567 import datetime current_time = datetime.datetime.now()# 当前时间 expires_time = current_time + datetime.timedelta(seconds=10) # 向后推延十秒 set_cookie('key','value',expires=expires_time) #设置Cookie及对应超时时间 path=&#39;/&#39;：指定哪些url可以访问到Cookie，默认/为所有。 domain=None：当我们需要设置的为一个跨域的Cookie值，那么可以使用该参数，比如：domain=&#39;.test.com&#39;，那么这个Cookie值可以被www.test.com、bbs.test.com等主域名相同的域所读取，否则Cookie只被设置的它的域所读取。为None时，代表当前域名下全局生效。 secure=False：https加密传输设置，当使用https协议时，需要设置该值，同样的，如果设置该值为True，如果不是https连接情况下，不会发送该Cookie值。 httponly=False：HTTPOnly是包含在HTTP响应头部中Set-Cookie中的一个标记。为一个bool值，当设置为True时，代表阻止客户端的Javascript访问Cookie。这是一种降低客户端脚本访问受保护的Cookie数据风险的有效的办法 设置COOKIE 简单的实现一下COOKIE的设置 12345from django.shortcuts import render,HttpResponse# Create your views here.def set_cookie(request): # 在HTTPResponse部分设置COOKIE值 cookie_reponse = HttpResponse('这是一个关于cookie的测试') cookie_reponse.set_cookie('test','hello cookie') return cookie_reponse 以上视图函数返回一个HttpResponse对象，并在该对象中集成COOKIE值的设定，设置key值为test，value值为hello cookie 获取COOKIE 再来简单的实现一下COOKIE的获取 1234def get_cookie(request): # 获取cookie值，从request属性中的COOKIE属性中 cookie_data = request.COOKIES.get('test') return HttpResponse('Cookie值为:%s' % cookie_data) Cookie值存储在，request中的COOKIES属性中 并且该属性获取到的结果与字典类似，直接通过内置函数get获取即可 删除COOKIE 这里通过该视图函数路由进行COOKIE的删除 1234def delete_cookie(request): response = HttpResponseRedirect('/check_cookie/') response.delete_cookie('test') return response delete_cookie(key, path=&#39;/&#39;, domain=None) 在Cookie中删除指定的key及对应的value，如果key值不存在，也不会引发任何异常。 由于Cookie的工作方式，path和domain应该与set_cookie时使用的值相同，否则Cookie值将不会被删除 通过response相应类的delete_cookie方法，本来应该在会话结束之后才消失的Cookie值，现在已经被直接删除掉。后台中通过Request中的Cookie字典获取到值也为None 不要忘记字典的get，获取不到结果时，返回None 但是，现在还有一个问题，我们在用户浏览器存储的Cookei值为明文，具有极大的安全隐患，django也提供了加密的Cookie值存储及获取方式 防止篡改COOKIE 通过set_signed_cookie函数进行持有签名的COOKIE值设置，避免用户在客户端进行修改 要记得，这个函数并不是对COOKIE值进行加密 HttpResonse.set_signed_cookie(key, value, salt=&#39;&#39;, max_age=None, expires=None, path=&#39;/&#39;, domain=None, secure=None, httponly=True) 为cookie值添加签名，其余参数与set_cookie相同 Request.get_signed_cookie(key, salt=&#39;&#39;, max_age=None) 从用户请求中获取通过salt盐值加了签名的Cookie值。 这里的salt要与之前存储时使用的salt值相同才可以解析出正确结果。 还要注意的是，如果对应的key值不存在，则会引发KeyError异常，所以要记得异常捕获来确定是否含有Cookie值 12345678def check_salt_cookie(request): try: salt_cookie = request.get_signed_cookie(key='salt_cookie',salt='nice') except KeyError: #获取不到该key值的Cookie response = HttpResponse('正在设置一个salt Cookie值') response.set_signed_cookie(key='salt_cookie',salt='nice',value='salt_cookie') return response else: #获取到了对应key值，展示到新的HttpResonse中 return HttpResponse('获取到的salt Cookie值:%s' % salt_cookie) 第一次访问的时候，还没有加Cookie值，所以我们在获取的时候会抛出KeyError异常 此时捕获异常，并且设置Cookie即可； 再次刷新的时候，因为这里已经给出了Cookie值，则不会引发异常，会在页面中展示获取到的加盐Cookie Session 虽然说有了Cookie之后，我们把一些信息保存在客户端浏览器中，可以保持用户在访问站点时的状态，但是也存在一定的安全隐患，Cookie值被曝露，Cookie值被他人篡改，等等。我们将换一种更健全的方式，也就是接下来要说的Session。 Session在网络中，又称会话控制，简称会话。用以存储用户访问站点时所需的信息及配置属性。当用户在我们的Web服务中跳转时，存储在Session中的数据不会丢失，可以一直在整个会话过程中存活。 在django中，默认的Session存储在数据库中session表里。默认有效期为两个星期。 session创建流程 客户端访问服务端，服务端为每一个客户端返回一个唯一的sessionid，比如xxx。 客户端需要保持某些状态，比如维持登陆。那么服务端会构造一个{sessionid: xxx }类似这样的字典数据加到Cookie中发送给用户。注意此时，只是一个随机字符串，返回给客户端的内容并不会像之前一样包含实际数据。 服务端在后台把返回给客户端的xxx字符串作为key值，对应需要保存的服务端数据为一个新的字典，存储在服务器上，例如：{xxx : {id:1}} 之后的一些客户端数据获取，都是通过获取客户端向服务端发起的HttpRequest请求中里Cookie中的sessionid之后，再用该sessionid从服务端的Session数据中调取该客户端存储的Session数据 注意：补充说明，默认存储在数据库的Session数据，是通过base64 编码的，我们可以通过Python的base64模块下的b64decode()解码得到原始数据 整个过程结束之后：客户端浏览器存储的其实也只是一个识别会话的随机字符串（xxx） 而服务器中是通过这个随机的字符串（xxx:value）进行真正的存储 Session的使用必须在Settings配置下 12345678INSTALLED_APPS = (... 'django.contrib.sessions', ...)MIDDLEWARE_CLASSES = ( 'django.contrib.sessions.middleware.SessionMiddleware', ...) 当settings.py中SessionMiddleware激活后 在视图函数的参数request接收到的客户端发来的HttpResquest请求对象中都会含有一个session属性 这个属性和之前所讨论的Cookie类似，是一个类字典对象，首先支持如下常用字典内置属性 获取Session session_data = request.session.get(Key) session_data = request.session[Key] 在Session中获取对应值，get方法获取时，如不存在该Key值，不会引发异常，返回None 而第二种直接通过字典获取，如Key值不存在，引发KeyErro 删除Session del request.seesion[Key] 删除对应session，Key值不存在时，引发KeyError request.session.clear() 清空Session中的所有数据。这里客户端还会保留sessionid 只不过在服务端sessionid对应的数据没有了。 request.session.flush() 直接删除当前客户端的的Seesion数据。这里不光服务端sessionid对应的数据没有了，客户端的sessionid也会被删除 设置有效期 request.session.set_expiry(value)： 设置Session的有效时间。 value：有效时间。 为整数时：将在value为秒单位之后过期 为0时：将在用户关闭浏览器之后过期。 为None时：使用全局过期的设置，默认为两个星期，14天。 为datetime时：在这个指定时间后过期。 request.session.get_expiry_age() 返回距离过期还剩下的秒数。 request.session.clear_expired() 清除过期的Session会话。 编写一个简单的视图函数来玩耍Session吧 12345678910111213141516from django.shortcuts import render,HttpResponseimport datetimedef set_session(request): if request.session.get('test_id'): session_data = request.session.get('test_id') # 用户拿到的的session随机字符串 session_key = request.session.session_key # 获取客户端浏览器中的SessionID值 session_expire = request.session.get_expiry_age() now = datetime.datetime.now() expire_time = now + datetime.timedelta(seconds=session_expire) response = '&lt;div&gt;SessionID : %s&lt;/div&gt;' % session_key + \\ '&lt;div&gt;Session : %s&lt;/div&gt;' % session_data + \\ '&lt;div&gt;ExpireTime : %s&lt;/div&gt;' % expire_time return HttpResponse(response) else: request.session['test_id'] = 'TEST' request.session.set_expiry(None) return HttpResponse('已设置好Session') 用户在第一次访问时，会走else分支，此时还没有任何服务端的Session及客户端的Cookie值设定 那么我们会通过request.session[Key]的方式来设置一个Session值，值为TEST 当用户第二次访问时将展示出所设置好的Session值及在客户端浏览器中存储的sessionid 在编写一个删除Session的视图函数吧 123456def delete_session(request): if request.session.get('test_id'): del request.session['test_id'] return HttpResponse('Session被删了') else: return HttpResponse('目前没有任何需要删除的session') 这里温柔的使用del request.session[Key]的方式来进行Session的删除 如果存在对应test_id的Session值则删除，反之返回一个字符串 Session删除总结 使用的是del的针对性删除方式，这样不会将整个客户端的session删除掉 使用request.session.clear()，只是清空了服务端Session中的数据，但是客户端的Cookie中还会保存sessionid，只不过这个值对应的字符串所对应的用户数据是一个空 使用request.session.flush()，那么客户端Cookie中保存的sessionid首先会被删除，其次服务端通过sessionid值保存的用户数据也会被全部删除。","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Django-Forms-表单层","slug":"Django-Forms-表单层","date":"2019-10-26T03:22:58.227Z","updated":"2019-12-09T11:26:06.013Z","comments":true,"path":"Django-Forms-表单层/","link":"","permalink":"https://cy-blogs.cn/Django-Forms-表单层/","excerpt":"Forms django提供了一整套健全的机制来帮助我们自动创建对应HTML中的表单，类似序列化器 开发者可以方便的使用已经设定好的一系列字段进行表单的设计 可以在某个app下面新建一个forms.py文件，在这个文件编写django自带表单类的编写 比如像下面这样 123from django import formsclass TestForm(forms.Form): name = forms.CharField(label='名字:',max_length=100)","text":"Forms django提供了一整套健全的机制来帮助我们自动创建对应HTML中的表单，类似序列化器 开发者可以方便的使用已经设定好的一系列字段进行表单的设计 可以在某个app下面新建一个forms.py文件，在这个文件编写django自带表单类的编写 比如像下面这样 123from django import formsclass TestForm(forms.Form): name = forms.CharField(label='名字:',max_length=100) 在这个表单类中，设置了一个CharField字段，并且具有label标签值为name 此外在``标签处还会设置maxlength=100的属性 django在接收到这样表单内的数据时，还将验证数据的长度 实例化该类，然后打印出来查看效果 12345678&lt;tr&gt; &lt;th&gt; &lt;label for=\"id_name\"&gt;名字:&lt;/label&gt; &lt;/th&gt; &lt;td&gt; &lt;input type=\"text\" name=\"name\" maxlength=\"100\" required id=\"id_name\" /&gt; &lt;/td&gt;&lt;/tr&gt; 在渲染后的结果中不包含提交的按钮，以及外层的form标签，还需要我们自己手动在模板页面中进行添加 form表单实例的使用也非常简单，直接在模板页面处将表单实例以模板变量形式传递赋值即可 1234# views.pydef index(request): form = forms.TestForm() return render(request,'index.html',locals()) 123456&lt;!-- index.html --&gt;&lt;form action=\"/\" method=\"POST\"&gt; &#123;% csrf_token %&#125; &#123;&#123; form &#125;&#125; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; is_valid 每一个form类的实例都具有一个is_valid()方法，验证表单内的字段是否合法，并将表单中合法的的数据将放到表单中的cleaned_data属性中 如果全部数据都没有问题，那么该函数将会返回True，返回的合法数据。结果是一个字典的数据类型 123456789101112form = TestFrom()if form.is_valid(): data = form.cleaned_datadef post_test(request): if request.method == \"POST\": form = TestForm(request.POST) if form.is_valid(): name = form.cleaned_data.get('name') return HttpResponse('OK') else: form = TestForm() return render(request, \"xxx.html\",&#123;\"form\":form&#125;) 在视图函数中，当用户以post形式提交数据，此时将post数据与表单类进行关联 使用post数据做为类实例化的参数，这种操作也叫作绑定数据到表单 如果用户在表单中填写张三并提交，那么绑定数据之后的表单实例像是这样 12&lt;label for=\"id_name\"&gt;名字:&lt;/label&gt;&lt;input id=\"id_name\" maxlength=\"100\" name=\"name\" type=\"text\" value=\"张三\" /&gt; input标签中的value值为用户post所提交的数据 如果绑定数据的表单实例经过is_valid函数校验并通过，那么正确的数据将存储在cleaned_data中，cleaned_data中的数据同时也是处理好的Python数据类型，比如这里为一个字典数据类型 接下来在视图函数中可以直接通过字典的操作方式来获取到用户在对应表单标签中所填写的数据 表单字段类型 所有表单字段Field的子类均带有默认参数require BooleanField 控件：CheckboxInput 复选框：`` 空值：False 12&gt; Python`：`True\\False&gt; 错误键：required CharField 控件：TextInput 文本输入：`` 空值：空字符串 12&gt; Python`：`str&gt; 错误键：max_length、min_length、required ChoiceField 控件：Select 选择框：... 空值：空字符串 Python：Unicode str 必选参数：choices，该参数为一个二元组组成的可迭代对象，二元组中的第一个值为获取到的数据，第二个值为表单中展示的内容。 错误键：required、invalid_choice 123class TestForm(forms.Form): choices = ( ('0','男'), ('1','女'), ) gender = forms.ChoiceField(choices=choices) DateField 控件：DateInput 日期以普通的文本框输入：`` 空值：None Python：datetime.date 验证是否为一个指定日期格式的字符串 错误键：required、invalid 可选参数：input_formats，一个时间格式化字符串，用来将表单中的数据转换为datetime.date对象 可选参数格式参考如下： 1'%Y-%m-%d', # '2006-10-25''%m/%d/%Y', # '10/25/2006''%m/%d/%y' # '10/25/06' DateTimeField 控件：DateTimeInput 日期/时间以普通的文本框输入：&lt;input type=’text’ …&gt; 空值：None Python：datetime.datetime 验证是否为一个指定日期格式的字符串 可选参数：input_formats，一个时间格式化字符串，用来将表单中的数据转换为datetime.datetime对象 错误键：required、invalid DecimalField 控件：当Field.localize 是False 时为NumberInput，否则为TextInput NumberInput文本输入：`` TextInput文本输入：`` 空值：None Python：decimal 验证给定值是否为一个十进制数字 可选参数：max_value、min_value控制大小值范围 max_digits：值允许的最大位数（小数点之前和之后的数字总共的位数，前导的零将被删除） decimal_places：允许的最大小数位 错误键：required，invalid， max_value， min_value， max_digits， max_decimal_places max_whole_digits EmailField 控件：文本输入：`` 空值：空字符串 Python：Unicode str 使用正则验证给定的值是否为一个合法的邮件地址 可选参数：max_length与min_length，限定邮件地址字符串大小长度。 错误键：required、invalid FileField 控件：ClearableFileInput 文件上传输入：`` 空值：None Python：UploadedFile 验证非空的文件数据绑定到表单 使用该字段时，在使用表单实例获取上传文件数据时，表单标签中需要具备enctype=&quot;multipart/form-data&quot;属性，此外还需要绑定文件数据在表单上 1form = TestForm(request.POST,request.FILES) FloatField 控件：当Field.localize是False 时为NumberInput，否则为TextInput NumberInput文本输入：`` TextInput文本输入：`` 空值：None Python：Float 验证给出的值是一个浮点数，对比float函数 可选参数：max_value、min_value限定大小值范围 错误键：required， invalid， max_value，min_value ImageField 控件：ClearableFileInput 文件上传输入：`` 空值：None Python：UploadedFile 验证文件数据并且检验是否是一个可以被pillow所解释的图像 使用该字段，需要安装pillow模块。 错误键：required，invalid，missing，empty，invalid_image IntergerField 控件：当Field.localize 是False时为NumberInput，否则为TextInput NumberInput文本输入：`` TextInput文本输入：`` 空值：None Python：int 验证给定的值是否是一个整数 可选参数：max_value、min_value限定大小值范围 错误键：required，invalid，max_value，min_value GenericIPAddressField 控件：TextInput 文本输入：`` 空值：空字符串 Python：Unicode str 可选参数 protocol：默认值为both，可选IPv4或IPv6。 错误键：required，invalid MultipleChoiceField 控件：SelectMultiple ... 空值：一个空列表 Python：list 验证表单中的值是否存在于选择列表中，对比ChoiceField，该字段支持多选 必选参数：choices，与ChoiceField类似，接收一个二元组可迭代对象 错误键：required，invalid_choice，invalid_list RegexField 控件：TextInput 文本输入：`` 空值：空字符串 Python：Unicode str 验证表单中值与某个正则表达式匹配 必选参数：regex，字符串或编译的正则表达式 可选参数：max_length、min_length 错误键：required，invalid SlugField 控件：TextInput 文本输入：`` 空值：空字符串 Python：Unicode对象 验证给定的值为字母、数字、下划线及连字符组成 错误键：required，invalid URLField 控件：TextInput 文本输入：`` 空值：空字符串 Python：Unicode对象 验证给定值是一个有效的URL 可选参数：max_length、min_length 错误键：required，invalid TimeField 控件：TextInput 文本输入：`` 空值：None Python：datetime.time 验证给定值是否为一个给定格式的时间字符串 可选参数：input_formats，控制表单输入的格式 表单属性 required： 表单字段为必填值，当传递数据为一个空值，不管是空字符串还是None 在表单验证时，将引发ValidationError异常，这个异常将会在表单上展示错误信息 label 指定当前字段的label标签值，字段默认Label为字段名所有下换线转换为空格 且一个字母大写生成 label_suffix 修改label提示字符串的追加符号，默认表单类实例化过程会自动在label属性后加: initial 字段的初始值。不能将初始值直接作为参数传入，会造成直接验证表单数据而报错。 1form = forms.TestForm(initial=&#123;'name':'Bob'&#125;) widget 表单字段渲染时使用的Widget类，如果不想使用默认的表单类型，通过该参数指明所需表单控件 可以使用类似的表单类型，在下面会有详细的介绍。 help_text 指定字段的描述文本，该文本一般会紧挨着字段显示 表单控件：widget 默认django会为每一个表单字段设置默认的HTML控件 控件用来渲染HTML中输入元素与提取提交的原始数据 如果你希望使用一个不同的控件Widget，可以为字段设置widget参数 1234from django import formsclass CommentForm(forms.Form): comment = forms.CharField(widget=forms.Textarea) #修改CharField默认控件TextInput为Textarea 此外，我们还可以为字段的Widget设置额外的属性 比如一些之后在HTML渲染时候将会使用到的标签class值等等 只需要在widget参数部分使用attrs形参指定即可，该参数设置这个字段控件的对应HTML属性 1name = forms.CharField( max_length=5, widget=forms.TextInput(attrs=&#123;'class':'green'&#125;)) 还可以使用日期控件覆盖默认日期控件 12YEARS = ('2016', '2017', '2018')MONTHS = &#123; 1:'一月', 2:'二月', 3:'三月', 4:'四月',5:'五月', 6:'六月', 7:'七月', 8:'八月',9:'九月', 10:'十月', 11:'十一月', 12:'十二月'&#125;birth_year = forms.DateField(widget=froms.SelectDateWidget(years=YEARS,months=MONTHS)) 文本输入控件 TextInput 文本输入：`` NumberInput 文本输入：`` EmailInput 文本输入：`` URLInput 文本输入：`` PasswordInput 密码输入：`` HiddenInput 隐藏输入：`` DateInput 日期以普通的文本框输入：`` 可选参数：format，时间的字符串格式 DateTimeInput 日期/时间以普通的文本框输入：`` 可选参数：format，时间的字符串格式 TimeInput 时间以普通的文本框输入：`` 可选参数：format，时间的字符串格式 Textarea 文本区域：... 选择和复选框 CheckboxInput 复选框：`` 可选参数：check_test 这个参数接收一个函数对象，函数对象的参数为当前CheckboxInput的值，函数对象如果返回True，该控件在字段渲染时自动勾上。 1comment = forms.CharField(widget=forms.CheckboxInput(check_test=lambda *arg: True)) Select 单选框：... 可选参数：choices，与字段设置相同，但是会被字段设置所覆盖。 NullBooleanSelect 单选框：选项为Unknown、Yes和No，Unknown也代表False。 SelectMultiple 多选框：... RadioSelect 单选框，与select类似，但是会将选择渲染为一个单选按钮列表 CheckboxSelectMultiple 多选框：与SelectMultiple类似，但是会渲染为一个复选框列表/ 复合控件 SelectDateWidget 封装了三个Widget，分别用于年、月、日 可选参数：可以来指定日期表单的选择 years：一个列表或元组的序列数据类型，用来确定年的选择。 months：一个字典数据类型，字典的key值为月份数字，从1开始，value值为在表单中渲染展示的字符串，比如 1MONTHS = &#123; 1:'一月', 2:'二月', 3:'三月', 4:'四月', 5:'五月', 6:'六月', 7:'七月', 8:'八月', 9:'九月', 10:'十月', 11:'十一月', 12:'十二月'&#125; 表单API 表单类的实例，只有两种，一种是绑定了数据的，一种是未绑定的。都可以渲染成为html Form.is_valid() 对于绑定了数据的表单，进行验证并返回一个数据是否合法的布尔值 并在所有数据有效时将数据放入cleaned_data中 Form.is_bound() 区分绑定表单和未绑定表单，当表单类绑定数据时，返回True Form.errors 当验证发生错误时的错误信息的字典，字典key值为字段名称，value为报错信息列表，可能有多个报错 表单的数据将会在调用is_valid时或访问errors属性时验证 并且验证过程只会调用一次，不论访问errors和调用is_valid多少次 12345678class TestForm(forms.Form): name = forms.CharField(max_length=5,) email = forms.EmailField(required=True) def clean_name(self): cleaned_data = super(TestForm,self).clean() if self.cleaned_data.get('name') == '小红': raise forms.ValidationError(\"不允许小红\") return cleaned_data 12&gt;&gt;&gt; f = forms.TestForm(&#123;'name':'小红','emali':'123'&#125;)&gt;&gt;&gt; a.errors&#123;'name': ['不允许小红'], 'email': ['This field is required.']&#125; Form.errors.as_data 返回报错信息的字典，映射字段报错信息到一个ValidationError实例 1&gt;&gt;&gt; f.errors.as_data()&#123; 'name': [ValidationError(['不允许小红'])], 'email': [ValidationError(['This field is required.'])]&#125; Form.errors.as_json(escape_html=False) 以json格式返回错误信息 12&gt;&gt;&gt; a.errors.as_json()'&#123; \"name\": [&#123;\"message\": \"\\\\u4e0d\\\\u5141\\\\u8bb8\\\\u5c0f\\\\u7ea2\", \"code\": \"\"&#125;], \"email\": [&#123;\"message\": \"This field is required.\", \"code\": \"required\"&#125;]&#125;' Form.initial 声明当前表单类的默认数据，参数为一个字典数据类型 key对应需要填充默认数据的表单字段，value值为实际数据 1class TestForm(forms.Form): name = forms.CharField(max_length=5,initial='Jack',) 12&gt;&gt;&gt; f = TestForm(initial=&#123;'name':'Bob'&#125;)&gt;&gt;&gt; print(f)&lt;tr&gt;&lt;th&gt;&lt;label for=\"id_name\"&gt;Name:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input id=\"id_name\" maxlength=\"5\" name=\"name\" type=\"text\" value=\"Bob\" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt; Form.has_changed() 检查表单当前的数据是否与默认值不同 12&gt;&gt;&gt; f = TestForm(data=&#123;'name':'Jack'&#125;,initial=&#123;'name':'Bob'&#125;)&gt;&gt;&gt; f.has_changed()True Form.cleaned_data 在对绑定数据的表单实例进行is_valid验证之后，如果数据无误 那么返回的数据将保存在cleaned_data中 如果有部分数据没有经过验证，那么cleaned_data中也会保留合法的字段 并且，在cleaned_data属性中获取到的数据，只包含表单类中含有的字段 1234class TestForm(forms.Form): name = forms.CharField(max_length=5,) email = forms.EmailField(required=True) active = forms.BooleanField() 123456789&gt;&gt;&gt; data = &#123;... 'name':'Jack', ... 'email':'111',... 'active':True,... &#125;&gt;&gt;&gt;&gt;&gt;&gt; f = TestForm(data=data)&gt;&gt;&gt; f.is_valid()False&gt;&gt;&gt; f.cleaned_data&#123; 'name':'Jack', 'active': True&#125; Form.as_p() 将表单渲染为一系列的``标签，每个标签内含一个字段porm.as_ul()` 渲染表单为一系列的标签，并且不包含标签，可以自行指定``的HTML属性 1&gt;&gt;&gt; print(f.as_ul())&lt;li&gt;&lt;label for=\"id_name\"&gt;Name:&lt;/label&gt; &lt;input id=\"id_name\" maxlength=\"5\" name=\"name\" type=\"text\" /&gt;&lt;/li&gt; Form.as_table() 渲染表单为`标签 1&gt;&gt;&gt; print(f.as_table())&lt;tr&gt;&lt;th&gt;&lt;label for=\"id_name\"&gt;Name:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input id=\"id_name\" maxlength=\"5\" name=\"name\" type=\"text\" /&gt;&lt;/td&gt;&lt;/tr&gt; 配置表单元素的HTML id值与默认自带的label标签 通过表单类进行渲染时，默认会包含以下属性 表单元素的HTML id属性 辅助的label标签 有些时候，想要设置自定义HTML id值或者取消label标签，可以使用如下内置函数 Form.auto_id=True 修改对应渲染表单属性 当auto_id值为False时，表单类的渲染将不会包含``以及id属性 12&gt;&gt;&gt; f = TestForm(auto_id=False)&gt;&gt;&gt; print(f)&lt;tr&gt;&lt;th&gt;Name:&lt;/th&gt;&lt;td&gt;&lt;input maxlength=\"5\" name=\"name\" type=\"text\" /&gt;&lt;/td&gt;&lt;/tr&gt; 模板中表单实例属性 模板页面接收到的form表单实例支持循环遍历访问 1&#123;% for field in form %&#125; &#123;&#123; field &#125;&#125;&#123;% endfor %&#125; 其中for迭代访问之后的每一个表单字段又支持如下操作 ``：字段的label，例如Email address。 ``：包含在HTML 标签中的字段值。 ``：这个字段的ID值。 ``：字段的值 ``：该字段的标签中name属性使用的值。 ``：该字段的帮助文档。 ``：字段的验证错误信息，字段标签会在 ``：如果该字段为隐藏字段，返回True。反之返回False。 ``：获取当前字段实例，可以用该属性来访问字段实例的属性 1&#123;&#123; field.field.max_length &#125;&#125; 与模型类关联的表单 除了以上我们自定义表单类来进行表单的初始化 django还提供了另外一种表单类的创建方法，可以通过与模型关联来构建表单 这种办法可以更加省时省力，直接使用模型类中已经定义好的字段来进行表单字段的生成 123456class TestTable(modes.Model): name = models.CharField(max_length=10) class TestTableForm(forms.ModelForm): class Meta: model = TestTable fields = ['name'] 生成的表单实例将具备模型类中的字段，表单生成的字段顺序也与模型类中的定义顺序相同 fields属性用来显示的设置所有需要在表单中处理的字段 也可以直接为该字段设置fields = &#39;__all__&#39;来使用所有模型类中的字段作为未来的表单字段 注意 ： 如果模型类中字段定义了blank=True，那么对应关联的表单类中字段会默认具有require=False的属性 模型类中字段的verbose_name属性对应关联表单类字段的Label属性 如果模型类字段中设置了choices值，那么对应关联表单字段的widget将会设置为select 当然，除了根据关联模型类来创建表单类，还可以在关联表单类中选择性的覆盖某些字段的设置 比如使用表单类Meta元类中的widgets属性可以以字典形式设置对应字段的控件 12345678class TestTableForm(forms.ModelForm): name = forms.URLField() class Meta: model = TestTable fields = ['name'] widgets = &#123; 'name':forms.Textarea(attrs=&#123;'class':'green'&#125;) &#125; 除此之外，还可以指定labels、help_texts和error_messages等信息 123456789101112131415class TestTableForm(forms.ModelForm): name = forms.URLField() class Meta: model = TestTable fields = ['name'] labels = &#123; 'name':'您的名字' &#125; help_texts = &#123; 'name':'请输入您的名字' &#125; error_messages = &#123; 'name':&#123; 'required':'你必须填写这个名字', 'max_length':'你的名字太长了' &#125; &#125; 与模型关联的表单验证 表单的验证在我们调用is_valid函数时执行，也可以通过访问errors属性或调用full_clean函数 验证的出错会引发ValidationError异常，该异常会向表单传达一个错误信息 验证的步骤主要分为两步，表单验证，如果关联了模型，则还会进行模型验证 表单字段的验证分为以下过程 字段to_python，这个方法将字段的值根据字段的类型转换为Python中的数据类型，如果不能转换则引发ValidationError异常 字段的clean函数，该函数用来运行对应的验证器，根据顺序执行to_python，validate特异性验证，以及run_validators（用于将错误信息汇总）验证，如果有任何验证过程引发了ValidationError异常，验证都将停止。其余通过验证的字段数据插入到表单的cleaned_data字典中 表单中的字段clean函数，这个验证用于完成特定属性，与表单字段类型无关；比如我们经常需要验证用户输入的字段值不能为小红，那么可以编写字段的clean函数，函数命名为clean_，fileds_name为字段名 123456class TestTableForm(forms.ModelForm): def clean_name(self): name = self.cleaned_data.get('name') if name == '小红': raise forms.ValidationError('不允许小红') return name 表单的clean函数，这个方法进行表单中多个字段值的联合验证，验证之后的数据返回为cleaned_data，可以通过重写该函数来提供的额外验证方法，并且为了维持clean方法的验证行为，在代码中，表单类需要调用父类的clean方法 123456def clean(self): cleaned_data = super(TestTableForm,self).clean() name = cleaned_data.get('name') if '1' in name: cleaned_data['name'] = name.replace('1','一') return cleaned_data 最后总结的来说： 一个表单在验证时，首先验证每一个字段，接着调用字段的clean_fields函数，最后使用表单类的clean函数进行验证 如果表单与模型关联，那么现在还有第二步验证，模型的验证 模型的验证为如下过程 验证关联模型的字段及相关属性：Model.clean_fields(exclud=None)，该方法将验证模型的所有字段属性，如果有字段验证错误，引发ValidationError异常 验证模型的完整性：Model.clean(exclude=None)，可以对模型做整体的检验，如果想要自己验证模型中通过属性校验的数据，可以在模型类中重新定义这个函数 123456from django.core.exceptions import ValidationErrorclass TestTable(models.Model): name = models.CharField(max_length=10,verbose_name='名字',unique=True) def clean(self): if '$' in self.name: raise ValidationError('无法使用$符号') 验证模型的唯一性：Model.validate_unique(exclude=None)，如果模型中所有唯一约束性，比如使用类似unique属性，会校验表单中的值是否唯一 并且，除了通过绑定模型的表单实例is_valid函数可以来进行以上的验证过程，如果想自己控制验证 可以直接使用模型的full_clean(exclude=None,validate_unique=True)方法进行以上三个步骤的验证 与模型关联的表单保存 与模型关联的表单，在校验成功之后，表单实例可以直接通过save函数来进行表单数据的保存数据库 12345def form_test(request): if request.method == \"POST\": form = TestTableForm(request.POST,request.FILES) if form.is_valid(): form.save() return HttpResponse('OK:%s' % value) 该函数也支持在模型类中进行重写，但是要切记使用父类的save方法，确保数据可以正确存储到数据库中 12345def save(self, *args, **kwargs): if self.name == 'abc': return False#不做存储 else: super(TestTable,self).save(*args, **kwargs)","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Ajax及Axios异步请求，接口数据序列化处理","slug":"Ajax及Axios异步请求接口数据序列化处理","date":"2019-10-26T03:21:46.194Z","updated":"2019-12-09T11:25:53.566Z","comments":true,"path":"Ajax及Axios异步请求接口数据序列化处理/","link":"","permalink":"https://cy-blogs.cn/Ajax及Axios异步请求接口数据序列化处理/","excerpt":"Ajax ajax可以使当前浏览器不需要整个重新加载，只是局部刷新，给用户的体验良好，也因为只是刷新局部页面，相对而言效率更高一些 同步交互：客户端发出一个请求后，需要等待服务器相应结束后，才可以发起第二个请求 异步交互：客户端发出一个请求后，无需等待该次服务器的相应，即可发起第二个请求 json数据类型","text":"Ajax ajax可以使当前浏览器不需要整个重新加载，只是局部刷新，给用户的体验良好，也因为只是刷新局部页面，相对而言效率更高一些 同步交互：客户端发出一个请求后，需要等待服务器相应结束后，才可以发起第二个请求 异步交互：客户端发出一个请求后，无需等待该次服务器的相应，即可发起第二个请求 json数据类型 数据在键值对中 数据由逗号分隔 花括号存储数据 方括号保存数组 1[ &#123; \"name\":\"Bill\", \"age\":1 &#125;, &#123; \"name\":\"George\", \"age\":2 &#125;, &#123; \"name\":\"Thomas\", \"age\": 3 &#125;]; jQuery-Ajax 使用ajax进行django后台数据的异步获取，django只是提供的数据，并不承担前端页面的渲染工程 这里使用jQuery所提供的ajax方法进行异步通信 首先测试数据库中模型类定义如下： 1234567class Article(models.Model): title = models.CharField(max_length=50,verbose_name=\"标题\") author = models.CharField(max_length=20,verbose_name=\"作者\") date = models.DateField(auto_now_add=True,verbose_name=\"发表日期\") content = models.TextField(verbose_name=\"文章内容\") def __str__(self): return self.title 测试数据可由用户自行添加，非常简单 编写主页视图函数，返回所有数据库中内容 123def index(request): articles = models.Article.objects.all() return render(request,'ajax/index.html',locals()) 此处的index.html页面不光承担所有数据的渲染工作 还将负责未来ajax异步请求，获取对应文章的详细内容 index.html页面代码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; label&#123; border: 5px outset gray; width: 150px; margin-top: 10px; &#125;&lt;/style&gt;&lt;head&gt; &#123;% load staticfiles %&#125; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Ajax测试&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"&#123;% static 'js/jquery-1.10.2.min.js' %&#125;\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"&#123;% static 'js/jquery.cookie.js' %&#125;\"&gt;&lt;/script&gt; &lt;!-- 该js文件用来引入jquery所提供的获取cookie值的库 为了提取对应csrf_token--&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是一个ajax的请求测试&lt;/h1&gt; &#123;% for article in articles %&#125; &lt;label class=\"&#123;&#123; article.id &#125;&#125;\"&gt; &#123;&#123; article.author &#125;&#125;:&#123;&#123; article.title &#125;&#125; &lt;/label&gt; &#123;% endfor %&#125; &lt;p class=\"content\"&gt; &lt;/p&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function () &#123; $(\"label\").click(function () &#123; $.ajax(&#123; url: '/article/', // 请求地址，对应Django某个路由映射 type: 'POST', // 请求方式 post data: &#123; 'csrfmiddlewaretoken': $.cookie('csrftoken'), // 提交数据需有当前csrf_token 防跨站请求伪造令牌 'id_': $(this).attr('class'), // 获取当前的id值 传递到视图后台 &#125;, success: function (result) &#123; var data = JSON.parse(result) // 解析获得实际字符串 $('.content').html(data) // 将内容以html形式显示到对应的p标签上 &#125; &#125;) &#125;) &#125;)&lt;/script&gt; 有了前端页面，并且ajax的请求地址为/article/，那么就需要我们定义一个视图函数返回对应的json数据，并且设置路由为/article/ 1234567891011121314151617181920#urls.pypath('ajax/',ajaxviews.index),# 首页路由path('article/',ajaxviews.article)# ajax请求路由#views.pydef article(request):if request.is_ajax():# 判断是否为ajax请求if request.method == \"POST\":# 为ajax的post方式请求 id_ = request.POST.get('id_') if id_: try: content = models.Article.objects.get(id=id_).content.replace('\\r\\n','&lt;br&gt;') # 这里还将获取到的文章字符串内容中的换行替换为HTML的换行标签 except models.Article.DoesNotExist: raise Http404 else: data = json.dumps(content,ensure_ascii=False,cls=JsonEncoder) # 返回get对应取到的实际属性 return HttpResponse(data) raise Http404 这里要注意的是，后端返回的数据得是序列化之后的才可以被前端js所解析，直接返回一个django model数据实例是不行的。所以需要我们视图函数对需要返回的数据进行序列化操作 对于数据的序列化操作主要有以下两种 json序列化 普通Python数据直接使用json模块进行序列化 12content = models.Article.objects.get(id=id_).content.replace('\\r\\n','&lt;br&gt;')#这里将文章内容对应返回，之所以有replace函数，是因为文章数据是通过admin后台复制添加，需要将其中的\\r\\n换行转换为HTML可以解析的&lt;br&gt;标识符data = json.dumps(content,ensure_ascii=False)# 第二个参数是因为序列化时对中文默认使用的ascii编码，此时需要将该值设置为False，这样前端接收到时才是一个正常中文结果return HttpResponse(data) 但如果要序列化的数据中包含时间类型date 或datetime时，这种办法就会报错啦 12&gt; TypeError: Object of type date is not JSON serializable&gt; 12345678910111213class JsonEncoder(json.JSONEncoder): # 自定义json处理器 def default(self, obj): if isinstance(obj, datetime): # 如果判断到类型为datetime格式 return obj.strftime('%Y-%m-%d %H:%M:%S') # 处理为字符串类型的 (年-月-日 时:分:秒) elif isinstance(obj, date): # 如果判断到json处理数据为date类型 return obj.strftime('%Y-%m-%d') else: return json.JSONEncoder.default(self,obj) # 其他数据类型按照默认的序列化方式处理即可 使用cls指定序列化方式，即可轻松解决特殊格式没有办法被json序列化的问题 1234content = models.Article.objects.get(id=id_).datadata = json.dumps(content,ensure_ascii=False,cls=JsonEncoder)# 通过json.dumps的cls参数指明所使用的自定义序列化类return HttpResponse(data) 对应前端接收展示 12var data = JSON.parse(result) // 普通json传输方式$('.content').html(data) 如果返回的数据并不是一个单独的数据属性，那么也可以通过json进行处理，以一个数据列表的形式返回 12345content = models.Article.objects.filter(id=id_).values()# ----------------------------------------------# content = models.Article.objects.all().values()# ----------------------------------------------data = json.dumps(list(content),ensure_ascii=False,cls=JsonEncoder)return HttpResponse(data) 对应前端接收展示 12345678910111213&lt;div class=\"content\"&gt; &lt;!-- 这里用到的不是之前的p标签 而是一个div容器 --&gt;&lt;/div&gt;success: function (result) &#123; var data = JSON.parse(result)[0]['content'] $('.content').html(data.replace(/\\r\\n/g,\"&lt;br&gt;\"))&#125;// ---------------------------------------------// 如果需要展示的是所有的结果，可以通过js的for循环success: function (result) &#123; var data = JSON.parse(result) var tag = '' for (var i = 0, len = data.length; i &lt; len; i++) &#123; tag += '&lt;p&gt;' + data[i]['content'].replace(/\\r\\n/g, \"&lt;br&gt;\") + '&lt;/p&gt;' tag += '&lt;hr&gt;' &#125; $('.content').html(tag)&#125; // ---------------------------------------------- Vue-Axios 除去jQuery所提供的异步通信ajax方法 在Vue中也提供了ajax的异步通信方法，叫做Axios Axios会自动转换json数据 简单的来编写一个视图函数 get：返回当前页面 post：返回一条json数据 12345678910111213141516171819202122232425window.onload = function () &#123; new Vue(&#123; el: '#content', // Vue接管的区域 data: &#123; message: '这个是表单内容', &#125;, methods: &#123; getajax() &#123; axios.get('/get_ajax/', &#123; params: &#123; // 这部分为get方式进行传参时使用的 id: 123 &#125; &#125;).then(function (response) &#123; console.log(response) // 打印输出get方式进行ajax请求时获取到的数据 &#125;).catch(function (error) &#123; console.log(error) // 当get方式ajax请求报错时，会进入该函数 &#125;) &#125; &#125;, &#125;)&#125; 对应的HTML页面 12345&lt;body&gt; &lt;div id=\"content\"&gt; &lt;button @click='getajax'&gt;点我发送ajax的get请求&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; 后台视图函数 1234if request.method == 'GET': message = request.GET.get('message') print(message) return render(request,'axios/index.html') 当使用的是post形式获取服务端数据时，首先要注意，axios默认的提交post 数据不是普通的form-data 12&gt; axios`的`post`使用的是`request payload`方式，参数格式是`application/json;charset=UTF-8&gt; 而我们之前的表单提交数据的类型都是application/x-www-form-urlencoded，所以直接再django后台通过request.POST.get是获取不到任何数据的 解决办法，需要我们在axios提交数据时，指明提交时的头部信息 12345678910111213141516171819202122232425window.onload = function () &#123; new Vue(&#123; el: '#content', // Vue接管的区域 data: &#123; message: '这个是表单内容', &#125;, methods: &#123; getajax() &#123; axios(&#123; method: 'post', url: '/get_ajax/', data: &#123; message:this.message, name: '张三' &#125;, headers: &#123; 'Content-Type':'application/x-www-form-urlencoded', &#125;, &#125;).then((response) =&gt; &#123; console.log(response.data) this.message = response.data &#125;) &#125; &#125;, &#125;)&#125; 虽然通过添加头部信息，可以让axios发送的数据被django后台所接收到，但是此时的数据还是有问题的 获取到的POST提交的数据被django打包成了一个QueryDict中的key值，value为空数组 导致后台按照平时的解析方式是获取不到的 解决办法也很简单，把QueryDict单独处理为一个字典 123456if request.method == 'POST': data = eval(list(request.POST.keys())[0]) # 将获取到的数据转换为字典 message = data.get('message') data = json.dumps(message + '我被服务端后台修改过') return HttpResponse(data) 接下来，当用户点击按钮时，post提交表单数据，给到django后台，后台追加字符串并返回，返回的数据被then回调函数所接收到，重新赋值给绑定的表单变量中 第二种办法，在前端vue提交数据时， serializer序列化 serializer是由django所提供的一个专门用来处理django数据对象(django model)变为序列化数据的框架 并且Django的序列化不支持单个对象，比如像objects.get获取到的数据，或是Python中的 str等数据类型 该序列化框架所提供的功能类位于django.core.serializers 12345678#views.py from django.core import serializerscontent = models.Article.objects.filter(id=id_)data = serializers.serialize('json',content,ensure_ascii=False)return HttpResponse(data)var data = JSON.parse(result)[0]['fields']['content']// 序列化传输方式$('.content').html(data.replace(/\\r\\n/g,\"&lt;br&gt;\"))console.log(data) 总结：通过管理器的get方法获取到的是一个独立的结果，并不是一个QuerySet数据对象，也不是一个普通Python数据类型；只能对数据其中的某条属性进行json格式的处理或是将其变为列表等序列数据类型之后再进行序列化处理 serializer反序列化 序列化：serializers.serialize 反序列化：serializers.deserialize 1234567from django.core import serializerscontent = models.Article.objects.filter(id=id_) # QuerySetdata = serializers.serialize('json',content,ensure_ascii=False) # strcontent = serializers.deserialize(\"json\", data)return HttpResponse(data) Ajax跨域 浏览器有一个很重要的概念：同源策略(Same-Origin Policy) 所谓同源是指，域名，协议，端口相同 不同源的客户端脚本javascript、ActionScript在没明确授权的情况下，不能读写对方的资源 同源：请求资源的地址与请求的发起方都属于同一域名下 JSONP JSONP是JSON with padding（填充式JSON 或参数式 JSON）的简写 JSONP实现跨域请求的原理简单的说，就是动态创建标签，然后利用的src不受同源策略约束来跨域获取数据。 JSONP由两部分组成：回调函数和数据 回调函数是当响应到来时应该在页面中调用的函数；回调函数的名字一般是在请求中指定的，而数据就是传入回调函数中的参数 注意：JSONP方式解决AJAX跨域，必须使用get方式，并且该方式常在一些数据量级比较小的情况下，因为需要服务端后台构建回调函数带参数的字符串，像是下面这样 123456def index(request): name = request.GET.get('name') + '哈哈哈哈哈' callback = request.GET.get('callback') data = '%s(\"%s\")' % (callback,name) # 这里以前端生成的回调函数名作为函数名，待返回数据作为参数返回 return HttpResponse(data) 前端代码：点击按钮传送表单的值到后台，并由后台处理后追加内容返回，返回的结果展示再p标签处 1&lt;input type='text' id='ajax_data'&gt;&lt;button&gt; 按钮&lt;/button&gt;&lt;p id=\"content\"&gt;&lt;/p&gt; Ajax代码，获取当前表单数据，并使用get方式传递到服务端 12345678910111213141516171819$(document).ready(function () &#123; $(\"button\").click(function () &#123; $.ajax(&#123; url: 'http://127.0.0.1:8000/axios/', // 请求地址，对应Django某个路由映射 type: 'get', // 请求方式 post dataType: \"jsonp\", // 指定服务端返回的数据为jsonp格式 data: &#123; 'name': $('#ajax_data').val(), &#125;, success: function (result) &#123; console.log(result) $('#content').html(result) &#125; &#125;) &#125;)&#125;) ajax发起请求，并指定服务端返回数据类型为jsonp格式 服务端构建函数包含参数的字符串，为jsonp请求发起时，给定的回调参数名，参数为要返回的数据 客户端先会调用回调函数，然后会调用 1success 回调函数可以接收处理服务端返回的数据 success回调函数是成功返回数据后必定会调用的函数 CORS 跨域资源共享CORS(Cross-Origin Resource Sharing)是一种机制，它使用额外的HTTP头来告诉浏览器，让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源 当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求 注意：不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了 实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信 这里需要我们将后端视图函数在接收到请求时，返回结果指明头部信息 123456789101112class Cors(View): def post(self,request): #判断是否为ajax请求 name = request.POST.get('name') response = HttpResponse(json.dumps('OK')) response[\"Access-Control-Allow-Origin\"] = \"http://127.0.0.1:5500\" # 允许可以跨域请求的站点 response[\"Access-Control-Allow-Methods\"] = \"POST, GET, OPTIONS\" # 允许可以跨域访问的请求方式 response[\"Access-Control-Allow-Headers\"] = \"*\" # 允许可以跨域请求时的头部字段 return response 前端页面的ajax代码正常提交数据即可 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.10.2.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"text\" id='name'&gt; &lt;button id='button'&gt;提交&lt;/button&gt;&lt;/body&gt; &lt;script&gt; $('#button').click(function ()&#123; $.ajax(&#123; url: 'http://127.0.0.1:8000/', type: 'post', data: &#123; name: $('#name').val() &#125;, success: function(result)&#123; console.log(result) &#125; &#125;) &#125;) &lt;/script&gt;&lt;/html&gt; django-cors-headers 除了以上手动构建返回结果的头部信息用来解决跨域问题 在django中还可以通过一个先成可以自动添加CORS-Header的中间件，只需要在settings.py中做一些简单的配置即可 要想使用该中间件需要安装django的三方插件 1pip install django-cors-headers 安装完成之后，在django的settings文件中加载app 1# settings.pyINSTALLED_APPS = [ ... 'django.contrib.staticfiles', 'corsheaders',] 接下来在中间件配置部分加载该插件所提供的中间件 1# settings.pyMIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'corsheaders.middleware.CorsMiddleware', # 顺序需要在common组件之前 'django.middleware.common.CommonMiddleware', #'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',] 继续配置允许跨站请求的白名单设置等属性 123# settings.pyCORS_ORIGIN_ALLOW_ALL = False # 是否允许其他所有站点发起跨站请求CORS_ORIGIN_WHITELIST = ( 'http://127.0.0.1:5500',) # 跨站请求白名单CORS_ALLOW_METHODS = ( 'POST',) # 允许跨站访问的请求方式CORS_ALLOW_HEADERS = ( '*',) # 允许跨站请求头中的字段类型 注：其中某些设置的默认值为如下所示 1234567891011121314151617default_headers = ( 'accept', 'accept-encoding', 'authorization', 'content-type', 'dnt', 'origin', 'user-agent', 'x-csrftoken', 'x-requested-with',)default_methods = ( 'DELETE', 'GET', 'OPTIONS', 'PATCH', 'POST', 'PUT',)","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]}]}
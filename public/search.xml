<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis 心跳检测</title>
    <url>/redis%E7%9A%84%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="Redis-心跳检测"><a href="#Redis-心跳检测" class="headerlink" title="Redis 心跳检测"></a>Redis 心跳检测</h1><blockquote>
<p>在命令传播阶段，<strong>从服务器默认以每秒一次的频率</strong>，向主服务器发送命令：</p>
<p>*<em>REPLCONF ACK *</em> //replication_offset是从服务器当前的复制偏移量。</p>
<p>心跳检测的作用：检测主服务器的网络连接状态；辅助实现min-slaves选项；检测命令丢失。</p>
<p>检测主从服务器的网络连接状态</p>
<p>通过向主服务器发送INFO replication命令，可以列出从服务器列表，可以看出从最后一次向主发送命令距离现在过了多少秒。</p>
<p><img src="https://img-blog.csdn.net/20170829110005938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemxmcHJvZ3JhbQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<p>lag的值应该在0或1之间跳动，如果超过1则说明主从之间的连接有故障。</p>
<p>辅助实现min-slaves选项</p>
<p>Redis可以通过配置<strong>防止主服务器在不安全的情况下执行写命令</strong>；</p>
<p>min-slaves-to-write 3</p>
<p>min-slaves-max-lag 10</p>
<p>上面的配置表示：从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时，主服务器将拒绝执行写命令。这里的延迟值就是上面INFOreplication命令的lag值。</p>
<p>检测命令丢失</p>
<p>如果因为网络故障，主服务器传播给从服务器的<strong>写命令在半路丢失</strong>，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将发觉从服务器当前的<strong>复制偏移量</strong>少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器。</p>
<p>主服务器向从服务器<strong>补发缺失数据</strong>这一操作的原理和部分重同步操作的原理非常相似，它们的区别在于：补发缺失数据操作在主从服务器没有断线的情况下执行，而部分重同步操作则在主从服务器断线并重连之后执行。</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis 心跳检测</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 哨兵机制</title>
    <url>/Redis%E7%9A%84%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Redis-哨兵机制"><a href="#Redis-哨兵机制" class="headerlink" title="Redis 哨兵机制"></a>Redis 哨兵机制</h1><h3 id="什么是哨兵机制？"><a href="#什么是哨兵机制？" class="headerlink" title="什么是哨兵机制？"></a>什么是哨兵机制？</h3><ul>
<li><p>Redis 的哨兵（sentinel）系统用于管理多个 Redis 服务器，<strong>哨兵是redis集群架构中非常重要的一个组件</strong>，该系统执行以下三个任务：</p>
<ul>
<li><strong>监控（Monitoring）</strong>：哨兵（sentinel）会不断地检查你的 Master 和Slave 是否运作正常。</li>
<li><strong>提醒（Notification）</strong>：当别监控的某个 Redis 出现问题时，哨兵（sentinel）可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li><strong>自动故障迁移（Automatic failover）</strong>：当一个Master 不能正常工作时，哨兵（sentinel）会开始一次自动故障迁移操作，它会将失效 Master 的其中一个 Slave 升级为新的 Master，并让失效 Master 的其他 Slave 改为复制新的 Master；当客户端视图连接失败的 Master时，集群也会向客户端返回新 Master 的地址，使得集群可以使用 Master 代替失效 Master。</li>
</ul>
</li>
<li><p><strong>哨兵（sentinel）是一个分布式系统，作为一个哨兵集群去运行的，相互协同工作，你可以在一个架构中运行多个哨兵（sentinel）进程</strong></p>
<blockquote>
<p>​        (1)故障转移时，判断一个master node宕机了，需要大部分哨兵都同意才行，涉及到分布式选举问题。<br>​         (2)及时部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身就是单点，那么就不靠谱。        </p>
<p>​        这些进程使用留言协议（gossipprotocols）来接收关于Master 是否下线的信息，并使用投票协议 （agreementprotocols）来决定是否执行自动故障迁移，以及选择哪个 Slave 作为新的 Master。</p>
<p>​        每个哨兵（sentinel）会向其它哨兵（sentinel）、master、slave<strong>定时</strong>发送消息，以确认对方是否 <strong>“活“ **着，如果发现对方在指定时间（可配置）内未响应，则暂时认为对方已挂（所谓的</strong>”主观认为冗机“**Subjective Down,简称sdown)）</p>
<p>​        若<strong>“哨兵群”</strong>中的多数据sentinel，都报告某一 master 没响应，系统才认为该 master <strong>“彻底死亡”</strong>(即:客观上的真正down机,Objective Down,简称odown),通过一定的vote算法,从剩下的slave节点中,选一台提升为master,然后自动修改相关配置。</p>
<p>​         虽然<strong>哨兵(sentinel) *<em>释出为一个单独的可执行文件 *</em>redis-sentinel **,但实际上它只是一个运行在特殊模式下的 Redis 服务器，你可以在启动一个普通 Redis 服务器时通过给定</strong> –sentinel** 选项来启动<strong>哨兵(sentinel)</strong>。</p>
</blockquote>
<p>​         哨兵(sentinel) 的一些设计思路和zookeeper非常类似</p>
<p><img src="/.cn//20171004163652928.png" alt="哨兵"></p>
</li>
</ul><a id="more"></a>
<h3 id="哨兵的核心知识"><a href="#哨兵的核心知识" class="headerlink" title="哨兵的核心知识"></a>哨兵的核心知识</h3><hr>
<ul>
<li><p>哨兵至少需要3个实例，来保证自己的健壮性。</p>
</li>
<li><p>哨兵+redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用性</p>
</li>
<li><p>对于哨兵+redis主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充分的测试和演练。</p>
</li>
</ul>
<h3 id="redis哨兵主备切换的数据丢失问题"><a href="#redis哨兵主备切换的数据丢失问题" class="headerlink" title="redis哨兵主备切换的数据丢失问题"></a>redis哨兵主备切换的数据丢失问题</h3><hr>
<p>两种丢失情况：</p>
<ul>
<li><p>异步复制导致的数据丢失</p>
<blockquote>
<p>​        因为master-&gt;slave的复制是异步的，所 以可能有部分数据还没复制到slave，master就宕机了，这些数据就丢失了。</p>
</blockquote>
</li>
<li><p>脑裂导致的数据丢失</p>
<blockquote>
<p>​        脑裂，也就是说，某个master所在机器 突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着<br> ​        这个时候，集群中就会出现两个master。<br> ​        此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续写向旧master数据可能就会丢失。<br> ​        因此master在恢复的时候，会被作为一个slave挂到新的master上，自己的数据会被清空，从新的master复制数据</p>
</blockquote>
</li>
</ul>
<h3 id="解决异步复制和脑裂导致的数据丢失"><a href="#解决异步复制和脑裂导致的数据丢失" class="headerlink" title="解决异步复制和脑裂导致的数据丢失"></a>解决异步复制和脑裂导致的数据丢失</h3><hr>
<p>min-slaves-to-write 1<br> min-slaves-max-lag 10<br> 要求至少有1个slave，数据复制和同步的延迟不能超过10秒<br> 如果说一旦所有slave，数据复制和同步的延迟都超过了10秒钟，那么这个时候，master就不会再接收任何请求了。<br> （1）减少异步复制的数据丢失<br> 有了min-slaves-max-lag这个配置，就可以确保说，一旦slave复制数据和ack延时太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求，这样可以把master宕机时由于部分数据未同步到slave导致的数据丢失降低的可控范围内<br> （2）减少脑裂的数据丢失<br> 如果一个master出现了脑裂，跟其他slave丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的slave发送数据，而且slave超过10秒没有给自己ack消息，那么就直接拒绝客户端的写请求<br> 这样脑裂后的旧master就不会接受client的新数据，也就避免了数据丢失<br> 上面的配置就确保了，如果跟任何一个slave丢了连接，在10秒后发现没有slave给自己ack，那么就拒绝新的写请求<br> 因此在脑裂场景下，最多就丢失10秒的数据</p>
<p><img src="/.cn//16098303-42c2105c21bdce39.webp" alt="img"></p>
<p>集群脑裂导致的数据丢失问题.png</p>
<p><img src="https://upload-images.jianshu.io/upload_images/16098303-8536b356a0b50aa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>脑裂导致数据丢失的问题如何降低损失.png</p>
<p><img src="https://upload-images.jianshu.io/upload_images/16098303-a9e5b4bd87a20f7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>异步复制导致的数据丢失问题.png</p>
<p><img src="https://upload-images.jianshu.io/upload_images/16098303-d31754d7d5f73a8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="哨兵模式的配置修改"><a href="#哨兵模式的配置修改" class="headerlink" title="哨兵模式的配置修改"></a>哨兵模式的配置修改</h3><hr>
<ul>
<li>实现步骤<ul>
<li>拷贝到etc目录<ul>
<li><strong>cp sentinel.conf /usr/local/redis/etc</strong></li>
</ul>
</li>
<li>修改sentinel.conf配置文件<ul>
<li><strong>sentinel monitor mymast 192.168.110.133 6379 1</strong> #主节点 名称 IP 端口号 选举次数</li>
<li>#配置主服务器的密码(如没设置密码，可以省略)<br>  <strong>sentinel auth-pass mymaster 123456</strong> </li>
</ul>
</li>
<li>修改心跳检测 5000毫秒<ul>
<li><strong>sentinel down-after-milliseconds mymaster 5000</strong></li>
</ul>
</li>
<li>做多多少合格节点<ul>
<li><strong>sentinel parallel-syncs mymaster 2</strong></li>
</ul>
</li>
<li>启动哨兵模式<ul>
<li><strong>./redis-server /usr/local/redis/etc/sentinel.conf –sentinel &amp;</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：</p>
<p>1.当启动哨兵模式之后，如果你的master服务器宕机之后，哨兵自动会在从redis服务器里面 投票选举一个master主服务器出来；这个主服务器也可以进行<strong>读写</strong>操作！</p>
<p>2.如果之前宕机的主服务器已经修好，可以正式运行了。那么这个服务器只能进行<strong>读</strong>的操作，会自动跟随由哨兵选举出来的新服务器！</p>
<p>3.大家可以进入./redis-cli，输入<strong>info，</strong>查看你的状态信息；</p>
</blockquote>
<p><img src="https://img-blog.csdn.net/20171004170405127?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXN3S25pZ2h0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
<h3 id="哨兵-Sentinel-总结"><a href="#哨兵-Sentinel-总结" class="headerlink" title="哨兵(Sentinel)总结"></a>哨兵(Sentinel)总结</h3><blockquote>
<p>1、<strong>Sentinel</strong>的作用：</p>
<p>A、Master 状态监测</p>
<p>B、如果Master 异常，则会进行Master-slave 转换，将其中一个Slave作为Master，将之前的Master作为Slave </p>
<p>C、Master-Slave切换后，master_redis.conf、slave_redis.conf和sentinel.conf的内容都会发生改变，即master_redis.conf中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换 </p>
<p>2、<strong>Sentinel</strong>的工作方式<strong>:</strong></p>
<p>1)：每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令。</p>
<p>2)：如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。 </p>
<p>3)：如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。 </p>
<p>4)：当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 。</p>
<p>5)：在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 。</p>
<p>6)：当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 。</p>
<p>7)：若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。 </p>
<p>若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</p>
<p>最后，如果大家看不太懂，推荐大家看两个博客，就明白了！</p>
<p>1.<a href="http://blog.csdn.net/zbw18297786698/article/details/52891695" target="_blank" rel="noopener">http://blog.csdn.net/zbw18297786698/article/details/52891695</a><br>2.<a href="http://blog.csdn.net/candy_rainbow/article/details/52842402" target="_blank" rel="noopener">http://blog.csdn.net/candy_rainbow/article/details/52842402</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis 哨兵机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 主从复制</title>
    <url>/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h1><ul>
<li><p>参考链接：</p>
<ul>
<li><p><a href="https://www.cnblogs.com/leeSmall/p/8398401.html" target="_blank" rel="noopener">Redis主从复制和哨兵 参考1</a></p>
<p><a href="https://www.cnblogs.com/chenhuabin/p/10048854.html" target="_blank" rel="noopener">Redis主从复制和哨兵 参考2</a></p>
<p><a href="https://www.cnblogs.com/lxx666/articles/10693844.html" target="_blank" rel="noopener">Redis主从架构和主从从架构集群搭建详细步骤</a></p>
<p><a href="https://www.cnblogs.com/wade-luffy/p/9639986.html" target="_blank" rel="noopener">Redis主从复制原理</a></p>
<p><a href="http://doc.redisfans.com/topic/replication.html" target="_blank" rel="noopener">Redis复制官方文档翻译</a></p>
</li>
</ul>
</li>
</ul><a id="more"></a>
<blockquote>
<p> ​        Redis 的定位是一个高可用的数据服务器，可是实际生产环境下，单机的 <code>redis</code> 服务器是无法满足真正意义上的高可用性的，</p>
<p>​        第一，单机的 <code>redis</code> 服务器很容易发生单点故障，即使 <code>redis</code> 提供了各种持久化的方法来避免数据的丢失，但是物理机上的故障（硬板损坏等）还是无法完全避免的。</p>
<p>​        第二，如果单台机器的性能进行纵向扩展，无论是<code>CPU</code>，内存还是磁盘容量都很容易达到瓶颈，无法满足实际需求。</p>
<p>​        针对这些问题，Redis提供了<strong>复制（replication）</strong>的功能，通过 “主从（一主多从）” 和 （集群（多住多从））的方式对 redis的服务进行水平扩展，用多台 redis 服务器共同构建一个高可用的 redis 服务系统。</p>
</blockquote>
<hr>
<p><img src="https://image-static.segmentfault.com/169/623/16962389-5c72b52170799_articlex" alt="图片描述">            </p>
<blockquote>
<p>​        主从复制，是指将一台<code>Redis</code>服务器的数据，复制到其它的 <code>Redis</code>服务器。前者称为主节点（master/leader），后者称为从节点（slave/follower）；数据的复制是单向的，只能由主节点到从节点。</p>
</blockquote>
<blockquote>
<p> ​            默认情况下，每台 <code>Redis</code>服务器都是主节点；且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。</p>
</blockquote>
<h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><hr>
<ul>
<li><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>
<li><strong>负载均衡</strong> ：在主从复制的基础上，配合读写分离，可以由主节点提供服务，由从节点提供读服务（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</li>
<li><strong>读写分离</strong>：可以用于实现读写分离，主库写，从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量。</li>
<li><strong>高可用基石</strong> ：主从复制还是哨兵和肌群能够实施的基础，因此说主从复制是 Redis高可用的基础。</li>
</ul>
<h3 id="主从括扑结构"><a href="#主从括扑结构" class="headerlink" title="主从括扑结构"></a>主从括扑结构</h3><hr>
<ul>
<li><p><strong>一主一从</strong>：用于节点故障转移从节点，当主节点的 写 命令并发高且需要持久化，可以值在从节点开启AOF （主节点不需要），这样保证了数据的安全性，也避免持久化对主节点的影响。</p>
<p> <img src="https://images2017.cnblogs.com/blog/1227483/201802/1227483-20180201102310015-486760227.png" alt="img"></p>
</li>
<li><p><strong>一主多从</strong> ：针对 <code>读</code>较多的场景， <code>读</code>由多个从节点来分担，但节点越多，主节点同步到多节点的次数也越多，影响带宽，也加重主节点的稳定</p>
<p>​     <img src="https://images2017.cnblogs.com/blog/1227483/201802/1227483-20180201103217750-831662244.png" alt="img"></p>
</li>
<li><p><strong>树状主从</strong>  ：一主多从的缺点（住节点推送次数多压力大）可用些方案解决，主节点只推送一次数据到从节点B，再由从节点B推送到C，减轻主节点推送的压力。</p>
</li>
</ul>
<p>  <img src="https://images2017.cnblogs.com/blog/1227483/201802/1227483-20180201103511703-1604168118.png" alt="img"></p>
<h3 id="Redis-主从复制启用"><a href="#Redis-主从复制启用" class="headerlink" title="Redis 主从复制启用"></a>Redis 主从复制启用</h3><hr>
<ul>
<li><p>主从复制的开启，完全是在从节点发起的；不需要我们在主节点做任何事情。</p>
</li>
<li><p>从节点开启主从复制，有三种方式：</p>
<blockquote>
<ol>
<li><p>配置文件：在从服务器的配置文件中加入：slaveof <masterip><masterpory></masterpory></masterip></p>
</li>
<li><p>启动命令： redis-server 启动命令后加入 –slaveof <masterip><masterport></masterport></masterip></p>
</li>
<li><p>客户端命令：Reids 服务器启动后，直接通过客户端执行命令： slaveof <masterip> <masterport> ,则该Redis实例成为从节点。</masterport></masterip></p>
<p>通过 info  relication  命令可以看到复制的一些信息</p>
</li>
</ol>
</blockquote>
</li>
<li><p>断开主从复制</p>
<blockquote>
<p>​        通过 slaveof <masterip> <masterport> 命令建立主从复制关系以后，可以通过slaveof no one断开。</masterport></masterip></p>
<p>​        从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化。</p>
</blockquote>
</li>
</ul>
<h3 id="Redis-主从复制原理"><a href="#Redis-主从复制原理" class="headerlink" title="Redis 主从复制原理"></a>Redis 主从复制原理</h3><hr>
<p>主从复制过程大体可以分为3个阶段：<strong>连接建立阶段（即准备阶段）</strong>、<strong>数据同步阶段</strong>、<strong>命令传播阶段</strong>：</p>
<p>在从节点执行 slaveof 命令后，复制过程便开始运作，下图大概可以看到,</p>
<p>从图中可以看出复制过程大致分为 6 个过程</p>
<p><img src="https://image-static.segmentfault.com/129/061/1290613498-5c72b64944189_articlex" alt="图片描述"></p>
<h4 id="从服务器故障后处理"><a href="#从服务器故障后处理" class="headerlink" title="从服务器故障后处理"></a><strong>从服务器故障后处理</strong></h4><blockquote>
<pre><code>当从服务器崩溃之后，重启之后进行初始化，会自动的同步主服务器的数据。在 redis的2.8版本之后，redis 采用了 **增量复制** 的方式优化了从服务器的初始化同步数据的过程。</code></pre></blockquote>
<h4 id="主服务器故障后处"><a href="#主服务器故障后处" class="headerlink" title="主服务器故障后处"></a><strong>主服务器故障后处</strong></h4><blockquote>
<pre><code>当主服务器崩溃之后，首先需要手动的选择一个从服务器升级为主服务器（需要手动调整所有相关的服务器），然后启动之前已经崩溃的主服务器做为从服务回到系统中。

可以看到，redis 在主服务器崩溃之后需要繁琐的人工预来恢复服务，特别是在主数据库进制了持久化之后，上述步骤不能错乱，否则会导致主数据库重启后恢复了错误数据，进而导致从数据库也同步错误数据这一灾难性后果。为此，redis 提供了哨兵机制，用于自动化的监控和维持分布式 redis 系统的良好运转。    </code></pre></blockquote>
<h3 id="连接建立阶段"><a href="#连接建立阶段" class="headerlink" title="连接建立阶段"></a>连接建立阶段</h3><h4 id="step1：保存主节点信息"><a href="#step1：保存主节点信息" class="headerlink" title="step1：保存主节点信息"></a>step1：保存主节点信息</h4><p>​    从节点服务器内部维护了两个字段，即<strong>masterhost</strong>和<strong>masterport</strong>字段，用于存储主节点的<strong>ip</strong>和<strong>port</strong>信息。</p>
<p>​    <strong>slaveof是异步命令，从节点完成主节点ip和port的保存后，向发送slaveof命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。</strong></p>
<h4 id="step2：建立socket连接"><a href="#step2：建立socket连接" class="headerlink" title="step2：建立socket连接"></a>step2：建立socket连接</h4><p>​    <strong>从节点每秒1次调用复制定时函数replicationCron()</strong>，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。</p>
<p><strong>如果连接成功：</strong></p>
<p>​    <strong>从节点：</strong>为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。</p>
<p>​    <strong>主节点：</strong>接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。</p>
<h4 id="step3：发送ping命令"><a href="#step3：发送ping命令" class="headerlink" title="step3：发送ping命令"></a>step3：发送ping命令</h4><p>​    从节点成为主节点的客户端之后，发送ping命令进行首次请求，<strong>目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求。</strong></p>
<p><strong>从节点发送ping命令后，可能出现3种情况：</strong></p>
<ol>
<li><p>返回ping：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。</p>
</li>
<li><p>超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。</p>
</li>
<li><p>返回ping以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。</p>
</li>
</ol>
<h4 id="step4：身份验证"><a href="#step4：身份验证" class="headerlink" title="step4：身份验证"></a>step4：身份验证</h4><p>如果从节点中设置了<strong>masterauth</strong>选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。</p>
<p>从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。</p>
<p>如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。</p>
<h4 id="step5：发送从节点端口信息"><a href="#step5：发送从节点端口信息" class="headerlink" title="step5：发送从节点端口信息"></a>step5：发送从节点端口信息</h4><p>身份验证之后，从节点会向主节点发送其监听的端口号，主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；<strong>该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。</strong></p>
<h3 id="数据同步阶段"><a href="#数据同步阶段" class="headerlink" title="数据同步阶段"></a>数据同步阶段</h3><p>主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。</p>
<p>具体执行的方式是：从节点向主节点发送<strong>psync命令</strong>，开始同步。</p>
<p>数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为<strong>全量复制和部分复制</strong>。</p>
<blockquote>
<p>在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端。原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。</p>
</blockquote>
<h3 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h3><p>​    数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。</p>
<p>​    在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。</p>
<p><strong>PS：</strong></p>
<p>​    <strong>延迟与不一致：</strong>命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关。</p>
<p>​    <strong>repl-disable-tcp-nodelay no：</strong>该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY；默认no，即不禁止TCP_NODELAY。当设置为yes时，TCP会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no。</p>
<h3 id="【数据同步阶段】全量复制和部分复制"><a href="#【数据同步阶段】全量复制和部分复制" class="headerlink" title="【数据同步阶段】全量复制和部分复制"></a>【数据同步阶段】全量复制和部分复制</h3><p>在Redis2.8以前，从节点向主节点发送sync命令请求同步数据，此时的同步方式是全量复制；</p>
<p>在Redis2.8以后，从节点可以发送psync命令请求同步数据，此时根据主从节点当前状态的不同，同步方式可能是全量复制或部分复制。</p>
<ol>
<li>全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。</li>
<li>部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。</li>
</ol>
<h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p><strong>Redis通过psync命令进行全量复制的过程如下：</strong></p>
<ol>
<li><p>从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行全量复制；</p>
</li>
<li><p>主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令。</p>
</li>
<li><p>主节点的bgsave执行完成后，将RDB文件发送给从节点；从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态。</p>
</li>
<li><p>主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态。</p>
</li>
<li><p>如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态。</p>
</li>
</ol>
<p><strong>通过全量复制的过程可以看出，全量复制是非常重型的操作：</strong></p>
<ol>
<li><p>主节点通过<strong>bgsave</strong>命令<strong>fork</strong>子进程进行<strong>RDB</strong>持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的；</p>
</li>
<li><p>主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗。</p>
</li>
<li><p>从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗。</p>
</li>
</ol>
<h4 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h4><p>​    由于全量复制在主节点数据量较大时效率太低，因此Redis2.8开始提供部分复制，用于处理网络中断时的数据同步。</p>
<p>​    部分复制的实现，依赖于三个重要的概念：复制偏移量，复制积压缓冲区，服务器运行ID</p>
<h5 id="offset-复制偏移量"><a href="#offset-复制偏移量" class="headerlink" title="offset 复制偏移量"></a>offset 复制偏移量</h5><p>​        在主从复制的Master(主节点)和Slave(从节点)双方都会各自维持一个offset，代表的是<strong>主节点向从节点传递的字节数</strong>；Master成功发送N个字节的命令后会将Master的offset加上N，Slave在接收到N个字节命令后同样会将Slave的offset增加N。Master和Slave如果状态是一致的那么它的的offset也应该是一致的。</p>
<p>​        offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。</p>
<h5 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h5><p>  复制积压缓冲区是由<strong>Master(主节点)维护的一个固定长度的FIFO队列(先进先出)</strong>，默认大小1MB；当主节点开始有从节点时创建，它的作用是缓存已经传播出去的命令。当Master进行命令传播时，不仅将命令发送给所有Slave，还会将命令写入到复制积压缓冲区里面。注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。</p>
<p>​        除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。</p>
<p>​        由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。</p>
<p><strong>从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制：</strong></p>
<ul>
<li><strong>如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；</strong></li>
<li><strong>如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。</strong></li>
</ul>
<h5 id="runid-服务器运行ID"><a href="#runid-服务器运行ID" class="headerlink" title="runid 服务器运行ID"></a>runid 服务器运行ID</h5><p>​        每个Redis服务器(无论主从)在启动时都会自动生成一个表明自己身份的随机ID(每次启动都不一样)，由40个随机的十六进制字符组成。在PSYNC中发送的这个ID是指之前连接的Master的ID，如果没保存这个ID，PSYNC命令会使用<strong>”PSYNC ? -1”</strong> 这种形式发送给Master，表示需要全量复制。</p>
<p>​        每个Redis节点，在启动时都会自动生成一个随机ID，由40个随机的十六进制字符组成；</p>
<p>runid用来唯一识别一个Redis节点。<strong>通过info Server命令，可以查看节点的runid。</strong></p>
<p>​        主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；</p>
<p><strong>主节点根据runid判断能否进行部分复制：</strong></p>
<ul>
<li><p>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</p>
</li>
<li><p>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</p>
</li>
</ul>
<h3 id="PSYNC命令"><a href="#PSYNC命令" class="headerlink" title="PSYNC命令"></a>PSYNC命令</h3><p>  Redis在2.8版本提供了PSYNC命令来带代替SYNC命令，为Redis主从复制提供了部分复制的能力。</p>
<h4 id="PSYNC命令格式"><a href="#PSYNC命令格式" class="headerlink" title="PSYNC命令格式"></a>PSYNC命令格式</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PSYNC &lt;runid&gt; &lt;offset&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> runid:主服务器ID</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> offset:从服务器最后接收命令的偏移量</span></span><br></pre></td></tr></table></figure>

<p>  <strong>PSYNC执行过程中比较重要的概念有3个：runid、offset（复制偏移量）以及复制积压缓冲区。</strong></p>
<h4 id="psync命令的执行"><a href="#psync命令的执行" class="headerlink" title="psync命令的执行"></a>psync命令的执行</h4><p><img src="/.cn//C:%5CUsers%5Casus%5CDesktop%5C990532-20180913134017449-1623896661.png" alt="990532-20180913134017449-1623896661"></p>
<ol>
<li><p>首先从节点根据当前状态，决定如何调用psync命令：</p>
<ul>
<li>如果从节点之前未执行过<strong>slaveof</strong>或最近执行了<strong>slaveof no one</strong>，则从节点发送命令为<strong>psync ? -1</strong>，向主节点请求全量复制；</li>
<li>如果从节点之前执行了<strong>slaveof</strong>，则发送命令为 <strong>psync <runid> <offset> **，其中</offset></runid></strong>runid<strong>为上次复制的主节点的</strong>runid<strong>，</strong>offset**为上次复制截止时从节点保存的复制偏移量。</li>
</ul>
</li>
<li><p>主节点根据收到的psync命令，及当前服务器状态，决定执行全量复制还是部分复制：</p>
<ul>
<li>如果主节点版本低于Redis2.8，则返回-ERR回复，此时从节点重新发送sync命令执行全量复制；</li>
<li>如果主节点版本够新，且runid与从节点发送的runid相同，且从节点发送的offset之后的数据在复制积压缓冲区中都存在，则回复+CONTINUE，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可；</li>
<li>如果主节点版本够新，但是runid与从节点发送的runid不同，或从节点发送的offset之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，则回复<strong>+FULLRESYNC <runid> <offset></offset></runid></strong>，表示要进行全量复制，其中runid表示主节点当前的runid，offset表示主节点当前的offset，从节点保存这两个值，以备使用。</li>
</ul>
</li>
</ol>
<h3 id="【命令传播阶段】心跳机制"><a href="#【命令传播阶段】心跳机制" class="headerlink" title="【命令传播阶段】心跳机制"></a>【命令传播阶段】心跳机制</h3><p>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。心跳机制对于主从复制的超时判断、数据安全等有作用。</p>
<h4 id="主-gt-从：PING"><a href="#主-gt-从：PING" class="headerlink" title="主-&gt;从：PING"></a>主-&gt;从：PING</h4><p>每隔指定的时间，<strong>主节点会向从节点发送PING命令</strong>，这个PING命令的作用，主要是为了让从节点进行超时判断。</p>
<p>PING发送的频率由 repl-ping-slave-period 参数控制，单位是秒，默认值是10s。</p>
<h4 id="从-gt-主：REPLCONF-ACK"><a href="#从-gt-主：REPLCONF-ACK" class="headerlink" title="从-&gt;主：REPLCONF ACK"></a>从-&gt;主：REPLCONF ACK</h4><p>在命令传播阶段，<strong>从节点会向主节点发送REPLCONF ACK命令，</strong>频率是每秒1次；</p>
<p><strong>命令格式为：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">REPLCONF ACK &#123;offset&#125;	# offset指从节点保存的复制偏移量。</span><br></pre></td></tr></table></figure>

<p><strong>REPLCONF ACK命令的作用包括：</strong></p>
<ol>
<li><p><strong>实时监测主从节点网络状态：</strong>该命令会被主节点用于复制超时的判断。此外，在主节点中使用info Replication，可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1。</p>
</li>
<li><p><strong>检测命令丢失：</strong>从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会推送缺失的数据（这里也会利用复制积压缓冲区）。</p>
</li>
</ol>
<ul>
<li><strong>注意：offset和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的。</strong></li>
</ul>
<ol start="3">
<li><strong>辅助保证从节点的数量和延迟：</strong>Redis主节点中使用min-slaves-to-write和min-slaves-max-lag参数，来保证主节点在不安全的情况下不会执行写命令；所谓不安全，是指从节点数量太少，或延迟过高。例如min-slaves-to-write和min-slaves-max-lag分别是3和10，含义是如果从节点数量小于3个，或所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。而这里从节点延迟值的获取，就是通过主节点接收到REPLCONF ACK命令的时间来判断的，即前面所说的info Replication中的lag值。</li>
</ol>
<p>　　</p>
<h2 id="开启主从复制"><a href="#开启主从复制" class="headerlink" title="开启主从复制"></a>开启主从复制</h2><p>从节点开启主从复制，有3种方式：</p>
<ul>
<li>配置文件：在从服务器的配置文件中加入：<strong>slaveof <masterip> <masterport></masterport></masterip></strong></li>
<li>启动命令：redis-server启动命令后加入： <strong>–slaveof <masterip> <masterport></masterport></masterip></strong></li>
<li>客户端命令：Redis服务器启动后，直接通过客户端执行命令：<strong>slaveof <masterip> <masterport></masterport></masterip></strong>，则该Redis实例成为从节点。</li>
</ul>
<h3 id="修改配置文件方法："><a href="#修改配置文件方法：" class="headerlink" title="修改配置文件方法："></a>修改配置文件方法：</h3><h4 id="1-配置从服务配置文件redis-conf"><a href="#1-配置从服务配置文件redis-conf" class="headerlink" title="1. 配置从服务配置文件redis.conf"></a>1. 配置从服务配置文件redis.conf</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">slaveof 192.168.1.9 6379    #添加属于某台主机的从 服务</span><br><span class="line">masterauth 123456       #从服务连接主服的密码（访问主服务器的密码）</span><br><span class="line">slave-read-only yes     #从服务只读，不可在命令行写入数据</span><br><span class="line"></span><br><span class="line">5.0.4以后：</span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">replica-read-only yes</span><br></pre></td></tr></table></figure>

<h4 id="2-重新启动从服务即实现主从连接"><a href="#2-重新启动从服务即实现主从连接" class="headerlink" title="2. 重新启动从服务即实现主从连接"></a>2. 重新启动从服务即实现主从连接</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. ./bin/redis-cli	# 启动redis客户端</span><br><span class="line">2. 输入 info replication # 查看与复制相关的状态，了解主从节点的当前状态</span><br></pre></td></tr></table></figure>

<p><strong>输入info replication 后显示的内容：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:slave      # 表示此台服务器是主是从</span><br><span class="line">master_host:39.107.38.62     # 主服务器ip</span><br><span class="line">master_port:6379        # 主服务器端口号</span><br><span class="line">master_link_status:up       # 与主服务器是否连接成功 up为成功 down失败</span><br><span class="line">master_last_io_seconds_ago:9</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:808</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:ea5230cc485f9c6f372b2c89a65613fb075aff8b</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:808</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:15</span><br><span class="line">repl_backlog_histlen:794</span><br></pre></td></tr></table></figure>

<h4 id="遇到的报错："><a href="#遇到的报错：" class="headerlink" title="遇到的报错："></a>遇到的报错：</h4><h5 id="1-Error-condition-on-socket-for-SYNC-Connection-refused"><a href="#1-Error-condition-on-socket-for-SYNC-Connection-refused" class="headerlink" title="1. Error condition on socket for SYNC: Connection refused"></a>1. Error condition on socket for SYNC: Connection refused</h5><p>  <strong>出现原因</strong>：</p>
<p>  ​    redis主服务器绑定了127.0.0.1，跨服务器IP的访问就会失败，只能本机才能访问，外部请求会被过滤。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">1. 主服务器绑定ip: bind 39.107.38.62</span><br><span class="line">3. bind 0.0.0.0</span><br><span class="line">2. 注释bind  # 会报下面的错↓</span><br></pre></td></tr></table></figure>

<h5 id="2-‘-DENIED-Redis-is-running-in-protected-mode-because-protected-mode-is-enabled-no-bind-address-was-specified-no-authentication-password-is-requested-to-clients-In-this-mode-connections-are-only-accepted-from-the-loopback-interface-If-you-want-to-connec"><a href="#2-‘-DENIED-Redis-is-running-in-protected-mode-because-protected-mode-is-enabled-no-bind-address-was-specified-no-authentication-password-is-requested-to-clients-In-this-mode-connections-are-only-accepted-from-the-loopback-interface-If-you-want-to-connec" class="headerlink" title="2. ‘-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connec"></a>2. ‘-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connec</h5><p>   <strong>出现原因</strong>：</p>
<p>   ​    处于保护模式，只能本地链接。没有绑定ip 没有设置验证密码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">1. 主服务器绑定ip： bind 39.107.38.62</span><br><span class="line">2. 设置主服务器访问密码：requirepass 12345</span><br></pre></td></tr></table></figure>

<h5 id="3-error-READONLY-You-can’t-write-against-a-read-only-replica"><a href="#3-error-READONLY-You-can’t-write-against-a-read-only-replica" class="headerlink" title="3. (error) READONLY You can’t write against a read only replica."></a>3. (error) READONLY You can’t write against a read only replica.</h5><p>​    <strong>出现原因</strong>：</p>
<p>​        从库只可读不可写</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">1. 设置slave-read-only no # 代表不限于只读</span><br></pre></td></tr></table></figure>

<h2 id="断开主从复制"><a href="#断开主从复制" class="headerlink" title="断开主从复制"></a>断开主从复制</h2><p>​    通过<strong>slaveof <masterip> <masterport></masterport></masterip></strong>命令建立主从复制关系以后，可以通过slaveof no one断开。</p>
<p>从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化。</p>
<hr>
<h4 id="Redis-哨兵"><a href="#Redis-哨兵" class="headerlink" title="Redis 哨兵"></a>Redis 哨兵</h4><hr>
<ul>
<li><p>哨兵的介绍</p>
<blockquote>
<p>​        redis 的设计者为了让 redis 能够在主从模式下实现故障恢复的自动化，为此提供了 redis 的哨兵功能。哨兵是一个独立于数据服务器的进程，用于监控 redis 数据服务器的状态，当主从模式下最关键的主服务器出现故障时，能够被哨兵自动的察觉。同时哨兵会在剩余的从服务器中“<strong>选择</strong>”出新的主服务器，达到自动化恢复系统的目的。</p>
</blockquote>
</li>
<li><p>哨兵的使用</p>
<blockquote>
<p>​        redis 提供了<strong>redis-setine</strong> 脚本用于部署哨兵，启动时通过指定的哨兵配置文件来对哨兵的行为进行灵活的控制。哨兵的配置文件中至少需要包含被哨兵监控的主服务器<strong>IP</strong>、<strong>端口</strong>、投票决定数目，当然可以配置诸如 <strong>down-after-milliseconds</strong> （发送<strong>ping</strong>命令的时间间隔，用于监听）等选项。</p>
<p>​        <strong>sentinel monitor</strong> *”master_name” “IP” “PORT”***</p>
<p>​        <strong>down-after-milliseconds</strong> *”milliseconds”*　(“milliseconds”大于1000时，默认为1000)</p>
</blockquote>
</li>
<li><p><strong>哨兵的工作方式</strong></p>
<blockquote>
<p>​        哨兵启动时会与主服务器建立连接，并且间接的获得所属从服务器信息，完成哨兵的初始化。哨兵初始化完成之后，会周期性的和主从服务器、其他哨兵节点（通过消息频道的订阅）进行通信。</p>
<p>​        哨兵每10秒会向所有服务器发送一次<strong>INFO</strong>命令，获得相关 redis 服务器的当前状态以便决定是否需要故障恢复。</p>
<p>​        当一个哨兵在<strong>down-after-milliseconds</strong>规定时间内未收到主服务器的响应，则当前哨兵<strong>“主观”</strong>认为主服务器下线，同时和监视当前系统的其它哨兵进行投票决定，当超过当前哨兵配置中投票决定的数目时，则当前哨兵<strong>“客观”</strong>认为主服务器下线，哨兵集群会选举出领导哨兵来进行主从服务器集群主从状态的切换(使用Raft算法)。</p>
</blockquote>
</li>
</ul>
<h3 id="redis主从复制总结"><a href="#redis主从复制总结" class="headerlink" title="redis主从复制总结"></a>redis主从复制总结</h3><hr>
<ul>
<li><h4 id="乐观复制策略"><a href="#乐观复制策略" class="headerlink" title="乐观复制策略"></a>乐观复制策略</h4><blockquote>
<p>​        redis的主从复制采用的是乐观复制的策略，在一定的时间内允许主从服务器的数据不完全一致，但是保持主从数据库数据的最终一致性(按照<strong>CAP定理</strong>,放弃了<strong>C</strong>(强一致性))。</p>
<p>　　这意味着redis主从服务器之间的数据复制操作时异步的，主服务器不等待从服务器返回复制的结果，可以立即处理新的写入命令。这一策略使得主服务器的性能在复制时不会受到太大影响，但是从服务器会出现短时间内数据不一致的情况。redis允许用户配置主库的<strong>min-slaves-to-write</strong>(代表至少N台从服务器完成复制，才允许主服务器写入)和<strong>min-slaves-max-lag</strong>(允许从服务器断开连接的时间)这两个配置项来控制分区中数据不一致的影响。</p>
</blockquote>
</li>
<li><h4 id="和集群的区别"><a href="#和集群的区别" class="headerlink" title="和集群的区别"></a>和集群的区别</h4><blockquote>
<p>redis的主从复制特性为redis带来了很高的读取可用性，但是对于海量数据的持久化存储是力不从心的。因为主从复制结构下，任意的节点都保存了100%的存储数据，所以能够存储的数据规模还是受限于单例服务器存储容量的大小。</p>
<p>　　为此，在单主多从结构的基础上，redis还提供了集群特性。通过将存储数据合理的分片存储在不同的redis节点上，通过集群水平扩容之后的redis集群拥有了极高的读写可用性和分区容错性。理解redis的主从复制原理是理解更为复杂的集群特性的基础。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis 主从复制</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 存储</title>
    <url>/docker%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<p>#Docker 存储</p><h3 id="Docek-镜像层的镜像分层结构"><a href="#Docek-镜像层的镜像分层结构" class="headerlink" title="Docek 镜像层的镜像分层结构"></a>Docek 镜像层的镜像分层结构</h3><ul>
<li>docker的镜像分层结构，如下所示：</li>
</ul><p><img src="https://docs.docker.com/storage/storagedriver/images/container-layers.jpg" alt="基于Ubuntu映像的容器层"></p><ul>
<li><p>docker镜像中引入层layer概念，镜像的制作过程中的每一步都会生产一个新的镜像层</p>
</li>
<li><p>容器读写层的工作原理</p>
<blockquote>
<p>我们刚刚在说镜像的分层特性的时候说到镜像是只读的。而事实上当我们使用镜像启动一个容器的时候，我们其实是可以在容器里随意读写的，从结果上看，似乎与镜像的只读特性相悖。</p>
<p>我们继续看上面的图，其实可以看到在镜像的最上层，还有一个读写层。而这个读写层，即在容器启动时为当前容器单独挂载。每一个容器在运行时，都会基于当前镜像在其最上层挂载一个读写层。而用户针对容器的所有操作都在读写层中完成。一旦容器销毁，这个读写层也随之销毁。</p>
<blockquote>
<p>知识点： 容器=镜像+读写层</p>
</blockquote>
<p>而我们针对这个读写层的操作，主要基于两种方式：写时复制和用时分配。</p>
</blockquote>
</li>
</ul><a id="more"></a>



<hr>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p><img src="https://docs.docker.com/storage/storagedriver/images/sharing-layers.jpg" alt="容器共享相同的图像"></p>
<ul>
<li><p>容器由最上面一个可写的容器层和若干个只读的镜像层组成，容器的数据就存在这些层中。这种分层结构最大的特点是Copy-on-Write。</p>
<ol>
<li><p>新数据会直接存放在最上面的容器层</p>
</li>
<li><p>修改现有数据会从镜像层复制文件到容器中，再在容器层修改并保存，镜像层的数据不会发生改变</p>
</li>
<li><p>若多个层中有命名相同的文件，用户只能看到最上面一层的文件</p>
</li>
</ol>
</li>
</ul>
<ul>
<li>分层结构使镜像和容器的创建、共享以及分发变得非常高效，而这些都要归功于 Docerk stoage driver。<strong>正是 storage driver 实现了多层数据的堆叠并为用户提供一个单一的合并之后的统一视图</strong>。</li>
</ul>
<hr>
<h3 id="Docker-为容器提供了两种存放数据的资源："><a href="#Docker-为容器提供了两种存放数据的资源：" class="headerlink" title="Docker 为容器提供了两种存放数据的资源："></a>Docker 为容器提供了两种存放数据的资源：</h3><ul>
<li>由storage driver（存储驱动） 管理的镜像层和容器层<ul>
<li>用来放一些无状态的数据<ul>
<li><strong>对于某些容器，直接将数据放在由</strong> storage driver <strong>维护的层中是很好的选择，比如那些无状态的应用。无状态意味着容器没有需要持久化的数据，随时可以从镜像直接创建。即存在与否依赖镜像的存在。</strong></li>
</ul>
</li>
</ul>
</li>
<li>Data Volume。（数据卷）<ul>
<li>用来放一些有状态的数据，例如数据库<ul>
<li><strong>本质上是</strong> Docker Host （主机）<strong>文件系统中的目录或文件，能够直接被 ** mount （挂载）</strong>到容器的文件系统中**。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="关于docker镜像的三问"><a href="#关于docker镜像的三问" class="headerlink" title="关于docker镜像的三问"></a>关于docker镜像的三问</h4><ul>
<li>基于镜像A创建镜像B时是否会拷贝A镜像中的所有文件：<code>是不会的</code></li>
<li>基于镜像创建容器时是否会拷贝镜像中的所有文件至文件层：<code>不会的</code></li>
<li>容器与镜像在结构上有什么区别：<code>没有区别容器会比镜像多了一个</code> <code>merged</code>文件</li>
</ul>
<blockquote>
<p>在讲原理前，先讲下写时复制和写时分配</p>
</blockquote>
<h4 id="写时复制（CoW）"><a href="#写时复制（CoW）" class="headerlink" title="写时复制（CoW）"></a>写时复制（CoW）</h4><blockquote>
<p>所有驱动都用到的技术——写时复制（CoW）。CoW就是copy-on-write，表示只在需要写时才去复制，这个是针对已有文件的修改场景比如基于一个image启动多个Container，如果为每个Container都去分配一个image一样的文件系统，那么将会占用大量的磁盘空间。而CoW技术可以让所有的容器共享image的文件系统，所有数据都从image中读取，只有当要对文件进行写操作时，才从image里把要写的文件复制到自己的文件系统进行修改。所以无论多少个容器共享同一个image，所作的写操作都是从image中复制到自己的文件系统中的复制本上进行，并不会修改image的源文件，且多个容器操作同一个文件，会在每个容器的文件系统里生成一个复本，每个容器修改的都是自己的复本，相互隔离的，相互不影响。使用CoW可以有效的提高磁盘的利用率。</p>
</blockquote>
<h4 id="用时分配（allocate-on-demand）"><a href="#用时分配（allocate-on-demand）" class="headerlink" title="用时分配（allocate-on-demand）"></a>用时分配（allocate-on-demand）</h4><blockquote>
<p>而用时分配是用在原本没有这个文件的场景，只有在要新写入一个文件时才分配空间，这样可以提高存储资源的利用率。比如启动一个容器，并不会为这个容器预分配一些磁盘空间，而是当有新文件写入时，才按需分配新空间。</p>
</blockquote>
<h4 id="Docker存储驱动的作用"><a href="#Docker存储驱动的作用" class="headerlink" title="Docker存储驱动的作用"></a>Docker存储驱动的作用</h4><blockquote>
<p>将这些分层的镜像文件堆叠起来，并且提供统一的视图.使container的文件系统看上去和我们普通的文件系统没什么区别。<br>当创建一个新的容器的时候,实际上是在镜像的分层上新添加了一层container layer（容器层）.之后所有对容器产生的修改,实际都只影响这一层。</p>
<p>注意</p>
<p>容器层：读写层(可写层)<br>镜像层：只读层</p>
</blockquote>
<blockquote>
<p> Docker 支持多种 storage driver，有 AUFS 、Device Mapper 、Btrfs 、OverlayFS 、VFS 和ZFS。它们都能实现分层的架构，同时又有各自的特性。对于Docker 用户来说，具体选择使用哪个 storage driver 是一个难题，因为：</p>
</blockquote>
<p>​            没有哪个driver 能够适应所有的场景。</p>
<p>​            driver 本身在快速发展和迭代。</p>
<blockquote>
<p>优先使用 Linux 发行版默认的 storage driver。Docker 安装时会根据当前系统的配置选择默认的 driver。默认 driver 具有最好的稳定性，因为默认 driver 在发行版上经过了严格的测试。</p>
</blockquote>
<blockquote>
<p>运行<code>docker info</code>可以查看可查看当前系统使用的<code>Storage driver</code>。</p>
<blockquote>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt; &gt; [root@izbp1dg6m4eebtcm77n0smz ~]# docker info</span><br><span class="line">&gt; &gt; Client:</span><br><span class="line">&gt; &gt; <span class="builtin-name">Debug</span> Mode: <span class="literal">false</span></span><br><span class="line">&gt; &gt; </span><br><span class="line">&gt; &gt; Server:</span><br><span class="line">&gt; &gt; Containers: 6</span><br><span class="line">&gt; &gt; Running: 4</span><br><span class="line">&gt; &gt; Paused: 0</span><br><span class="line">&gt; &gt; Stopped: 2</span><br><span class="line">&gt; &gt; Images: 4</span><br><span class="line">&gt; &gt;<span class="built_in"> Server </span>Version: 19.03.5</span><br><span class="line">&gt; &gt; Storage Driver: overlay2</span><br><span class="line">&gt; &gt; Backing Filesystem: extfs</span><br><span class="line">&gt; &gt; Supports d_type: <span class="literal">true</span></span><br><span class="line">&gt; &gt; Native Overlay Diff: <span class="literal">false</span></span><br><span class="line">&gt; &gt;<span class="built_in"> Logging </span>Driver: json-file</span><br><span class="line">&gt; &gt; Cgroup Driver: cgroupfs</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<blockquote>
</blockquote>
<hr>
<blockquote>
<p>Ubuntu 用的 <code>AUFS</code>，底层文件系统是 <code>extfs</code>，各层数据存放在 <code>/var/lib/docker/aufs</code>。<br>centos默认的<code>driver</code>用的是<code>overlay2</code>，底层的文件系统是xfs,各层数据存放在<code>/var/lib/docker</code></p>
</blockquote>
<blockquote>
<p>而写时分配是用在原本没有这个文件的场景，只有在要新写入一个文件时才分配空间，这样可以提高存储资源的利用率。</p>
<p>比如启动一个容器，并不是为这个容器预分配一些磁盘空间，而是当有新文件写入时，才按需分配新空间。</p>
</blockquote>
<ul>
<li>docker提供了多种的存储驱动来实现不同的方式存储镜像</li>
</ul>
<h5 id="Docker五种存储驱动原理及应用场景和性能测试对比"><a href="#Docker五种存储驱动原理及应用场景和性能测试对比" class="headerlink" title="Docker五种存储驱动原理及应用场景和性能测试对比"></a>Docker五种存储驱动原理及应用场景和性能测试对比</h5><blockquote>
<p><code>Docker</code> 最开始采用AUFS作为文件系统，也得益于AUFS分层的概念，实现了多个Container可以共享同一个image。但由于<code>AUFS</code> 为并入 <code>Linux</code>内核，且只支持 <code>Ubuntu</code>，考虑到兼容的问题，在 <code>Docker 0.7</code> 版本中引入了存储驱动，就如Docker官网上说的，没有单一的驱动适应所有的应用场景，要根据不同的场景选择合适的存储驱动，才能有效的提高Docker 的性能。如何选择适合的存储驱动，要先了解存储驱动原理才能更好的判断。</p>
</blockquote>
<blockquote>
<p>接下来我们说说这些分层的镜像是如何在磁盘中存储的。</p>
</blockquote>
<ul>
<li><p><code>docker</code> 提供了多种存储驱动来实现不同的方式存储镜像</p>
<ul>
<li><p>下列出了 <code>Docker</code> 中支持的存储驱动程序：</p>
<table>
<thead>
<tr>
<th align="center">技术</th>
<th align="center">存储驱动成名称</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>OverlayFS</code></td>
<td align="center"><code>overlay</code> 或  <code>overlay2</code></td>
</tr>
<tr>
<td align="center"><code>AUFS</code></td>
<td align="center"><code>aufs</code></td>
</tr>
<tr>
<td align="center"><code>Btrfs</code></td>
<td align="center"><code>btrfs</code></td>
</tr>
<tr>
<td align="center"><code>Device Mapper</code></td>
<td align="center"><code>devicemapper</code></td>
</tr>
<tr>
<td align="center"><code>VFS</code></td>
<td align="center"><code>vfs</code></td>
</tr>
<tr>
<td align="center"><code>ZFS</code></td>
<td align="center"><code>zfs</code></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h5 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h5><blockquote>
<p>AUFS（AnotherUnionFS）是一种 Union FS ，是文件级的存储驱动。AUFS 是一个能透明覆盖一个或多个县有文件系统的层状文件系统，把多层合并成文件系统的单层表示。简单来说就是支持将不同目录挂载到同一个虚拟文件系统下的文件系统。这种文件可以一层一层地叠加修改文件。无论低下有多少层都是只读的，只有最上层的文件系统是可写的。当需要修改文件时，AUFS创建该文件的一个副本，使用CoW将文件从只读层复制到可写层进行修改，结果保存在可写层。在Docker中，低下的只读层就是image，可写层就是Container。结构如下图所示：</p>
</blockquote>
<p>  <a href="http://dockone.io/uploads/article/20190702/87af417e9f80a3eb8ae9716ae07b3dc1.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/87af417e9f80a3eb8ae9716ae07b3dc1.jpg" alt="1.jpg"></a></p>
<blockquote>
<p><strong>历史</strong>：aufs驱动老早就在Docker中存在了！其实，他在使用<code>graphdriver</code>这个名字之前久存在了。如果你查看项目在那（即首次使用graphdriver名称）提交之前的历史，之前项目中当时只有一个aufs的实现。下边devicemapper部分会讲到更多关于graphdriver这个名称诞生的历史。</p>
<p><strong>实现</strong>：Aufs最初代表的意思“另一个联合文件系统（another union filesystem）”，试图对当时已经存在的UnionFS实现进行重写。正如你期望的那样，它是一个传统意义的上层覆盖，通过利用aufs称作为“分支（branch）”的特性，让堆叠的目录合并成一个堆叠内容单一挂载点视图。此驱动会将父级信息组合一个有序列表，并把它作为挂载参数，然后把重活移交给aufs来把这些分层组装成一个联合视图。更多的细节信息可以在aufs的<a href="http://aufs.sourceforge.net/aufs3/man.html" target="_blank" rel="noopener">帮助文档</a>上看到。</p>
<p><strong>优点</strong>：这可能是历史最久且测试最完善的graphdriver后端了。它拥有不错的性能，也比较稳定，适用于广泛的场景。尽管它只在Ubuntu或者Debian的内核上才可以启用（下边有说明），但是这两个发行版和Docker一起使用的场景已经非常多，这让它在广阔的环境中得到了验证。同时，通过让不同的容器从同一个分层里面加载相同的库（因为他们在磁盘上是相同的inode）达到了共享内存页的效果。</p>
<p><strong>缺点</strong>：Aufs从来没有被上游Linux内核社区接受。多年来Ubuntu和Debian都需要往内核集成一个历史久远的补丁包，且原作者已经放弃了让它被内核采纳的努力。可能与IPV4和IPv6的辩论有些类似，人们担心某一天内核更新后会出现难以整合aufs的补丁的情况，从而导致aufs没得玩。但是就如IPv6，替换aufs势在必行的决心讲了一年又一年。除此之外，它面临着很多其他比较棘手的问题。其中一个最麻烦的、也是比较有历史的问题（尽管某种程度上这是一个安全的特性），是关于在高层更改向上拷贝的文件的权限的，这个问题困扰了不少用户。最终在2015年早期的时候通过编号为<a href="http://dockone.io/docker/docker#11799" target="_blank" rel="noopener">#11799</a>的PR使用aufs的<code>dirperm1</code>特性修复了。自然，这需要内核中有具有<code>dirperm1</code>能力aufs，然而这在今天任何较新版本的Ubuntu或者Debian上都已经不成问题了。</p>
<p><strong>总结</strong>：如果你在使用Ubtuntu或者Debian，那默认的graphdriver就是aufs，它能满足你绝大多数需求。有人期望有一天它能被overlay的实现取代，但是考虑到overlay文件系统的诸多问题，以及在上游内核中的成熟程度等挑战，这尚未实现。最后，aufs中没有配额的支持。</p>
</blockquote>
<h5 id="Overlay"><a href="#Overlay" class="headerlink" title="Overlay"></a>Overlay</h5><blockquote>
<p>Overlay 是Linux内核3.18后支持的，也是一种Union FS，和AUFS的多层不同的是Overlay只有两层：一个upper文件系统和一个lower文件系统，分别代表Docekr的镜像层和容器层。当需要修改一个文件时，使用CoW将文件从只读的lower复制到可写的upper进行修改，结果也保存在upper层。在Docekr中，底下的只读层就是image，可写层就是Container。目前最新的OverlayFS为Overlay2。结构图如下所示：</p>
</blockquote>
<p>  <a href="http://dockone.io/uploads/article/20190702/c12e244abea02f7ed1eb42f0ccdbcf1d.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/c12e244abea02f7ed1eb42f0ccdbcf1d.jpg" alt="2.jpg"></a></p>
<blockquote>
<p><strong>历史</strong>：<strong>2014年8月</strong>，Red Hat的 Alex Larsson在编号为<a href="https://github.com/docker/docker/commit/453552c8384929d8ae04dcf1c6954435c0111da0" target="_blank" rel="noopener">453552c8384929d8ae04dcf1c6954435c0111da0</a>的代码提交中添加了针对OverlayFS（最初的上游内核的名称）的graphdriver。</p>
<p><strong>实现</strong>：Overlay是一个联合文件系统，它的概念较之aufs的分支模型更为简单。Overlay通过三个概念来实现它的文件系统：一个“下层目录（lower-dir）”，一个“上层目录（upper-dir）”，和一个做为文件系统合并视图的“合并（merged）”目录。受限于只有一个“下层目录”，需要额外的工作来让“下层目录”递归嵌套（下层目录自己又是另外一个overlay的联合），或者按照Docker的实现，将所有位于下层的内容都硬链接到“下层目录”中。正是这种可能潜在的inode爆炸式增长（因为有大量的分层和硬连接）阻碍了很多人采用Overlay。Overlay2通过利用更高内核（4.0以及以上的版本）中提供了的更优雅处理多个位于下层分层的机制解决了这个问题。</p>
<p><strong>优点</strong>：Overlay作为一个合并进主线Linux内核的一个有完整支持的联合文件系统有望成为人们的焦点。与aufs类似，通过使用磁盘上相同的共享库，它也能让分散的容器实现内存共享。Overlay同时有很多的上游Linux内核基于现代的应用场景，如Docker，被持续开发（参看overlay2）。</p>
<p><strong>缺点</strong>：硬链接的实现方式已经引发了 <a href="http://dockone.io/docker/docker#10613" target="_blank" rel="noopener">inode耗尽</a>的问题，这阻碍了它的大规模采用。inode耗尽并不是唯一的问题，还有其他一些与用户命名空间、SELinux支持有关的问题，且整体的成熟状况不足也阻碍着overlay直接取代aufs成为Docker默认的graphdriver。随着很多问题的解决，特别是在最新的内核发新版中，overlay的可用度越来越高了。如今出现的Overlay2修复了inode耗尽的问题，应该是从Docker 1.12版本之后的焦点，成为overlay驱动的后续开发对象。出于向后兼容的原因，<code>overlay</code>驱动将会继续留在Docker引擎中继续支持现有的用户。</p>
<p><strong>总结</strong>：考虑到aufs没有足够多的发行版的支持，能有一个上游集成的联合文件系统且拥有Linux内核文件系统社区的支持，overlay驱动的加入是一个重大进步。Overlay在过去的18-24个月已经成熟了很多，并且随着overlay2的出现，它之前一些麻烦的问题已经解决了。希望overlay（或者更具可能性的overlay2）会成为未来默认的graphdriver。为了overlay最好的体验，上游内核社区在4.4.x的内核系列里面修复了很多overlay实现中存在的问题；选择该系列中更新的版本可以获得overlay更好的性能和稳定性。</p>
</blockquote>
<h5 id="Overlay2"><a href="#Overlay2" class="headerlink" title="Overlay2"></a>Overlay2</h5><blockquote>
<p><strong>历史</strong>：<a href="https://github.com/dmcgowan" target="_blank" rel="noopener">Derek McGowan</a>在编号为<a href="https://github.com/docker/docker/pull/22126" target="_blank" rel="noopener">#22126</a>的PR中添加了overlay2的graphdriver，在<strong>2016年6月</strong>被合并进Docker 1.12版本，正如该PR的标题注明的，要取代之前overlay的主要原因是它能“支持多个下层目录”，能解决原先驱动中inode耗尽的问题。</p>
<p><strong>实现</strong>：在上面的overlay部分已经讲述了Linux内核中的Overlay的框架。上面链接的PR中改进了原有的设计，基于Linux内核4.0和以后版本中overlay的特性，可以允许有多个下层的目录。</p>
<p><strong>优点</strong>：overlay2解决了一些因为最初驱动的设计而引发的inode耗尽和一些其他问题。Overlay2继续保留overlay已有的优点，包括在同一个引擎的多个容器间从同一个分层中加载内库从而达到内存共享。</p>
<p><strong>缺点</strong>：现在可能唯一能挑出overlay2的问题是代码库还比较年轻。很多早期的问题已经在早期测试过程中发现并被及时解决了。但是Docker 1.12是第一个提供overlay2的发行版本，随着使用量的增长，相信可能还会发现其他问题。</p>
<p><strong>总结</strong>：将Linux内核中的一个现代的、广受支持的联合文件系统，和一个和Docker中一个性能优秀的graphdriver结合起来，这应该是Docker引擎未来打造默认的graphdriver最好的道路，只有这样才能获得各种Linux发行版广泛的支持。</p>
</blockquote>
<h5 id="Device-mapper"><a href="#Device-mapper" class="headerlink" title="Device mapper"></a>Device mapper</h5><blockquote>
<p>Device mapper 是Linux 内核 2.6.9 后支持的，提供的一种从逻辑设备到物理设备的映射框架机制，在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略。前面讲的 AUFS 和 OverlayFS 都是文件级存储，而 Device mapper 是块级存储，所有的操作都是直接对块进行操作，而不是文件。Device mapper 驱动会先在块设备上创建一个资源池，然后在资源池上创建一个带有文件系统的基本设备，所有镜像都是这个基本设备的快照，而容器则是镜像的快照。所以在容器里看到文件系统是资源池上基本设备的文件系统的快照，并不有为容器分配空间。当要写入一个新文件时，在容器的镜像内为其分配新的块并写入数据，这个用时分配。当要修改已有文件时，再使用 CoW 为容器快照分配块空间，将要修改的数据复制在容器快照中新的块里在进行修改。Device mapper 驱动默认会创建一个 100 G 的文件包含镜像和容器。每个容器被限制在 10G 大小的卷内，可以自己设置调整。结构如下图所示：</p>
</blockquote>
<p>  <a href="http://dockone.io/uploads/article/20190702/0ef920a30190955999076f524229f321.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/0ef920a30190955999076f524229f321.jpg" alt="3.jpg"></a></p>
<blockquote>
<p> <strong>历史</strong>：Devicemapper很早就以Ｃ代码的包装器面貌存在了，用来和libdevmapper进行交互； 是2013的９月Alex Larsson在编号为<a href="https://github.com/docker/docker/commit/739af0a17f6a5a9956bbc9fd1e81e4d40bff8167" target="_blank" rel="noopener"> 739af0a17f6a5a9956bbc9fd1e81e4d40bff8167</a>的代码提交中添加的。几个月后的重构了才诞生了我们现在所知道的“graphdriver”这个词；Solomon Hykes在2013年10月份早期代码合并的注释中说：将devmapper和aufs整合进通用的“graphdriver”框架。</p>
<p>  <strong>实现</strong>：devicemapper这个graphdriver利用了Linux中devicemapper代码中众多特性之一，“轻配置（thin provisioning）”，或者简称为“thinp”。<em>（译注：根据Wikipedia，“thin provisioning是利用虚拟化技术，让人觉得有比实际可用更多的物理资源。如果系统的资源足够，能同时满足所有的虚拟化的资源，那就不能叫做thin-provisioned。”）</em> 这与之前提到的联合文件系统不同，因为devicemapper是基于块设备的。这些“轻配置（thin-provisioned）”的块设备带来的是如联合文件系统所提供的一样轻量的行为，但是最重要的一点是，他们不是基于文件的（而是基于块设备的）。正如你能推测的，这让计算分层之间的差别变得不再容易，也丧失了通过在容器间使用同样的库片段而共享内存的能力。</p>
<p>  <strong>优点</strong>：Devicemapper在过去的年间也被一些人感到不屑，但是它提供的一个非常重要的能力让红帽系（Fedora,RHEL，Project Atomic）也有了一个graphdriver。因为它是基于块设备而不是基于文件的，它有一些内置的能力如配额支持，而这在其他的实现中是不容易达到的。</p>
<p>  <strong>缺点</strong>：使用devicemapper没有办法达到开箱立即唾手可得很好的性能。你必须遵循<a href="https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/#/configure-direct-lvm-mode-for-production" target="_blank" rel="noopener">安装和配置指示</a>才能得到性能还可以的配置。并且最重要的是，在任何需要用Docke引擎来做点正事的地方，都不要使用“虚拟设备（loopback）”模式（对于运行有devicemapper且负载高的系统，如延迟删除（ deferred removal）这样的特性绝对有必要的，这能减少引擎看起来好似夯住了一样的悲剧。）。它的一些特性依赖libdevmaper特定的版本，并且需要比较高级的技能来验证系统上所有的设置。同时，如果Docker Engine的二进制是静态编译的话，devicemapper会完全无法工作，因为它需要<a href="http://dockone.io/docker/docker#11412" target="_blank" rel="noopener">udev sync</a>的支持，而这不能被静态编译进引擎中。</p>
<p>  <strong>总结</strong>：对于红帽类发行版本来说，devicemapper已经成为“可以直接用”的选择，并且在过去几年间里得到了红帽团队的大力支持和改进。它质量上有优点也有缺点，如果安装/配置过程中没有特别格外注意的话，可能导致和其他选项比较起来性能低下、质量不高。鉴于overlay和overlay2受到了Fedora和RHEL最新的内核的支持，并且拥有SELinux的支持，除非在Red Hat场景中有某种必须使用devicemapper的需求，我想随着用户的成熟他们会转向overlay的怀抱。</p>
</blockquote>
<h5 id="Btrfs"><a href="#Btrfs" class="headerlink" title="Btrfs"></a>Btrfs</h5><blockquote>
<p>Btrfs 被称为下一代写时复制文件系统，并入Linux内核，也是文件级存储，但可以向 Device mapper 一直操作底层设备。 Btrfs 把文件系统的一部分配置为一个完整的子文件系统，称为 subvolume。那么采用 subvolume ，一个大的文件系统可以被划分为很多个子文件系统，这些子文件系统共享底层的设备空间，在需要磁盘空间使用时便从底层设备中分配，类似应用程序调用 malloc（）分配内存一样。为了灵活利用设备空间， Btrfs 将磁盘空间划分为多个 chunk。每个 chunk 可以使用不同的磁盘空间分配策略。比如某些 chunk 只存放 metadata ，某些chunk 只存放数据。这种模型有很多优点，比如 Btrfs 支持动态添加设备。用户在系统中添加新的磁盘之后，可以使用 Btrfs 的命令将该设备添加到文件系统中。Btrfs 把一个大的文件系统当成一个资源池，配置成多个完整的子文件系统，还可以往资源池里加新的子文件系统，而基础镜像则是子文件系统的快照，每个子镜像和容器都有自己的快照，这些快照都是 subvolume 的快照。</p>
</blockquote>
<p>   <a href="http://dockone.io/uploads/article/20190702/99ab3acda52806a948625219d9e96a0b.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/99ab3acda52806a948625219d9e96a0b.jpg" alt="4.jpg"></a></p>
<blockquote>
<p>当写入一个新文件时，为在容器的快照里为其分配一个新的数据块，文件写在这个空间里，这个叫做分配。而当要修改已有文件时，使用 CoW 复制分配一个新的原始数据和快照，在这个新分配的空间变更数据，变结束再跟新相关的数据结构指向新子文件系统和快照，原来的原始数据和快照没有指针指向，被覆盖。</p>
</blockquote>
<blockquote>
<p><strong>历史</strong>：<strong>2013年12月</strong>较晚的时候，Red Hat公司的Alex Larsson在编号为<a href="https://github.com/docker/docker/commit/e51af36a85126aca6bf6da5291eaf960fd82aa56" target="_blank" rel="noopener">e51af36a85126aca6bf6da5291eaf960fd82aa56</a>的提交中，让使用btrfs作为管理<code>/var/lib/docker</code>的文件系统成为可能。</p>
<p><strong>实现</strong>：Btrfs的原生特性中，有两个是“子卷（subvolumes）”和“快照（snapshots）”。<em>（译注：根据Wikipedia，“子卷在btrfs中不是一个块设备，也不应该被当做是一个块设备。相反，子卷可以被想象成POSIX文件的命名空间。这个命名空间可以通过顶层的子卷来访问到，也可以独立地被挂载。快照在Btrfs中实际上是一个子卷，通过使用Btrfs的写时复制来和其他的子卷共享数据，对快照的更改不会影响原先的子卷。” ）</em> graphdriver实现中主要结合了这两个能力，从而提供了堆叠和类似写时复制的特性。当然，graphdriver的根（默认情况下是：<code>/var/lib/docker</code>）需要是一个被btrfs文件系统格式化的磁盘。</p>
<p><strong>优点</strong>：Btrfs几年前发布的时候（2007-2009时代），它被视作一个未来的Linux文件系统并<a href="https://lwn.net/Articles/342892/" target="_blank" rel="noopener">受到了大量的关注</a>。如今在上游Linux内核中，该文件系统已经比较健壮，并受到良好的支持，是众多可选的文件系统之一。</p>
<p><strong>缺点</strong>：但是Btrfs并没有成为Linux发行版的主流选择，所以你不大可能已经有一个btrfs格式化的磁盘。因为这种在Linux发行版中采用不足的原因，它并没有受到类似其他graphdriver一样的关注和采用。</p>
<p><strong>总结</strong>：如果你正在使用btrfs，那很显然的这个graphdriver应该迎合了你的需求。在过去几年有过很多Bug，并且有一段时间缺乏对SELinux的支持，但是这已经<a href="http://dockone.io/docker/docker#16452" target="_blank" rel="noopener">被修复</a>了。同时，对btrfs配额的支持也直接加进了docker守护进程中，这是<a href="https://github.com/zhuguihua" target="_blank" rel="noopener">Zhu Guihua</a>在编号为<a href="http://dockone.io/docker/docker#19651" target="_blank" rel="noopener">#19651</a>的PR中添加的，这个特性包含在了Docker 1.12版本中。</p>
</blockquote>
<h5 id="ZFS"><a href="#ZFS" class="headerlink" title="ZFS"></a>ZFS</h5><blockquote>
<p>ZFS 文件系统是一个革命性的全新的文件系统，它从根本上改变了文件系统的管理方式， ZFS 完全抛弃了 “ 卷管理 ” ，不再创建虚拟的卷，而是把所有设备集中到一个存储池中进行管理，用 “ 存储池 ”  的概念来管理物理存储空间。过去，文件系统都是构建在物理设备之上的，为了管理这些物理设备，并为数据提供冗余，“ 卷管理 ” 的概念提供了一个单设备的映射。而 ZFS 创建在虚拟的，被称为 “ zpools ” 的存储池之上。每个存储池由若干虚拟设备（ virtual devices ，vdevs ）组成。这些虚拟设备可以是原始磁盘，也节能是一个RAID1 镜像设备，或是非标准 RAID 等级的多磁盘组。  于是 zpool 上的文件系统可以使用这些虚拟设备的总存储容量。</p>
</blockquote>
<p>  <a href="http://dockone.io/uploads/article/20190702/d6daba2b7adfe96daca62f9ed90bf0c4.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/d6daba2b7adfe96daca62f9ed90bf0c4.jpg" alt="5.jpg"></a></p>
<blockquote>
<p>下面看一下Docker 里ZFS的使用。首先从 zpool里分配一个ZFS 文件系统给镜像的基础层，而其他镜像层则是这个 ZFS 文件系统快照的克隆，快照是只读的，而克隆是可写的，当容器启动时则在镜像的顶层生成一个可写层。如下图所示：</p>
</blockquote>
<p>  <a href="http://dockone.io/uploads/article/20190702/34cc4c9ea6c96b6f83dabb961ed8950e.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/34cc4c9ea6c96b6f83dabb961ed8950e.jpg" alt="6.jpg"></a></p>
<blockquote>
<p>d当要写一个新文件时，使用按需分配，一个新的数据块从 zpool 里生成新的数据写入这个块，而这个新空间存于容器（ ZFS 的克隆 ）里。</p>
<p>当要修改一个已存在的文件时，使用写时复制，分配一个新空间并把原始数据复制到新空间完成修改。</p>
</blockquote>
<blockquote>
<p><strong>历史</strong>：ZFS的graphdriver是由Arthur Gautier和Jörg Thalheim一起在<a href="http://dockone.io/docker/docker#9411" target="_blank" rel="noopener">#9411</a>的PR中实现的，在<strong>2014年的5月</strong>被合并进了Docker引擎里面，并且从Docker 1.7版本开始用户可以使用。该实现依赖Go的一个三方包<a href="https://github.com/mistifyio/go-zfs" target="_blank" rel="noopener">go-zfs</a>进行相关zfs命令的交互。</p>
<p><strong>实现</strong>：与btrfs和devicemapper类似，要使用zfs驱动必需要有一个ZFS格式化的块设备挂载到graphdriver路径（默认是/var/lib/docker）。同时也需要安装好zfs工具（在绝大多数的发行版上是一个名为zfs-utils的包）供zfs Go库调用来执行相关操作。ZFS有能力创建快照（与btrfs类似），然后以快照的克隆作为分享层的途径（在ZFS的实现中成了一个快照）。因为ZFS不是一个基于文件的实现，aufs和overlay中所拥有的内存共享能力在ZFS是没有的。</p>
<p><strong>优点</strong>：ZFS正在受到越来越多的欢迎，在Ubuntu 16.04中，在Ubuntu的LXC/LXD中已经被使用。最初由Sun创建，ZFS已经存在很长的时间了，并且在Solaris和很多BSD的衍生版中使用，并且它的Linux移植版实现看起来也比较稳定，对于容器文件系统的场景也有足够合理性能。<code>ZFS</code>graphdriver也很及时的在Dockr 1.12中通过PR <a href="http://dockone.io/docker/docker#21946" target="_blank" rel="noopener">#21946</a>添加了配额的支持，这让它在配额支持方面和btrfs、devicemapper站在了同一起跑线上。</p>
<p><strong>缺点</strong>：除了没有基于文件（inode）的共享达到内库共享之外，很难说ZFS和其它同样基于块设备的实现相比有什么缺点。通过比较，ZFS看起来欢迎程度越来越高。对于那些完全支持或者正在使用ZFS的Linux发行版或者UNIX衍生版而言，zfs graphdriver可以是一个非常好的选择。</p>
<p><strong>总结</strong>：ZFS的支持为Docker引擎中稳定的graphdriver加了分。对于那些ZFS的使用者，或者那些ZFS扮演了更要角色的发行版来说，Docker能直接支持该文件系统，对这些社区来说是一个好消息。对于那些默认文件系统是ext4和xfs的发行版，默认采用overlay驱动的用户来说，时间会告诉我们他们是否会对zfs驱动产生更多的兴趣。</p>
</blockquote>
<h4 id="存储驱动的对比及适应场景"><a href="#存储驱动的对比及适应场景" class="headerlink" title="存储驱动的对比及适应场景"></a>存储驱动的对比及适应场景</h4><table>
<thead>
<tr>
<th><strong>存储驱动</strong></th>
<th><strong>特点</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AUFS</td>
<td>联合文件系统、未并入内核主线、文件级存储</td>
<td>作为docker的第一个存储驱动，已经有很长的历史，比较稳定，且在大量的生产中实践过，有较强的社区支持</td>
<td>有多层，在做写时复制操作时，如果文件比较大且存在比较低的层，可能会慢一些</td>
<td>大并发但少IO的场景</td>
</tr>
<tr>
<td>overlayFS</td>
<td>联合文件系统、并入内核主线、文件级存储</td>
<td>只有两层</td>
<td>不管修改的内容大小都会复制整个文件，对大文件进行修改显示要比小文件消耗更多的时间</td>
<td>大并发但少IO的场景</td>
</tr>
<tr>
<td>Devicemapper</td>
<td>并入内核主线、块级存储</td>
<td>块级无论是大文件还是小文件都只复制需要修改的块，并不是整个文件</td>
<td>不支持共享存储，当有多个容器读同一个文件时，需要生成多个复本，在很多容器启停的情况下可能会导致磁盘溢出</td>
<td>适合io密集的场景</td>
</tr>
<tr>
<td>Btrfs</td>
<td>并入linux内核、文件级存储</td>
<td>可以像devicemapper一样直接操作底层设备，支持动态添加设备</td>
<td>不支持共享存储，当有多个容器读同一个文件时，需要生成多个复本</td>
<td>不适合在高密度容器的paas平台上使用</td>
</tr>
<tr>
<td>ZFS</td>
<td>把所有设备集中到一个存储池中来进行管理</td>
<td>支持多个容器共享一个缓存块，适合内存大的环境</td>
<td>COW使用碎片化问题更加严重，文件在硬盘上的物理地址会变的不再连续，顺序读会变的性能比较差</td>
<td>适合paas和高密度的场景</td>
</tr>
</tbody></table>
<p><a href="http://dockone.io/uploads/article/20190702/747be895d53add6ea9ddf868f95ff8ec.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/747be895d53add6ea9ddf868f95ff8ec.jpg" alt="7.jpg"></a></p>
<h5 id="AUFS-VS-Overlay"><a href="#AUFS-VS-Overlay" class="headerlink" title="AUFS VS  Overlay"></a>AUFS VS  Overlay</h5><blockquote>
<p>AUFS和Overlay都是联合文件系统，但AUFS有多层，而Overlay只有两层，所以在做写时复制操作时，如果文件比较大且存在比较低的层，则AUSF可能会慢一些。而且Overlay并入了linux kernel mainline，AUFS没有，所以可能会比AUFS快。但Overlay还太年轻，要谨慎在生产使用。而AUFS做为docker的第一个存储驱动，已经有很长的历史，比较的稳定，且在大量的生产中实践过，有较强的社区支持。目前开源的DC/OS指定使用Overlay。</p>
</blockquote>
<h5 id="Overlay-VS-Device-mapper"><a href="#Overlay-VS-Device-mapper" class="headerlink" title="Overlay VS Device mapper"></a>Overlay VS Device mapper</h5><blockquote>
<p>Overlay是文件级存储，Device mapper是块级存储，当文件特别大而修改的内容很小，Overlay不管修改的内容大小都会复制整个文件，对大文件进行修改显示要比小文件要消耗更多的时间，而块级无论是大文件还是小文件都只复制需要修改的块，并不是整个文件，在这种场景下，显然device mapper要快一些。因为块级的是直接访问逻辑盘，适合IO密集的场景。而对于程序内部复杂，大并发但少IO的场景，Overlay的性能相对要强一些。</p>
</blockquote>
<h5 id="Device-mapper-VS-Btrfs-Driver-VS-ZFS"><a href="#Device-mapper-VS-Btrfs-Driver-VS-ZFS" class="headerlink" title="Device mapper VS Btrfs Driver VS ZFS"></a>Device mapper VS Btrfs Driver VS ZFS</h5><blockquote>
<p>Device mapper和Btrfs都是直接对块操作，都不支持共享存储，表示当有多个容器读同一个文件时，需要生活多个复本，所以这种存储驱动不适合在高密度容器的PaaS平台上使用。而且在很多容器启停的情况下可能会导致磁盘溢出，造成主机不能工作。Device mapper不建议在生产使用。Btrfs在docker build可以很高效。<br>ZFS最初是为拥有大量内存的Salaris服务器设计的，所在在使用时对内存会有影响，适合内存大的环境。ZFS的COW使碎片化问题更加严重，对于顺序写生成的大文件，如果以后随机的对其中的一部分进行了更改，那么这个文件在硬盘上的物理地址就变得不再连续，未来的顺序读会变得性能比较差。ZFS支持多个容器共享一个缓存块，适合PaaS和高密度的用户场景。</p>
</blockquote>
<h4 id="IO性能对比"><a href="#IO性能对比" class="headerlink" title="IO性能对比"></a>IO性能对比</h4><blockquote>
<p>测试工具：IOzone（是一个文件系统的benchmark工具，可以测试不同的操作系统中文件系统的读写性能）<br>测试场景：从4K到1G文件的顺序和随机IO性能<br>测试方法：基于不同的存储驱动启动容器，在容器内安装IOzone，执行命令：</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">./iozone -<span class="selector-tag">a</span> -n <span class="number">4</span>k -g <span class="number">1</span>g -<span class="selector-tag">i</span> <span class="number">0</span> -<span class="selector-tag">i</span> <span class="number">1</span> -<span class="selector-tag">i</span> <span class="number">2</span> -f /root/test<span class="selector-class">.rar</span> -Rb ./iozone.xls</span><br></pre></td></tr></table></figure>

<h5 id="测试项的定义和解释"><a href="#测试项的定义和解释" class="headerlink" title="测试项的定义和解释"></a>测试项的定义和解释</h5><blockquote>
<p>Write：测试向一个新文件写入的性能。<br>Re-write：测试向一个已存在的文件写入的性能。<br>Read：测试读一个已存在的文件的性能。<br>Re-Read：测试读一个最近读过的文件的性能。<br>Random Read：测试读一个文件中的随机偏移量的性能。<br>Random Write：测试写一个文件中的随机偏移量的性能。</p>
</blockquote>
<h5 id="测试数据对比"><a href="#测试数据对比" class="headerlink" title="测试数据对比"></a>测试数据对比</h5><blockquote>
<p>Write：</p>
<p><a href="http://dockone.io/uploads/article/20190702/f592fe0e47c24441541b3970f6775674.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/f592fe0e47c24441541b3970f6775674.jpg" alt="8.jpg"></a></p>
<p>Re-write:</p>
<p><a href="http://dockone.io/uploads/article/20190702/778f51a47542033e0ded1b1b1d0edd63.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/778f51a47542033e0ded1b1b1d0edd63.jpg" alt="9.jpg"></a></p>
<p>Read：</p>
<p><a href="http://dockone.io/uploads/article/20190702/3028c70ce9a0abcfa673459b199612a3.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/3028c70ce9a0abcfa673459b199612a3.jpg" alt="10.jpg"></a></p>
<p>Re-Read：</p>
<p><a href="http://dockone.io/uploads/article/20190702/fb9fe60305c941fbfbc564cb2351e588.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/fb9fe60305c941fbfbc564cb2351e588.jpg" alt="11.jpg"></a></p>
<p>Random Read：</p>
<p><a href="http://dockone.io/uploads/article/20190702/ef273f23ee51927344a224ef3798e75a.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/ef273f23ee51927344a224ef3798e75a.jpg" alt="12.jpg"></a></p>
<p>Random Write：</p>
<p><a href="http://dockone.io/uploads/article/20190702/3a07e8a8a9b4de99602d02dc849b771b.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/3a07e8a8a9b4de99602d02dc849b771b.jpg" alt="13.jpg"></a></p>
</blockquote>
<ul>
<li>通过以上的性能数据可以看到：<ul>
<li>AUFS在读的方面性能相比Overlay要差一些，但在写的方面性能比Overlay要好。</li>
<li>device mapper在512M以上文件的读写性能都非常的差，但在512M以下的文件读写性能都比较好。</li>
<li>btrfs在512M以上的文件读写性能都非常好，但在512M以下的文件读写性能相比其他的存储驱动都比较差。</li>
<li>ZFS整体的读写性能相比其他的存储驱动都要差一些。 简单的测试了一些数据，对测试出来的数据原理还需要进一步的解析。</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>Docker</code> 提供了可插拔的存储驱动程序架构。它使我们能够灵活地 <code>插入</code> <code>Docker</code>中的存储驱动程序。他完全基于<code>Linux</code>文件系统 。</p>
</blockquote>
<blockquote>
<p>要实现这一功能，我们必须 在<code>docker</code> 守护进程的开始时就设置驱动程序。 <code>Docker</code> 守护程序只能运行一个存储驱动程序，并且该守护程序实例创建的所有容器使用相同的存储驱动程序。</p>
</blockquote>
<ul>
<li><p>当前存储驱动</p>
<ul>
<li>查看守护程序使用哪个存储驱动程序，可以使用一下命令。</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ docker <span class="meta">info</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到上面的命令显示了守护进程使用的存储驱动程序。备份文件系统 <code>extfs</code> 。 <code>extfs</code> 表示覆盖存储驱动程序在文件系统的顶部运行。</p>
<p>后备文件系统实质用于在 <code>/var/lib/docker</code> 录下创建 <code>Docker</code> 主机的本地存储区域的文件系统。</p>
</blockquote>
<ul>
<li><p>下表包含必须与主机备份文件系统相匹配的存储驱动程序。</p>
<table>
<thead>
<tr>
<th align="center">存储驱动</th>
<th align="center">常用</th>
<th align="center">已禁用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">overlay</td>
<td align="center">ext4xfs</td>
<td align="center">btrfs  aufs  overlayzfs  eCryptfs</td>
</tr>
<tr>
<td align="center">overlay2</td>
<td align="center">ext4xfs</td>
<td align="center">btrfs  aufs  overlayzfs  eCryptfs</td>
</tr>
<tr>
<td align="center">aufs</td>
<td align="center">ext4xfs</td>
<td align="center">btrfs  aufs  eCryptfs</td>
</tr>
<tr>
<td align="center">aufs</td>
<td align="center">btrfsonly</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">devicemapper</td>
<td align="center">Direct-lvm</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center">vfs</td>
<td align="center">debugging only</td>
<td align="center">N/A</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">N/A</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<p>注意 ：- “已禁用/Disabled on” 表示某些存储驱动程序无法在某些后台文件系统上运行</p>
</blockquote>
</li>
</ul>
<h4 id="设置存储驱动程序"><a href="#设置存储驱动程序" class="headerlink" title="设置存储驱动程序"></a>设置存储驱动程序</h4><blockquote>
<p>可以通过 <code>dockersd</code>命令按指定名称来设置存储驱动程序。以下命令启动守护程序并设置新的驱动程序。</p>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ dockerd <span class="attribute">--storage-driver</span>=devicemapper</span><br></pre></td></tr></table></figure>

<blockquote>
<p>稍后，可以通过 <code>docker info</code> 命令检查 <code>docker</code> 服务驱动程序</p>
</blockquote>
<hr>
<p><strong>对于某些容器，直接将数据放在由</strong> storage driver <strong>维护的层中是很好的选择，比如那些无状态的应用。无状态意味着容器没有需要持久化的数据，随时可以从镜像直接创建。即存在与否依赖镜像的存在。</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如一些工具箱，启动是为了执行命令，不需要保存数据供以后使用，使用完直接退出，容器删除时存在容器层的工作数据也一起删除，这没问题，下次启动新容器即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但对于另一类应用这种方式就不合适了，它们有持久化数据的需求，容器启动时需要加载已有的数据，容器销毁时希望保留产生的新数据，也就是说，这类容器是有状态的，例如数据库。</span></span><br><span class="line">这就要用到docker 的另一个存储机制：data <span class="keyword">volume</span><span class="bash"></span></span><br></pre></td></tr></table></figure>

<h3 id="Data-Volume（数据卷）"><a href="#Data-Volume（数据卷）" class="headerlink" title="Data Volume（数据卷）"></a>Data Volume（数据卷）</h3><hr>
<blockquote>
<p>对于有些容器，我们可能会持久化数据的需求，也就是容器启动时需要加载已有的数据，容器销毁时希望保留产生的数据，也就是说这类容器是有状态的。</p>
<p>这就需要用到 <code>Docker</code> 的 <code>Data Volume</code> 存储机制。<code>Data Volume</code>本质上是 <code>Docker host</code>文件系统中的目录或文件，能够直接被 <code>mount</code> 到容器的文件系统。</p>
<p>在具体的使用上，<code>Docekr</code> 提供了两种类型的Volume：bind mount 和docker managed volume。</p>
</blockquote>
<h5 id="附：bind-mount-与-docker-managed-volume-的区别"><a href="#附：bind-mount-与-docker-managed-volume-的区别" class="headerlink" title="附：bind mount 与 docker managed volume 的区别"></a>附：bind mount 与 docker managed volume 的区别</h5><ul>
<li>这两种 <strong>data volume</strong> 实际上都是使用 <strong>host</strong> 文件系统的中的某个路径作为 <strong>mount</strong> 源。它们不同之处在于：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>不同点</strong></th>
<th><strong>bind mount</strong></th>
<th><strong>docker managed volume</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>volume 位置</strong></td>
<td>可任意指定</td>
<td><strong>/var/lib/docker/volumes/…</strong></td>
</tr>
<tr>
<td><strong>对已有mount point 影响</strong></td>
<td>隐藏并替换为 <strong>volume</strong></td>
<td>原有数据复制到 <strong>volume</strong></td>
</tr>
<tr>
<td><strong>是否支持单个文件</strong></td>
<td>支持</td>
<td>不支持，只能是目录</td>
</tr>
<tr>
<td><strong>权限控制</strong></td>
<td>可设置为只读，默认为读写权限</td>
<td>无控制，均为读写权限</td>
</tr>
<tr>
<td><strong>移植性</strong></td>
<td>移植性弱，与 <strong>host path</strong> 绑定</td>
<td>移植性强，无需指定 <strong>host</strong> 目录</td>
</tr>
</tbody></table>
<h5 id="什么是数据卷"><a href="#什么是数据卷" class="headerlink" title="什么是数据卷"></a>什么是数据卷</h5><ul>
<li><p>Data Volume 数据卷 ：是可以存放在一个或多个容器内的 <strong>特定的目录</strong>，提供独立于容器之外的<strong>持久化存储</strong>；是经过<strong>特殊设计的目录</strong>，可以绕过联合文件系统（UFS），为一个或多个容器提供访问；</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Docker</span> Contrainer</span><br><span class="line">面向对象中的对象</span><br><span class="line"></span><br><span class="line">对象一旦被销毁，数据就不存在了</span><br><span class="line"></span><br><span class="line">容器一旦被销毁，则容器内的数据将一并被删除</span><br><span class="line"></span><br><span class="line">服务器中的图案也会一并销毁</span><br><span class="line"></span><br><span class="line">容器中的数据不是持久化状态的</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不使用 <code>volume</code>的时候，对容器进行的改动是不会被保存的，使用 <code>volume</code>可以实现持久化存储；比如运行一个数据的操作，数据库的一个容器，数据库的数据应该被持久化存储的，<code>volume</code>就可以实现这个，并且 <code>volume</code>可以提供容器与容器之间的共享数据；</p>
</blockquote>
</li>
</ul>
<h5 id="Docker-的理念之一："><a href="#Docker-的理念之一：" class="headerlink" title="Docker 的理念之一："></a>Docker 的理念之一：</h5><blockquote>
<p>就是将其应用于其运行的环境打包，因此，通过<code>Docker</code> 容器的生存周期，都是与容器中运行的程序相一致的，而我们对数据的要求通常是持久化的；另一方面，<code>docker</code>容器之间也需要有一个 <strong>共享数据的渠道</strong> ，而这些需求就催生出了<code>docker</code>数据卷的产生；</p>
</blockquote>
<h5 id="数据卷的设计的目的："><a href="#数据卷的设计的目的：" class="headerlink" title="数据卷的设计的目的："></a>数据卷的设计的目的：</h5><blockquote>
<p>在于 <strong>数据的永久化</strong> ，它完全独立于容器的生存周期，因此，<code>Docekr</code>不会在容器删除时删除其挂载的数据卷，也不会存在类似垃圾收集机制，对容器引用的数据卷进行处理了；</p>
</blockquote>
<h5 id="数据卷特点："><a href="#数据卷特点：" class="headerlink" title="数据卷特点："></a>数据卷特点：</h5><ul>
<li><ol>
<li><code>Docker</code>数据卷是独立于<code>Docker</code>的存在，它存在于<code>Docker host</code>（宿主机）中，因此，它与容器的生存周期是分离的；</li>
<li><code>Docker</code>数据卷本质上是存在于<code>Docker</code>宿主机的本地文件系统中；</li>
<li><code>Docker</code> 数据卷可以是目录也可以是文件；（不是块设备）</li>
<li><code>Docker</code> 容器可以利用数据卷的技术与容器宿主机进行数据共享；</li>
<li>同一个目录或者文件，可以支持多个容器进行访问，这样其实实现了容器的数据共享和交换；</li>
<li>数据卷是在容器启动是进行初始化的，那么如果容器使用的镜像包含了的数据也会在容器启动时拷贝到容器的数据卷中；</li>
<li><code>数据卷可以在容器之间共享和重用</code>；</li>
<li><code>数据卷的修改会立马生效</code>；容器可以对数据卷里的内容直接修改；容器对数据卷进行的修改是及时的，所有的修改都会直接体现在数据卷中；</li>
<li><code>数据卷的更新不会影响镜像</code>；因为文件不会写到镜像中去，数据卷是独立于联合文件系统的，而镜像本身基于联合文件系统，so镜像与数据卷之间不会有相互影响的情况；</li>
<li><code>数据卷会一直存在，即使挂载数据卷的容器已经删除</code>因为数据均本质上是宿主机上的一个目录，同时为了提供数据的永久化，它的生存周期与容器是完全隔离的；</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20190617160156293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTQ2ODkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<blockquote>
<p>Docker 容器中的数据操作经过了UFS 的，UFS 会在宿主机中写一次文件，这个文件在宿主机上是临时的，这时候就出现了重复写的情况，会影响系统的性能；此外，删除容器的时候，就没有人能够通过UFS 在访问到宿主机中的文件了；</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190617160937555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTQ2ODkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>容器卷可以绕过 UFS 直接操作主机上的文件，当容器删除的时候，宿主机上的文件还在，就在指定的目录下，在重新创建容器的时候们可以指定容器继续读取宿主机上的文件；</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20190617161045446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTQ2ODkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h5><blockquote>
<p>包含数据卷挂载的容器在容器关闭时，如果修改了宿主机下的数据卷会，容器里面会产生改变吗？ </p>
</blockquote>
<ul>
<li><strong>bind mount 数据卷</strong></li>
</ul>
<blockquote>
<p>使用docker run –name nginx-test -p 8080:80 -d -v ~/myvolume:/usr/share/nginx/html nginx  创建一个bind mount 数据卷 是宿主机的存储位置必须是绝对路径。目录不存在则会生成</p>
</blockquote>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下两种情况创建的数据卷如果浏览器访问宿主机的ip:8080 会出现报错，因为这是创建的时候清空了容器数据卷下index.html</span></span><br><span class="line"><span class="comment"># 创建的宿主机和容器的数据卷都有读写的权限</span></span><br><span class="line">$ docker run <span class="params">--name</span> nginx-test -p 8080<span class="function">:80</span> -d -v ~<span class="string">/myvolume</span>:<span class="string">/usr/share/nginx/html</span> nginx</span><br><span class="line"><span class="comment"># 这样执行后的文件宿主机的~/myvolume 文件如果不存在直接创建，容器的文件路径不存在也会直接创建，如果/usr/share/nginx/html文件存在里面内容会清空</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给容器里面的数据卷加权限</span></span><br><span class="line">$ docker run <span class="params">--name</span> nginx-test -p 8080<span class="function">:80</span> -d -v ~<span class="string">/myvolume</span>:<span class="string">/usr/share/nginx/html</span><span class="function">:ro</span> nginx</span><br><span class="line"><span class="comment"># 如果执行这个 :/usr/share/nginx/html:ro这个地方加的是 :ro 是设置的只有读取权限</span></span><br></pre></td></tr></table></figure>

<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行dockers inspect 容器名称或容器（ID） 是将容器的配置文件已json字符串的形式返回</span></span><br><span class="line"><span class="string">"Binds"</span>: [</span><br><span class="line">                <span class="string">"/root/myvolume:/usr/share/nginx/html"</span>   <span class="comment"># 宿主机数据卷位置: 容器的目录位置</span></span><br><span class="line">            ],</span><br><span class="line"></span><br><span class="line"><span class="string">"Mounts"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Type"</span>: <span class="string">"bind"</span>,</span><br><span class="line">                <span class="string">"Source"</span>: <span class="string">"/root/myvolume"</span>,   <span class="comment"># 是宿主机数据卷的存储位置</span></span><br><span class="line">                <span class="string">"Destination"</span>: <span class="string">"/usr/share/nginx/html"</span>,</span><br><span class="line">                <span class="string">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="string">"RW"</span>: <span class="literal">true</span>,   <span class="comment"># 权限 true是可以读写 fales 是只读</span></span><br><span class="line">                <span class="string">"Propagation"</span>: <span class="string">"rprivate"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure>

<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 在宿主机的数据卷下执行:</span></span><br><span class="line">vim index.html </span><br><span class="line"><span class="meta"># 在文件里写入hello ， 你在访问的时候就可以在页面上看到你写入得数据了</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行 docker exec -it 容器名称（容器ID） bahs进入到容器里面，每个容器都会包含一个迷你版的linux系统</p>
<p>执行 cd /usr/share/nginx/html  </p>
<p>执行 ls</p>
<p>你会看到容器目录里会有我们刚才创建好的文件</p>
<p>index.html</p>
<p>执行 cat index.html  可以看到里面我们加入的数据</p>
<p>如果是挂载数据卷的时候加 <code>:ro</code> 容器内修改文件，发现会提示该文件是只读的  </p>
</blockquote>
<hr>
<ul>
<li><strong>docker managed volume 数据卷</strong><ul>
<li>创建出来的两个都是有读写权限的</li>
</ul>
</li>
</ul>
<blockquote>
<p>使用docker run –name nginx-test2 -p 8080:80 -d -v /usr/share/nginx/html nginx 创建一个<strong>docker managed volume 数据卷</strong> </p>
<p>这种命令创建是不用指定宿主机数据卷存储位置的默认在 /var/lib/docker/volumes/ 下的文件名是经过<code>sha256</code> 摘要过的</p>
</blockquote>
<ul>
<li>查看宿主机创建出来的数据卷</li>
</ul>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">$ cd  /var/<span class="class"><span class="keyword">lib</span>/<span class="title">docker</span>/<span class="title">volumes</span>/</span></span><br><span class="line">$ ls </span><br><span class="line"><span class="number">8</span>d668720aaeccee44b5fb554571912a6a257eb3a28cecf334203805a0c9b6fd3  <span class="comment">#这是自己创建出来的数据卷</span></span><br><span class="line"><span class="comment"># 执行 cd _data 进入这这个文件夹里面</span></span><br><span class="line">$ ls</span><br><span class="line"><span class="number">50</span>x.html  index.html   <span class="comment"># 这两个文件是把容器里文件给拷贝了出来</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在宿主机或者容器里面都可以对文件进行读写操作</p>
</blockquote>
<h5 id="挂载多个目录实现数据卷的"><a href="#挂载多个目录实现数据卷的" class="headerlink" title="挂载多个目录实现数据卷的"></a>挂载多个目录实现数据卷的</h5><ul>
<li>就是执行多个 <code>-v</code> 就可以</li>
</ul>
<h5 id="容器间的数据共享"><a href="#容器间的数据共享" class="headerlink" title="容器间的数据共享"></a>容器间的数据共享</h5><ul>
<li>数据卷容器挂载了一个本地文件系统的目录，其它容器通过挂载这个数据卷容器来实现容器间的数据的共享；</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180524134945342?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTQ2ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h5 id="容器间挂载"><a href="#容器间挂载" class="headerlink" title="容器间挂载"></a>容器间挂载</h5><blockquote>
<p>创建数据卷，只要在<code>docker run</code>命令后面跟上<code>-v</code>参数即可创建一个数据卷，当然也可以跟多个<code>-v</code>参数来创建多个数据卷，当创建好带有数据卷的容器后，就可以在其他容器中通过<code>--volumes-from</code>参数来挂载该数据卷了，而不管该容器是否运行。</p>
</blockquote>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">docker</span> <span class="comment">run</span> <span class="literal">-</span><span class="comment">tid</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">rm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">volumes</span><span class="literal">-</span><span class="comment">from</span> <span class="comment">nginx</span><span class="literal">-</span><span class="comment">test</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">name</span> <span class="comment">nginx</span><span class="literal">-</span><span class="comment">test3</span> <span class="comment">nginx</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>-i  : 以交互模式运行容器，通常与 -t 同时使用；</p>
<p>-t  : 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p>
<p>-d : 后台运行容器，并返回容器ID；</p>
</blockquote>
<ul>
<li>再创建一个nginx-test4，挂载nginx-test3中从nginx-test挂载的数据卷，当然也可以直接挂载初识的nginx-test容器的数据卷</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>即使删除了初始的数据卷容器 nginx-test，或者是删除了其他容器，但只要是有容器在使用该数据卷，那么它里面的数据就不会丢失</span><br><span class="line"><span class="bullet">* </span>命令中的rm表示当容器退出即停止的时候，会自动删除该容器</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="备份数据卷"><a href="#备份数据卷" class="headerlink" title="备份数据卷"></a>备份数据卷</h5><ul>
<li>创建一个容器container1，包含两个数据卷/usr/share/nginx/html1和/usr/share/nginx/html2（这两个目录是在容器里的数据卷路径）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -tid -v /usr/share/nginx/html1 -v /usr/share/nginx/html2 --name container1 -p 8080:80 nginx</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建容器container1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it container1 bash   <span class="comment">#进入创建好的容器里面</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> html1/  <span class="comment"># 进入到html1数据卷中	</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> html1 &gt;&gt; 1.text <span class="comment"># 向 1.text 文件中追加数据，文件不存在则会创建文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> html2/  <span class="comment"># 进入到html2数据卷中</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> html2 &gt;&gt; 2.text <span class="comment"># 向 2.text 文件中追加数据，文件不存在则会创建文件</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>接下来进行数据卷的备份操作</li>
</ul>
<blockquote>
<p>使用  - -volumes-from 来创建一个加载 container1 容器卷的容器，并从宿主机挂载当前所在目录到容器的 /backup 目录，容器内会 tar 压缩 /var/colume1 目录下的文件到 /backup/backup1.tar，因为宿主机当前目录已经映射到 /backup 目录了，因此会在宿主机当前目录也存在该压缩包。备份完毕后 -rm 自动删除该创建的容器。</p>
</blockquote>
<ul>
<li>备份container1容器中的/usr/share/nginx/html1数据卷数据</li>
</ul>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份container1容器中的/usr/share/nginx/html1数据卷数据</span></span><br><span class="line"><span class="comment"># -tid 这个参数加不加都可以</span></span><br><span class="line"><span class="comment"># --rm 加上，备份后就会自动删除这个容器，如果不加这个 --rm 参数，name备份后的容器就会保留，docker ps -a就会查看到）</span></span><br><span class="line"><span class="comment"># $(pwd) </span></span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]<span class="comment"># docker run -tid --rm --volumes-from container1 -v $(pwd):/backup nginx tar cvf /backup/backup1.tar /usr/share/nginx/html1</span></span><br><span class="line">b3663a3bdd302a38036d6a156471cd448c8e5b9333a20f9480b3c61cbd9270df</span><br><span class="line"></span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]<span class="comment"># ls</span></span><br><span class="line">backup1.tar</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>–volumes-from [containerName]：这个命令来指定需要备份的容器的名字；（数据卷容器的名字）</li>
<li>-v $(pwd):/backup:权限：使用-v命令来指定希望备份文件存放的位置；本地存放目录：容器存放目录：读写权限；（默认权限是读写）</li>
<li>tar cvf /backup/backup.tar [container data volume]：tar表示执行备份的操作是：压缩文件的命令；</li>
<li>/backup/backup.tar是文件存放的地址， [container data volume]指定需要备份的目录；</li>
<li>tar cvf 压缩；tar xvf解压缩；</li>
</ul>
</blockquote>
<ul>
<li>备份container1容器中的/usr/share/nginx/html2数据卷数据</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"># 备份container1容器中的/usr/share/nginx/html2数据卷数据</span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# pwd</span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# docker run -tid --rm --volumes-<span class="keyword">from</span> container1 -v $(pwd):/backup nginx tar cvf /backup/backup2.tar /usr/share/nginx/html2</span><br><span class="line"><span class="number">001129</span>bc393d5d0ed4665d053d4ca7972584cf2bd56980064be182ec758138cd</span><br><span class="line"></span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# ll</span><br><span class="line">total <span class="number">22464</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root    <span class="number">10240</span> Dec <span class="number">16</span> <span class="number">18</span>:<span class="number">52</span> backup1.tar  # 文件<span class="number">1</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root    <span class="number">10240</span> Dec <span class="number">16</span> <span class="number">19</span>:<span class="number">05</span> backup2.tar  # 文件<span class="number">2</span></span><br><span class="line">drwxr-xr-x <span class="number">2</span> root root     <span class="number">4096</span> Dec <span class="number">16</span> <span class="number">16</span>:<span class="number">45</span> myvolume</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">22973527</span> Mar <span class="number">26</span>  <span class="number">2019</span> Python<span class="number">-3.7</span><span class="number">.3</span>.tgz</span><br></pre></td></tr></table></figure>

<ul>
<li>备份container1 容器中的 /usr/share/nginx/html1 和 /usr/share/nginx/html2 数据卷数据</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">#  备份container1 容器中的 /usr/share/nginx/html2 和 /usr/share/nginx/html2 数据卷数据</span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# pwd</span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# docker run -tid --rm --volumes-<span class="keyword">from</span> container1 -v $(pwd):/backup nginx tar cvf /backup/backup.tar /usr/share/nginx/html1</span><br><span class="line">/usr/share/nginx/html2</span><br><span class="line"><span class="number">441</span>df929e123cbe51564ca3d6bf3f06a5ea415298a34bb9871f1ed2b68a60102</span><br><span class="line"></span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# ll</span><br><span class="line">total <span class="number">22476</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root    <span class="number">10240</span> Dec <span class="number">16</span> <span class="number">18</span>:<span class="number">52</span> backup1.tar</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root    <span class="number">10240</span> Dec <span class="number">16</span> <span class="number">19</span>:<span class="number">05</span> backup2.tar</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root    <span class="number">10240</span> Dec <span class="number">16</span> <span class="number">19</span>:<span class="number">09</span> backup.tar</span><br><span class="line">drwxr-xr-x <span class="number">2</span> root root     <span class="number">4096</span> Dec <span class="number">16</span> <span class="number">16</span>:<span class="number">45</span> myvolume</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">22973527</span> Mar <span class="number">26</span>  <span class="number">2019</span> Python<span class="number">-3.7</span><span class="number">.3</span>.tgz</span><br></pre></td></tr></table></figure>

<h5 id="恢复数据给同一个容器"><a href="#恢复数据给同一个容器" class="headerlink" title="恢复数据给同一个容器"></a>恢复数据给同一个容器</h5><blockquote>
<p>之前的数据卷是从 container1 中备份的，现在模拟 container1 数据卷丢失，然后直接用之前备份的 backup.tar 进行恢复</p>
</blockquote>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为了测试恢复，先删除容器里原先的数据（注意：数据卷目录不能删除，只能删除其中的数据）</span></span><br><span class="line">[root<span class="variable">@iz2zefaujekcdpmfw1qs4az</span> ~]<span class="comment"># docker exec -it container1 bash </span></span><br><span class="line"><span class="comment">#进入到创建的容器里</span></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/</span><span class="comment"># ls</span></span><br><span class="line">bin  boot  dev	etc  home  lib	lib64  media  mnt  opt	proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/</span><span class="comment"># cd /usr/share/nginx  </span></span><br><span class="line"><span class="comment">#进入到容器里面的数据卷所在的目录</span></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx</span><span class="comment"># ls</span></span><br><span class="line">html  html1  html2  </span><br><span class="line"></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx</span><span class="comment"># cd html1</span></span><br><span class="line"><span class="comment"># 进入到 html1 数据卷目录</span></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx/html1</span><span class="comment"># ls</span></span><br><span class="line"><span class="number">1</span>.text</span><br><span class="line"></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx/html1</span><span class="comment"># rm -rf 1.text </span></span><br><span class="line"><span class="comment"># 删除 1.text 文件</span></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx/html1</span><span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx</span><span class="comment"># cd html2</span></span><br><span class="line"><span class="comment"># 进入到 html2 的数据卷目录</span></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx/html2</span><span class="comment"># ls</span></span><br><span class="line"><span class="number">2</span>.text</span><br><span class="line"></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx/html2</span><span class="comment"># rm -rf 2.text </span></span><br><span class="line"><span class="comment"># 删除 2.text 文件</span></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx/html2</span><span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行数据卷恢复，恢复数据卷中的所有数据</span></span><br><span class="line">注意-C后面的路径，表示将数据恢复到容器里的路径直接使用压缩包中文件的各个路径。比如压缩包中的结果如下：</span><br><span class="line">tar -xvf backup.tar   <span class="comment">#解压压缩文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据1</span></span><br><span class="line">usr/share/nginx/html1/<span class="number">1</span>.text</span><br><span class="line">--usr</span><br><span class="line">	--share</span><br><span class="line">		--nginx</span><br><span class="line">			--html1</span><br><span class="line">				--<span class="number">1</span>.text</span><br><span class="line"><span class="comment"># 数据2		</span></span><br><span class="line">usr/share/nginx/html2/<span class="number">2</span>.text</span><br><span class="line">--usr</span><br><span class="line">	--share</span><br><span class="line">		--nginx</span><br><span class="line">			--html2</span><br><span class="line">				--<span class="number">2</span>.text</span><br><span class="line"><span class="comment"># 直接将文件解压到 /usr/share/nginx/html1 和 /usr/share/nginx/html2 目录</span></span><br><span class="line">[root<span class="variable">@iz2zefaujekcdpmfw1qs4az</span> ~]<span class="comment"># docker run --rm --volumes-from container1 -v $(pwd):/backup nginx tar xvf /backup/backup.tar -C /</span></span><br><span class="line">usr/share/nginx/html1/</span><br><span class="line">usr/share/nginx/html1/<span class="number">1</span>.text</span><br><span class="line">usr/share/nginx/html2/</span><br><span class="line">usr/share/nginx/html2/<span class="number">2</span>.text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接进入容器查看</span></span><br><span class="line">[root<span class="variable">@iz2zefaujekcdpmfw1qs4az</span> ~]<span class="comment"># docker exec -it container1 bash</span></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/</span><span class="comment"># cd /usr/share/nginx/ </span></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx</span><span class="comment"># ls</span></span><br><span class="line">html  html1  html2</span><br><span class="line"><span class="comment"># 查看数据是否存在</span></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx</span><span class="comment"># ls html1</span></span><br><span class="line"><span class="number">1</span>.text</span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx</span><span class="comment"># ls html2</span></span><br><span class="line"><span class="number">2</span>.text</span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx</span><span class="comment"># cat html1/1.text </span></span><br><span class="line">html1</span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx</span><span class="comment"># cat html2/2.text </span></span><br><span class="line">html2</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="如果你备份的数据里面有，不是设置的数据卷里面的数据，使用这个命令是恢复不了的（恢复的是设置的数据卷里面的数据）"><a href="#如果你备份的数据里面有，不是设置的数据卷里面的数据，使用这个命令是恢复不了的（恢复的是设置的数据卷里面的数据）" class="headerlink" title="!  如果你备份的数据里面有，不是设置的数据卷里面的数据，使用这个命令是恢复不了的（恢复的是设置的数据卷里面的数据）"></a><strong>!</strong>  如果你备份的数据里面有，不是设置的数据卷里面的数据，使用这个命令是恢复不了的（恢复的是设置的数据卷里面的数据）</h5></li>
<li><h5 id="你可以创一个新的容器多一个，你数据卷挂载你备份数据时候，备份的文件的路径就可以解决了"><a href="#你可以创一个新的容器多一个，你数据卷挂载你备份数据时候，备份的文件的路径就可以解决了" class="headerlink" title="你可以创一个新的容器多一个，你数据卷挂载你备份数据时候，备份的文件的路径就可以解决了"></a>你可以创一个新的容器多一个，你数据卷挂载你备份数据时候，备份的文件的路径就可以解决了</h5></li>
</ul>
<h5 id="恢复数据给新的容器"><a href="#恢复数据给新的容器" class="headerlink" title="恢复数据给新的容器"></a>恢复数据给新的容器</h5><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"># 新建一个容器container2</span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# docker run -tid -v /usr/share/nginx/html1 -v /usr/share/nginx/html2 --name container2 nginx</span><br><span class="line"><span class="number">89</span>abb55858fb1e3dddc07c2066d05614349aaf78ba446a1ea12f1241b98e4896</span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line"><span class="number">89</span>abb55858fb        nginx               <span class="string">"/bin/bash"</span>         <span class="number">9</span> seconds ago       Up <span class="number">8</span> seconds        <span class="number">80</span>/tcp              container2</span><br><span class="line"><span class="number">6869560e6f</span>f5        nginx               <span class="string">"/bin/bash"</span>         <span class="number">2</span> hours ago         Up <span class="number">2</span> hours          <span class="number">80</span>/tcp              container1</span><br><span class="line"></span><br><span class="line"># 开始恢复数据</span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# pwd</span><br><span class="line">/root</span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# ll</span><br><span class="line">total <span class="number">22476</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root    <span class="number">10240</span> Dec <span class="number">16</span> <span class="number">18</span>:<span class="number">52</span> backup1.tar</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root    <span class="number">10240</span> Dec <span class="number">16</span> <span class="number">19</span>:<span class="number">05</span> backup2.tar</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root    <span class="number">10240</span> Dec <span class="number">16</span> <span class="number">19</span>:<span class="number">09</span> backup.tar</span><br><span class="line">drwxr-xr-x <span class="number">2</span> root root     <span class="number">4096</span> Dec <span class="number">16</span> <span class="number">16</span>:<span class="number">45</span> myvolume</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">22973527</span> Mar <span class="number">26</span>  <span class="number">2019</span> Python<span class="number">-3.7</span><span class="number">.3</span>.tgz</span><br><span class="line"></span><br><span class="line"># 恢复数据</span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# docker run --rm --volumes-<span class="keyword">from</span> container2 -v $(pwd):/backup nginx tar xvf /backup/backup.tar -C /</span><br><span class="line">usr/share/nginx/html1/</span><br><span class="line">usr/share/nginx/html1/<span class="number">1.</span>text</span><br><span class="line">usr/share/nginx/html2/</span><br><span class="line">usr/share/nginx/html2/<span class="number">2.</span>text</span><br><span class="line"></span><br><span class="line"># 查看确实已经恢复了</span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# docker exec -it container2 bash</span><br><span class="line"><span class="symbol">root@</span><span class="number">89</span>abb55858fb:/# ls /usr/share/nginx/</span><br><span class="line">html  html1  html2</span><br><span class="line"><span class="symbol">root@</span><span class="number">89</span>abb55858fb:/# ls /usr/share/nginx/html1</span><br><span class="line"><span class="number">1.</span>text</span><br><span class="line"><span class="symbol">root@</span><span class="number">89</span>abb55858fb:/# ls /usr/share/nginx/html2</span><br><span class="line"><span class="number">2.</span>text</span><br><span class="line"><span class="symbol">root@</span><span class="number">89</span>abb55858fb:/# cat /usr/share/nginx/html1/<span class="number">1.</span>text </span><br><span class="line">html1</span><br><span class="line"><span class="symbol">root@</span><span class="number">89</span>abb55858fb:/# cat /usr/share/nginx/html2/<span class="number">2.</span>text </span><br><span class="line">html2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li><p>–volumes-from [containerName]：这个命令来指定需要备份的容器的名字；（数据卷容器的名字）</p>
</li>
<li><p>-v $(pwd):/backup:权限：使用-v命令来指定希望备份文件存放的位置；本地存放目录：容器存放目录：读写权限；（默认权限是读写）</p>
</li>
<li><p>tar cvf /backup/backup.tar [container data volume]：tar表示执行备份的操作是：压缩文件的命令；</p>
</li>
<li><p>/backup/backup.tar是文件存放的地址， [container data volume]指定需要备份的目录；</p>
</li>
<li><p>tar cvf 压缩；tar xvf解压缩；</p>
</li>
<li><p>新容器创建时挂载的数据卷路径最好和之前备份的数据卷路径一致</p>
</li>
<li><p>新容器创建时，如果挂载的数据卷只是备份卷的一部分，那么恢复的时候也只是恢复一部分数据。</p>
</li>
<li><p>比如新建容器挂载数据卷为 <code>-v /usr/share/nginx/html1</code> ,那么使用 <code>backup.tar</code> 恢复时，只会恢复 <code>/usr/share/nginx/html1</code> 的数据， <code>/usr/share/nginx/html2</code> 的数据是不会恢复的</p>
</li>
<li><p>比如新容器创建时挂载的数据卷目录和备份的数据卷目录不一致，那么数据恢复不了，除非修改 - C 后面的路径，比如新建容器时指定数据卷目录为 <code>/usr/share/nginx/html</code> ，恢复时也是用 <code>-C /usr/share/nginx/html</code>，则是可以成功恢复的</p>
</li>
</ul>
</blockquote>
<h5 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h5><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">volume</span><span class="bash"> ls     列出所有的数据卷</span></span><br><span class="line">docker <span class="keyword">volume</span><span class="bash"> ls --filter dangling=<span class="literal">true</span>     过滤不在使用的数据卷</span></span><br><span class="line">docker <span class="keyword">volume</span><span class="bash"> rm [volume name]     删除一个数据卷，容器正在使用的数据卷不能删除，绑定挂载的数据卷无法删除</span></span><br></pre></td></tr></table></figure>

<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">docker volume rm <span class="keyword">my</span>-volio  删除数据卷 <span class="keyword">my</span>-volio</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。</p>
</blockquote>
<ul>
<li>无主的数据卷可能会占据很多空间，要清理请使用以下命令</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ docker <span class="keyword">volume</span><span class="bash"> prune</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux用户组及权限管理</title>
    <url>/Linux%E7%94%A8%E6%88%B7%E7%BB%84%E5%8F%8A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h3><hr><blockquote>
<p><code>Linux</code> 是哟个多用户的操作系统，引入用户，可以更加方便管理 <code>Linux</code> 服务器</p>
<p>系统默认需要以一个用户的身份登入，而且在系统上启动进程也需要以一个用户身份器运行，用户可以限制某些进程对特定资源的权限控制</p>
</blockquote><a id="more"></a>

<h3 id="Linux用户及组"><a href="#Linux用户及组" class="headerlink" title="Linux用户及组"></a>Linux用户及组</h3><hr>
<blockquote>
<p><code>Linux</code> 操作系统对多用户的管理，是非常繁琐的，所以用组的概念来管理用户就变到的简单，每个用户可以在一个独立的组，每个组也可以有零个用户或者多个用户。</p>
<p><code>Linux</code> 系统用户是根据用户 <code>ID</code> 来识别的，默认 <code>ID</code> 长度为 <code>32</code> 位，默认 <code>ID</code> 编号从 <code>0</code> 开始，但是为了和老式系统兼容，用户 <code>ID</code>限制在 <code>60000</code>一下， <code>Linux</code> 用户总共分为三种，分别如下：</p>
</blockquote>
<ul>
<li>超级用户： <code>root</code>， <code>ID</code> 为0</li>
<li>系统用户：<code>ID</code> 从1 到499</li>
<li>普通用户：<code>ID</code>为500以上</li>
</ul>
<blockquote>
<p><code>Linux</code> 系统中的每个文件或者文件夹，都有一个所属用户及所属组</p>
<p>使用 <code>ID</code> 命令可以显示当前用户的信息，使用 <code>passwd</code> 命令可以修改当前用户密码。 <code>Linux</code>操作系统用户的特点如下</p>
</blockquote>
<ul>
<li>每个用户拥有一个 <code>UserID</code>，操作系统实际读取的是 <code>UID</code>，而非用户名；</li>
<li>每个用户属于一个主组；属于一个或多个附属组，一个用户最多有 <code>31</code>个附属组；</li>
<li>每个组用有一个 <code>GroupID</code>;</li>
<li>每个进程以一个用户身份进行，该用户可以对进程拥有资源控制权限；</li>
<li>每个可登录用户拥有一个指定的 <code>Shell</code>环境</li>
</ul>
<h4 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h4><hr>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">useradd</span> usertest <span class="comment"># 创建用户usertest</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建新用户，可以使用命令<code>useradd</code>，执行命令即可创建新用户</p>
<p>同时会创建一个同名的组，默认该用户属于该用户组</p>
</blockquote>
<blockquote>
<p>创建用户，会根据如下步骤进行操作</p>
</blockquote>
<ul>
<li>在<code>/etc/passwd</code>文件中添加用户信息</li>
<li>如使用<code>passwd</code>命令创建密码，密码会被加密保存在<code>/etc/shdaow</code>中</li>
<li>为用户创建家目录：<code>/home/usertest</code>，创建目录操作应操作系统而异</li>
<li>将<code>/etc/skel</code>中的<code>.bash</code>开头的文件复制至用户家目录</li>
<li>创建与用户名相同的组，该用户默认属于这个同名组，组信息保存在<code>/etc/group</code>配置文件中</li>
</ul>
<blockquote>
<p>其他命令可选参数如下所示</p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">-d <span class="comment"># 指定新用户的主目录-G # 指定新用户的组列表-s # 新用户所使用的shell环境</span></span><br><span class="line">useradd usertest -s <span class="regexp">/bin/</span>bash -d <span class="regexp">/home/u</span>sertest<span class="comment"># 创建新用户usertest，指定shell环境为bash，主目录在/home/usertest</span></span><br></pre></td></tr></table></figure>

<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><hr>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">userdel # 保留用户的家目录userdel –r usertest # 删除用户及用户家目录，用户login系统无法删除userdel –rf usertest # 强制删除用户及该用户家目录，不论是否login系统</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当一个用户创建之后，我们可以通过<code>usermod</code>命令来修改用户及组的属性</p>
</blockquote>
<ul>
<li><code>linux</code>下命令选项</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">选项：  -c, --comment 注释            GECOS 字段的新值  -d, --home HOME_DIR           用户的新主目录  -e, --expiredate EXPIRE_DATE  设定帐户过期的日期为 EXPIRE_DATE  -f, --inactive INACTIVE       过期 INACTIVE 天数后，设定密码为失效状态  -g, --gid<span class="built_in"> GROUP </span>              强制使用<span class="built_in"> GROUP </span>为新主组  -G, --groups GROUPS           新的附加组列表 GROUPS  -a, --append<span class="built_in"> GROUP </span>           将用户追加至上边 -G 中提到的附加组中，                                并不从其它组中删除此用户  -h, --help                    显示此帮助信息并推出  -l, --login LOGIN             新的登录名称  -L, --lock                    锁定用户帐号  -m, --move-home               将家目录内容移至新位置 (仅于 -d 一起使用)  -o, --non-unique              允许使用重复的(非唯一的) UID  -p, --password PASSWORD       将加密过的密码 (PASSWORD) 设为新密码  -R, --root CHROOT_DIR         chroot 到的目录  -s, --shell SHELL             该用户帐号的新登录 shell  -u, --uid UID                 用户帐号的新 UID  -U, --unlock                  解锁用户帐号  -Z, --selinux-user  SEUSER       用户账户的新 SELinux 用户映射</span><br><span class="line">groups username# 查看用户所属组</span><br></pre></td></tr></table></figure>

<h4 id="修改用户所属组"><a href="#修改用户所属组" class="headerlink" title="修改用户所属组"></a>修改用户所属组</h4><hr>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">usermod usertest -G old_normal# 将用户usertest修改加入old_normal组中</span><br><span class="line">usermod usertest -a -G other_normal# 将用户追加至other_normal组中，且不影响原有组状态</span><br><span class="line">cat /etc<span class="built_in">/group </span>| grep usertest # 可以查看到usertest用户当前所属组的情况</span><br></pre></td></tr></table></figure>

<h4 id="修改用户家目录及启动shell"><a href="#修改用户家目录及启动shell" class="headerlink" title="修改用户家目录及启动shell"></a>修改用户家目录及启动shell</h4><hr>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">usermod usertest -d /home<span class="built_in">/user </span>-s /bin/sh</span><br></pre></td></tr></table></figure>

<h4 id="修改用户名"><a href="#修改用户名" class="headerlink" title="修改用户名"></a>修改用户名</h4><hr>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">usermod -l <span class="keyword">new</span> <span class="keyword">old</span># 将<span class="keyword">old</span>用户名变为<span class="keyword">new</span></span><br></pre></td></tr></table></figure>

<h4 id="锁定-解锁用户"><a href="#锁定-解锁用户" class="headerlink" title="锁定/解锁用户"></a>锁定/解锁用户</h4><hr>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">usermod -L usertest;# 锁定usertest用户usermod -U usertest;# 解锁usertest用户</span><br></pre></td></tr></table></figure>

<h3 id="Linux组管理"><a href="#Linux组管理" class="headerlink" title="Linux组管理"></a>Linux组管理</h3><hr>
<blockquote>
<p>所有的<code>Linux</code>或者<code>Windows</code>系统都有组的概念，通过组可以更加方便的管理用户</p>
<p>组的概念应用于各行行业，例如企业会使用部门、职能或地理区域的分类方式来管理成员，映射在<code>Linux</code>系统，同样可以创建用户，并用组的概念对其管理</p>
<p>Linux组有如下特点</p>
</blockquote>
<ul>
<li>每个组有一个组<code>ID</code></li>
<li>组信息保存在<code>/etc/group</code>中</li>
<li>每个用户至少拥有一个主组，同时还可以拥有<code>31</code>个附属组</li>
</ul>
<h4 id="创建新组"><a href="#创建新组" class="headerlink" title="创建新组"></a>创建新组</h4><hr>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">groupadd <span class="keyword">normal</span> <span class="comment"># 创建normal组</span></span><br><span class="line">groupadd -g <span class="number">1000</span> <span class="keyword">normal</span> <span class="comment"># 创建ID为1000的分组</span></span><br></pre></td></tr></table></figure>

<h4 id="其他组属性"><a href="#其他组属性" class="headerlink" title="其他组属性"></a>其他组属性</h4><hr>
<blockquote>
<p>常见参数</p>
</blockquote>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">-r # 系统账户-f # 如果指定的组已经存在，则退出-g # 指定当前组id-n --new --old # 修改组名</span><br><span class="line">groupmod -n old_normal normal# 修改normal组名为old_normal</span><br><span class="line">groupmod -g <span class="number">1001</span> old_normal# 修改old_normal组id为<span class="number">1001</span></span><br></pre></td></tr></table></figure>

<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><blockquote>
<p>设置好了用户和组，那么接下来就可以对其进行权限控制</p>
<p>由于linux下处处皆文件，所谓权限也就是对文件的<strong>读</strong>、<strong>写</strong>、<strong>执行</strong>，至少这三种</p>
<p>当操作系统下某个进程在运行时，进程的权限，也相当于这个进程的运行用户身份权限</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">权限</th>
<th align="left">文件</th>
<th align="left">目录</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="left">读取文件</td>
<td align="left">列出目录</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">修改文件</td>
<td align="left">修改目录内文件</td>
</tr>
<tr>
<td align="left">x</td>
<td align="left">执行文件</td>
<td align="left">进入目录</td>
</tr>
</tbody></table>
<ul>
<li>权限分组</li>
</ul>
<blockquote>
<p>默认的linux的权限分为三种角色</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">&gt; user`、`group`、`other</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>每个文件将基于<strong>UGO</strong>三种权限进行设置</p>
<p>一般一个文件创建之后，谁创建该文件，默认成为该文件的所有者</p>
</blockquote>
<h3 id="用户及组权限"><a href="#用户及组权限" class="headerlink" title="用户及组权限"></a>用户及组权限</h3><hr>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">ls -ahl# 查看文件所有者</span><br><span class="line">chmod g+rwx <span class="meta">file</span># 给<span class="meta">file</span>文件增加rwx权限chmod g-<span class="meta">x</span> <span class="meta">file</span># 给<span class="meta">file</span>文件减少<span class="meta">x</span>权限</span><br></pre></td></tr></table></figure>

<h3 id="用户及组修改"><a href="#用户及组修改" class="headerlink" title="用户及组修改"></a>用户及组修改</h3><hr>
<blockquote>
<p>修改某个文件或目录所属<strong>用户</strong>或<strong>组</strong></p>
</blockquote>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">chown -R root <span class="keyword">file</span># 修改<span class="keyword">file</span>文件所属用户为root</span><br><span class="line">chown -R :root <span class="keyword">file</span># 修改<span class="keyword">file</span>文件所属用户为rootchgrp -R root <span class="keyword">file</span># 修改<span class="keyword">file</span>文件所属组为root</span><br></pre></td></tr></table></figure>

<h3 id="二进制权限"><a href="#二进制权限" class="headerlink" title="二进制权限"></a>二进制权限</h3><hr>
<blockquote>
<p>linux下具备权限设置为1，反之为0，那么一个权限按照二进制位数来计算，如下所示</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">--x: <span class="number">001</span> <span class="number">1</span>-wx: <span class="number">011</span> <span class="number">3</span>rwx: <span class="number">111</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>很清晰，对应的权限位置所代表的数字分别是：<strong>r=4</strong>，<strong>w=2</strong>，<strong>x=1</strong></p>
</blockquote>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">chmod 775 <span class="meta">file</span># 修改<span class="meta">file</span>文件权限为 rwxrwxr-<span class="meta">x</span></span><br></pre></td></tr></table></figure>

<h3 id="权限掩码"><a href="#权限掩码" class="headerlink" title="权限掩码"></a>权限掩码</h3><hr>
<blockquote>
<p>神奇的事情需要我们考虑，每次创建文件，默认都会具备一定的权限，而这个权限是如何分配而来的呢？</p>
<p>是通过一个叫做权限掩码的东西来维护的，这个码可以通过<strong>umask</strong>命令看到</p>
<p>默认系统的掩码是<strong>022</strong></p>
</blockquote>
<ul>
<li>文件权限由默认权限减去掩码</li>
</ul>
<blockquote>
<p>文件默认权限：666<br>那么创建一个文件真实的权限是：666-022=644</p>
</blockquote>
<blockquote>
<p>目录的默认权限：777</p>
<p>一个目录的真实权限是：777-022=755</p>
</blockquote>
<ul>
<li>设置默认掩码</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">umask -S <span class="number">011</span></span><br></pre></td></tr></table></figure>

<h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><hr>
<table>
<thead>
<tr>
<th align="left">权限</th>
<th align="left">对文件的影响</th>
<th align="left">对目录的影响</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>suid</strong></td>
<td align="left">以文件的所属用户身份执行，而非执行文件的用户</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><strong>sgid</strong></td>
<td align="left">以文件所属组身份去执行</td>
<td align="left">在该目录中创建任意新文件的所属组与该目录的所属组相同</td>
</tr>
<tr>
<td align="left"><strong>sticky</strong></td>
<td align="left">无</td>
<td align="left">对目录拥有写入权限的用户仅可以删除其拥有的文件，无法删除其他用户所拥有的文件</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux用户组及权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><hr><blockquote>
<p>随着IT产业的不断发展，<code>linux</code> 操作系统应用领域越来越广泛，尤其是近年来 <code>linux</code>在服务器领域飞速的发展，主要得益于 <code>linux</code>操作系统具备的如下优点</p>
</blockquote><a id="more"></a>

<ul>
<li>开源免费</li>
<li>系统迭代更新</li>
<li>系统性能稳定</li>
<li>安全性高</li>
<li>多任务/多用户</li>
<li>耗资源小，无需图形化界面</li>
<li>内核小</li>
<li>应用领域广泛</li>
<li>使用及入门容易</li>
</ul>
<h3 id="操作系统分类介绍"><a href="#操作系统分类介绍" class="headerlink" title="操作系统分类介绍"></a>操作系统分类介绍</h3><hr>
<blockquote>
<p>学习 <code>Linux</code> 操作系统，需要悬着不同的发行版本</p>
<p><code>Linux</code> 操作系统是一个大类别， <code>Linux</code> 操作系统主流发型版本包括： <code>Red Hat Linux</code> 、 <code>CentOS</code> , <code>Ubuntu</code> , <code>SUSE Linux</code>  , <code>Fedore Linux</code> 等，具体发行版本区别如下</p>
</blockquote>
<ul>
<li><code>Red Hat Linux</code></li>
</ul>
<blockquote>
<p> <code>Red Hat Linux</code>  是最早的 <code>Linux</code> 发行版本之一</p>
<p>同时也是最著名的 <code>Linux</code> 版本， <code>Red Hat Linux</code> 已经创造了自己的品牌，也是读者经常听到的 ’‘ 红帽操作系统’‘</p>
<p><code>Red Hat 1994</code> 年创立，目前公司全世界有 <code>3000</code> 多人，一直致力于开放的源代码体系，向用户提供一套完整的服务，这使得它特别适合在公共网络中使用</p>
<p>这个版本的 <code>Liunx</code> 也使用最新的内核，还拥有大多数人都需要使用的主要软件包</p>
</blockquote>
<ul>
<li><code>Centos</code></li>
</ul>
<blockquote>
<p>社区企业版操作系统（<code>Community Enterprise Operating System</code>，<code>CentOS</code>）是<code>Linux</code>发行版之一，它是来自于<code>Red Hat Enterprise Linux</code>依照开放源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以<code>CentOS</code>替代商业版的<code>Red Hat Enterprise Linux</code>使用。</p>
<p><code>CentOS</code>于<code>Red Hat Linux</code>不同之处在于<code>CentOS</code>并不包含封闭的源代码软件，可以开源免费使用，得到运维人员、企业、程序员的青睐，<code>CentOS</code>发行版操作系统是目前企业使用最多的系统之一</p>
<p><code>2016年12月12日</code>，<code>CentOS</code>基于<code>Red Hat Enterprise Linux的CentOS Linux 7 (1611)</code>系统正式对外发布</p>
</blockquote>
<ul>
<li><code>Ubuntu</code></li>
</ul>
<blockquote>
<p><code>Ubuntu</code>是一个以桌面应用为主的<code>Linux</code>操作系统，其名称来自非洲南部祖鲁语或豪萨语的“<code>ubuntu</code>”一词（译为吾帮托或乌班图），意思是“人性”、“我的存在是因为大家的存在”，是非洲传统的一种价值观</p>
<p><code>Ubuntu</code>基于<code>Debian</code>发行版和<code>GNOME</code>桌面环境，<code>Ubuntu</code>发行版操作系统的目标在于为一般用户提供一个最新的、同时稳定的以开放自由软件构建而成的操作系统，目前<code>Ubuntu</code>具有庞大的社区力量，用户可以方便地从社区获得帮助</p>
</blockquote>
<ul>
<li><code>SUSE Linux</code></li>
</ul>
<blockquote>
<p><code>SUSE</code>(发音 /ˈsuːsə/)，<code>SUSE Linux</code>出自德国，<code>SuSE Linux AG</code>公司发行维护的<code>Linux</code>发行版，是属于此公司的注册商标<code>2003年11月4日</code>，<code>Novell</code>表示将会对<code>SUSE</code>提出收购。收购的工作于<code>2004年1月</code>完成。</p>
<p><code>Novell</code>也向大家保证<code>SUSE</code>的开发工作仍会继续下去，<code>Novell</code>更把公司内全线电脑的系统换成<code>SUSE LINUX</code>，并同时表示将会把<code>SUSE</code>特有而优秀的系统管理程序 - <code>YaST2</code>以<code>GPL</code>授权释出</p>
</blockquote>
<ul>
<li><code>Fedora Linux</code></li>
</ul>
<blockquote>
<p><code>Fedora</code>是一个知名的<code>Linux</code>发行版，是一款由全球社区爱好者构建的面向日常应用的快速、稳定、强大的操作系统。</p>
<p>它允许任何人自由地使用、修改和重发布，无论现在还是将来。它由一个强大的社群开发。</p>
<p>这个社群的成员以自己的不懈努力，提供并维护自由、开放源码的软件和开放的标准。<code>Fedora</code>约每六个月会发布新版本</p>
</blockquote>
<h3 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h3><hr>
<p><code>cd</code> </p>
<blockquote>
<p>目录切换</p>
</blockquote>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">..</span>   <span class="comment">#上一层目录</span></span><br><span class="line"><span class="keyword">cd</span>   <span class="comment"># 家目录</span></span><br><span class="line"><span class="keyword">cd</span> ~  <span class="comment"># 家目录</span></span><br><span class="line"><span class="keyword">cd</span> / <span class="comment"># 根目录</span></span><br></pre></td></tr></table></figure>

<p><code>ls</code></p>
<blockquote>
<p>浏览目录下的文件或文件夹</p>
</blockquote>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ls</span> -a <span class="comment"># 列举所有文件或目录，包含.开头的隐藏文件</span></span><br><span class="line"><span class="keyword">ls</span> -l <span class="comment"># 详细信息列举文件或目录</span></span><br><span class="line"><span class="keyword">ls</span> -i <span class="comment"># 列出每个文件的Inode号</span></span><br><span class="line"><span class="keyword">ls</span> -t <span class="comment"># 根据修改时间列出文件</span></span><br></pre></td></tr></table></figure>

<p><code>pwd</code></p>
<blockquote>
<p>显示当前所处目录</p>
</blockquote>
<p><code>mkdir</code></p>
<blockquote>
<p>创建目录</p>
</blockquote>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">mkdir <span class="keyword">a</span> <span class="comment"># 创建a目录</span></span><br><span class="line">mkdir -p <span class="keyword">a</span>/b/c <span class="comment"># 递归创建目录</span></span><br></pre></td></tr></table></figure>

<p><code>rm</code></p>
<blockquote>
<p>删除文件或目录</p>
</blockquote>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">rm <span class="keyword">a</span> <span class="comment"># 删除a文件</span></span><br><span class="line">rm -r <span class="keyword">a</span> <span class="comment"># 删除a 目录</span></span><br><span class="line">rm -rf <span class="keyword">a</span> <span class="comment"># 强制删除a 文件，不提示确认</span></span><br></pre></td></tr></table></figure>

<p><code>cp</code></p>
<blockquote>
<p>拷贝或备份文件</p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cp <span class="regexp">/root/</span><span class="number">1</span>.py <span class="regexp">/hoom/</span><span class="number">1</span>.py  <span class="comment"># 拷贝文件至新目录下</span></span><br></pre></td></tr></table></figure>

<p><code>mv</code></p>
<blockquote>
<p>重命名或移动文件或目录</p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mv <span class="regexp">/root/</span><span class="number">1</span>.py <span class="regexp">/hoome/</span><span class="number">1</span>.py.bak <span class="comment"># 移动文件并重命名</span></span><br></pre></td></tr></table></figure>

<p><code>touch</code></p>
<blockquote>
<p>创建普通文件</p>
</blockquote>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="section">touch</span> <span class="number">1.</span>py # 创建<span class="number">1.</span>py文件</span><br></pre></td></tr></table></figure>

<p><code>cat</code></p>
<blockquote>
<p>查看文件内容</p>
</blockquote>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">cat <span class="meta-keyword">/etc/</span>redis/redis.conf <span class="meta"># 查看redis.conf文件</span></span><br><span class="line">car -n <span class="meta"># 对输出所有进行编号</span></span><br><span class="line">car -b <span class="meta"># 对输出非空进行编号</span></span><br></pre></td></tr></table></figure>

<p><code>head</code></p>
<blockquote>
<p>查看文件头部内容，通常为十行</p>
</blockquote>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">head -3 /etc/memcached.conf <span class="comment"># 查看前三行</span></span><br><span class="line">head -n<span class="number"> 100 </span><span class="comment"># 查看前100行</span></span><br><span class="line">head -c<span class="number"> 3 </span><span class="comment"># 查看前三字节</span></span><br></pre></td></tr></table></figure>

<p><code>tail</code></p>
<blockquote>
<p>查看文件头部内容，通常为十行</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">tail -n <span class="number">3</span> <span class="number">1.</span>txt # 查看后<span class="number">3</span>行</span><br><span class="line">tail -f # 阻塞并即时输出文件变化后追加的数据</span><br></pre></td></tr></table></figure>

<p><code>chmod</code></p>
<blockquote>
<p>修改文件或目录权限</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">chmod <span class="number">775</span> <span class="number">1.</span>py # 赋予文件<span class="number">775</span>权限 rwx rwx r-w</span><br></pre></td></tr></table></figure>

<p><code>chown</code></p>
<blockquote>
<p>修改文件或目录所属组及所属用户</p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">chown -R root.root <span class="regexp">/tmp/</span>test.txt <span class="comment"># 文件所属用户及所属组均为root</span></span><br></pre></td></tr></table></figure>

<p><code>df</code></p>
<blockquote>
<p>磁盘信息查询</p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">df</span> -h <span class="comment"># 查询磁盘使用量</span></span><br><span class="line">df -i <span class="comment"># 分区Inode使用量</span></span><br></pre></td></tr></table></figure>

<p><code>du</code></p>
<blockquote>
<p>查看文件大小</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">du -h <span class="number">1.</span>txt # 查看<span class="number">1.</span>txt文件大小</span><br></pre></td></tr></table></figure>

<p><code>echo</code></p>
<blockquote>
<p>打印或输出内容</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'hello'</span> <span class="comment"># 输出hello</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'hello'</span> &gt; 1.md <span class="comment"># 以hello内容覆盖1.md</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'hello'</span> &gt;&gt; 1.md <span class="comment"># 以hello追加至1.md文件中</span></span><br></pre></td></tr></table></figure>

<p><code>tar</code></p>
<blockquote>
<p>解压或压缩文件</p>
</blockquote>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">tar -<span class="keyword">jxvf </span> <span class="comment"># 解压bz2属性的压缩包</span></span><br><span class="line">tar -zxvf  <span class="comment"># 解压gz属性的压缩包</span></span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar</span> -czcf <span class="comment"># 使用gzip格式压缩文件</span></span><br><span class="line">tar -cjvf <span class="comment"># 使用bzip2格式压缩文件</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible-PlayBook</title>
    <url>/Ansible-PlayBook/</url>
    <content><![CDATA[<h2 id="ansible-playbook"><a href="#ansible-playbook" class="headerlink" title="ansible-playbook"></a>ansible-playbook</h2><blockquote>
<p>在之前的<code>ansible</code>使用中，我们都是通过命令行的形式实现对应远程主机的响应管理</p>
<p>但这样的工作方式功能上来说还是有一定的局限性，并且维护并不方便，引入<code>playbook</code>可以更加方便我们对于功能的编写维护，并且具有良好的灵活性</p>
<p><code>playbook</code>也可以理解为命令行功能的一个合集脚本，用来编写更加复杂的业务</p>
</blockquote><a id="more"></a>
<h3 id="yaml语法"><a href="#yaml语法" class="headerlink" title="yaml语法"></a>yaml语法</h3><blockquote>
<p><code>Yaml</code>为通用数据串行化格式语法，简洁而强大</p>
<p><code>ansible</code>中的配置文件就采用了<code>Yaml</code>格式语法存在，以下就是对<code>Yaml</code>语法的介绍</p>
</blockquote>
<ul>
<li><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">yaml</span></span><br></pre></td></tr></table></figure>

<p>基本语法规则如下</p>
<ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进的空格数目不唯一，只要相同层级元素左侧对齐即可</li>
<li><code>#</code>号表示注释</li>
</ul>
</li>
<li><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">yaml</span></span><br></pre></td></tr></table></figure>

<p>语法支持的数据结构有三种：</p>
<ul>
<li>键值对：相当于<code>hash</code>表映射关系，字典</li>
<li>序列：相当于数组或列表</li>
<li>纯量（标量）：单独的值，无法继续拆分，比如字符串、整数、浮点数、<code>Null</code>、布尔值（<code>true</code>、<code>false</code>）</li>
</ul>
</li>
</ul>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul>
<li>字符串定义时，默认可以不使用引号标注</li>
</ul>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">str_1: abc</span><br><span class="line">&#123;'str_1': 'abc',&#125; <span class="meta"># 对应Python中数据类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如字符串中出现特殊字符或包含空格，需要使用引号标注</li>
</ul>
<figure class="highlight sml"><table><tr><td class="code"><pre><span class="line">str_2: <span class="symbol">'abc</span>: bbb'</span><br><span class="line">&#123;<span class="symbol">'str_2'</span>: <span class="symbol">'abc</span>: bbb'&#125; # 对应<span class="type">Python</span>中数据类型</span><br></pre></td></tr></table></figure>

<ul>
<li>双引号不会对字符串中特殊字符进行转义</li>
</ul>
<figure class="highlight sml"><table><tr><td class="code"><pre><span class="line">str_3: <span class="symbol">'abc</span>: \n bbb'</span><br><span class="line">str_4: <span class="string">"abc: \n bbb"</span></span><br><span class="line">&#123;<span class="symbol">'abc</span>: \\n bbb', <span class="symbol">'str_4'</span>: <span class="symbol">'abc</span>: \n bbb'&#125; # 对应<span class="type">Python</span>中数据类型</span><br></pre></td></tr></table></figure>

<ul>
<li>单引号字符串还有引号，需要使用两个单引号进行转义</li>
</ul>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">str_5: 'a''b'</span><br><span class="line">&#123;'str_5': <span class="string">"a'b"</span>&#125; <span class="meta"># 对应Python中数据类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当字符串需要换行时，从第二行开始的下面几行，需要有对齐缩进，换行会被解释为空格，其余缩进前空格会忽略</li>
</ul>
<figure class="highlight sml"><table><tr><td class="code"><pre><span class="line">str_6: <span class="symbol">'abc</span></span><br><span class="line">    aaa</span><br><span class="line">    bbb</span><br><span class="line">    ccc'</span><br><span class="line">&#123;<span class="symbol">'str_6'</span>: <span class="symbol">'abc</span> aaa bbb ccc'&#125; # 对应<span class="type">Python</span>中数据类型</span><br></pre></td></tr></table></figure>

<ul>
<li>多行字符串可以使用 <code>|</code>保留换行符形成段落，或使用<code>&gt;</code>将换行符替换为空格</li>
</ul>
<figure class="highlight sml"><table><tr><td class="code"><pre><span class="line">str_7: &gt;  bbb  aaastr_8: |  bbb  aaa&#123;<span class="symbol">'str_7'</span>: <span class="symbol">'bbb</span> aaa\n', <span class="symbol">'str_8'</span>: <span class="symbol">'bbb</span>\naaa\n'&#125; # str_7: &gt;</span><br><span class="line">  bbb</span><br><span class="line">  aaa</span><br><span class="line"></span><br><span class="line">str_8: |</span><br><span class="line">  bbb</span><br><span class="line">  aaa</span><br><span class="line">&#123;<span class="symbol">'str_7'</span>: <span class="symbol">'bbb</span> aaa\n', <span class="symbol">'str_8'</span>: <span class="symbol">'bbb</span>\naaa\n'&#125; # 对应<span class="type">Python</span>中数据类型</span><br><span class="line">对应<span class="type">Python</span>中数据类型</span><br></pre></td></tr></table></figure>

<ul>
<li><code>+</code>表示保留字符串末位的换行，<code>-</code>表示删除字符串末位的换行</li>
</ul>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">str_9: <span class="string">|+</span></span><br><span class="line">  aaabbb</span><br><span class="line"></span><br><span class="line">str_10: <span class="string">|-</span></span><br><span class="line">  aaabbb</span><br><span class="line">'str_9': 'aaabbb\n', 'str_10': 'aaabbb'&#125; <span class="meta"># 对应Python中数据类型</span></span><br></pre></td></tr></table></figure>

<h4 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h4><ul>
<li>Yaml中的键值对数据通过冒号定义，冒号后的数据与冒号之间存在一个空格</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">dict_1: adict_2: &#123; <span class="number">1</span> : <span class="keyword">a</span> &#125;dict_3: dict_1: <span class="keyword">a</span></span><br><span class="line">dict_2: &#123; <span class="number">1</span> : <span class="keyword">a</span> &#125;</span><br><span class="line">dict_3:</span><br><span class="line">  <span class="variable">a:</span> <span class="number">1</span></span><br><span class="line">  <span class="variable">b:</span> <span class="number">2</span></span><br><span class="line">&#123;<span class="string">'dict_1'</span>: <span class="string">'a'</span>, <span class="string">'dict_2'</span>: &#123;<span class="number">1</span>: <span class="string">'a'</span>&#125;, <span class="string">'dict_3'</span>: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;&#125; # 对应Python中数据类型</span><br><span class="line"> <span class="variable">a:</span> <span class="number">1</span>  <span class="variable">b:</span> <span class="number">2</span>&#123;<span class="string">'dict_1'</span>: <span class="string">'a'</span>, <span class="string">'dict_2'</span>: &#123;<span class="number">1</span>: <span class="string">'a'</span>&#125;, <span class="string">'dict_3'</span>: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;&#125; # 对应Python中数据类型</span><br></pre></td></tr></table></figure>

<h4 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h4><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">- list_1</span><br><span class="line">- list_2</span><br><span class="line">-</span><br><span class="line"> - a_1</span><br><span class="line"> - a_2</span><br><span class="line">[<span class="string">'list_1'</span>, <span class="string">'list_2'</span>, [<span class="string">'a_1'</span>, <span class="string">'a_2'</span>]] # 对应<span class="symbol">Python</span>中数据类型</span><br><span class="line">- list_1- list_2- - a_1 - a_2[<span class="string">'list_1'</span>, <span class="string">'list_2'</span>, [<span class="string">'a_1'</span>, <span class="string">'a_2'</span>]] # 对应<span class="symbol">Python</span>中数据类型</span><br></pre></td></tr></table></figure>

<h4 id="数据嵌套使用"><a href="#数据嵌套使用" class="headerlink" title="数据嵌套使用"></a>数据嵌套使用</h4><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">- test_1:</span><br><span class="line">  - a</span><br><span class="line">  - b</span><br><span class="line">- test_2:</span><br><span class="line">    var_1: <span class="literal">true</span></span><br><span class="line">    var_2: <span class="number">0.2</span></span><br><span class="line">[&#123;<span class="string">'test_1'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>]&#125;, &#123;<span class="string">'test_2'</span>: &#123;<span class="string">'var_1'</span>: <span class="literal">True</span>, <span class="string">'var_2'</span>: <span class="number">0.2</span>&#125;&#125;] <span class="meta"># 对应Python中数据类型</span></span><br></pre></td></tr></table></figure>

<h3 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h3><ul>
<li><code>playbook</code>的编写使用<code>yaml</code>语法规则，先来看一下最简单的<code>playbook</code></li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: all</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Yum Install Apache</span><br><span class="line">    	yum: <span class="attribute">name</span>=httpd <span class="attribute">state</span>=installed</span><br><span class="line">    - name: Start Apache Server</span><br><span class="line">    	service: <span class="attribute">name</span>=httpd <span class="attribute">state</span>=started</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一行：<code>---</code>指明<code>Ymal</code>将文件解释为正确的文档的要求，<code>Yaml</code>允许可以有多个文档同时出现在一个文件里，每个文档之间由<code>---</code>进行分割，目前我们的<code>playbook</code>中只需要有一个文档即可</p>
<p>第二行：<code>hosts</code>指明当前<code>playbook</code>将要操作的目标主机有哪些，这里我们选择全部</p>
<p>第三行：<code>remote_user</code>指明当前操作所使用的远程主机用户</p>
<p>第四行：<code>tasks</code>为任务列表，<code>playbook</code>将按照从上到下的定义顺序执行其中的模块对应的操作，<code>name</code>属性为一个字符串用以标示当前任务的介绍，第一个任务将使用<code>yum</code>模块安装<code>apache</code>服务，第二个任务使用<code>ansible</code>模块<code>service</code>，使<code>httpd</code>服务启动</p>
</blockquote>
<ul>
<li>执行<code>playbook</code>使用<code>ansible-playbook</code></li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ansible-playbook <span class="regexp">/etc/</span>ansible<span class="regexp">/playbook.yml</span></span><br></pre></td></tr></table></figure>

<h3 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h3><blockquote>
<p>当遇到较为复杂的情况时，单独的<code>playbook</code>可能无法应对业务需求，那么可能需要编写多个<code>playbook</code></p>
<p>这时，如果在<code>playbook</code>中的<code>handlers</code>或<code>tasks</code>可能在多个<code>playbook</code>中重复使用，就可以通过<code>ansible</code>所提供的<code>include</code>功能，将复用的部分单独写成一个文件，在需要的地方<code>include</code>包含进来即可</p>
</blockquote>
<ul>
<li>比如有这样的一个功能是需要多次复用的，这个文件叫做<code>tasks.yaml</code></li>
</ul>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">--- </span><br><span class="line">- name: Yum Install Nginx</span><br><span class="line">		yum: name=nginx <span class="keyword">state</span>=installed</span><br></pre></td></tr></table></figure>

<ul>
<li>那么在一个主要<code>playbook</code>文件中可以这样引入</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span>  </span><br><span class="line">	<span class="attr">tasks:</span></span><br><span class="line"><span class="attr">    - include:</span> <span class="string">tasks.yml</span></span><br></pre></td></tr></table></figure>

<ul>
<li>执行该<code>playbook</code></li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ansible-playbook <span class="regexp">/etc/</span>ansible<span class="regexp">/playbook.yml</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>include</code>包含的其他<code>playbook</code>支持模板变量，可以通过定义<code>vars</code>变量覆盖，或者像这样</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Yum</span> <span class="string">Install</span> <span class="string">Nginx</span> </span><br><span class="line">		<span class="attr">yum:</span> <span class="string">name=&#123;&#123;</span> <span class="string">server_name</span> <span class="string">&#125;&#125;</span> <span class="string">state=installed</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>playbook</code>文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span> </span><br><span class="line">	<span class="attr">tasks:</span>  </span><br><span class="line">    	<span class="bullet">-</span> <span class="attr">include:</span> <span class="string">tasks.yml</span> <span class="string">server_name=nginx</span></span><br></pre></td></tr></table></figure>

<ul>
<li>此外在<code>1.4</code>及以上版本中，还支持字典、列表形式的参数传递</li>
</ul>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">--- </span><br><span class="line">-name: Yum Install Nginx  	</span><br><span class="line">		yum: name=&#123;&#123; server_name &#125;&#125; <span class="keyword">state</span>=installed</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">---</span> </span><br><span class="line"><span class="selector-tag">-hosts</span>: <span class="selector-tag">all</span> </span><br><span class="line">	<span class="selector-tag">tasks</span>:  </span><br><span class="line">		<span class="selector-tag">-</span> &#123; <span class="attribute">include</span>: tasks.yml, server_name: nginx &#125;</span><br></pre></td></tr></table></figure>

<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><blockquote>
<p>除去通过<code>include</code>功能将不同的任务分别写入不同的文件，然后按需<code>include</code>包含进来，在<code>ansible</code>中还有一种标准规范叫做<code>role</code>角色</p>
<p>通过不同级别的层级目录和文件来对变量、任务、配置模板等进行拆分管理，提高扩展性和可维护性</p>
</blockquote>
<ul>
<li>一般来说，一个<code>role</code>角色定义目录结构如下</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">role_name/	<span class="comment"># 角色名目录，playbook调用时需要	</span></span><br><span class="line">    <span class="built_in">file</span>/	<span class="comment"># 存放copy或script等模块调用文件	</span></span><br><span class="line">    tasks/	<span class="comment"># 存放各种task任务，需要包含一个main.yml	</span></span><br><span class="line">    handlers/	<span class="comment"># 存放各种handlers任务，需要包含一个main.yml	</span></span><br><span class="line">    vars/	<span class="comment"># 存放定义好的变量，需要包含一个main.yml	</span></span><br><span class="line">    templates/	<span class="comment"># 存放需要使用到的配置模板	</span></span><br><span class="line">    meta/	<span class="comment"># 当前角色的特殊设定及其依赖，需要包含一个main.yml</span></span><br></pre></td></tr></table></figure>

<ul>
<li>角色目录存放的路径可以在<code>ansible</code>的配置文件中定义</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"># <span class="regexp">/etc/</span>ansible<span class="regexp">/ansible.cfgroles_path = /</span>etc<span class="regexp">/ansible/</span>roles</span><br></pre></td></tr></table></figure>

<ul>
<li>示例目录结构</li>
</ul>
<p><a href="https://lienze.tech/blog/images/1562121857022.png" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/1562121857022.png" alt="1562121857022"></a></p>
<ul>
<li>任务<code>tasks</code>目录下<code>main</code>文件内容</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"># tasks/main.yml- <span class="type">name</span>: Install Apache <span class="keyword">Server</span>  	yum: <span class="type">name</span>=httpd state=installed- <span class="type">name</span>: <span class="keyword">Write</span> Apache Config  	<span class="keyword">template</span>: src=httpd.j2 dest=/etc/httpd/conf/httpd.conf  	<span class="keyword">notify</span>: <span class="keyword">Restart</span> Apache <span class="keyword">Server</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>handlers</code>目录下<code>main</code>文件内容</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"># handlers/main.yml- <span class="type">name</span>: <span class="keyword">Restart</span> Apache <span class="keyword">Server</span>  	service: <span class="type">name</span>=httpd state=restarted</span><br></pre></td></tr></table></figure>

<ul>
<li><code>templates</code>下配置模板</li>
</ul>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># templates/httpd.j2#上面内容太多省略，只保留模板变量部分Listen &#123;&#123; listen_port &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>变量<code>vars</code>目录下<code>main</code>文件</li>
</ul>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># vars/main.ymllisten_port: 8000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>调用<code>role</code>的<code>playbook</code>文件内容</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- <span class="string">hosts:</span> all  <span class="string">remote_user:</span> root  <span class="string">roles:</span> 	- apache</span><br></pre></td></tr></table></figure>

<ul>
<li>在执行角色<code>role</code>此处为<code>apache</code>任务时，会将文件夹下的<code>main.yml</code>文件自动导入合并，执行结果如下</li>
</ul>
<p><a href="https://lienze.tech/blog/images/1562122149050.png" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/1562122149050.png" alt="1562122149050"></a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux,Ansible-PlayBook</tag>
      </tags>
  </entry>
  <entry>
    <title>Paramiko</title>
    <url>/Paramiko/</url>
    <content><![CDATA[<h2 id="Paramiko"><a href="#Paramiko" class="headerlink" title="Paramiko"></a>Paramiko</h2><blockquote>
<p><code>Paramiko</code>是<code>SSHv2</code>协议的<code>Python</code>实现，提供客户端和服务器功能</p>
<p><code>Paramiko</code>本身是一个围绕<code>SSH</code>网络概念的纯<code>Python</code>接口</p>
<p>利用<code>paramiko</code>我们可以通过<code>Python</code>方便的进行<code>ssh</code>操作</p>
</blockquote><a id="more"></a>
<p>+++</p>
<blockquote>
<p>paramiko<code>包含两个核心组件：</code>SSHClient<code>和</code>SFTPClient</p>
</blockquote>
<h3 id="SSHClient"><a href="#SSHClient" class="headerlink" title="SSHClient"></a>SSHClient</h3><p>+++</p>
<blockquote>
<p><code>SSHClient</code>的作用类似于<code>Linux</code>的<code>ssh</code>命令，是对<code>SSH</code>会话的封装</p>
<p>该类封装了传输<code>Transport</code>，通道<code>Channel</code>及<code>SFTPClient</code>建立的方法<code>open_sftp</code>，通常用于执行远程命令</p>
</blockquote>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><ul>
<li><code>class paramiko.client.SSHClient</code></li>
</ul>
<blockquote>
<p>创建<code>SSH</code>客户端实例</p>
</blockquote>
<ul>
<li><code>SSHClient.connect(hostname, port=22, username=None, password=None, pkey=None, key_filename=None, timeout=None, allow_agent=True, look_for_keys=True, compress=False..)</code></li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数解释</span></span><br><span class="line">- hostname：连接的目标主机</span><br><span class="line">- <span class="attribute">port</span>=SSH_PORT：指定端口</span><br><span class="line">- <span class="attribute">username</span>=None：验证的用户名</span><br><span class="line">- <span class="attribute">password</span>=None：验证的用户密码</span><br><span class="line">- <span class="attribute">pkey</span>=None：私钥方式用于身份验证</span><br><span class="line">- <span class="attribute">key_filename</span>=None：一个文件名或文件列表，指定私钥文件</span><br><span class="line">- <span class="attribute">timeout</span>=None：可选的tcp连接超时时间</span><br><span class="line">- <span class="attribute">allow_agent</span>=<span class="literal">True</span>：是否允许连接到ssh代理，默认为True 允许</span><br><span class="line">- <span class="attribute">look_for_keys</span>=<span class="literal">True</span>：是否在~/.ssh中搜索私钥文件，默认为True 允许</span><br><span class="line">- <span class="attribute">compress</span>=<span class="literal">False</span>：是否打开压缩</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过验证连接远程服务端</p>
</blockquote>
<hr>
<ul>
<li><code>SSHClient.exec_command(command, bufsize=-1, timeout=None, get_pty=False, environment=None)</code></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 参数解释</span></span><br><span class="line"><span class="bullet">- </span>command：要执行的命令</span><br><span class="line"><span class="bullet">- </span>bufsize：与Python中文件对象的同名函数解释相同，缓冲区大小</span><br><span class="line"><span class="bullet">- </span>timeout：设置命令的超时相应事件</span><br><span class="line"><span class="bullet">- </span>get_pty：从服务器请求一个伪终端（默认为假）</span><br><span class="line"><span class="bullet">- </span>environment：一个当前shell环境的字典，远程命令的默认执行环境</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>command</code>参数为要执行的<code>shell</code>命令，打开一个新通道并执行请求的命令</p>
<p>该函数的返回结果为一个元组，其中包含<code>stdin</code>、<code>stdout</code>和<code>stderr</code>，也就是我们常见的标准输入，输出以及出错</p>
<p>一般来说，命令的结果我们将通过<code>stdout</code>进行获取</p>
</blockquote>
<hr>
<ul>
<li><code>SSHClient.close()</code></li>
</ul>
<blockquote>
<p>关闭<code>SSH</code>连接</p>
</blockquote>
<hr>
<ul>
<li><code>SSHClient.invoke_shell(term=’vt100’, width=80, height=24, width_pixels=0, height_pixels=0, environment=None)</code></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 参数解释</span></span><br><span class="line"><span class="bullet">- </span>term：模拟终端类型</span><br><span class="line"><span class="bullet">- </span>width：终端长度</span><br><span class="line"><span class="bullet">- </span>height：终端宽度</span><br><span class="line"><span class="bullet">- </span>width_pixels：终端的像素宽度</span><br><span class="line"><span class="bullet">- </span>height_pixels：终端的像素高度</span><br><span class="line"><span class="bullet">- </span>environment：命令的shell环境</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>ssh</code>服务器上启动交互式<code>shell</code>会话</p>
<p>一个新的通道被打开并连接到，使用请求的终端类型和大小的伪终端，并作为返回值</p>
<p>换句通俗的话来讲，就是创建了一个实际的<code>shell</code>窗口空间进行命令交互</p>
</blockquote>
<hr>
<ul>
<li><code>SSHClient.set_missing_host_key_policy(policy)</code></li>
</ul>
<blockquote>
<p>设置连接到没有已知主机密钥的服务器时要使用的策略</p>
<p>常见使用策略为<code>paramiko.client.AutoAddPolicy</code>，其意义为自动将主机名和新主机密钥添加到本地主机密钥对象并保存</p>
</blockquote>
<h4 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h4><blockquote>
<p>以下是一个简单的通过<code>SSHClient</code>建立的通道进行命令的传输与返回结果的获取的代码！</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(hostname,username,password)</span>:</span></span><br><span class="line">	client = paramiko.SSHClient() </span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">	client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    <span class="comment"># 设置密钥策略</span></span><br><span class="line">	client.connect(hostname,username=username,password=password)</span><br><span class="line">    <span class="comment"># 连接主机</span></span><br><span class="line">	<span class="keyword">return</span> client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec_cmd</span><span class="params">(client,cmd)</span>:</span></span><br><span class="line">	stdin,stdout,stderr = client.exec_command(cmd)</span><br><span class="line">	<span class="keyword">return</span> stdout.read().decode(),stderr.read().decode()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">	hostname = <span class="string">'192.168.0.104'</span></span><br><span class="line">	username = <span class="string">'pi'</span></span><br><span class="line">	password = <span class="string">'123456'</span></span><br><span class="line">	cmd = <span class="string">'ps -aux'</span></span><br><span class="line"></span><br><span class="line">	client = connect(hostname,username,password)</span><br><span class="line">	res = exec_cmd(client, cmd)</span><br><span class="line">	<span class="keyword">if</span> res[<span class="number">0</span>]:</span><br><span class="line">		print(res[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">if</span> res[<span class="number">1</span>]:</span><br><span class="line">		print(<span class="string">'[E]:\n'</span>,res[<span class="number">1</span>])</span><br><span class="line">	client.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的代码通过默认建立好的连接对象进行命令的传输以及返回结果的获取</p>
</blockquote>
<h4 id="invoke-shell"><a href="#invoke-shell" class="headerlink" title="invoke_shell"></a>invoke_shell</h4><ul>
<li>接下来使用<code>invoke_shell</code>进行虚拟终端的连接，首先初始化<code>SSH</code>通道</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SSHChannle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, username, password, port=<span class="number">22</span>)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">            初始化SSH通道</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.sh = paramiko.SSHClient()</span><br><span class="line">        self.sh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">        self.sh.connect(host, username=username, password=password)</span><br><span class="line">        self.channle = self.sh.invoke_shell()</span><br><span class="line">        self.cmd = <span class="string">''</span></span><br></pre></td></tr></table></figure>

<ul>
<li>思路为开启两个线程，分别负责命令的接收与命令的发送</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ssh_recv</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        接收SSH通道中发来的消息</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> self.channle.exit_status_ready():</span><br><span class="line">        <span class="comment"># 如果远程进程已退出并返回退出状态，则返回true</span></span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            buf = self.channle.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            print(buf,end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">            print(ex)</span><br><span class="line">        sys.stdout.flush()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_ssh_cmd</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        发送命令给SSH通道</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> self.channle.exit_status_ready():</span><br><span class="line">        self.cmd = input()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.channle.send(self.cmd + <span class="string">'\r'</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">            print(ex)</span><br><span class="line">        <span class="comment"># sys.stdin.flush()</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在实例中定义<code>run</code>函数用来开启两个线程并负责线程的资源回收以及SSH通道的关闭</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    ssh_recv_thread = threading.Thread(target=self.get_ssh_recv)</span><br><span class="line">    ssh_send_thread = threading.Thread(target=self.send_ssh_cmd)</span><br><span class="line">    ssh_recv_thread.start()</span><br><span class="line">    ssh_send_thread.start()</span><br><span class="line"></span><br><span class="line">    ssh_recv_thread.join()</span><br><span class="line">    ssh_send_thread.join()</span><br><span class="line"></span><br><span class="line">    self.sh.close()  <span class="comment"># 关闭通道</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>win</code>下的<code>CMD</code>中查看效果，其中的乱码格式其实为连接后命令传输的特殊标记格式，可以在后面结合前端中类似<code>xterm.js</code>等插件查看到实际花里胡哨的效果</li>
</ul>
<p><a href="https://lienze.tech/blog/images/invoke_shell.gif" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/invoke_shell.gif" alt="invoke_shell"></a></p>
<h3 id="SFTPClient"><a href="#SFTPClient" class="headerlink" title="SFTPClient"></a>SFTPClient</h3><blockquote>
<p><code>SFTPClient</code>的作用类似与<code>Linux</code>的<code>sftp</code>命令，是对<code>SFTP</code>客户端的封装</p>
<p>用以实现远程文件操作，如文件上传、下载、修改文件权限等操作</p>
</blockquote>
<h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><ul>
<li>官方文档</li>
</ul>
<blockquote>
<p>docs.paramiko.org/en/2.4/api/sftp.html</p>
</blockquote>
<ul>
<li><code>sftp=paramiko.SFTPClient.from_transport(t,window_size=None,max_packet_size=None)</code></li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"># 参数解释- t：该参数可以通过paramiko.<span class="constructor">Transport( (<span class="params">ip</span>,<span class="params">port</span> )</span>)，创建一个已通过验证的传输通道，参数为IP和端口的二元组</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据参数<code>t</code>指定的已验证传输通道进行<code>SFTP</code>客户端的创建</p>
</blockquote>
<ul>
<li><code>sftp.put(localpath, remotepath, callback=None, confirm=True)</code></li>
</ul>
<blockquote>
<p>上传本地路径为<code>localpath</code>的文件到目标主机<code>remotepath</code>处</p>
</blockquote>
<ul>
<li><code>sftp.get(remotepath, localpath, callback=None)</code></li>
</ul>
<blockquote>
<p>下载远程路径为<code>remotepath</code>路径的的文件到本地主机<code>localpath</code>处</p>
</blockquote>
<ul>
<li><code>open(filename, mode=’r’, bufsize=-1)</code></li>
</ul>
<blockquote>
<p>打开位于远程主机上的文件，与<code>open</code>函数类似，返回文件对象</p>
</blockquote>
<ul>
<li><code>listdir(path=&#39;.&#39;)</code></li>
</ul>
<blockquote>
<p>返回给定路径下文件及目录的列表，默认路径为当前工作目录</p>
</blockquote>
<ul>
<li><code>chdir(path=None)</code></li>
</ul>
<blockquote>
<p>修改当前<code>SFTP</code>连接会话的工作目录</p>
</blockquote>
<ul>
<li><code>lstat(path)</code></li>
</ul>
<blockquote>
<p>检索当前<code>path</code>所指向的文件信息</p>
</blockquote>
<ul>
<li><code>mkdir(path,mode=511)</code></li>
</ul>
<blockquote>
<p>根据<code>path</code>在目标主机创建默认权限为<code>511</code>的目录</p>
</blockquote>
<ul>
<li><code>rmdir(path)</code></li>
</ul>
<blockquote>
<p>删除给定<code>path</code>所指向的目录</p>
</blockquote>
<ul>
<li><code>remove(path)</code></li>
</ul>
<blockquote>
<p>删除给定<code>path</code>所指向的文件</p>
</blockquote>
<h4 id="实例代码-1"><a href="#实例代码-1" class="headerlink" title="实例代码"></a>实例代码</h4><blockquote>
<p>以下是一个比较简陋的关于<code>SFTPClient</code>的测试代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connecnt</span><span class="params">(hostname,username,password)</span>:</span> <span class="comment">#创建连接对象</span></span><br><span class="line">    client = paramiko.Transport( (hostname,<span class="number">22</span>))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        client.connect(username=username,password=password)</span><br><span class="line">    <span class="keyword">except</span> paramiko.SSHException:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    sftp_client = paramiko.SFTPClient.from_transport(client)</span><br><span class="line">    <span class="keyword">return</span> sftp_client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    hostname = <span class="string">'192.168.0.104'</span></span><br><span class="line">    username = <span class="string">'pi'</span></span><br><span class="line">    password = <span class="string">'123456'</span></span><br><span class="line">    sftp_client = connecnt(hostname,username,password)</span><br><span class="line">    remotefile_path = <span class="string">'/home/pi/test'</span> <span class="comment"># 目标主机文件路径</span></span><br><span class="line">    localfile_path = <span class="string">'/home/test'</span> <span class="comment"># 本地主机文件路径</span></span><br><span class="line"></span><br><span class="line">    sftp_client.put(localfile_path, remotefile_path) <span class="comment">#上传本地test文件到远程</span></span><br><span class="line">    sftp_client.get(remotefile_path, localfile_path) <span class="comment">#下载远程test文件到本地</span></span><br><span class="line">    print(sftp_client.listdir())</span><br><span class="line">    print(<span class="string">'--------------------'</span>)</span><br><span class="line">    print(sftp_client.lstat(remotefile_path))</span><br><span class="line">    print(<span class="string">'--------------------'</span>)</span><br><span class="line">    <span class="keyword">with</span> sftp_client.open(remotefile_path) <span class="keyword">as</span> fp:</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Paramiko</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible</title>
    <url>/Ansible/</url>
    <content><![CDATA[<h2 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h2><blockquote>
<p><code>ansible</code>基于Python开发，集合了众多运维工具（<code>puppet</code>、<code>cfengine</code>、<code>chef</code>、<code>func</code>、<code>fabric</code>）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能<br>在使用时，<code>ansible</code>不需要在被控制安装客户端，<code>ansible</code>工作基于<code>ssh</code>，只要被控制端服务器有<code>ssh</code>服务，加上一个<code>Python</code>环境，就可以使用<code>ansible</code><br>另外，<code>ansible</code>在15年的时候，以1.5亿美元被<code>RedHat</code>公司收购，新版的<code>RedHat</code>操作系统内置<code>ansible</code>软件，很厉害的</p>
</blockquote><a id="more"></a>
<p>##Ansible部署</p>
<blockquote>
<p><code>ansible</code>安装可以通过源码，<code>yum</code>源以及<code>python</code>所提供的<code>pip</code>管理工具进行安装</p>
</blockquote>
<ul>
<li>使用pip管理工具进行安装</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install ansible</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>yum</code>进行安装</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yum install epel-release <span class="comment"># 安装扩展源</span></span><br><span class="line">yum install ansible</span><br></pre></td></tr></table></figure>

<h2 id="Ansible配置"><a href="#Ansible配置" class="headerlink" title="Ansible配置"></a>Ansible配置</h2><blockquote>
<p>安装之后，默认<code>ansible</code>工具的配置文件在<code>/etc/ansible</code>下</p>
<p>如通过<code>pip</code>命令安装，是没有这个目录的，需要我们手动创建，其中所需主要配置文件如下</p>
</blockquote>
<ul>
<li><code>ansible.cfg</code>：<code>ansible</code>主配置文件</li>
<li><code>hosts</code>：被管理主机<code>IP</code>或者主句名列表文件，也是比较重要的一个文件</li>
<li><code>roles</code>：角色或插件目录（默认为空）</li>
</ul>
<blockquote>
<p>此外除了默认的<code>ansible</code>的配置文件路径，关于<code>ansible</code>的配置文件路径选择还有如下几种，按照序列表示优先级</p>
</blockquote>
<ul>
<li><code>export ANSIBLE_CONFI</code>：指定的全局变量</li>
<li><code>./ansible.cfg</code>：当前目录下的配置文件</li>
<li><code>~/.ansible.cfg</code>：当前用户目下的配置文件</li>
<li><code>/ext/ansible/ansible.cfg</code>：<code>etc</code>目录下的配置文件</li>
</ul>
<blockquote>
<p>如果以上四个路径下均没有<code>cfg</code>配置文件，则使用默认配置</p>
<p>如果通过源码进行安装，那么在<code>/etc/ansible</code>目录下会自动包含<code>ansible.cfg</code>文件</p>
<p>也可以通过访问在线的配置文件地址进行获取</p>
</blockquote>
<blockquote>
<p><a href="https://raw.githubusercontent.com/ansible/ansible/devel/examples/ansible.cfg" target="_blank" rel="noopener">https://raw.githubusercontent.com/ansible/ansible/devel/examples/ansible.cfg</a></p>
</blockquote>
<ul>
<li><code>ansible</code>配置文件中可以进行<code>ansible</code>的各项参数的设置，包括并发线程数量、用户、模块路径、调优等等<ul>
<li><code>defaluts</code>：默认的配置项，一般不需要修改</li>
<li><code>privilege_escalation</code>：执行命令的用户权限设置</li>
<li><code>paramiko_connection</code>：<code>paramiko</code>插件设置</li>
<li><code>ssh_connection</code>：<code>ssh</code>连接设置</li>
</ul>
</li>
<li>默认<code>ansible</code>使用<code>hosts</code>文件列举监控主句，格式为<code>ini</code>，可以进行<code>IP</code>的分组以及<code>IP</code>规则设置，比如如下的例子</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[webserver]</span></span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1001</span><span class="selector-pseudo">:22</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ansible</code>支持很多模块来进行对被控制主机的管理，包括：<code>command</code>、<code>shell</code>、<code>script</code>、<code>yum</code>、<code>copy</code>、<code>File</code>、<code>async</code>、<code>docker</code>、<code>cron</code>、<code>mysql_user</code>、<code>ping</code>、<code>sysctl</code>、<code>user</code>、<code>acl</code>、<code>add_host</code>、<code>easy_install</code>、<code>haproxy</code>等。默认在执行命令时，使用模块为、<code>command</code>，接下来会进行介绍</p>
</blockquote>
<h2 id="Ansible使用参数"><a href="#Ansible使用参数" class="headerlink" title="Ansible使用参数"></a>Ansible使用参数</h2><blockquote>
<p><code>ansible</code>在工作时，需要使用我们安装好的、<code>ansible</code>来执行命令</p>
<p>经常在使用、<code>ansible</code>模块进行工作时，可能还需要额外提供一些参数来辅助工作，下面是常用参数</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>-v</code></td>
<td>打印详细信息</td>
</tr>
<tr>
<td><code>-m</code></td>
<td>指定使用的模块，默认为 <code>command</code>模块</td>
</tr>
<tr>
<td><code>-k</code></td>
<td>要求输入远程主机密码</td>
</tr>
<tr>
<td><code>-a</code></td>
<td>将参数或命令传入模块</td>
</tr>
<tr>
<td><code>-c</code></td>
<td>测试执行过程，但不真正执行</td>
</tr>
<tr>
<td><code>-sudo</code></td>
<td>基于 <code>sudo</code>用户执行</td>
</tr>
<tr>
<td><code>--list-hosts</code></td>
<td>列举命令生效的主机</td>
</tr>
<tr>
<td><code>-l</code></td>
<td>限制匹配规则的主机数</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>指定 <code>hosts</code>文件路径</td>
</tr>
<tr>
<td><code>-u</code></td>
<td><code>SSH</code> 连接所使用用户</td>
</tr>
</tbody></table>
<blockquote>
<p>现在看到这些命令参数你可能有一些懵，不过不要着急，结合模块使用，你将很快了解这些参数的实际意义</p>
</blockquote>
<h2 id="配置免密登陆"><a href="#配置免密登陆" class="headerlink" title="配置免密登陆"></a>配置免密登陆</h2><blockquote>
<p>由于 <code>ansible</code>是通过 <code>ssh</code> 服务进行命令下达执行，那避免不了用户认证</p>
<p>但是在批量执行时，多次的重复认证会导致我们的效率极其低下，这里可以通过配置主控端与被控端知己之间 <code>SSH</code> 免密登陆来实现用户认证的跳过，可谓是一次配置，轻松很久</p>
</blockquote>
<ul>
<li>在主控服务器 <code>192.168.1.104</code> 下生成密钥</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="comment"># -t 指定加密的方式，默认为rsa</span></span><br></pre></td></tr></table></figure>

<ul>
<li>进行秘钥的分布</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@<span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span></span><br></pre></td></tr></table></figure>

<ul>
<li>输入对应远程主机的 <code>ssh</code> 账号密码之后，接下来在主控服务器就可以不进行 <code>SSH</code> 的用户认证也可以访问到被控制端，这里测试主机为 <code>192.168.1.104</code> （主控）， <code>192.168.1.101</code> （被控）</li>
</ul>
<h2 id="定义主机及组规则"><a href="#定义主机及组规则" class="headerlink" title="定义主机及组规则"></a>定义主机及组规则</h2><blockquote>
<p><code>ansible</code> 通过定义好的主句以组规则（<code>Inventory</code>） 在执行命令时通过匹配进行远程操作</p>
<p>这个文件默认就是我们上面所说的 <code>/etc/ansible/hosts</code> 文件，其中定义的几种方式如下</p>
</blockquote>
<ul>
<li>直接 <code>IP</code> 写入</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span></span><br></pre></td></tr></table></figure>

<ul>
<li>规则分组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[webserver]</span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span>:<span class="number">2333</span></span><br><span class="line">www.example.com</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在规则的 <code>IP</code> 后指定端口</p>
</blockquote>
<ul>
<li>规则命名</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">myhost ansible_ssh_host=<span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span></span><br><span class="line">[webservers]</span><br><span class="line">myhost</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在使用时，直接利用<code>myhost</code>即可</p>
<p>除去示例中的指定方式，还有如下一些参数可以利用</p>
</blockquote>
<ul>
<li><code>ansible_ssh_host</code>：目标主机地址</li>
<li><code>ansible_ssh_port</code>：目标主机<code>ssh</code>服务端口</li>
<li><code>ansible_ssh_user</code>：目标主机<code>ssh</code>登录用户</li>
<li><code>ansible_ssh_pass</code>：目标主机<code>ssh</code>登录密码</li>
<li><code>ansible_connection</code>：连接类型：<code>local</code>、<code>ssh</code>、<code>paramiko</code></li>
<li><code>ansible_ssh_priveate_key_file</code>：连接所需<code>ssh</code>私钥文件；</li>
<li><code>ansible_shell_type</code>：目标主机的shell类型：<code>ash</code>、<strong>bash</strong>（默认使用的<code>shell</code>，可以结合<code>help</code>查看帮助文档）、<code>ksh</code>（支持42个内部命令）、<code>csh</code>、<code>zsh</code>（最庞大的shell，支持84个内部命令）</li>
<li>正则规则</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">webservers</span>][<span class="symbol">a:z</span>]bc.example.com192.168.1.10[1:5]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在主机处填写对应的正则规则，可以更加方便的映射某个网段下的<code>ip</code>地址</p>
</blockquote>
<h3 id="Ping模块"><a href="#Ping模块" class="headerlink" title="Ping模块"></a>Ping模块</h3><blockquote>
<p>ping模块可以判断被控主机是否在线， 返回值为changed和ping</p>
<p>首先在<code>/etc/ansible/hosts</code>文件下添加被控主机，并建立分组为<strong>webservers</strong></p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[webservers]</span>192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.101</span><span class="selector-pseudo">:22</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>ping</code>命令的用法，要进入到<code>python</code>安装目录下，找到对应的<code>ansible</code>可执行文件</li>
</ul>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">./ansible <span class="keyword">all</span> -m ping</span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回值<code>ping</code>如果为<code>pong</code>则代表可以<code>ping</code>通</p>
<p><code>ansible</code>命令行第二个参数可以是一个主机的正则规则，<code>all</code>代表所有<code>hosts</code>文件下<code>IP</code>，也可以指定使用某个分组</p>
</blockquote>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">./ansible webservers -m <span class="built_in">ping</span></span><br></pre></td></tr></table></figure>

<h3 id="Command模块"><a href="#Command模块" class="headerlink" title="Command模块"></a>Command模块</h3><blockquote>
<p>通过<code>ansible</code>执行命令时，默认使用<code>command</code>模块，该模块主要用于执行<code>linux</code>基础命令</p>
</blockquote>
<ul>
<li>注意：对比之后的<code>Shell</code>及<code>Script</code>功能模块，<code>Command</code>模块不支持管道</li>
<li><code>command</code>支持的额外参数</li>
</ul>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./ansible-doc</span> -s <span class="keyword">command</span><span class="comment"># 文档</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>chdir</code></td>
<td align="left">执行命令时，先进入到该目录下</td>
</tr>
<tr>
<td align="left"><code>creates</code></td>
<td align="left">给定文件存在时，不执行该命令</td>
</tr>
<tr>
<td align="left"><code>free_form</code></td>
<td align="left">需要执行的脚本</td>
</tr>
<tr>
<td align="left"><code>removes</code></td>
<td align="left">给定文件存在，则执行该命令</td>
</tr>
</tbody></table>
<ul>
<li>对远程主机执行命令</li>
</ul>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./ansible</span> webservers -m <span class="keyword">command</span> -a <span class="string">"ifconfig"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>执行命令时更改工作目录</li>
</ul>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./ansible</span> webservers -m <span class="keyword">command</span> -a <span class="string">"ls chdir=/home/"</span></span><br></pre></td></tr></table></figure>

<h3 id="Shell模块"><a href="#Shell模块" class="headerlink" title="Shell模块"></a>Shell模块</h3><blockquote>
<p><code>shell</code>使用远程主机下的<code>/bin/sh</code>进行命令执行，支持比<code>command</code>模块更多的命令，常用参数如下</p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">./ansible-doc -s <span class="keyword">shell</span><span class="bash"><span class="comment"># 文档</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>额外参数</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>chdir</code></td>
<td align="left">执行命令时，先进入到该目录下</td>
</tr>
<tr>
<td align="left"><code>creates</code></td>
<td align="left">给定文件存在时，不执行该命令</td>
</tr>
<tr>
<td align="left"><code>free_form</code></td>
<td align="left">需要执行的脚本</td>
</tr>
<tr>
<td align="left"><code>removes</code></td>
<td align="left">给定文件存在，则执行该命令</td>
</tr>
<tr>
<td align="left"><code>executable</code></td>
<td align="left">更换执行命令所使用的<code>shell</code>环境</td>
</tr>
</tbody></table>
<ul>
<li>远程主机编写<code>sh</code>脚本，向屏幕输出<code>hello</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>执行远程主机的<code>shell</code>脚本</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">./ansible webservers -m <span class="keyword">shell</span><span class="bash"> -a <span class="string">"sh ~/test.sh"</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Script模块"><a href="#Script模块" class="headerlink" title="Script模块"></a>Script模块</h3><blockquote>
<p>该模块可以方便运行当前管理机上的脚本直接到远程被控端，而不需要先将脚本拷贝到远程主机后在执行</p>
</blockquote>
<ul>
<li>在主控制<code>home</code>目录下创建<code>sh</code>脚本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"this is Control"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将这个<code>sh</code>脚本通过<code>script</code>模块执行到远程被控端</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">./ansible webservers -m<span class="built_in"> script </span>-a <span class="string">"/root/test.sh"</span></span><br></pre></td></tr></table></figure>

<h3 id="Copy模块"><a href="#Copy模块" class="headerlink" title="Copy模块"></a>Copy模块</h3><blockquote>
<p><code>copy</code>模块可以方便的将当前主机下文件拷贝到远程主机，类似<code>scp</code>命令等</p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">./ansible-doc -s <span class="keyword">copy</span><span class="bash"><span class="comment"># 文档地址</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>支持的参数</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>src</code></td>
<td align="left">将本地路径复制到远程服务器; 可以是绝对路径或相对的。如果是一个目录，它将被递归地复制。如果路径以/结尾，则只有该目录下内容被复制到目的地，如果没有使用/来结尾，则包含目录在内的整个内容全部复制</td>
</tr>
<tr>
<td align="left"><code>content</code></td>
<td align="left">当用<code>content</code>代替<code>src</code>参数的时候，可以把文档的内容设置到特定的值</td>
</tr>
<tr>
<td align="left"><code>dest</code></td>
<td align="left">目标绝对路径。如果<code>src</code>是一个目录，<code>dest</code>也必须是一个目录。如果<code>dest</code>是不存在的路径，并且如果<code>dest</code>以/结尾或者<code>src</code>是目录，则<code>dest</code>被创建。如果<code>src</code>和<code>dest</code>是文件，如果<code>dest</code>的父目录不存在，任务将失败</td>
</tr>
<tr>
<td align="left"><code>backup</code></td>
<td align="left">如果文件修改，则在覆盖之前将原文件备份，备份文件包含时间信息</td>
</tr>
<tr>
<td align="left"><code>directory_mode</code></td>
<td align="left">设定目录的权限，在新建时使用，不会影响已存在的目录</td>
</tr>
<tr>
<td align="left"><code>force</code></td>
<td align="left">当目标内容不同于源时，将替换远程文件。设置为<code>no</code>时，只有在目标文件不存在的情况下才会传输文件</td>
</tr>
<tr>
<td align="left"><code>group</code></td>
<td align="left">设置文件/目录的所属组</td>
</tr>
<tr>
<td align="left"><code>mode</code></td>
<td align="left">设置文件权限</td>
</tr>
<tr>
<td align="left"><code>owner</code></td>
<td align="left">设置文件/目录的所属用户</td>
</tr>
</tbody></table>
<h3 id="Copy前备份"><a href="#Copy前备份" class="headerlink" title="Copy前备份"></a>Copy前备份</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">./ansible all -m copy -a <span class="string">"src=/root/ansible_copy_file backup=yes dest=/home/"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在第一次拷贝时，由于目标主机还并没有这个文件， 备份动作不生效</p>
<p>在对文件内容进行修改后重新执行该命令拷贝文件</p>
<p>此时目标主机下，不光会有我们上传的拷贝文件，还有之前文件的一个备份</p>
</blockquote>
<h4 id="覆盖内容"><a href="#覆盖内容" class="headerlink" title="覆盖内容"></a>覆盖内容</h4><blockquote>
<p>直接通过<code>content</code>参数指定内容，并对目标主机上已存在的<code>test_copy</code>文件进行覆盖</p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">./ansible all -m <span class="keyword">copy</span><span class="bash"> -a <span class="string">"content='这是命令修改\n'  dest=/home/test_copy"</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这条命令将会把远程主机<code>home</code>目录下的<code>test_copy</code>文件覆盖为我们的<code>content</code>内容</p>
</blockquote>
<h3 id="Stat模块"><a href="#Stat模块" class="headerlink" title="Stat模块"></a>Stat模块</h3><blockquote>
<p>该模块可以获取远程主机下的文件信息，需要使用<code>path</code>参数指明文件路径</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">./ansible all -m stat -<span class="selector-tag">a</span> <span class="string">"path=/home/test_copy"</span></span><br></pre></td></tr></table></figure>

<h3 id="Yum模块"><a href="#Yum模块" class="headerlink" title="Yum模块"></a>Yum模块</h3><blockquote>
<p>该模块可以对远程主机上的软件安装、卸载进行管理</p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">./ansible-doc -s <span class="keyword">copy</span><span class="bash"><span class="comment"># 文档</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>支持参数</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">name</td>
<td align="left">必须参数，用于指定需要管理的软件包，比如<code>nginx</code></td>
</tr>
<tr>
<td align="left">state</td>
<td align="left">用于指定软件包的状态，默认值为<code>present</code>，表示确保软件包已经安装 除了<code>present</code>，其他可用值有<code>installed</code>、<code>latest</code>、<code>absent</code>、<code>removed</code> 其中<code>installed</code>与<code>present</code>等效，<code>latest</code>表示安装<code>yum</code>中最新的版本，<code>absent</code>和<code>removed</code>等效，表示删除对应的软件包</td>
</tr>
</tbody></table>
<ul>
<li>在远程主机下安装<code>nginx</code></li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">./ansible all -m yum -<span class="selector-tag">a</span> <span class="string">"name=nginx state=installed"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看<code>nginx</code>服务状态</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">systemctl status nginx</span></span><br></pre></td></tr></table></figure>

<h3 id="Service模块"><a href="#Service模块" class="headerlink" title="Service模块"></a>Service模块</h3><blockquote>
<p>该模块主要用于远程服务器上对应的服务管理，比如开启或关闭<code>apache</code>服务等</p>
</blockquote>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./ansible-doc</span> -s yum<span class="comment"># 文档</span></span><br></pre></td></tr></table></figure>

<ul>
<li>支持参数</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>name</code></td>
<td align="left">需要管理的服务名称，如<code>nginx</code></td>
</tr>
<tr>
<td align="left"><code>state</code></td>
<td align="left">此参数用于指定服务的状态 比如，我们想要启动远程主机中的<code>nginx</code>，则可以将<code>state</code>的值设置为<code>started</code> 如果想要停止远程主机中的服务，则可以将<code>state</code>的值设置为<code>stopped</code> 此参数的可用值有<code>started</code>、<code>stopped</code>、<code>restarted</code>、<code>reloaded</code></td>
</tr>
<tr>
<td align="left"><code>enabled</code></td>
<td align="left">此参数用于指定是否将服务设置为开机启动项，设置为<code>yes</code>表示将对应服务设置为开机启动，设置为<code>no</code>表示不会开机启动</td>
</tr>
</tbody></table>
<ul>
<li>将远程主机下的<code>httpd</code>服务开启</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">./ansible all -m<span class="built_in"> service </span>-a <span class="string">"name=httpd state=started"</span></span><br></pre></td></tr></table></figure>

<h3 id="File模块"><a href="#File模块" class="headerlink" title="File模块"></a>File模块</h3><blockquote>
<p><code>file</code>模块可以帮助我们完成一些对文件的基本操作</p>
<p>比如，<strong>创建文件</strong>或<strong>目录</strong>、<strong>删除文件</strong>或<strong>目录</strong>、<strong>修改文件权限</strong>等</p>
</blockquote>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./ansible-doc</span> -s yum<span class="comment"># 文档</span></span><br></pre></td></tr></table></figure>

<ul>
<li>支持参数</li>
</ul>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>path</code></td>
<td align="left">指明需要操作的文件或目录路径</td>
</tr>
<tr>
<td align="left"><code>state</code></td>
<td align="left">此参数非常灵活，其对应的值需要根据情况设定。比如，我们想要在远程主机上创建<code>/testdir/a/b</code>目录，那么则需要设置<code>path=/testdir/a/b</code>，但是，我们无法从<code>/testdir/a/b</code>这个路径看出<code>b</code>是一个文件还是一个目录，<code>ansible</code>也同样无法单单从一个字符串就知道你要创建文件还是目录，所以，我们需要通过<code>state</code>参数进行说明 当我们想要创建的<code>/testdir/a/b</code>是一个目录时，需要将<code>state</code>的值设置为<code>directory</code>，<code>directory</code>为目录之意，当它与<code>path</code>结合，<code>ansible</code>就能知道我们要操作的目标是一个目录 当我们想要操作的<code>/testdir/a/b</code>是一个文件时，则需要将<code>state</code>的值设置为<code>touch</code> 当我们想要创建软链接文件时，需将<code>state</code>设置为<code>link</code>；想要创建硬链接文件时，需要将<code>state</code>设置为<code>hard</code> 当我们想要删除一个文件时（删除时不用区分目标是文件、目录、还是链接），则需要将<code>state</code>的值设置为<code>absent</code>，<code>absent</code>为缺席之意，当我们想让操作的目标”缺席”时，就表示我们想要删除目标</td>
</tr>
<tr>
<td align="left"><code>src</code></td>
<td align="left"><code>src</code>参数：当<code>state</code>设置为<code>link</code>或者<code>hard</code>时，表示我们想要创建一个软链或者硬链 所以，我们必须指明软链或硬链链接的哪个文件，通过<code>src</code>参数即可指定链接源</td>
</tr>
<tr>
<td align="left"><code>force</code></td>
<td align="left">当<code>state=link</code>的时候，可配合此参数强制创建链接文件，当<code>force=yes</code>时，表示强制创建链接文件。不过强制创建链接文件分为三种情况 情况一：当要创建的链接文件指向的源文件并不存在时，使用此参数，可以先强制创建出链接文件 情况二：当要创建链接文件的目录中已经存在与链接文件同名的文件时，将<code>force</code>设置为<code>yes</code>，会将同名文件覆盖为链接文件，相当于删除同名文件，创建链接文件 情况三：当要创建链接文件的目录中已经存在与链接文件同名的文件，并且链接文件指向的源文件也不存在，这时会强制替换同名文件为链接文件</td>
</tr>
<tr>
<td align="left"><code>owner</code></td>
<td align="left">指定文件所属用户</td>
</tr>
<tr>
<td align="left"><code>group</code></td>
<td align="left">指定文件所属组</td>
</tr>
<tr>
<td align="left"><code>mode</code></td>
<td align="left">指定文件权限</td>
</tr>
</tbody></table>
<ul>
<li>将远程主机下的<code>Python3</code>创建软连接到<code>home</code>目录</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">.<span class="regexp">/ansible all -m file -a "path=/</span>home<span class="regexp">/python3 state=link src=/u</span>sr<span class="regexp">/local/</span>python3<span class="regexp">/bin/</span>python3<span class="string">"</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub操作</title>
    <url>/Git/</url>
    <content><![CDATA[<h1 id="GitHub操作起来真的是太简单啦！"><a href="#GitHub操作起来真的是太简单啦！" class="headerlink" title="GitHub操作起来真的是太简单啦！"></a>GitHub操作起来真的是太简单啦！</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><blockquote>
<p>Git是一个<strong>免费的开源</strong>分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务。</p>
<p>Git易于学习， 占地面积小，具有闪电般快速的性能。它超越了Subversion，CVS，Perforce和ClearCase等SCM工具，具有廉价本地分支，便捷的<strong>临时区域</strong>和<strong>多个工作流程</strong>等功能</p>
</blockquote><a id="more"></a>
<h3 id="git流程"><a href="#git流程" class="headerlink" title="git流程"></a>git流程</h3><p><a href="https://lienze.tech/blog/images/git流程图.jpg" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/git%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="git流程图"></a></p>
<ul>
<li><code>workspace</code>：工作区</li>
<li><code>Index/Stage</code>：暂存区</li>
<li><code>Repository</code>：仓库区/本地仓库</li>
<li><code>Remote</code>：远程仓库</li>
</ul>
<h3 id="SVN与Git的区别"><a href="#SVN与Git的区别" class="headerlink" title="SVN与Git的区别"></a>SVN与Git的区别</h3><ul>
<li><code>SVN</code></li>
</ul>
<blockquote>
<p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的、而干活的时候，用的都是自己的电脑</p>
<p>首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器</p>
<p>集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了</p>
</blockquote>
<ul>
<li><code>Git</code></li>
</ul>
<blockquote>
<p>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库</p>
<p>这工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了</p>
<p>Git在本地磁盘上就保存着所有有关当前项目的历史更新，并且Git中的绝大多数操作都只需要访问本地文件和资源，不用连网，所以处理起来速度飞快</p>
<p>用SVN的话，没有网络或者断开VPN你就无法做任何事情</p>
<p>但用Git的话，就算你在飞机或者火车上，都可以非常愉快地频繁提交更新，等到了有网络的时候再上传到<strong>远程的镜像仓库</strong>。换作其他版本控制系统，这么做几乎不可能，抑或是非常麻烦</p>
</blockquote>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><ul>
<li><code>Windows</code>：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></li>
<li><code>Linux</code>：</li>
</ul>
<h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a><code>Git配置</code></h3><ul>
<li><code>git config --global</code>：全局git配置，这台机器所有的Git仓库均会使用这个配置</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.name <span class="string">"eastside"</span> # 你的名字</span><br><span class="line">git<span class="built_in"> config </span>--global user.email <span class="string">"..@xx.com"</span> # 你的邮箱</span><br></pre></td></tr></table></figure>

<h3 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h3><h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><ul>
<li>什么是版本库？</li>
</ul>
<blockquote>
<p>版本库又名仓库，英文名repository</p>
<p>你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件还原</p>
</blockquote>
<ul>
<li>选择，进入某个目录</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> projectcd project</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化目录为本地仓库</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git init</span></span><br></pre></td></tr></table></figure>

<ul>
<li>初始化之后，目录下会多一个隐藏目录<code>.git</code>，该目录是<code>git</code>用来管理版本的，</li>
</ul>
<h3 id="添加项目文件"><a href="#添加项目文件" class="headerlink" title="添加项目文件"></a>添加项目文件</h3><ul>
<li>以创建django项目为例，在<code>git</code>本地仓库开启一个django项目</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">django-admin startproject testpro</span></span><br></pre></td></tr></table></figure>

<ul>
<li>添加项目文件或目录至暂存区</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> testpro</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将暂存区内容提交至本地仓库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">commit</span> -m <span class="string">"a django project"</span></span><br><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"a django project"</span>[<span class="keyword">master</span> (root-<span class="keyword">commit</span>) adb00b3] a django <span class="keyword">project</span> <span class="number">5</span> files <span class="keyword">changed</span>, <span class="number">172</span> insertions(+) <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> testpro/manage.py <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> testpro/testpro/__init__.py <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> testpro/testpro/settings.py <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> testpro/testpro/urls.py <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> testpro/testpro/wsgi.py</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>-m</code>参数指定提交注释</p>
</blockquote>
<ul>
<li>查看此时仓库状态</li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">lienze<span class="variable">@DESKTOP</span>-BIDA1PF MINGW64 ~<span class="regexp">/Desktop/project</span> (master)<span class="variable">$ </span>git statusOn branch masternothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<h3 id="文件修改提交"><a href="#文件修改提交" class="headerlink" title="文件修改提交"></a>文件修改提交</h3><blockquote>
<p>如果在开发过程中，对其中的某个文件进行了修改，那么<code>git</code>在对比文件指纹的过程中发现了差异，此时也需要将新修改的文件进行提交</p>
</blockquote>
<ul>
<li>修改<code>settings.py</code>文件配置</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">ALLOWED_HOSTS</span> = [<span class="string">"*"</span>,]<span class="comment"># ALLOWED_HOSTS = []</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看仓库状态</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">$ git statusOn branch masterChanges <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:  (use "git add &lt;file&gt;..." <span class="keyword">to</span> <span class="keyword">update</span> what will be <span class="keyword">committed</span>)  (use "git checkout -- &lt;file&gt;..." <span class="keyword">to</span> <span class="keyword">discard</span> changes <span class="keyword">in</span> working directory)        modified:   settings.pyno changes added <span class="keyword">to</span> <span class="keyword">commit</span> (use "git add" <span class="keyword">and</span>/<span class="keyword">or</span> "git commit -a")</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时仓库说，<code>modified: settings.py</code>，我们对其中某个文件进行了修改</p>
</blockquote>
<ul>
<li>将修改之后的文件加入暂存区</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> -A</span></span><br></pre></td></tr></table></figure>

<ul>
<li>此时查看状态</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">$ git statusOn branch masterChanges <span class="keyword">to</span> <span class="keyword">be</span> committed:  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)        modified:   settings.<span class="keyword">py</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将暂存区的内容提交至本地仓库</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">commit</span> -m <span class="string">'change settings'</span></span><br><span class="line"><span class="keyword">On</span> branch masternothing <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span><br></pre></td></tr></table></figure>

<ul>
<li>丢弃修改，可以丢弃工作区对于文件的修改</li>
</ul>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git checkout <span class="comment">-- settings.py</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意：命令<code>git checkout -- settings.py</code>中的<code>--</code>很重要，如果没有<code>--</code>的话，那么命令变成创建分支了</li>
</ul>
<h3 id="文件删除提交"><a href="#文件删除提交" class="headerlink" title="文件删除提交"></a>文件删除提交</h3><ul>
<li>在<code>django</code>项目的隔壁创建一个<code>1.py</code>文件</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="section">touch</span> <span class="number">1.</span>py</span><br></pre></td></tr></table></figure>

<ul>
<li>添加该文件</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> -Agit commit -m <span class="string">"add 1.py"</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除该文件</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">rm <span class="number">1.</span>py</span><br></pre></td></tr></table></figure>

<ul>
<li>恢复删除文件</li>
</ul>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git checkout <span class="comment">-- 1.py</span></span><br></pre></td></tr></table></figure>

<ul>
<li>提交至本地工作区</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">git commit -<span class="selector-tag">a</span> -m <span class="string">"rm 1.py"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>git commit -a</code>：提交全部修改</p>
</blockquote>
<h2 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h2><blockquote>
<p>在团队开发中，我们需要每个开发者彼此配合，对同一款项目代码进行编写，此时需要我们借助线上仓库</p>
</blockquote>
<ul>
<li><code>github</code>：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com</a></li>
<li><code>gitee</code>：<a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com</a></li>
</ul>
<blockquote>
<p>由于网络环境，此处选择<code>gitee</code></p>
</blockquote>
<ul>
<li>将远程仓库添加到本地</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> edu git@gitee.com:eastside/edu.git</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>添加一个远程库，库名为<code>edu</code>，地址是<code>git@gitee.com:eastside/edu.git</code></p>
</blockquote>
<ul>
<li>列举当前所有的远程库</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git remote</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除某个远程库</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git remote <span class="builtin-name">remove</span> edu</span><br></pre></td></tr></table></figure>

<ul>
<li>将本地的仓库推到名为<code>edu</code>的远程仓库中</li>
</ul>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 仓库地址：https:<span class="comment">//gitee.com/eastside/edu.gitgit push edu master</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>将远程仓库的代码拉取到本地，在第一次拉取时，可能因为缺少远程服务器上的<code>README.txt</code>文件，而导致远程和本地的分支不一样，通过以下命令</li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git pull --rebase origin <span class="keyword">master</span> <span class="title"># 新建 README</span>文件</span><br><span class="line">git pull edu <span class="keyword">master</span> <span class="title">--allow-unrelated-histories</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将远程仓库克隆到本地</li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://gitee.com/eastside/edu.git</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是一个已经和远程仓库<code>master</code>分支关联的本地仓库</p>
</blockquote>
<ul>
<li>git全局配置多个用户名冲突时</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$  git<span class="built_in"> config </span>--global --replace-all user.email <span class="string">"输入你的邮箱"</span> $  git<span class="built_in"> config </span>--global --replace-all user.name <span class="string">"输入你的用户名"</span></span><br></pre></td></tr></table></figure>

<h3 id="GIT分支"><a href="#GIT分支" class="headerlink" title="GIT分支"></a>GIT分支</h3><blockquote>
<p>每次提交，<code>Git</code>都把它们串成一条时间线，这条时间线就是一个分支</p>
<p>截止到目前，只有一条时间线，在<code>Git</code>里，这个分支叫<strong>主分支</strong>，即<code>master</code>分支</p>
<p>我们可以通过<code>checkout</code>命令进行分支的创建及切换</p>
</blockquote>
<ul>
<li><code>git checkout -b</code>：创建并切换分支<ul>
<li><code>git branch branchname</code>：创建分支</li>
<li><code>git checkout branchname</code>：切换分支</li>
</ul>
</li>
<li>创建一个测试分支</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">git checkout -<span class="selector-tag">b</span> testbranch</span><br></pre></td></tr></table></figure>

<ul>
<li>删除一个分支</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-d testbranch</span><br></pre></td></tr></table></figure>

<ul>
<li>提交分支代码</li>
</ul>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">git push <span class="comment">--all</span></span><br></pre></td></tr></table></figure>

<ul>
<li>合并分支</li>
</ul>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">merge</span> testbranch</span><br></pre></td></tr></table></figure>

<h3 id="GIT冲突"><a href="#GIT冲突" class="headerlink" title="GIT冲突"></a>GIT冲突</h3><blockquote>
<p>常见git冲突造成，是由于在多个分支下，或多个仓库中，对同一个文件修改，或添加了新的文件之后</p>
<p>由于某一方对于文件的修改没有及时在另一方生效，当另一方或另一分支在进行提交时，即会出现冲突</p>
</blockquote>
<ul>
<li>在testbranch分支下，修改1.py文件，并提交到云仓库</li>
<li>在master分支下，也修改1.py文件，并尝试提交</li>
</ul>
<p><a href="https://lienze.tech/blog/images/1565915294853.png" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/1565915294853.png" alt="1565915294853"></a></p>
<ul>
<li>此时冲突出现，使用<code>git status</code>命令查看当前仓库状态</li>
</ul>
<p><a href="https://lienze.tech/blog/images/git冲突status.png" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/git%E5%86%B2%E7%AA%81status.png" alt="git冲突status"></a></p>
<ul>
<li>查看被修改的文件<code>1.py</code></li>
</ul>
<p><a href="https://lienze.tech/blog/images/git冲突文件.png" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/git%E5%86%B2%E7%AA%81%E6%96%87%E4%BB%B6.png" alt="git冲突文件"></a></p>
<ul>
<li><code>Git</code>用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，<code>&gt;&gt;&gt;&gt;&gt; testbranch</code>是指<code>fenzhi1</code>上修改的内容，我们可以将差异部分的标注删掉重新提交，或是与对方协商，另行拷贝文件内容，重新clone仓库，将拷贝过的内容添加至内</li>
<li>之后再进行提交</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> 1.pygit commit -m <span class="string">"conflict fixed"</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>这样就可以搞定了</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Cli</title>
    <url>/Vue-Cli/</url>
    <content><![CDATA[<h2 id="组件开发自动化工具"><a href="#组件开发自动化工具" class="headerlink" title="组件开发自动化工具"></a>组件开发自动化工具</h2><blockquote>
<p><code>Node.js</code>是一个新的后端(后台)语言，它的语法和<code>JavaScript</code>类似，所以可以说它是属于前端的后端语言</p>
</blockquote><blockquote>
<p><strong>运行环境：后端语言一般运行在服务器端，前端语言运行在客户端的浏览器上</strong></p>
<p><strong>功能：后端语言可以操作文件，可以读写数据库，前端语言不能操作文件，不能读写数据库。</strong></p>
</blockquote><a id="more"></a>

<ul>
<li><code>Node.js</code>如果安装成功，可以查看<code>Node.js</code>的版本,在终端输入如下命令</li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br><span class="line">npm</span><br></pre></td></tr></table></figure>

<ul>
<li>全局安装<code>vue</code>脚手架，<code>vue-cli</code>，这玩意儿可以自动生成项目模板</li>
</ul>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">vue-<span class="keyword">cli</span></span><br><span class="line">cnpm install --<span class="keyword">global</span> vue-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>

<h3 id="单页应用-SPWA"><a href="#单页应用-SPWA" class="headerlink" title="单页应用 SPWA"></a>单页应用 SPWA</h3><blockquote>
<p>单页<code>Web</code>应用（<strong>single page web application</strong>，<code>SPWA</code>），就是将系统所有的操作交互限定在一个<code>web</code>页面中。</p>
<p>单页应用程序 (<code>SPA</code>)是加载单个<code>HTML</code>页面，系统的不同功能通过加载不同功能组件的形式来切换，不同功能组件全部封装到了<code>js</code>文件中，这些文件在应用开始访问时就一起加载完；</p>
<p>整个系统在切换不同功能时，页面的地址是不变的，系统切换可以做到局部刷新，也可以叫做无刷新，这么做的目的是为了给用户提供更加流畅的用户体验</p>
</blockquote>
<ul>
<li>通过<code>vue-cli</code>脚手架开启一个项目：</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vue init webpack myproject</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">- Project name: 项目名称，如果不需要就直接回车。注：此处项目名不能使用大写。</span><br><span class="line">- Project description: 项目描述，直接回车</span><br><span class="line">- Author：作者</span><br><span class="line">- vue build: 构建方式 默认即可</span><br><span class="line">- <span class="keyword">install</span> vue-router? 是否安装vue的路由插件</span><br><span class="line"></span><br><span class="line">- <span class="keyword">Use</span> ESLint <span class="keyword">to</span> lint your code? 是否使用ESLint检测你的代码？</span><br><span class="line">	（ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。）</span><br><span class="line">	</span><br><span class="line">- Pick an ESLint preset:选择分支风格</span><br><span class="line">	<span class="number">1.</span>standard(https://github.com/feross/standard) js的标准风格</span><br><span class="line">	<span class="number">2.</span>Airbnb(https://github.com/airbnb/javascript) JavaScript最合理的方法，这个github	地址说是JavaScript最合理的方法</span><br><span class="line">	<span class="number">3.</span><span class="keyword">none</span> (configure it yourself) 自己配置</span><br><span class="line">	</span><br><span class="line">- Setup unit tests? 是否安装单元测试</span><br><span class="line">- Pick a <span class="keyword">test</span> runner 选择一个单元测试运行器</span><br><span class="line">	<span class="number">1.</span>Jest（Jest是由Facebook发布的开源的、基于Jasmine的JavaScript单元测试框架）</span><br><span class="line">	<span class="number">2.</span>Karma <span class="keyword">and</span> Mocha</span><br><span class="line">	<span class="number">3.</span><span class="keyword">none</span></span><br><span class="line">	</span><br><span class="line">- Setup e2e tests <span class="keyword">with</span> Nightwatch(Y/n)?是否安装E2E测试框架NightWatch</span><br><span class="line">	（E2E，也就是<span class="keyword">End</span> <span class="keyword">To</span> <span class="keyword">End</span>，就是所谓的“用户真实场景”。）</span><br><span class="line">	</span><br><span class="line">- Should we run <span class="string">'npm install'</span> <span class="keyword">for</span> you <span class="keyword">after</span> the <span class="keyword">project</span> has been created?</span><br><span class="line">项目创建后是否要为你运行“npm <span class="keyword">install</span>”?</span><br><span class="line">	yes,<span class="keyword">use</span> npm(使用npm)</span><br><span class="line">	yes,<span class="keyword">use</span> yarn(使用yarn)</span><br><span class="line">	<span class="keyword">no</span>,I will handle that myself(自己操作)</span><br></pre></td></tr></table></figure>

<ul>
<li>启动开发服务器：</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">cd myproject <span class="comment"># 进入目录</span></span><br><span class="line">cnpm install <span class="comment"># 安装依赖</span></span><br><span class="line">cnpm <span class="keyword">run</span><span class="bash"> dev <span class="comment"># 开启服务</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>vue</code>启动服务之后，是通过一个小型的<code>express</code>服务进行测试开发环境部署，在这个服务中，主要是通过<code>webpack-dev-middleware</code>和<code>webpack-hot-middleware</code>这两个中间件完成，并且会在每次代码对于<code>src</code>目录下的代码进行修改时，服务端会动态检测并让浏览器自动刷新</p>
</blockquote>
<ul>
<li>项目目录介绍</li>
</ul>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby"> src <span class="comment"># 主开发目录，所有的单文件组件都会放在这个目录下</span></span></span><br><span class="line"><span class="ruby">- static <span class="comment"># 项目静态目录，所有的css、js都会放在这个文件夹下</span></span></span><br><span class="line"><span class="ruby">- dist <span class="comment"># 项目打包发布文件夹，最后要上线单文件夹项目都在这个文件夹中</span></span></span><br><span class="line"><span class="ruby">- node_modules <span class="comment"># node的包目录</span></span></span><br><span class="line"><span class="ruby">- config <span class="comment"># 配置目录，主要用于区分开发环境，测试环境，线上环境的不同</span></span></span><br><span class="line"><span class="ruby">- build <span class="comment"># 项目打包时依赖的目录</span></span></span><br></pre></td></tr></table></figure>

<h3 id="组件开发"><a href="#组件开发" class="headerlink" title="组件开发"></a>组件开发</h3><blockquote>
<p>将一个组件相关的<code>html</code>结构，<code>css</code>样式，以及交互的<code>JavaScript</code>代码从<code>html</code>文件中剥离出来，合成一个文件，这种文件就是单文件组件，相当于一个组件具有了结构、表现和行为的完整功能，方便组件之间随意组合以及组件的重用，这种文件的扩展名为<code>.vue</code>，比如：<code>menu.vue</code></p>
<p>组件文件一般定义在<code>src</code>目录下的<code>components</code>文件夹里</p>
</blockquote>
<ul>
<li><code>template</code>标签定义<code>HTML</code>部分</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;teamplate&gt;</span><br><span class="line">    &lt;div class=&quot;&quot; @click=&quot;&quot;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">        	账号</span><br><span class="line">            &lt;input type=&quot;text&quot;&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/teamplate&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>js</code>写成模块导出的形式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用export default命令，为模块指定默认输出</span><br><span class="line">export default&#123;</span><br><span class="line">    data: function()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            name:&quot;张三&quot;,</span><br><span class="line">            age:16,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>样式中的编写，如果含有scope关键字，表示这些样式是组件局部的，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">.beauty&#123;</span><br><span class="line">    width:100px;</span><br><span class="line">    line-height:50px;</span><br><span class="line">    border-bottom:1px solid #ddd;</span><br><span class="line">    margin:0px auto;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><blockquote>
<p>当拥有一个组件文件时，要在项目的<code>src</code>目录下的<code>router</code>目录下的<code>index.js</code>文件下</p>
<p>进行组件的路由加载配置</p>
</blockquote>
<blockquote>
<p>在导入组件文件时，可以使用<code>@</code>符号，代表从<code>src</code>目录起</p>
<p>比如：<em>import</em> index <em>from</em> ‘@/components/index’</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Router from &apos;vue-router&apos;</span><br><span class="line">import HelloWorld from &apos;@/components/HelloWorld&apos;</span><br><span class="line">import first from &apos;@/components/first&apos; // 从组件目录下导入组件文件，不需要加后缀</span><br><span class="line">import index from &apos;@/components/index&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &apos;history&apos;,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      component: index,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/first&apos;, // 访问路径</span><br><span class="line">      component: first</span><br><span class="line">    &#125;</span><br><span class="line">  ]	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当配置好路由之后，需要在最主要的<code>App.Vue</code>文件下进行连接引入</p>
</blockquote>
<blockquote>
<p>通过<code>&lt;router-link to=&quot;连接地址&quot;&gt;首页&lt;/router-link&gt;</code>标签进行连接引入</p>
<p>通过<code>&lt;router-view&gt;&lt;/router-view&gt;</code>标签进行路由加载，可以简写为：<code>&lt;router-view/&gt;</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;</span><br><span class="line">    &lt;router-link to=&quot;/first&quot;&gt;第一个页面&lt;/router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>App.Vue</code>文件下的<code>template</code>标签处如果已经引入了其他跳转连接；</p>
<p>那么在子组件的<code>template</code>部分不需要在进行引入</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>编写<code>components</code>组件</li>
<li><code>index.js</code>配置路由</li>
<li>在主入口<code>App.vue</code>中加载路由组件<code>&lt;router-view/&gt;</code>，一般默认已经写好</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/Vue/</url>
    <content><![CDATA[<h2 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h2><blockquote>
<p><code>Vue.js</code>是前端三大新框架：<code>Angular.js</code>、<code>React.js</code>、<code>Vue.js</code>之一，<code>Vue.js</code>目前的使用和关注程度在三大框架中稍微胜出，并且它的热度还在递增</p>
<p><code>Vue</code>的核心库只关注视图层，<code>Vue</code>的目标是通过尽可能简单的<code>API</code>实现响应的数据绑定，在这一点上<code>Vue.js</code>类似于后台的模板语言</p>
<p><code>Vue</code>也可以将界面拆分成一个个的组件，通过组件来构建界面，然后用自动化工具来生成单页面(<code>SPA - single page application</code>)系统</p>
</blockquote><a id="more"></a>
<ul>
<li><code>Vue.js</code>官方文档： <a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a></li>
<li><code>vue.js</code>下载地址： <a href="https://cn.vuejs.org/v2/guide/installation.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/installation.html</a></li>
</ul>
<h3 id="npm配置cnpm"><a href="#npm配置cnpm" class="headerlink" title="npm配置cnpm"></a>npm配置cnpm</h3><ul>
<li><code>windows</code>下配置<code>cnmp</code>环境：</li>
</ul>
<blockquote>
<p>默认的使用<code>NPM</code>可能会因为网络问题而导致无法使用或延迟居高，可以使<code>npm</code>升级为<code>cnpm</code>，从国内淘宝镜像中加载所需的<code>npm</code>软件源</p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g cnpm --registry=https:<span class="regexp">//</span>registry.<span class="built_in">npm</span>.taobao.org</span><br></pre></td></tr></table></figure>

<ul>
<li>设置安装包缓存路径</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">cnpm<span class="built_in"> config </span><span class="builtin-name">set</span> cache <span class="string">"C:\nodejs\node_cache"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置安装包位置</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">cnpm<span class="built_in"> config </span><span class="builtin-name">set</span><span class="built_in"> prefix </span><span class="string">"C:\nodejs\node_global"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>之后使用命令安装的模块存储在<strong>C:\nodejs\node_global\node_modules</strong>里</p>
<p>请按照个人需求设置你的文件位置</p>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">npm<span class="built_in"> config </span><span class="builtin-name">set</span> cache <span class="string">"C:\nodejs\node_cache"</span></span><br></pre></td></tr></table></figure>

<h3 id="Vue部署"><a href="#Vue部署" class="headerlink" title="Vue部署"></a>Vue部署</h3><ul>
<li>安装<code>Vue</code></li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">cnpm <span class="keyword">install</span> vue -g</span><br></pre></td></tr></table></figure>

<ul>
<li>安装<code>vue</code>脚手架</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">cnpm install vue-<span class="keyword">cli</span> -g</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>-g</code>参数代表全局位置安装，这样可以在环境变量生效的情况下直接在命令行等工具下使用vue命令行进行项目的开启</p>
</blockquote>
<h3 id="vue-devtools调试工具"><a href="#vue-devtools调试工具" class="headerlink" title="vue-devtools调试工具"></a>vue-devtools调试工具</h3><blockquote>
<p><code>vue-devtools</code>可以方便开发者进行<code>Vue</code>中变量等信息的调试跟踪</p>
</blockquote>
<ul>
<li>下载<code>vue-devtools</code></li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/vuejs/vue-devtools</span><br></pre></td></tr></table></figure>

<ul>
<li>进入到<code>vue-devtools</code>目录下安装依赖包</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">cd</span> <span class="string">vue-devtools-dev</span></span><br><span class="line"><span class="attr">cnpm</span> <span class="string">install </span></span><br><span class="line"><span class="attr">cnpm</span> <span class="string">run build</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意：在进行调试工具安装时，首先需要修改<code>shells&gt;chrome</code>文件夹下的<code>mainifest.json</code>中的persistent为true</li>
<li>将插件目录下的<code>chrome</code>文件夹拖入到<code>chrome</code>浏览器的扩展程序下，记得打开调试模式</li>
</ul>
<blockquote>
<p>扩展程序可以通过浏览器访问</p>
</blockquote>
<p><a href="https://lienze.tech/blog/images/1561789924.png" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/1561789924.png" alt="1561789924"></a></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">chrome:</span><span class="comment">//extensions/</span></span><br></pre></td></tr></table></figure>

<h3 id="Vue-CDN"><a href="#Vue-CDN" class="headerlink" title="Vue-CDN"></a>Vue-CDN</h3><blockquote>
<p>除去通过<code>npm</code>安装的方式来使用<code>vue</code>，还可以直接使用<code>cdn</code>中的<code>vue.js</code>文件</p>
</blockquote>
<ul>
<li>vue.js：开发版本，包含了有帮助的命令行警告</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>vue.min.js：生产环境版本，优化了尺寸和速度</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Vue语法"><a href="#Vue语法" class="headerlink" title="Vue语法"></a>Vue语法</h3><blockquote>
<p>每个<code>vue</code>应用都是通过实例化一个新的<code>vue</code>对象开始的</p>
</blockquote>
<ul>
<li>创建第一个模板语法：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="comment">&lt;!-- 这个也叫做插值表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123; // vm这个变量不允许使用连字符，可以使用下划线，比如vm-data是不允许的</span><br><span class="line">    el: &quot;#content&quot;, </span><br><span class="line">    // 对应document中的一个标签，当vue对象创建后，这个标签内的区域就被接管</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &quot;这是vue里的变量&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>当一个<code>vue</code>实例被创建时，<code>vue</code>的响应式系统中加入了对其<code>data</code>对象中能找到的所有属性</li>
<li>当这些属性值被改变时，视图也会发生<strong>相应</strong>，并将对应属性更新为新的值</li>
<li>也可以通过定义函数来改变实例中<code>data</code>对象中的数据，数据改变，视图中的数据也将改变</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;ChangeMsg&quot;&gt;改变&lt;/button&gt;</span><br><span class="line">    &lt;!-- 绑定点击事件为定义好的vue函数 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &quot;我对应的是message的变量&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123; // 定义一个函数 并绑定在按钮的点击事件上</span><br><span class="line">            ChangeMsg:function()&#123;</span><br><span class="line">                this.message = &quot;我被改变了&quot;;</span><br><span class="line">                // 修改当前实例中的message变量</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的代码，将在点击按钮时，使当前的<code>message</code>变量发生变化</p>
<p>``这样的语法有点类似一些<code>Web</code>框架，比如<code>django</code>的模板语言中的模板变量</p>
</blockquote>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><blockquote>
<p>除了直接定义某个变量的固定值进行页面渲染，模板变量还支持通过函数的返回值进行赋值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; classType &#125;&#125;学习&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123; describe() &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;, // getElementById(&apos;app&apos;)</span><br><span class="line">        data: &#123;</span><br><span class="line">            classType: &quot;vue&quot;,</span><br><span class="line">            content: &quot;这是vue的一个测试&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            describe:function()&#123;</span><br><span class="line">                return &quot;这是一个函数的返回值&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Vue模板指令"><a href="#Vue模板指令" class="headerlink" title="Vue模板指令"></a>Vue模板指令</h3><ul>
<li>模板语法指的是如何将数据放入html中</li>
</ul>
<blockquote>
<p><strong>Vue.js使用了基于HTML的模板语法，允许开发者声明式地将DOM绑定至底层 Vue 实例的数据</strong></p>
<p><strong>所有 Vue.js的模板都是合法的 HTML ，所以能被遵循规范的浏览器和HTML 解析器解析</strong></p>
</blockquote>
<ul>
<li>插入值，模板变量</li>
</ul>
<blockquote>
<p>数据绑定最常见的形式就是使用<code>Mustache</code>语法(双大括号) 的文本插值，也就是上面示例中的``</p>
</blockquote>
<h4 id="内容绑定"><a href="#内容绑定" class="headerlink" title="内容绑定"></a>内容绑定</h4><h5 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h5><blockquote>
<p>将内容按照<code>html</code>格式进行插入</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p v-html=&quot;contetn&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      content: &quot;&lt;b&gt;段落标签&lt;/b&gt;文本内容&quot;  </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在网站上动态渲染任意<code>HTML</code>是非常危险的，因为容易导致<code>XSS</code>攻击</p>
<p><code>v-html</code>一般只用在可信内容中，<strong>永不</strong>用在用户提交的内容上</p>
</blockquote>
<h5 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h5><blockquote>
<p>将内容按照文本格式进行插入，但会覆盖原有标签内的内容，不会有加载的闪烁问题</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p v-text=&quot;contetn&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">       	&#123;&#123; gender ? &apos;男&apos; : &apos;女&apos; &#125;&#125;</span><br><span class="line">        &lt;!-- ok? true:false --&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">	</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      	gender: true, // 变量值为true时，显示模板变量中左边的值</span><br><span class="line">      	content: &quot;&lt;b&gt;段落标签&lt;/b&gt;文本内容&quot;  </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h5><blockquote>
<p>解决使用差值表达式时页面渲染过程，由于变量没有初始化而导致的闪烁问题</p>
</blockquote>
<blockquote>
<p>通俗的来说，比如<code>变量的实际内容没有被创建，那么此时页面只会展示出</code>这样的效果，之后当变量初始化之后，``将变化为实际的值，此时变化的过程我们称作闪烁</p>
</blockquote>
<blockquote>
<p>这个指令可以隐藏未编译的标签直到实例准备完毕</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            message: &quot;测试&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在上面的代码中，如果网速够慢的清空下，页面首先加载显示出的内容是``</li>
<li><strong>解决办法</strong>：通过<code>v-clock</code>指令，在使用到模板变量的标签上写入，并设置一个<code>v-clock</code>的类样式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    [v-cloak]&#123;</span><br><span class="line">        display: none;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-cloak id=&quot;app&quot;&gt;</span><br><span class="line">	&lt;p v-cloak&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h4><h5 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h5><blockquote>
<p>如果我们需要设置的模板变量是一个属性，比如<code>a</code>标签的<code>href</code>属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;a v-bind:href=&quot;message&quot;&gt;连接&lt;/a&gt;</span><br><span class="line">    &lt;a :href=&quot;message +&apos;abc&apos;&quot;&gt;连接&lt;/a&gt;</span><br><span class="line">    &lt;!-- 属性内的模板变量写法已被移除，使用v-bind:attr 或 :attr --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">    	message: &quot;https://www.baidu.com&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以通过<code>v-bind</code>指令或者<code>:</code>的简写对某个<code>dom</code>元素的属性进行绑定</p>
<p>在下面还有更加详细的属性绑定示例</p>
</blockquote>
<h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><h5 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h5><blockquote>
<p>给元素绑定对应事件，以下是对于点击事件的绑定</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;show&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;show&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">	el: &quot;#app&quot;,</span><br><span class="line">    method: &#123;</span><br><span class="line">    	show: function()&#123;</span><br><span class="line">			alert(&quot;弹一下&quot;)</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="跑马灯效果"><a href="#跑马灯效果" class="headerlink" title="跑马灯效果"></a>跑马灯效果</h4><blockquote>
<p>这里有一个跑马灯效果可以玩耍</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;button @click=&quot;start&quot;&gt;开始&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;stop&quot;&gt;停止&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &quot;这是一个跑马灯&quot;,</span><br><span class="line">        sT: null, // 定时器实例</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        work()&#123;</span><br><span class="line">            this.message = this.message.substring(1) + this.message[0] </span><br><span class="line">            // 循环定时器所作的事情</span><br><span class="line">        &#125;,</span><br><span class="line">        start()&#123;</span><br><span class="line">            if (this.sT==null) &#123; // 判断此时是否已有定时器开启</span><br><span class="line">                console.log(&quot;开启定时器&quot;)</span><br><span class="line">                this.sT = setInterval(this.work,400)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                console.log(&quot;已经开启 不在开启&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        stop()&#123; // 关闭定时器 设置定时器变量为null</span><br><span class="line">            console.log(&quot;关闭定时器&quot;)</span><br><span class="line">            clearInterval(this.sT)</span><br><span class="line">            this.sT = null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="绑定事件修饰符"><a href="#绑定事件修饰符" class="headerlink" title="绑定事件修饰符"></a>绑定事件修饰符</h4><h5 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h5><blockquote>
<p>比如一个按钮在一个<code>div</code>中，并且按钮和<code>div</code>均有自己的事件，那么此时点击按钮，事件会像冒泡一样从按钮开始一直到<code>div</code>进行触发，<code>.stop</code>修饰符用来阻止默认的事件触发行为</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;fDiv&quot; @click=&quot;divClick&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;fBtn&quot; @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#fDiv&quot;, // 控制区域</span><br><span class="line">            data: &#123;&#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                divClick()&#123;</span><br><span class="line">                    console.log(&quot;div被点击了&quot;)</span><br><span class="line">                &#125;,</span><br><span class="line">                btnClick()&#123;</span><br><span class="line">                    console.log(&quot;按钮被点击了&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>.stop</code>修饰阻止冒泡</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;fDiv&quot; @click=&quot;divClick&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;fBtn&quot; @click.stop=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h5 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h5><blockquote>
<p>比如像<code>a</code>标签这样的，在点击时他有默认的跳转动作，可以通过<code>.prevent</code>阻止该默认行为</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;fDiv&quot;&gt;</span><br><span class="line">	&lt;a href=&quot;https://www.baidu.com&quot; @click.prevent=&quot;aLink&quot;&gt;去百度&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm = new Vue()&#123;</span><br><span class="line">    el: &quot;#fDiv&quot;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">    	aLink()&#123;</span><br><span class="line">    		console.log(&quot;连接被点击&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="捕获事件"><a href="#捕获事件" class="headerlink" title="捕获事件"></a>捕获事件</h5><blockquote>
<p>默认的事件触发处理机制是冒泡机制，capture代表具有该修饰的事件，会优先触发，脱离冒泡顺序；</p>
<p>也可理解为谁有该修饰符，先触发谁的事件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;fDiv&quot; @click.capture=&quot;divClick&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;fBtn&quot; @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &quot;#fDiv&quot;, // 控制区域</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            divClick()&#123;</span><br><span class="line">                console.log(&quot;div被点击了&quot;)</span><br><span class="line">            &#125;,</span><br><span class="line">            btnClick()&#123;</span><br><span class="line">                console.log(&quot;按钮被点击了&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="自身事件"><a href="#自身事件" class="headerlink" title="自身事件"></a>自身事件</h5><blockquote>
<p>与<code>capture</code>和冒泡不同，<code>.self</code>只有是自身触发的当前的事件才真正执行处理的回调函数</p>
<p>并且<code>.self</code>只会阻止当前元素的事件触发行为</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;fDiv&quot; @click.self=&quot;divClick&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;fBtn&quot; @click.self=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与上同</span></span><br></pre></td></tr></table></figure>

<h5 id="单次事件"><a href="#单次事件" class="headerlink" title="单次事件"></a>单次事件</h5><blockquote>
<p>使用<code>.once</code>只触发一次事件函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;fDiv&quot;&gt;</span><br><span class="line">    &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent.once=&quot;aLink&quot;&gt;去百度&lt;/a&gt;</span><br><span class="line">    &lt;!-- 连接无法跳转的阻止事件 只会出现一次 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm = new Vue()&#123;</span><br><span class="line">    el: &quot;#fDiv&quot;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">    	aLink()&#123;</span><br><span class="line">    		console.log(&quot;连接被点击&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="表单双向绑定"><a href="#表单双向绑定" class="headerlink" title="表单双向绑定"></a>表单双向绑定</h3><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><blockquote>
<p>使用v-model指令可以在表单<code>input</code>、<code>textarea</code>以及<code>select</code>元素上创建双向数据绑定</p>
<p>根据表单上的值，自动更新模板变量中的值</p>
</blockquote>
<blockquote>
<p><code>v-model</code>会忽略表单的初始值，比如：<code>checked</code>、<code>value</code>、<code>selected</code>，如果需要的话，应该在<code>javascript</code>中首先声明初始值</p>
</blockquote>
<h5 id="text"><a href="#text" class="headerlink" title="text"></a><strong>text</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &quot;这是个表单内容&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a><strong>textarea</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;textarea v-model=&quot;message&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同上</span></span><br></pre></td></tr></table></figure>

<h5 id="checkbox"><a href="#checkbox" class="headerlink" title="checkbox"></a><strong>checkbox</strong></h5><ul>
<li><strong>单个复选框</strong>：数据为绑定为<code>true</code>和<code>false</code>的布尔值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;checked&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                checked: true,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>多个复选框</strong>：选中的结果会绑定到同一个数组，将保存的<code>v-model</code>变量创建为数组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;checked&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input name=&quot;fruit&quot; type=&quot;checkbox&quot; value=&quot;apple&quot;  v-model=&quot;checked&quot;&gt;苹果</span><br><span class="line">    &lt;input name=&quot;fruit&quot; type=&quot;checkbox&quot; value=&quot;banana&quot; v-model=&quot;checked&quot;&gt;香蕉</span><br><span class="line">    &lt;input name=&quot;fruit&quot; type=&quot;checkbox&quot; value=&quot;orange&quot; v-model=&quot;checked&quot;&gt;橘子</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                checked: new Array,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="radio"><a href="#radio" class="headerlink" title="radio"></a><strong>radio</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;picked&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;junior&quot; v-model=&quot;picked&quot;&gt;男</span><br><span class="line">    &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;girl&quot; v-model=&quot;picked&quot;&gt;女</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                picked: &quot;哈哈哈哈&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="select"><a href="#select" class="headerlink" title="select"></a><strong>select</strong></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;selected&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;select v-model=&quot;selected&quot;&gt;</span><br><span class="line">        &lt;option disabled value=&quot;&quot;&gt;你想去哪&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;山西&quot;&gt;山西&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                selected: &quot;&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="selects"><a href="#selects" class="headerlink" title="selects"></a><strong>selects</strong></h5><blockquote>
<p>设置<code>select</code>标签的<code>multiple</code>属性即可设置为多选下拉菜单，按着<code>ctrl</code>键可以多选</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;selecteds&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;select multiple v-model=&quot;selecteds&quot;&gt;</span><br><span class="line">        &lt;option value=&quot;上衣&quot;&gt;上衣&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;裤子&quot;&gt;裤子&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;鞋&quot;&gt;鞋&lt;/option&gt;  </span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                selecteds: new Array, // 多重数据一般都要保存成数组</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><h5 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h5><blockquote>
<p>默认情况下，<code>v-model</code>在<code>input</code>和<code>textarea</code>表单中进行同步输入框的改动</p>
<p>添加了<code>.lazy</code>修饰符之后，对应的<code>v-model</code>绑定事件触发机制将变为<code>change</code>事件，只有在光标失去焦点时会触发</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model.lazy=&quot;message&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &quot;这是个表单内容&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h5><blockquote>
<p>如果用户希望将输入表单的内容处理为<code>Number</code>类型，可以使用<code>.number</code>给<code>v-model</code>进行修饰；如果表单字符串无法被处理为数字，则返回原始的值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;typeof message&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model.number=&quot;message&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h5 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h5><blockquote>
<p>使用<code>.trim</code>可以自动过滤输入框的首尾空格</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model.trim=&quot;message&quot;&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br><span class="line">    &lt;!-- 通过查看另一个表单中同步的缩进 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><blockquote>
<p>当某些情况下，无法确定表单中所代表的属性值，可以使用<code>v-bind</code>进行动态绑定，<code>v-model</code>获取到的表单输入此时则是我们定义的<code>v-bind</code>属性值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;radio&quot; v-model=&quot;message&quot; :value=&quot;choiceA&quot;&gt; A</span><br><span class="line">    &lt;input type=&quot;radio&quot; v-model=&quot;message&quot; :value=&quot;choiceB&quot;&gt; B</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &quot;&quot;, // 表单绑定变量</span><br><span class="line">                choiceA: &quot;Yes!&quot;, // 属性绑定变量，未来不需要修改标签中的value值即可动态修改</span><br><span class="line">                choiceB: &quot;No!&quot;,</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><ul>
<li>关键词：<code>computed</code></li>
</ul>
<blockquote>
<p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的</p>
<p>在模板中放入太多的逻辑会让模板过重且难以维护</p>
<p>也就是说，某些时候页面中的模板变量如果需要复杂的运算处理，应该使用<strong>计算属性</strong>，而不是直接在模板位置进行计算。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">            var vm = new Vue(&#123;</span><br><span class="line">                el: &quot;#container&quot;,</span><br><span class="line">                data: &#123;</span><br><span class="line">                    String1:&quot;这是一个字符串&quot;,</span><br><span class="line">                &#125;,</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    MreverseString()&#123;</span><br><span class="line">                        return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;)</span><br><span class="line">                    &#125; // 定义一个函数进行字符串逆置</span><br><span class="line">                &#125;,</span><br><span class="line">                computed: &#123;</span><br><span class="line">                    CreverseString()&#123;</span><br><span class="line">                        return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;)</span><br><span class="line">                    &#125; // 定义一个计算属性进行字符串逆置</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-cloak id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p&gt;这是一个字符串:&#123;&#123; String1 &#125;&#125; &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;他的逆置:&#123;&#123; String1.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125;&#125; &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;他的逆置:&#123;&#123; CreverseString &#125;&#125; &lt;/p&gt;</span><br><span class="line">    &lt;!-- 计算属性直接写入函数名 --&gt;</span><br><span class="line">    &lt;p&gt;他的逆置:&#123;&#123; MreverseString() &#125;&#125; &lt;/p&gt;</span><br><span class="line">    &lt;!-- 普通methods函数调用需加括号 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：虽然计算属性和函数都可以达成同样的目的，但是<code>computed</code>会缓存结果，计算属性如果发现依赖的属性<code>message</code>未发生改变，再次访问计算属性不会重复运算函数，而是直接利用已有结果；如果依赖数据发生改动，计算属性函数才会重新运算。</li>
<li>在函数及计算属性中添加日志输出即可看到这个效果：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    MreverseString() &#123;</span><br><span class="line">        console.log(&quot;MreverseString被运算了&quot;)</span><br><span class="line">        return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">	CreverseString() &#123;</span><br><span class="line">		console.log(&quot;CreverseString被运算了&quot;)</span><br><span class="line">		return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在终端下进行计算属性以及函数的访问即可看到效果。</li>
</ul>
<h4 id="计算属性SetAttr"><a href="#计算属性SetAttr" class="headerlink" title="计算属性SetAttr"></a>计算属性SetAttr</h4><blockquote>
<p>默认的计算属性只有获取<code>getattr</code>的方式，我们可以手动为他添加一个<code>setter</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    CreverseString: &#123;</span><br><span class="line">        get: function()&#123;</span><br><span class="line">            return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        set: function(val)&#123;</span><br><span class="line">            this.String1 = val.split(&quot;&quot;).reverse().join(&quot;&quot;)</span><br><span class="line">            // 如果当前的逆置之后字符串为val，那么原本的字符串需要再颠倒一次</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="侦听属性"><a href="#侦听属性" class="headerlink" title="侦听属性"></a>侦听属性</h3><blockquote>
<p>侦听属性的作用是侦听某些属性的变化，从而做相应的操作，进行对数据变化的相应，</p>
<p>侦听属性是一个对象（字典），<code>key</code>值是要监听的元素，值是当监听的元素发生改变时要执行的函数；</p>
<p>监听函数有两个参数，一个是当前值，另一个是变化后的值</p>
</blockquote>
<ul>
<li>比如监听一个变量的变化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                content: &quot;&quot;, // 表单内容</span><br><span class="line">                count: 0, // 记录表单内用户敲了多少次</span><br><span class="line">            &#125;,</span><br><span class="line">            watch:&#123;</span><br><span class="line">                content:function (oldVal,newVal)&#123;</span><br><span class="line">                    // 只要在文本框输入内容影响到了age数据发生改变，就会触发</span><br><span class="line">                    this.count += 1</span><br><span class="line">                &#125;，</span><br><span class="line">            &#125;，</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p&gt;&lt;label&gt;你敲了:&#123;&#123; count &#125;&#125;次&lt;/label&gt;&lt;/p&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; placeholder=&quot;请输入你的年纪&quot; v-model=&quot;content&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="属性绑定-1"><a href="#属性绑定-1" class="headerlink" title="属性绑定"></a>属性绑定</h3><blockquote>
<p>使用<code>v-bind:class</code>指令来设置元素的class属性；</p>
<p>属性表达式的类型可以是字符串、对象或数组</p>
</blockquote>
<h4 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h4><blockquote>
<p>可以通过为元素绑定一个数组，用来为元素设置单个或多个样式，类名在数组中用单引号</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    .fontBold &#123;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">    &#125;</span><br><span class="line">    .fontRed &#123;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p :class=&quot;[&apos;fontBold&apos;,&apos;fontRed&apos;]&quot;&gt;这是一个段落&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h4><blockquote>
<p>可以通过为元素绑定一个对象，对象的key是样式类，对象的value是true或false来动态切换class</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                flag: true,</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                toggle() &#123;</span><br><span class="line">                    if (this.flag)&#123; // 判断当前toggle变量的属性，对称变换</span><br><span class="line">                        this.flag = false</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        this.flag = true</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p :class=&quot;&#123;fontBold: flag&#125;&quot; @click=&quot;toggle&quot;&gt;这是一个段落&lt;/p&gt;</span><br><span class="line">    &lt;p :class=&quot;&#123;flag? fontBold:&apos;&apos;&#125;&quot; @click=&quot;toggle&quot;&gt;这是一个段落&lt;/p&gt;</span><br><span class="line">    &lt;!-- 三元表达式 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="样式绑定"><a href="#样式绑定" class="headerlink" title="样式绑定"></a>样式绑定</h3><blockquote>
<p>使用<code>v-bind:style</code>语法，为元素绑定样式</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:style</span>=<span class="string">"&#123;color:'red','font-weight':'bold'&#125;"</span>&gt;</span></span><br><span class="line">    一段文字</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>也可以在<code>vue</code>的<code>data</code>中定义一个对象，用来描述样式，其中带有连字符的样式属性要加引号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p :style=&quot;styleObj&quot;&gt;一段文字&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">	styleObj: &#123;</span><br><span class="line">		color:&apos;red&apos;,</span><br><span class="line">		&apos;font-weight&apos;:&apos;bold&apos;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li><code>data</code>中的对象也可以通过数组类型绑定到元素上</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p :style=&quot;[styleObj1,styleObj2]&quot;&gt;一段文字&lt;/p&gt;</span><br><span class="line">    &lt;!-- 对于js的样式绑定不需要加引号，因为就是一个变量 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">styleObj1: &#123;</span><br><span class="line">    border: &apos;1px solid gray&apos;,</span><br><span class="line">    width: &apos;100px&apos;,</span><br><span class="line">&#125;,</span><br><span class="line">styleObj2:&#123;</span><br><span class="line">    background: &apos;black&apos;,</span><br><span class="line">    color: &apos;blue&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><blockquote>
<p>通过条件指令可以控制元素的显示及隐藏，或者说叫做创建和销毁</p>
</blockquote>
<h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><blockquote>
<p><code>v-if</code>指令用于条件性的渲染一块内容。这块内容只会在指令的表达式返回<code>truthy</code>值的时候渲染</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-cloak id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-if=&quot;oh3&quot;&gt;h3标题&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p v-if=&quot;gender === &apos;girl&apos;&quot;&gt;你是女的&lt;/p&gt;</span><br><span class="line">    &lt;p v-else-if=&quot;gender === &apos;boy&apos;&quot;&gt;你是男的&lt;/p&gt;</span><br><span class="line">    &lt;p v-else&gt;不男不女&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                oh3:&quot;a&quot;,</span><br><span class="line">                gender: &apos;other&apos;</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>truthy</code>和<code>ture</code>的区别：</li>
<li>隐含有<code>true</code>属性的变量不可以认为它是<code>true</code>，它不是<code>boolean</code>类型</li>
</ul>
<h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><blockquote>
<p>与<code>v-if</code>不同的是，<code>v-show</code> 的元素始终会被渲染并保留在<code>DOM</code>中</p>
<p><code>v-show</code> 只是简单地切换元素的<code>CSS</code>属性 <code>display</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-cloak id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-if=&quot;oh3&quot;&gt;h3标题&lt;/h3&gt;</span><br><span class="line">    &lt;h4 v-show=&quot;oh4&quot;&gt;h4标题&lt;/h4&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                oh3:&quot;1&quot;, // v-if 在该变量不为真时直接消失在document中</span><br><span class="line">                oh4:&quot;1&quot;, // v-show 处理不为真的变量条件 绑定元素不会消失</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h4><blockquote>
<p>把一个数组对应为一组元素</p>
<p>用 <code>v-for</code> 指令根据一组数组的选项列表进行渲染</p>
</blockquote>
<blockquote>
<p><code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，<code>items</code> 是源数据数组并且 <code>item</code> 是数组元素迭代的别名</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ol id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;li v-for=&quot;user in users&quot;&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; user.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                users: [</span><br><span class="line">                    &#123;name:&quot;张三&quot;,age:18&#125;,</span><br><span class="line">                    &#123;name:&quot;李四&quot;,age:20&#125;,</span><br><span class="line">                    &#123;name:&quot;王五&quot;,age:19&#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>v-for还可以支持将当前循环索引作为渲染时的第二个参数，第二个参数为访问索引位置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p  v-for=&quot;(user,index) in users&quot;&gt;</span><br><span class="line">    &#123;&#123; index &#125;&#125;:&#123;&#123; user.age &#125;&#125;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">    users: [</span><br><span class="line">        &#123;name:&quot;张三&quot;,age:18&#125;,</span><br><span class="line">        &#123;name:&quot;李四&quot;,age:20&#125;,</span><br><span class="line">        &#123;name:&quot;王五&quot;,age:19&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>v-for</code>迭代访问一个对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p v-for=&quot;key in myself&quot;&gt; </span><br><span class="line">    &#123;&#123; key &#125;&#125;</span><br><span class="line">    &lt;!-- 当v-for渲染时只有一个参数，此时参数为value值 --&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myself : &#123;</span><br><span class="line">    name:&quot;赵六&quot;,</span><br><span class="line">    age:&quot;17&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>v-for</code>支持最多三个参数，同时获取遍历对象的<code>key</code>和<code>value</code>值，以及<code>index</code>索引位置</li>
</ul>
<blockquote>
<p>要注意的是，此时的<code>key</code>和<code>value</code>和<code>python</code>中的顺序是颠倒的，<code>key</code>在后，<code>value</code>在前</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p v-for=&quot;(value,key,index) in myself&quot;&gt;</span><br><span class="line">    &#123;&#123; index &#125;&#125;: &#123;&#123; key &#125;&#125; - &#123;&#123; value &#125;&#125;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myself : &#123;</span><br><span class="line">    name:&quot;孙七&quot;,</span><br><span class="line">    age:&quot;17&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>v-for</code>进行一段取值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p v-for=&quot;n in 8&quot;&gt;</span><br><span class="line">        &#123;&#123; n &#125;&#125;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;!-- 1 2 3 4 5 6 7 8 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="选项卡练习"><a href="#选项卡练习" class="headerlink" title="选项卡练习"></a>选项卡练习</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                choicId: null,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    li&#123;</span><br><span class="line">        list-style-type: none;</span><br><span class="line">        border: 3px outset lightgreen;</span><br><span class="line">        width: 100px;</span><br><span class="line">        background:lightblue;</span><br><span class="line">        margin:5px;</span><br><span class="line">    &#125;</span><br><span class="line">    li:hover&#123;</span><br><span class="line">        border: 3px inset gray;</span><br><span class="line">        cursor: pointer;</span><br><span class="line">    &#125;</span><br><span class="line">    [v-cloak]&#123;</span><br><span class="line">        display: none;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-cloak id=&quot;container&quot;&gt;   </span><br><span class="line">    &lt;ol list&gt;</span><br><span class="line">        &lt;li @click=&quot;choicId = 1&quot;&gt;A&lt;/li&gt;</span><br><span class="line">        &lt;li @click=&quot;choicId = 2&quot;&gt;B&lt;/li&gt;</span><br><span class="line">        &lt;li @click=&quot;choicId = 3&quot;&gt;C&lt;/li&gt;</span><br><span class="line">        &lt;li @click=&quot;choicId = 4&quot;&gt;D&lt;/li&gt;</span><br><span class="line">    &lt;/ol&gt;</span><br><span class="line">    &lt;p v-show=&quot;choicId == 1&quot;&gt;aaaaaaaaaa&lt;/p&gt;</span><br><span class="line">    &lt;p v-show=&quot;choicId == 2&quot;&gt;bbbbbbbbbb&lt;/p&gt;</span><br><span class="line">    &lt;p v-show=&quot;choicId == 3&quot;&gt;cccccccccc&lt;/p&gt;</span><br><span class="line">    &lt;p v-show=&quot;choicId == 4&quot;&gt;dddddddddd&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>js</code>中两个等号和三个等号的区别：</li>
</ul>
<blockquote>
<p><code>==</code>表示： 如果两边值的类型不同的时候，是要先先进行类型转换后，才能做比较；<code>equality</code>等同</p>
</blockquote>
<blockquote>
<p><code>===</code>表示：不需要做类型转换，如果两边值的类型不同，就表示一定是不等的<code>identity</code>恒等</p>
</blockquote>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p><code>Vue</code>无法检测到对于数组的索引设置及长度修改以及对于对象属性的删除或添加</p>
<p>但是可以通过以下方式进行属性添加触发状态更新</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.set($vm.Object,&quot;key&quot;,&quot;val&quot;) // 对于对象 这样的添加方式可以触发状态更新</span><br><span class="line">Vue.set($vm.Array, index, newVal) // 对于数组 添加元素 触发状态更新</span><br><span class="line">// vm.items.splice(newLength) // 设置数组长度</span><br></pre></td></tr></table></figure>

<ul>
<li><code>javascript.splice(where, num, [additem1,additem2...] )</code>：删除或添加元素</li>
</ul>
<blockquote>
<p>此外，当<code>v-for</code>与<code>v-if</code>同时使用时，<code>v-for</code>有更高的优先级，这会造成重复遍历得到的元素都要在做一次<code>v-if</code>的判断，如果我们是为了有目的判断当前是否需要渲染这个元素，或是跳过这个循环，可以将<code>v-if</code>放在外层元素，比如<code>template</code>标签中，(<code>template</code>标签无实际意义，默认不展示，但是可以起到包裹作用)</p>
</blockquote>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><blockquote>
<p><code>Vue.js</code>允许你自定义过滤器，可被用于一些常见的文本，对它们进行格式化</p>
</blockquote>
<blockquote>
<p>过滤器可以用在两个地方：<strong>双花括号插值和 v-bind 表达式</strong> (后者从 2.1.0+ 开始支持)</p>
<p>过滤器应该被添加在<code>JavaScript</code>表达式的尾部，由<code>管道</code>符号指示</p>
</blockquote>
<ul>
<li>语法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    &#123;&#123; message | filter &#125;&#125;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p v-bind:type=&quot;message | filter&quot;&gt; &lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>过滤器本质上是一个函数，比如我们定义一个将表单输入的内容中所有的字母变大写的过滤器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div v-cloak id=&quot;container&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br><span class="line">        &lt;p&gt;展示: &#123;&#123; message | toUpper &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &quot;&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">            filters: &#123;</span><br><span class="line">                toUpper: function (value) &#123;</span><br><span class="line">                    if (!value) return &apos;&apos; // 字符串内容为空 直接返回</span><br><span class="line">                    console.log(&quot;正在变大小&quot;)</span><br><span class="line">                    return String(value).toUpperCase()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>过滤器函数也可以有多个参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; message | filter(arg1, arg2) &#125;&#125;</span><br><span class="line">// message 第一个参数</span><br><span class="line">// arg1 第二个参数</span><br><span class="line">// arg2 第三个参数</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-cloak id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br><span class="line">    &lt;p&gt;展示: &#123;&#123; message | toLong(&quot;| &quot;,&quot; |&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">    toLong(value,arg1,arg2)&#123;</span><br><span class="line">        if (!value) return &apos;&apos;</span><br><span class="line">        return arg1 + value + arg2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Vue实例生命周期"><a href="#Vue实例生命周期" class="headerlink" title="Vue实例生命周期"></a>Vue实例生命周期</h3><blockquote>
<p>每个<code>Vue</code>实例在被创建时都要经过一系列的初始化过程</p>
<p>例如：需要设置数据监听、编译模板、将实例挂载到<code>DOM</code>并在数据变化时更新<code>DOM</code>等</p>
<p>同时在这个过程中会自动运行一些叫做生命周期钩子的函数，我们可以使用这些函数，在实例的不同阶段加上我们需要的代码，实现特定的功能</p>
</blockquote>
<ul>
<li><code>beforeCreate</code>：数据还没有监听，没有绑定到<code>vue</code>对象实例，同时也没有挂载对象</li>
<li><code>created</code>：数据已经绑定到了对象实例，但是还没有挂载对象</li>
<li><code>beforeMount</code>：模板已经编译好了，根据数据和模板已经生成了对应的元素对象，将数据对象关联到了对象的<code>$el</code>属性</li>
</ul>
<blockquote>
<p><code>$el</code>属性是一个<code>HTMLElement</code>对象，也就是这个阶段，<code>vue</code>实例通过原生的<code>createElement</code>等方法来创建这个<code>html</code>片段，准备注入到我们<code>vue</code>实例指明的<code>el</code>属性所对应的挂载点</p>
</blockquote>
<ul>
<li><code>mounted</code>： 将<code>$el</code>的内容挂载到了<code>el</code>，相当于我们在<code>jQuery</code>执行了<code>$(el).html($el)</code>，生成页面上真正的<code>dom</code></li>
</ul>
<blockquote>
<p>上面我们就会发现页面的元素和我们<code>$el</code>的元素是一致的；在此之后，我们能够用方法来获取到<code>el</code>元素下的<code>dom</code>对象，并进行各种操作</p>
</blockquote>
<ul>
<li><code>beforeUpdate</code>：数据发生变化时调用</li>
<li><code>updated</code>：由于数据更改导致的虚拟<code>DOM</code>重新渲染和打补丁，在这之后会调用该钩子</li>
<li><code>beforeDestroy</code>：<code>Vue</code>实例销毁前</li>
<li><code>destroyed</code>：<code>Vue</code>实例销毁后</li>
</ul>
<blockquote>
<p><code>window.$vm.$destroy()</code></p>
</blockquote>
<ul>
<li>一大段代码进行钩子函数的调用过程监控</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">    function showData(process, vm) &#123;</span><br><span class="line">        console.log(process)</span><br><span class="line">        console.log(&quot;vue数据:&quot;, vm.message) // 当前Vue中的数据</span><br><span class="line">        console.log(&quot;Vue挂载el:&quot;) // Vue接管的元素</span><br><span class="line">        console.log(vm.$el) </span><br><span class="line">        console.log(&quot;真实Dom:&quot;)</span><br><span class="line">        console.log(document.getElementById(&quot;container&quot;).innerHTML)</span><br><span class="line">        console.log(&apos;-----------------&apos;)</span><br><span class="line">    &#125; // 这个函数用来输出相关信息的</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &quot;#container&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &quot;aaaaa&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeCreate: function () &#123;</span><br><span class="line">            showData(&quot;创建Vue实例前&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        created: function () &#123;</span><br><span class="line">            showData(&quot;创建Vue实例后&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount: function () &#123;</span><br><span class="line">            showData(&quot;挂载到Dom前&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted: function () &#123;</span><br><span class="line">            showData(&quot;挂载到Dom后&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate: function () &#123;</span><br><span class="line">            showData(&quot;数据发生变化时&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        updated: function () &#123;</span><br><span class="line">            showData(&quot;数据发生变化后&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeDestroy: function () &#123;</span><br><span class="line">            showData(&quot;Vue实例销毁前&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        destroyed: function () &#123;</span><br><span class="line">            showData(&quot;Vue实例销毁后&quot;, this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p v-html=&quot;message&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a>ES6语法</h4><blockquote>
<p><code>ES6</code>是<code>JavaScript</code>语言的新版本，它也可以叫做<code>ES2015</code>，之前学习的<code>JavaScript</code>属于<code>ES5</code>，<code>ES6</code>在它的基础上增加了一些语法</p>
<p><code>ES6</code>是未来<code>JavaScript</code>的趋势，而且<code>vue</code>组件开发中会使用很多的<code>ES6</code>的语法，所以掌握这些常用的<code>ES6</code>语法是必须的</p>
</blockquote>
<h5 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h5><ul>
<li><code>let</code>：定义封闭作用域的变量，并且变量只能声明一次</li>
<li><code>const</code>：定义封闭作用域的常量，并且变量只能声明一次</li>
</ul>
<blockquote>
<p><code>let</code>和<code>const</code>是新增的声明变量的开头的关键字，在这之前，变量声明是用<code>var</code>关键字</p>
<p>这两个关键字和<code>var</code>的区别是，它们声明的变量没有<strong>预解析</strong>，无法脱离定义空间使用</p>
<p><code>let</code>和<code>const</code>的区别是，<code>let</code>声明的是一般变量，<code>const</code>申明的常量，不可修改</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(a) // undefined</span><br><span class="line">console.log(b) // b is not defined</span><br><span class="line">console.log(c) // c is not defined</span><br><span class="line">var a =  1</span><br><span class="line">var a = 2</span><br><span class="line">let b = 2</span><br><span class="line">// let b = 3 // Identifier &apos;b&apos; has already been declared</span><br><span class="line">const c = 3</span><br><span class="line">// const c = 4 // Identifier &apos;c&apos; has already been declared</span><br><span class="line">c = 4 //  Assignment to constant variable</span><br></pre></td></tr></table></figure>

<h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><blockquote>
<p>可以把箭头函数理解成匿名函数的第二种写法，箭头函数的作用是可以在对象中绑定<code>this</code></p>
<p>解决了<code>JavaScript</code>中<code>this</code>指定混乱的问题</p>
</blockquote>
<ul>
<li>定义函数的一般方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function func()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>匿名赋值创建函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var func = function()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>箭头函数的写法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var func = (a, b) =&gt; &#123;</span><br><span class="line">    // 这样的函数在嵌套时，会自动绑定外部作用域下的this</span><br><span class="line">&#125;</span><br><span class="line">var func = a =&gt; &#123;</span><br><span class="line">    // 一个参数时，可以省略参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload = function () &#123;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &quot;#container&quot;,</span><br><span class="line">        data: &#123; message: &quot;abcdef&quot;, &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            show() &#123;</span><br><span class="line">                console.log(&quot;这是show函数:&quot;, this.message),</span><br><span class="line">                    func = () =&gt; &#123;</span><br><span class="line">                    console.log(&quot;我是内部函数:&quot;, this.message)</span><br><span class="line">                &#125;,</span><br><span class="line">                    func(), // 调用一下这个内部函数</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;show&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h4><blockquote>
<p>组件<code>Component</code>是<code>Vue.js</code>最强大的功能之一</p>
</blockquote>
<blockquote>
<p>组件可以扩展<code>HTML</code>元素，<strong>封装可重用的代码</strong></p>
<p>所有的<code>Vue</code>组件同时也都是<code>Vue</code>的实例，所以可接受相同的选项对象（除了一些根级特有的选项）并提供相同的生命周期钩子</p>
</blockquote>
<h5 id="注册全局组件"><a href="#注册全局组件" class="headerlink" title="注册全局组件"></a>注册全局组件</h5><ul>
<li>注册一个全局组件语法格式如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(tagName, options)</span><br><span class="line">// tagName：组件名</span><br><span class="line">// options：配置选项</span><br></pre></td></tr></table></figure>

<ul>
<li>比如这样一个全局组件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;button_show&apos;, &#123;</span><br><span class="line">    data: function () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            count: 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, // 当前组件会需要的数据，定义为函数的返回值</span><br><span class="line">    template: &apos;&lt;button @click=&quot;count++&quot;&gt;按钮:&#123;&#123; count &#125;&#125;&lt;/button&gt;&apos;</span><br><span class="line">    // 组件的标签模板</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来可以在任何<code>Vue</code>接管的元素中使用该组件，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;button_show&gt;&lt;/button_show&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload = function () &#123;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">    	el: &quot;#container&quot;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="data必须是函数"><a href="#data必须是函数" class="headerlink" title="data必须是函数"></a>data必须是函数</h5><blockquote>
<p>组件就是<code>vue</code>的实例，所有<code>vue</code>实例中属性和方法，组件中也可以用</p>
<p>其中<code>data</code>属性必须是一个函数，因为组件会重复使用在多个地方，为了使用在多个地方的组件数据相对独立，<code>data</code>属性需要用一个函数的返回值来将数据处理为不同的每个个体</p>
</blockquote>
<h5 id="Prop传递数据"><a href="#Prop传递数据" class="headerlink" title="Prop传递数据"></a>Prop传递数据</h5><blockquote>
<p><code>Prop</code>是你可以在组件上注册的一些自定义特性</p>
<p>当一个值传递给一个<code>prop</code>特性的时候，它就变成了那个组件实例的一个属性</p>
<p>为了给组件传递数据，我们可以用一个 <code>props</code> 选项将一些特性值列举在其中</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    Vue.component(&quot;myp&quot;,&#123;</span><br><span class="line">        props: [&quot;content&quot;,&quot;like&quot;], // 需要两个外界传入的值</span><br><span class="line">        template: &quot;&lt;p :class=&apos;like&apos;&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt;&quot;</span><br><span class="line">        // 组件绑定未来要接受的变量，要用到v:bind</span><br><span class="line">    &#125;)</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                content: &apos;这是p段落的文本&apos;,</span><br><span class="line">                like: &apos;beauty&apos;, // 要传递的变量</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">.beauty&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    color: red;</span><br><span class="line">    background: green;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;myp :like=&quot;like&quot; :content=&quot;content&quot;&gt;&lt;/myp&gt;</span><br><span class="line">    &lt;!-- 传递到组件中 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-路由组件</title>
    <url>/Vue-%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue-Router"></a>Vue-Router</h2><blockquote>
<p><code>Vue-router</code>做路径匹配时支持动态片段、全匹配片段以及查询参数（片段指的是<code>URL</code>中的一部分）</p>
<p>对于解析过的路由，这些信息都可以通过路由上下文对象（从现在起，我们会称其为路由对象）访问。</p>
<p>在使用了<code>vue-router</code>的应用中，路由对象会被注入每个组件中，赋值为<code>this.$route</code>，并且当路由切换时，路由对象会被更新</p>
</blockquote><a id="more"></a>
<h3 id="Vue的两种模式"><a href="#Vue的两种模式" class="headerlink" title="Vue的两种模式"></a>Vue的两种模式</h3><blockquote>
<p>一般单页面应用是(<code>SPA</code>)不会请求页面而是只更新视图</p>
<p><code>vue-router</code>提供了两种方式来实现前端路由：<code>Hash</code>模式和<code>History</code>模式,可以用<code>mode</code>参数来决定使用哪一种方式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &apos;history&apos;,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>hash</code>模式：<code>vue-router</code>默认使用<code>Hash</code>模式，使用 <code>url</code>的<code>hash</code>来模拟一个完整的<code>url</code>；此时<code>url</code>变化时，浏览器是不会重新加载的；<code>Hash(即#)</code>是<code>url</code>的锚点，代表的是网页中的一个位置，仅仅改变<code>#</code>后面部分，浏览器只会滚动对应的位置，而不会重新加载页面。<code>#</code>仅仅只是对浏览器进行指导，而对服务端是完全没有作用的！它不会被包括在<code>http</code>请求中，故也不会重新加载页面。同时<code>hash</code>发生变化时，<code>url</code>都会被浏览器记录下来，这样你就可以使用浏览器的后退了</li>
<li><code>History</code>模式：如果你不喜欢<code>hash</code>这种<code>#</code>样式，可以使用<code>history</code>模式。这种模式利用了<code>HTML5 History</code>新增的<code>pushState()</code>和<code>replaceState()</code>方法。除了之前的<code>back</code>，<code>forward</code>，<code>go</code>方法；这两个新方法可以应用在<strong>浏览器历史记录</strong>的增加替换功能上。使用<code>History</code>模式，通过历史记录修改<code>url</code>。但它不会立即向后端发送请求。</li>
</ul>
<blockquote>
<p>注意：虽然<code>History</code>模式可以丢掉不美观的<code>#</code>，也可以正常的前进后退，但是刷新<code>f5</code>后，此时浏览器就会访问服务器，在没有后台支持的情况下，此时就会得到一个<code>404</code>！</p>
<p>官方文档给出的描述是：<code>不过这种模式要玩好；还需要后台配置支持</code></p>
<p>因为我们的应用是单个客户端应用，如果后台没有正确的配置，当用户直接访问时,就会返回<code>404</code>，所以，要在服务端增加一个覆盖所有情况的的候选资源。如果<code>url</code>匹配不到任何静态资源；则应该返回同一个<code>index.html</code>页面</p>
</blockquote>
<h3 id="路由属性"><a href="#路由属性" class="headerlink" title="路由属性"></a>路由属性</h3><ul>
<li><p>路由对象<code>this.$route</code>支持属性</p>
<ul>
<li><code>$route.path</code>：字符串，等于当前路由对象的路径，会被解析为绝对路径</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/aaa/</span>bbb</span><br></pre></td></tr></table></figure>

<ul>
<li><code>$route.params</code>：包含路由中的动态片段和全匹配片段的键值对</li>
<li><code>$route.query</code>：获取连接中查询参数的键值对</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/foo?user=1</span><br><span class="line">// 可以获取到</span><br><span class="line">$route.query.user == 1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>$route.router</code>：路由规则所属的路由器以及其所属的组件</li>
<li><code>$route.matched</code>：数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象</li>
<li><code>$route.name</code>：当前路径的名字</li>
</ul>
</li>
<li><p>路由中设置自定义参数</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.map(&#123;</span><br><span class="line">  &apos;/a&apos;: &#123;</span><br><span class="line">    component: &#123; ... &#125;,</span><br><span class="line">    auth: true // 这里 auth 是一个自定义字段</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>当 <code>/a</code> 被匹配时，<code>$route.auth</code> 的值将会是 <code>true</code>。我们可以利用这个特性在全局的钩子函数中进行身份验证</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.beforeEach(function (transition) &#123;</span><br><span class="line">  if (transition.to.auth) &#123;</span><br><span class="line">    // 对用户身份进行验证...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="动态路由（-号通配符）"><a href="#动态路由（-号通配符）" class="headerlink" title="动态路由（:号通配符）"></a>动态路由（:号通配符）</h3><blockquote>
<p>路由中的动态片段使用以冒号开头的路径片段定义</p>
<p>类比<code>django</code>中的路由传参</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path(&apos;&lt;int:name&gt;/&apos;,views.xx),</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path: &apos;/user/:username&apos;,</span><br><span class="line">component: &#123;</span><br><span class="line">    template: &apos;&lt;p&gt;用户名是&#123;&#123;$route.params.username&#125;&#125;&lt;/p&gt;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一条路径中可以包含多个动态片段，每个片段都会被解析成 <code>$route.params</code> 的一个键值对</p>
</blockquote>
<ul>
<li>解析模式</li>
</ul>
<table>
<thead>
<tr>
<th>模式</th>
<th>匹配的路径</th>
<th>$route.params</th>
</tr>
</thead>
<tbody><tr>
<td><code>/user/:username</code></td>
<td><code>/user/evan</code></td>
<td><code>{ username: &#39;evan&#39; }</code></td>
</tr>
<tr>
<td><code>/user/:username/post/:post_id</code></td>
<td><code>/user/evan/post/123</code></td>
<td><code>{ username: &#39;evan&#39;, post_id: 123 }</code></td>
</tr>
</tbody></table>
<h3 id="全匹配路由（-号通配符）"><a href="#全匹配路由（-号通配符）" class="headerlink" title="全匹配路由（*号通配符）"></a>全匹配路由（*号通配符）</h3><blockquote>
<p>动态片段只能匹配路径中的一个部分，而全匹配片段则基本类似于它的贪心版</p>
<p>例如 <code>/foo/*bar</code> 会匹配任何以 <code>/foo/</code> 开头的路径</p>
<p>当使用一个通配符时，<code>$route.params</code>内会自动添加一个名为<code>pathMatch</code>的参数，其中包含了在连接中通过通配符所匹配到的部分</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;/user/*/cc&apos;,</span><br><span class="line">    name: &apos;User&apos;,</span><br><span class="line">    component: User,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>访问的<code>URL</code>如下</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8080</span><span class="regexp">/user/</span><span class="number">1231</span><span class="regexp">/aaa/</span>cc</span><br></pre></td></tr></table></figure>

<ul>
<li>那么此时<code>*</code>通配符拿到的部分为</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"pathMatch"</span>: <span class="string">"1231/aaa"</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="具名路径（命名路由）"><a href="#具名路径（命名路由）" class="headerlink" title="具名路径（命名路由）"></a>具名路径（命名路由）</h3><ul>
<li>类似<code>django</code>的路由命名，<code>vue</code>路由映射中也可以为某一个路由通过<code>name</code>属性设置命名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;/user/:userid&apos;,</span><br><span class="line">    name: &apos;User&apos;,</span><br><span class="line">    component: User,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>在使用<code>v-link</code>标签进行路由跳转时，就可以更加方便啦</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;name: &apos;User&apos;, params: &#123;userid: &apos;zhangsan&apos; &#125;&#125;&quot;&gt;user&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以在<code>js</code>代码中使用<code>router.go</code>切换到该路径下</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">router</span><span class="selector-class">.go</span>(&#123; <span class="attribute">name</span>: <span class="string">'user'</span>, params: &#123; userId: <span class="number">123</span> &#125;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="V-link"><a href="#V-link" class="headerlink" title="V-link"></a>V-link</h2><ul>
<li><code>v-link</code> 是一个用来让用户在<code>vue-router</code>应用的不同路径间跳转的指令。该指令接受一个<code>JavaScript</code>表达式，并会在用户点击元素时用该表达式的值去调用 <code>router.go</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 字面量路径 --&gt;</span><br><span class="line">&lt;a v-link=&quot;&apos;home&apos;&quot;&gt;Home&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 效果同上 --&gt;</span><br><span class="line">&lt;a v-link=&quot;&#123; path: &apos;home&apos; &#125;&quot;&gt;Home&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 具名路径 --&gt;</span><br><span class="line">&lt;a v-link=&quot;&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>应该使用 <code>v-link</code> 而不是 <code>href</code> 来处理浏览时的跳转。原因如下<ul>
<li>它在<code>HTML5 history</code>模式和<code>hash</code>模式下的工作方式相同，所以如果你决定改变模式，或者<code>IE9</code>浏览器退化为<code>hash</code>模式时，都不需要做任何改变</li>
</ul>
</li>
<li>在<code>HTML5 history</code>模式下，<code>v-link</code> 会监听点击事件，防止浏览器尝试重新加载页面</li>
<li>在<code>HTML5 history</code>模式下使用 <code>root</code> 选项时，不需要在 <code>v-link</code> 的<code>URL</code>中包含<code>root</code>路径</li>
</ul>
<h3 id="V-Link其他选项"><a href="#V-Link其他选项" class="headerlink" title="V-Link其他选项"></a>V-Link其他选项</h3><ul>
<li>replace</li>
</ul>
<blockquote>
<p>一个带有 <code>replace: true</code> 的链接被点击时将会触发 <code>router.replace()</code> 而不是 <code>router.go()</code>。由此产生的跳转不会留下历史记录</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;name: &apos;User&apos;, params: &#123;userid: &apos;zhangsan&apos; &#125;, replace: true &#125;&quot;&gt;replace&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>append</li>
</ul>
<blockquote>
<p>带有 <code>append: true</code> 选项的相对路径链接会确保该相对路径始终添加到当前路径之后。举例来说，从 <code>/a</code> 跳转到相对路径 <code>b</code> 时，如果没有 <code>append: true</code> 我们会跳转到 <code>/b</code>，但有 <code>append: true</code> 则会跳转到 <code>/a/b</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;name: &apos;User&apos;, append: true &#125;&quot;&gt;append&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<h2 id="路由钩子"><a href="#路由钩子" class="headerlink" title="路由钩子"></a>路由钩子</h2><blockquote>
<p>全局的钩子</p>
</blockquote>
<ul>
<li><code>beforeEach(to, from, next)</code></li>
</ul>
<blockquote>
<p>添加一个全局的前置钩子函数，这个函数会在路由切换开始时调用。调用发生在整个切换流水线之前。如果此钩子函数拒绝了切换，整个切换流水线根本就不会启动</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const router = new Router(&#123;</span><br><span class="line">   ...</span><br><span class="line">export default router</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // to and from are both route objects. must call `next`.</span><br><span class="line">  console.log(to) // to: Route: 即将要进入的目标 路由对象</span><br><span class="line">  console.log(&apos;-------------&apos;)</span><br><span class="line">  console.log(from) // from: Route: 当前导航正要离开的路由</span><br><span class="line">  console.log(&apos;-------------&apos;)</span><br><span class="line">  console.log(next) // 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>路由解析流程</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>导航被触发。</span><br><span class="line"><span class="number">2.</span>在失活的组件里调用离开守卫。</span><br><span class="line"><span class="number">3.</span>调用全局的 beforeEach 守卫。</span><br><span class="line"><span class="number">4.</span>在重用的组件里调用 beforeRouteUpdate 守卫 (<span class="number">2.2</span>+)。</span><br><span class="line"><span class="number">5.</span>在路由配置里调用 beforeEnter。</span><br><span class="line"><span class="number">6.</span>解析异步路由组件。</span><br><span class="line"><span class="number">7.</span>在被激活的组件里调用 beforeRouteEnter。</span><br><span class="line"><span class="number">8.</span>调用全局的 beforeResolve 守卫 (<span class="number">2.5</span>+)。</span><br><span class="line"><span class="number">9.</span>导航被确认。</span><br><span class="line"><span class="number">10.</span>调用全局的 afterEach 钩子。</span><br><span class="line"><span class="number">11.</span>触发 DOM 更新。</span><br><span class="line"><span class="number">12.</span>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>beforeEach</code>控制路由跳转，拦截路由</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // to and from are both route objects. must call `next`.</span><br><span class="line">  let toQuery = JSON.parse(JSON.stringify(to.query));</span><br><span class="line">  console.log(toQuery) // 获取连接参数</span><br><span class="line">  if(to.meta.requiredAuth == true)&#123; // 如果要进入的路由需要用户登陆</span><br><span class="line">    if(window.localStorage.getItem(&apos;username&apos;))&#123; // 获取存储的用户名</span><br><span class="line">      next()</span><br><span class="line">    &#125; else&#123; // 没有获取到，则跳转到登陆页面</span><br><span class="line">      next(&#123;</span><br><span class="line">        path: &apos;/&apos;,</span><br><span class="line">        query: toQuery,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Django-DBrouter</title>
    <url>/Django%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B7%AF%E7%94%B1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="DB-router"><a href="#DB-router" class="headerlink" title="DB-router"></a>DB-router</h2><blockquote>
<p>通过编写<strong>db-router</strong>可以灵性连接<strong>mysql</strong>主从复制等情况下的多数据库</p>
</blockquote><ul>
<li>假设你已经配置好了类似<strong>MYSQL</strong>主从复制的服务，如果没有可以参照<a href="https://lienze.tech/blog/mysql/c813917a.html" target="_blank" rel="noopener">这里</a></li>
</ul><a id="more"></a>

<h3 id="配置Django数据库连接"><a href="#配置Django数据库连接" class="headerlink" title="配置Django数据库连接"></a>配置Django数据库连接</h3><ul>
<li>settings.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;  </span><br><span class="line">    <span class="string">'default'</span>: &#123;     </span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,  </span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'192.168.1.101'</span>,   </span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,   </span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,    </span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,  </span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'test1'</span> </span><br><span class="line">    &#125;,    </span><br><span class="line">    <span class="string">'slave'</span>: &#123;     </span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,   </span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'192.168.1.102'</span>,  </span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,       </span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>, </span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,   </span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'test1'</span>  </span><br><span class="line">    &#125;&#125;</span><br><span class="line">DATABASE_ROUTERS = [<span class="string">'pro.utils.MasterSlaveDBRouter'</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>编写<strong>db-router</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MasterSlaveDBRouter</span>:</span>  </span><br><span class="line">    <span class="string">"""数据库主从读写分离路由"""</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_read</span><span class="params">(self, model, **hints)</span>:</span>   </span><br><span class="line">        <span class="string">"""读数据库"""</span>   </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"slave"</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_write</span><span class="params">(self, model, **hints)</span>:</span>  </span><br><span class="line">        <span class="string">"""写数据库"""</span>       </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"default"</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allow_relation</span><span class="params">(self, obj1, obj2, **hints)</span>:</span> </span><br><span class="line">        <span class="string">"""是否运行关联操作"""</span>     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如出现以下错误，修改主库binlog日志格式</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">django.db.utils.InternalError: (1665, 'Cannot <span class="keyword">execute</span> <span class="keyword">statement</span>: impossible <span class="keyword">to</span> write <span class="keyword">to</span> <span class="built_in">binary</span> <span class="keyword">log</span> since BINLOG_FORMAT = <span class="keyword">STATEMENT</span> <span class="keyword">and</span> <span class="keyword">at</span> <span class="keyword">least</span> one <span class="keyword">table</span> uses a <span class="keyword">storage</span> <span class="keyword">engine</span> limited <span class="keyword">to</span> <span class="keyword">row</span>-based logging. <span class="keyword">InnoDB</span> <span class="keyword">is</span> limited <span class="keyword">to</span> <span class="keyword">row</span>-<span class="keyword">logging</span> <span class="keyword">when</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">is</span> <span class="keyword">READ</span> COMMITTED <span class="keyword">or</span> <span class="keyword">READ</span> UNCOMMITTED.<span class="string">')</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">binlog_format</span>=mixed</span><br></pre></td></tr></table></figure>

<h3 id="打开日志用以分析"><a href="#打开日志用以分析" class="headerlink" title="打开日志用以分析"></a>打开日志用以分析</h3><ul>
<li>可以通过配置<strong>mysql</strong>日志记录，用以查看主从在读写情况下的效果</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">general_log</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">general_log_file</span>=/var/lib/mysql/general.log</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
  </entry>
  <entry>
    <title>Django-DBrouter</title>
    <url>/Django-DBrouter/</url>
    <content><![CDATA[<h2 id="DB-router"><a href="#DB-router" class="headerlink" title="DB-router"></a>DB-router</h2><blockquote>
<p>通过编写<strong>db-router</strong>可以灵性连接<strong>mysql</strong>主从复制等情况下的多数据库</p>
</blockquote><ul>
<li>假设你已经配置好了类似<strong>MYSQL</strong>主从复制的服务，如果没有可以参照<a href="https://lienze.tech/blog/mysql/c813917a.html" target="_blank" rel="noopener">这里</a></li>
</ul><a id="more"></a>

<h3 id="配置Django数据库连接"><a href="#配置Django数据库连接" class="headerlink" title="配置Django数据库连接"></a>配置Django数据库连接</h3><ul>
<li>settings.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;  </span><br><span class="line">    <span class="string">'default'</span>: &#123;     </span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,  </span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'192.168.1.101'</span>,   </span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,   </span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,    </span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,  </span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'test1'</span> </span><br><span class="line">    &#125;,    </span><br><span class="line">    <span class="string">'slave'</span>: &#123;     </span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,   </span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'192.168.1.102'</span>,  </span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,       </span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>, </span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,   </span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'test1'</span>  </span><br><span class="line">    &#125;&#125;</span><br><span class="line">DATABASE_ROUTERS = [<span class="string">'pro.utils.MasterSlaveDBRouter'</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>编写<strong>db-router</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MasterSlaveDBRouter</span>:</span>  </span><br><span class="line">    <span class="string">"""数据库主从读写分离路由"""</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_read</span><span class="params">(self, model, **hints)</span>:</span>   </span><br><span class="line">        <span class="string">"""读数据库"""</span>   </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"slave"</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_write</span><span class="params">(self, model, **hints)</span>:</span>  </span><br><span class="line">        <span class="string">"""写数据库"""</span>       </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"default"</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allow_relation</span><span class="params">(self, obj1, obj2, **hints)</span>:</span> </span><br><span class="line">        <span class="string">"""是否运行关联操作"""</span>     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如出现以下错误，修改主库binlog日志格式</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">django.db.utils.InternalError: (1665, 'Cannot <span class="keyword">execute</span> <span class="keyword">statement</span>: impossible <span class="keyword">to</span> write <span class="keyword">to</span> <span class="built_in">binary</span> <span class="keyword">log</span> since BINLOG_FORMAT = <span class="keyword">STATEMENT</span> <span class="keyword">and</span> <span class="keyword">at</span> <span class="keyword">least</span> one <span class="keyword">table</span> uses a <span class="keyword">storage</span> <span class="keyword">engine</span> limited <span class="keyword">to</span> <span class="keyword">row</span>-based logging. <span class="keyword">InnoDB</span> <span class="keyword">is</span> limited <span class="keyword">to</span> <span class="keyword">row</span>-<span class="keyword">logging</span> <span class="keyword">when</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">is</span> <span class="keyword">READ</span> COMMITTED <span class="keyword">or</span> <span class="keyword">READ</span> UNCOMMITTED.<span class="string">')</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">binlog_format</span>=mixed</span><br></pre></td></tr></table></figure>

<h3 id="打开日志用以分析"><a href="#打开日志用以分析" class="headerlink" title="打开日志用以分析"></a>打开日志用以分析</h3><ul>
<li>可以通过配置<strong>mysql</strong>日志记录，用以查看主从在读写情况下的效果</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">general_log</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">general_log_file</span>=/var/lib/mysql/general.log</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSSH</title>
    <url>/WebSSH/</url>
    <content><![CDATA[<h2 id="WebSSH"><a href="#WebSSH" class="headerlink" title="WebSSH"></a>WebSSH</h2><blockquote>
<p><code>webssh</code>从而<code>SSH</code>无需<code>Xshell</code>之类的模拟终端工具进行<code>SSH</code>连接，将<code>SSH</code>这一比较低层的操作也从<code>C/S</code>架构扭转成为<code>B/S</code>架构</p>
<p>这样的架构常用在运维制作开发一些堡垒机等系统，或者目前比较新型的在线教育方式，通过<code>WebSSH</code>向学生提供一个可以直接使用浏览器进行相关<code>Linux</code>操作或代码编写的学习方式</p>
<p><code>WebSSh</code>主要是建立客户端与服务端的即时通信</p>
</blockquote><a id="more"></a>
<h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><ul>
<li>此种<code>WebSSH</code>实现方式，将通过结合<code>WebSocket</code>以及逐步的<code>Paramiko</code>来进行实现，所需要的技术栈如下</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">＃前端</span></span><br><span class="line"><span class="attr">vue</span> <span class="string"></span></span><br><span class="line"><span class="attr">websocket</span> <span class="string"></span></span><br><span class="line"><span class="attr">xterm.js</span></span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后端</span></span><br><span class="line">django</span><br><span class="line">dwebsocket</span><br><span class="line">paramiko</span><br><span class="line">threading</span><br></pre></td></tr></table></figure>

<h3 id="技术介绍"><a href="#技术介绍" class="headerlink" title="技术介绍"></a>技术介绍</h3><ul>
<li><code>xterm</code></li>
</ul>
<blockquote>
<p>前端通过<code>xterm</code>插件进行<code>shell</code>黑窗口环境的构建，这个插件会自动解析由后台<code>paramiko</code>返回的带有标记样式的命令结果，并渲染到浏览器中，非常酷炫</p>
</blockquote>
<ul>
<li><code>websocket</code></li>
</ul>
<blockquote>
<p>这里通过<code>websocket</code>进行浏览器与<code>django</code>的数据交通同轴，<code>Websocket</code><a href="https://eastside.gitee.io/blog/django/d57108c1.html" target="_blank" rel="noopener">是什么</a></p>
</blockquote>
<ul>
<li><code>paramiko</code></li>
</ul>
<blockquote>
<p><code>paramiko</code>此时的角色采取承担<code>django</code>与<code>Linux</code>环境的互动，将前端发来的命令发送给后台，将后端发来的命令结果返回到前端的<code>xterm</code>组件中</p>
</blockquote>
<h3 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h3><blockquote>
<p>前端<code>xterm</code>组件使用：简单</p>
</blockquote>
<ul>
<li>安装<code>xterm</code></li>
</ul>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">cnpm安装xterm <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>vue</code>框架中约会<code>xterm</code>的样式文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// main.js</span><br><span class="line">// The Vue build version to load with the `import` command</span><br><span class="line">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import App from &apos;./App&apos;</span><br><span class="line">import router from &apos;./router&apos;</span><br><span class="line">import &apos;xterm/dist/xterm.css&apos; // 看这里，添加xterm css文件样式</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">/* eslint-disable no-new */</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化<code>xterm</code>组件并添加两个插件：<code>attach</code>可以将终端附加到<code>websocket</code>流中，<code>fit</code>可以调整终端的大小以及行和列适应父级元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// index.vue</span><br><span class="line"></span><br><span class="line">import &#123; Terminal &#125; from &apos;xterm&apos;</span><br><span class="line">import * as attach from &apos;xterm/lib/addons/attach/attach&apos;</span><br><span class="line">import * as fit from &apos;xterm/lib/addons/fit/fit&apos;</span><br><span class="line"></span><br><span class="line">Terminal.applyAddon(attach)</span><br><span class="line">Terminal.applyAddon(fit)</span><br></pre></td></tr></table></figure>

<ul>
<li>构建<code>websocket</code>并绑定到终端，<code>websocket</code>地址为<code>ws</code>协议链接，此时使用的是即将在<code>django</code>中配置<code>Websocket</code>后台视图的路由，这一系列行为将挂载到钩子函数下进行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">    let terminalContainer = document.getElementById(<span class="string">'terminal'</span>)</span><br><span class="line">    this.term = new Terminal(this.terminal)</span><br><span class="line">    this.term.open(terminalContainer)</span><br><span class="line"></span><br><span class="line">    // open websocket</span><br><span class="line">    this.terminalSocket = new WebSocket(<span class="string">'ws://127.0.0.1:8000/webssh/'</span>)</span><br><span class="line">    this.terminalSocket.onopen = function()&#123;</span><br><span class="line">        console.log(<span class="string">'websocket is Connected...'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    this.terminalSocket.onclose = function()&#123;</span><br><span class="line">        console.log(<span class="string">'websocket is Closed...'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    this.terminalSocket.onerror = function()&#123;</span><br><span class="line">        console.log(<span class="string">'damn Websocket is broken!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    this.term.attach(this.terminalSocket)</span><br><span class="line">    // 绑定xterm到ws流中</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>当浏览器关闭时，也代表着客户端关闭，此时主动插入连接，交给<code>vue</code>的钩子函数来处理这个问题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">beforeDestroy () &#123;</span><br><span class="line">  this.terminalSocket.close()</span><br><span class="line">  this.term.destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后端实现"><a href="#后端实现" class="headerlink" title="后端实现"></a>后端实现</h3><blockquote>
<p><code>django</code>这里使用<code>dwebsocket</code>模块进行<code>ws</code>的服务端编写与通信</p>
</blockquote>
<ul>
<li>首先确定路由，也是前端的<code>ws</code>连接地址</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">＃urls.py </span><br><span class="line"><span class="meta">... </span></span><br><span class="line">	path（<span class="string">'webssh /'</span>，webssh）</span><br></pre></td></tr></table></figure>

<ul>
<li>定义函数，初始化<code>SSH</code>连接对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#views.py </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_ssh</span><span class="params">(host,username,password,port=<span class="number">22</span>)</span>:</span></span><br><span class="line">    sh = paramiko.SSHClient()</span><br><span class="line">    sh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    sh.connect(host, username=username, password=password)</span><br><span class="line">    channle = sh.invoke_shell(term=<span class="string">'xterm'</span>)</span><br><span class="line">    <span class="keyword">return</span> channle</span><br></pre></td></tr></table></figure>

<ul>
<li>由于在<code>SSH</code>通道中，服务端可能返回结果的方式并不与客户端发起的命令一唱一和，可能是一唱多和，类似类似<code>top</code>的命令，一次命令输入之后，服务端会返回<code>N</code>次结果，此时在<code>django</code>首先中采用多线程，专门处理命令结果的返回；以下是这个任务线程函数的定义</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_ssh_msg</span><span class="params">(channle,ws)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        channle: 建立好的SSH连接通道</span></span><br><span class="line"><span class="string">        这个函数会不停的接收ssh通道返回的命令</span></span><br><span class="line"><span class="string">        返回到前端的ws套接字里</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> channle.exit_status_ready():</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            buf = channle.recv(<span class="number">1024</span>) <span class="comment"># 接收命令的执行结果</span></span><br><span class="line">            ws.send(buf) <span class="comment"># 向Websocket通道返回</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<ul>
<li>剩余的就是视图函数的调用和线程开启部分了！</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@accept_websocket</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">webssh</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        1: 接收前端(ws)的命令，发给后台(ssh)</span></span><br><span class="line"><span class="string">        2: 接收后台的返回结果，给到前端</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> request.is_websocket:</span><br><span class="line">        channle = _ssh(host, username=username, password=password)</span><br><span class="line">        ws = request.websocket </span><br><span class="line">        t = threading.Thread(target=recv_ssh_msg,args=(channle,ws))</span><br><span class="line">        t.setDaemon(<span class="literal">True</span>) </span><br><span class="line">        t.start() <span class="comment"># 线程开启</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            cmd = ws.wait() <span class="comment"># 阻塞接收前端发来的命令</span></span><br><span class="line">            <span class="keyword">if</span> cmd:</span><br><span class="line">                channle.send(cmd) <span class="comment"># 由SSH通道转交给Linux环境</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 连接断开 跳出循环 </span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        ws.close() <span class="comment"># 释放对应套接字资源</span></span><br><span class="line">        channle.close()</span><br></pre></td></tr></table></figure>

<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><ul>
<li>如下</li>
</ul>
<p><a href="https://lienze.tech/blog/images/webssh.gif" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/webssh.gif" alt="Webssh"></a></p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Websocket</title>
    <url>/Websocket/</url>
    <content><![CDATA[<h2 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h2><blockquote>
<p><code>WebSocket</code>实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端可以主动向客户端发送数据。</p>
<p>传统的<code>HTTP</code>协议是无状态的，种客户端是主动方，服务端是被动方的；对于涉及实时信息的<code>Web</code>应用带来了很大的不便，如带有即时通信、实时数据、订阅推送等功能的应用。在之前有两种办法解决这个问题</p>
</blockquote><a id="more"></a>
<blockquote>
<p>轮询是最原始的实现实时<code>Web</code>应用的解决方案。轮询技术要求客户端以设定的时间间隔周期性地向服务端发送请求，频繁地查询是否有新的数据改动。这种方法会导致过多不必要的请求，浪费流量和服务器资源。</p>
<p><code>Comet</code>技术又可以分为长轮询和流技术；长轮询改进了上述的轮询技术，减小了无用的请求。它会为某些数据设定过期时间，当数据过期后才会向服务端发送请求；这种机制适合数据的改动不是特别频繁的情况。流技术通常是指客户端使用一个隐藏的窗口与服务端建立一个<code>HTTP</code>长连接，服务端会不断更新连接状态以保持<code>HTTP</code>长连接存活；这样的话，服务端就可以通过这条长连接主动将数据发送给客户端；流技术在大并发环境下，可能会考验到服务端的性能。</p>
<p><code>WebSocket</code>真正实现了<code>Web</code>的实时通信，使<code>B/S</code>模式具备了<code>C/S</code>模式的实时通信能力</p>
<p><code>WebSocket</code>的工作流程是这样的：浏览器通过<code>JavaScript</code>向服务端发出建立<code>WebSocket</code>连接的请求，在<code>WebSocket</code>连接建立成功后，客户端和服务端就可以通过 TCP连接传输数据。因为<code>WebSocket</code>连接本质上是<code>TCP</code>连接，不需要每次传输都带上重复的头部数据，所以它的数据传输量比轮询和<code>Comet</code>技术小了很多</p>
</blockquote>
<blockquote>
<p><code>Websocket</code>在建立连接之前有一个<code>Handshake</code>（<code>Opening Handshake</code>）过程，在关闭连接前也有一个Handshake（<code>Closing Handshake</code>）过程，建立连接之后，双方即可双向通信</p>
</blockquote>
<h3 id="HTML的Websocket"><a href="#HTML的Websocket" class="headerlink" title="HTML的Websocket"></a>HTML的Websocket</h3><ul>
<li>初始化websocket</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var ws = <span class="keyword">new</span> <span class="constructor">WebSocket(<span class="params">url</span>, [<span class="params">protocol</span>] )</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>url</code>：指定连接的<code>websocket</code></p>
<p><code>protocol</code>：可接受的子协议</p>
</blockquote>
<h4 id="响应事件"><a href="#响应事件" class="headerlink" title="响应事件"></a>响应事件</h4><blockquote>
<p>当<code>ws</code>套接字初始化成功之后，我们可以通过定义回调函数在某些事件触发时执行，以下是常见响应事件</p>
</blockquote>
<ul>
<li>当<code>ws</code>连接建立时触发</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">   	<span class="comment">// 连接开启</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当<code>ws</code>连接接收到数据时触发</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span><span class="params">(evt)</span></span>&#123;</span><br><span class="line">    <span class="comment">// evt.data即是接收到的数据对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当<code>ws</code>连接发生通信错误时触发</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">ws.onerror = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 连接出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当连接关闭时触发</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 连接关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>初次之外，还可以通过一些方法函数进行数据的传输或连接的关闭</p>
</blockquote>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>通过<code>ws</code>连接发送数据</li>
</ul>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">ws.<span class="built_in">send</span>(str)</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭连接</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ws</span>.<span class="keyword">close</span>()</span><br></pre></td></tr></table></figure>

<h4 id="简单的示例"><a href="#简单的示例" class="headerlink" title="简单的示例"></a>简单的示例</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">ws</span> = <span class="keyword">new</span> WebSocket(<span class="string">'ws://127.0.0.1:3000'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ws</span>.onopen = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'连接建立'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ws</span>.onmessage = <span class="function"><span class="keyword">function</span><span class="params">(ev)</span>&#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'server:'</span>,ev.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ws</span>.onerror = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'连接建立'</span>)</span><br><span class="line">    <span class="keyword">ws</span>.<span class="keyword">close</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ws</span>.onclose = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'连接关闭'</span>)</span><br><span class="line">    <span class="keyword">ws</span>.<span class="keyword">close</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Django的Websocket"><a href="#Django的Websocket" class="headerlink" title="Django的Websocket"></a>Django的Websocket</h3><blockquote>
<p><code>dwebsocket</code>是一个在<code>django</code>用来实现<code>websocket</code>服务端的三方模块，使用上手非常简单，安装方式如下</p>
</blockquote>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> dwebsocket</span><br></pre></td></tr></table></figure>

<ul>
<li><code>git</code>地址</li>
</ul>
<blockquote>
<p><a href="https://github.com/duanhongyi/dwebsocket" target="_blank" rel="noopener">https://github.com/duanhongyi/dwebsocket</a></p>
</blockquote>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><blockquote>
<p>在后台中，通过该三方模块可以让我们在<code>django</code>的视图中实现对于<code>websocket</code>的操作</p>
</blockquote>
<blockquote>
<p>首先是两个基本的装饰器，用来限定过滤<code>websocket</code>的连接</p>
</blockquote>
<ul>
<li><code>dwebsocket.accept_websocket</code></li>
</ul>
<blockquote>
<p>允许<code>http</code>与<code>websocket</code>连接</p>
</blockquote>
<ul>
<li><code>dwebsocket.require_websocke</code></li>
</ul>
<blockquote>
<p>只允许<code>websocket</code>连接</p>
</blockquote>
<blockquote>
<p>除去两种装饰器方法进行过滤判断，还可以通过在视图函数中的<code>request</code>进行<code>websocket</code>的判断</p>
</blockquote>
<ul>
<li><code>request.is_websocket</code></li>
</ul>
<blockquote>
<p>如果是个<code>websocket</code>请求返回<code>True</code>，如果是个普通的<code>http</code>请求返回<code>False</code></p>
<p>可以用这个方法区分普通连接与<code>websocket</code></p>
</blockquote>
<ul>
<li><code>request.websocket</code></li>
</ul>
<blockquote>
<p>在一个<code>websocket</code>请求建立之后，这个请求将会有一个<code>websocket</code>属性，用来给客户端提供一个简单的<code>api</code>通讯，如果<code>request.is_websocket()</code>是<code>False</code>，这个属性将是<code>None</code></p>
</blockquote>
<ul>
<li><code>request.websocket.wait</code></li>
</ul>
<blockquote>
<p>接收客户端发来的一条消息；如果在收到消息或客户端关闭连接之前，它不会有任何返回，只会返回None</p>
</blockquote>
<ul>
<li><code>request.websocket.read</code></li>
</ul>
<blockquote>
<p>如果从客户端接收到新消息，<code>read</code>函数返回这条消息；如果没有新消息，则返回None</p>
<p>这是一个替代<code>wait</code>的非阻塞读取数据的方法</p>
</blockquote>
<ul>
<li><code>request.websocket.count_messages()</code></li>
</ul>
<blockquote>
<p>返回消息队列数量</p>
</blockquote>
<ul>
<li><code>request.websocket.has_messages()</code></li>
</ul>
<blockquote>
<p>如果有新消息返回<code>True</code>，否则返回<code>False</code></p>
</blockquote>
<ul>
<li><code>request.websocket.send(message)</code></li>
</ul>
<blockquote>
<p>向客户端发送消息</p>
</blockquote>
<ul>
<li><code>requqest.websocket.__iter__</code></li>
</ul>
<blockquote>
<p><code>websocket</code>迭代器</p>
</blockquote>
<ul>
<li>关于<code>Django</code>的<code>Demo</code>将会在下一章节结合<code>paramiko</code>以及<code>xterm.js</code>来进行一个<code>webssh</code>的实现</li>
</ul>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Tinymce富文本编辑器</title>
    <url>/Tinymce%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<h2 id="图文混排"><a href="#图文混排" class="headerlink" title="图文混排"></a>图文混排</h2><blockquote>
<p>在某些富文本编辑器中，我们可以支持文件与图片的同时编写，将文字与图片混合排列</p>
<p>在<code>django</code>中可以使用<code>TimyMce</code>富文本编辑器进行图文混排功能的实现</p>
</blockquote><a id="more"></a>
<h3 id="TinyMce"><a href="#TinyMce" class="headerlink" title="TinyMce"></a>TinyMce</h3><blockquote>
<p><code>TinyMCE</code>：是一个轻量级的基于浏览器的所见即所得编辑器，支持目前流行的各种浏览器，由<code>JavaScript</code>写成</p>
<p>功能配置灵活简单，两行代码就可以将编辑器嵌入网页中，并且支持<code>AJAX</code>，加载速度非常快</p>
<p>最重要的是，<code>TinyMCE</code>是一个根据<code>LGPL license</code>发布的自由软件，你可以把它用于商业应用。下图是此编辑器的界面</p>
</blockquote>
<h3 id="配置上传路径"><a href="#配置上传路径" class="headerlink" title="配置上传路径"></a>配置上传路径</h3><blockquote>
<p>首先配置整个项目的上传文件路径，为了区别与自身的<code>static</code>静态目录</p>
<p>这里的上传文件我们将另外保存至<code>upload</code>文件夹</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#settings.py</span></span><br><span class="line">UPLOAD_ROOT = os.path.join(BASE_DIR,<span class="string">'upload'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="配置模板页面"><a href="#配置模板页面" class="headerlink" title="配置模板页面"></a>配置模板页面</h3><blockquote>
<p>首先需要在使用到<code>tinymce</code>富文本编辑器的<code>html</code>页面下导入必备<code>js</code>文件</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&#123;% static 'js/jquery-1.10.2.min.js' %&#125;"</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&#123;% static 'js/tinymce_setup.js' %&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&#123;% static 'tinymce/js/tinymce/tinymce.min.js' %&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下来，在模板页面中加入一个<code>id</code>为<code>content</code>的输入表单，这里我们以一个文章数据为例</p>
</blockquote>
<ul>
<li>首先是模型层文件定义</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#models.py </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>,verbose_name=<span class="string">'标题'</span>)</span><br><span class="line">    author = models.CharField(max_length=<span class="number">100</span>,verbose_name=<span class="string">'作者'</span>)</span><br><span class="line">    content = models.TextField(verbose_name=<span class="string">'内容'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的<code>content</code>内容要用到富文本编辑器</p>
</blockquote>
<ul>
<li>接着是模板页面的主要部分</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">'/'</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"文章标题"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"文章作者"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"rich_content"</span> <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">value</span>=<span class="string">" "</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="修改插件配置"><a href="#修改插件配置" class="headerlink" title="修改插件配置"></a>修改插件配置</h3><blockquote>
<p>这里搭配了一个<code>tinymce_setup.js</code>文件，用来控制富文本编辑器所使用的插件等</p>
<p>全文配置如下</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tinymce.init(&#123;</span><br><span class="line">    // 选择id为content的标签作为编辑器</span><br><span class="line">    selector: <span class="string">'#rich_content'</span>,</span><br><span class="line">    // 方向从左到右</span><br><span class="line">    directionality:<span class="string">'ltr'</span>,</span><br><span class="line">    // 语言选择中文</span><br><span class="line">    language:<span class="string">'zh_CN'</span>,</span><br><span class="line">    // 高度为<span class="number">400</span> 宽度为一半</span><br><span class="line">    height:<span class="number">300</span>,</span><br><span class="line">    width: <span class="string">'50%'</span>,</span><br><span class="line">    // 工具栏上面的补丁按钮</span><br><span class="line">    plugins: [</span><br><span class="line">            <span class="string">'advlist autolink link image lists charmap print preview hr anchor pagebreak spellchecker'</span>,</span><br><span class="line">            <span class="string">'searchreplace wordcount visualblocks visualchars code fullscreen insertdatetime media nonbreaking'</span>,</span><br><span class="line">            <span class="string">'save table contextmenu directionality template paste textcolor'</span>,</span><br><span class="line">            <span class="string">'codesample imageupload'</span>,</span><br><span class="line">    ],</span><br><span class="line">    // 工具栏的补丁按钮</span><br><span class="line">     toolbar: <span class="string">'insertfile undo redo | \</span></span><br><span class="line"><span class="string">     styleselect | \</span></span><br><span class="line"><span class="string">     bold italic | \</span></span><br><span class="line"><span class="string">     alignleft aligncenter alignright alignjustify | \</span></span><br><span class="line"><span class="string">     bullist numlist outdent indent | \</span></span><br><span class="line"><span class="string">     link image | \</span></span><br><span class="line"><span class="string">     print preview media fullpage | \</span></span><br><span class="line"><span class="string">     forecolor backcolor emoticons |\</span></span><br><span class="line"><span class="string">     codesample fontsizeselect fullscreen |\</span></span><br><span class="line"><span class="string">     imageupload'</span>,</span><br><span class="line">    // 字体大小</span><br><span class="line">    fontsize_formats: <span class="string">'10pt 12pt 14pt 18pt 24pt 36pt'</span>,</span><br><span class="line">    // 按tab不换行</span><br><span class="line">    nonbreaking_force_tab: true,</span><br><span class="line">    imageupload_url: <span class="string">"/upload_img/"</span>,</span><br><span class="line">    // 上传后图片保存为绝对路径</span><br><span class="line">    relative_urls : false,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注释已经很清晰</p>
<p>要注意的是<code>imageupload_url</code>配置用来确定当前图片上传所对应的视图路由</p>
</blockquote>
<h3 id="上传视图配置"><a href="#上传视图配置" class="headerlink" title="上传视图配置"></a>上传视图配置</h3><blockquote>
<p>接下来编写富文本编辑器的上传图片路由函数及对应的路由配置</p>
<p>路由映射<code>tinymce_setup.js</code>与中的<code>imageupload_url</code>配置路由相同</p>
<p>这里还要注意，由于此时<code>tinymce</code>的上传图片表单并不是和本身所容纳的<code>form</code>表单一起上传，所以并不会具备<code>csrf_token</code>值，需要我们将上传图片的函数额外进行装饰器装饰，取消<code>csrf_token</code>验证</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5</span><span class="params">(str_)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    m = hashlib.md5()</span><br><span class="line">    m.update(str(time.time()).encode())</span><br><span class="line">    filename = m.hexdigest()</span><br><span class="line">    <span class="keyword">return</span> filename + <span class="string">'.'</span> + str_.split(<span class="string">'.'</span>)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_img</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        img = request.FILES.get(<span class="string">'file'</span>)</span><br><span class="line">        <span class="keyword">if</span> img:</span><br><span class="line">            file_name_md5 = md5(img.name)</span><br><span class="line">            <span class="keyword">with</span> open(os.path.join(UPLOAD_ROOT,file_name_md5), <span class="string">'wb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">                <span class="keyword">for</span> buf <span class="keyword">in</span> img.chunks():</span><br><span class="line">                    fp.write(buf)</span><br><span class="line">                <span class="comment"># 迭代读取文件并写入到本地</span></span><br><span class="line">        response = &#123;&#125;</span><br><span class="line">        response[<span class="string">'path'</span>] = <span class="string">'/upload/'</span> + file_name_md5</span><br><span class="line">        response[<span class="string">'error'</span>] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(response))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>视图函数还是老样子去接收上传文件并保存即可</p>
<p>这里还使用了<code>md5</code>的方式进行文件名保存，避免重名文件上传互相覆盖</p>
</blockquote>
<ul>
<li>路由配置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line">path(<span class="string">'upload_img/'</span>,views.upload_img),</span><br></pre></td></tr></table></figure>

<h3 id="表单接收视图"><a href="#表单接收视图" class="headerlink" title="表单接收视图"></a>表单接收视图</h3><blockquote>
<p>以上的视图函数只能处理上传图片的内容接收</p>
<p>我们的模板页面中还有作者及标题两样表单内容会被<code>POST</code>提交到后台</p>
<p>并且要主要的是，富文本编辑器里除了图片的内容，还有文字等其他内容，这里也需要我们保存下来</p>
</blockquote>
<ul>
<li>这里还需要一个视图函数去接管处理</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">'index.html'</span>)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        title = request.POST.get(<span class="string">'title'</span>)</span><br><span class="line">        author = request.POST.get(<span class="string">'author'</span>)</span><br><span class="line">        content = request.POST.get(<span class="string">'content'</span>)</span><br><span class="line">        models.Article.objects.create(</span><br><span class="line">            title = title,</span><br><span class="line">            author = author,</span><br><span class="line">            content = content,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">'/show/'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>表单路由</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line">path(<span class="string">''</span>,views.index),</span><br></pre></td></tr></table></figure>

<ul>
<li>这里上传之后，保存在后台的<code>content</code>数据是这个样子</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/upload/ec8f8c9a56ed32464a6727741fd58d8d.png"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>今天<span class="tag">&lt;<span class="name">em</span>&gt;</span>一切<span class="tag">&lt;/<span class="name">em</span>&gt;</span>都是<span class="tag">&lt;<span class="name">strong</span>&gt;</span>美丽<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>的，哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="图片访问路由"><a href="#图片访问路由" class="headerlink" title="图片访问路由"></a>图片访问路由</h3><blockquote>
<p>当有了上传图片的视图函数及所有内容的接收视图函数</p>
<p>这里还有一个特殊的问题，现在如果在富文本编辑器中选择上传图片，你会发现图片已经在选择时就已经存储到了后台<code>upload</code>文件夹下，这也是为什么我们的图片上传视图函数要单独编写，并且还需要取消<code>csrf_token</code>的验证的原因</p>
</blockquote>
<blockquote>
<p>除了这个问题你还会发现，在富文本编辑器中，上传的图片是看不到的，是一个坏掉的图片；</p>
<p>使用<code>F12</code>开发者工具你可以看到，这里的图片展示为一个<code>img</code>标签，而标签的<code>src</code>属性内容正是通过上传视图函数返回的<code>response</code>中的<code>path</code>值</p>
<p>想让这个<code>path</code>值在访问时，能获取到实际的图片效果，需要我们在路由文件中继续配置，配置专门的<code>upload/xxxx.jpg</code>的图片路由访问，让图片真正展示出来</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.views.static <span class="keyword">import</span> serve</span><br><span class="line">re_path(<span class="string">'^upload/(?P&lt;path&gt;.*)/$'</span>,serve,&#123;<span class="string">'document_root'</span>:UPLOAD_ROOT&#125;),</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上传后图片的访问路径是<code>/upload/</code>，那么这里的路由也是<code>upload/</code>，之后通过静态文件映射函数<code>serve</code>查找<code>upload</code>文件夹下的同路径同名图片资源</p>
<p>当有了这条路由配置之后，再次再富文本编辑器中加入图片，你就会发现图片出现啦</p>
</blockquote>
<h3 id="上传并展示"><a href="#上传并展示" class="headerlink" title="上传并展示"></a>上传并展示</h3><blockquote>
<p>最后，我们将测试上传图片及文字</p>
<p>并且上传成功之后，重定向到<code>show</code>视图函数</p>
</blockquote>
<ul>
<li>这个视图函数用来提取当前最新的上传数据并返回到模板页面</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        article = models.Article.objects.all().last()</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'show.html'</span>,locals())</span><br></pre></td></tr></table></figure>

<ul>
<li>展示的模板页面</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>展示文章<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;% if article %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; article.title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;&#123; article.author &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; article.content|safe &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实本身富文本编辑器上传的文本内容就已经在一个<code>p</code>标签中，所以这里没有用段落标签</p>
<p>另外由于保存在数据库的文本为<code>html</code>格式，而后台传递来的模板变量<code>django</code>出于安全考虑会自动进行转义，直接观看到的效果不会<code>html</code>样式，只是一些普通字符串；</p>
<p>这里可以使用<code>safe</code>过滤器将内容认定为安全，展示为原始的<code>html</code>效果，其实还不错</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>富文本编辑器其实就是将用户输入的内容变为<code>html</code>代码</p>
<p>这里的图文混排，只是在图片加入时，单独将图片上传保存，并且回调获取到上传的路径</p>
<p>之后只需要服务端后台配置好相关的上传图片访问路由配置即可</p>
</blockquote>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>HayStack全文检索在Django中应用</title>
    <url>/HayStack%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%9C%A8Django%E4%B8%AD%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h2><p><a href="https://django-haystack.readthedocs.io/en/v2.4.1/tutorial.html" target="_blank" rel="noopener">官方文档</a></p><blockquote>
<p>全文检索就是针对所有内容进行动态匹配搜索的概念</p>
<p>针对特定的关键词进行<strong>建立索引</strong>并<strong>精确匹配</strong>取出搜索结果，并且达到性能优化的目的</p>
</blockquote><ul>
<li>为啥要有全文检索</li>
</ul><a id="more"></a>


<blockquote>
<p>最常见的全文检索就是我们在数据库中进行的模糊查询</p>
<p>但是模糊查询是针对整体内容的一个动态匹配过程，在数据量较大的情况下匹配效率极低</p>
<p>常规项目中数据量一般都比较多并且内容繁杂，所以正常的项目搜索功能中很少会使用模糊查询进行操作</p>
<p>如果你开发的项目用户量较少并且项目数据较少，那么此时模糊查询可以是你值得考虑的选项</p>
</blockquote>
<ul>
<li><code>django</code>使用啥进行全文检索</li>
</ul>
<blockquote>
<p><code>Python</code>提供了各种模块进行全文检索，最常见的是<code>haystack</code>模块</p>
<p>该模块设计为支持<code>whoosh</code>、<code>solr</code>、<code>Xapian</code>、<code>Elasticsearch</code>四种全文检索引擎后端</p>
<p>使用<code>haystack</code>模块，不用更改代码，直接切换引擎，可以极大的减少代码量</p>
<p><code>haystack</code>属于一种<strong>全文检索</strong>的框架</p>
</blockquote>
<hr>
<ul>
<li><strong><code>whoosh</code></strong></li>
</ul>
<blockquote>
<p>纯<code>Python</code>编写的全文搜索引擎，是目前最快的<code>python</code>所编写的检索引擎，虽然性能比不上<code>solr</code>、<code>Xapian</code>、<code>Elasticsearch</code>等；但是无二进制包，程序不会莫名其妙的崩溃，对于小型的站点，<code>whoosh</code>已经足够使用</p>
</blockquote>
<ul>
<li><strong><code>solr</code></strong></li>
</ul>
<blockquote>
<p><code>Solr</code>是一个高性能，采用<code>Java5</code>开发，基于<code>Lucene</code>的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎</p>
<p><code>Lucene</code>：不是一个完整的<strong>全文检索引擎</strong>，是一个全文检索引擎的<strong>架构</strong>，提供了完整的查询引擎和索引引擎，<code>Lucene</code>的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能</p>
</blockquote>
<ul>
<li><strong><code>Xapian</code></strong></li>
</ul>
<blockquote>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">&gt; Xapian`是一个用`C++`编写的全文检索程序，他的作用类似于`Java`的`lucene</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><strong><code>Elasticsearch</code></strong></li>
</ul>
<blockquote>
<p><code>ElasticSearch</code>是一个基于<code>Lucene</code>的搜索服务器它提供了一个分布式多用户能力的全文搜索引擎，基于<code>RESTful web</code>接口</p>
<p><code>Elasticsearch</code>是用Java开发的，并作为<code>Apache</code>许可条款下的开放源码发布，是当前流行的企业级搜索引擎。该引擎常设计用于云计算中；能够达到<strong>实时搜索</strong>，<strong>稳定</strong>，<strong>可靠</strong>，<strong>快速</strong>，<strong>安装</strong>使用方便</p>
</blockquote>
<h3 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h3><blockquote>
<p><code>whoosh</code>作为一个全文搜索引擎模块</p>
<p>分词功能和检索功能已经非常强大，但是针对中文的处理还是比较欠缺</p>
<p>可以通过<code>Jieba</code>模块重写分词操作，支持<code>whoosh</code>对中文的强大操作</p>
</blockquote>
<ul>
<li>安装中文分词模块</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> jieba</span><br></pre></td></tr></table></figure>

<ul>
<li><p>除了<code>jieba</code>分词，现在还有很多付费的中文分词模块</p>
<blockquote>
<p><a href="http://ictclas.nlpir.org/nlpir/" target="_blank" rel="noopener">中科院计算所NLPIR</a></p>
<p><a href="https://github.com/NLPchina/ansj_seg" target="_blank" rel="noopener"><code>ansj</code>分词器</a></p>
<p><a href="https://github.com/HIT-SCIR/ltp" target="_blank" rel="noopener">哈工大的<code>LTP</code></a></p>
<p><a href="https://github.com/thunlp/THULAC" target="_blank" rel="noopener">清华大学<code>THULAC</code></a></p>
<p><a href="https://nlp.stanford.edu/software/segmenter.shtml" target="_blank" rel="noopener">斯坦福分词器</a></p>
<p><a href="https://github.com/hankcs/HanLP" target="_blank" rel="noopener"><code>Hanlp</code>分词器</a></p>
<p><a href="https://github.com/yanyiwu/cppjieba" target="_blank" rel="noopener">结巴分词</a></p>
<p><a href="https://github.com/koth/kcws" target="_blank" rel="noopener"><code>KCWS</code>分词器(字嵌入<code>+Bi-LSTM+CRF</code>)</a></p>
<p><a href="https://github.com/frcchang/zpar/releases" target="_blank" rel="noopener"><code>ZPar</code></a></p>
<p><a href="https://github.com/wks/ik-analyzer" target="_blank" rel="noopener"><code>IKAnalyzer</code></a></p>
</blockquote>
</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>首先安装<code>HayStack</code>框架以及<code>whoosh</code>搜索引擎</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install django-haystack</span><br><span class="line">pip install whoosh</span><br></pre></td></tr></table></figure>

<h3 id="settings配置"><a href="#settings配置" class="headerlink" title="settings配置"></a>settings配置</h3><ul>
<li>添加<code>haystack</code>应用到项目的<code>settings</code>文件下的<code>app</code>部分</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [ </span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,	</span><br><span class="line">    ...   </span><br><span class="line">    <span class="string">'haystack'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>添加搜索引擎，这里使用<code>whoosh</code>引擎</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">HAYSTACK_CONNECTIONS = &#123;  </span><br><span class="line">    <span class="string">'default'</span>: &#123;      </span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'haystack.backends.whoosh_cn_backend.WhooshEngine'</span>,   </span><br><span class="line">        <span class="string">'PATH'</span>: os.path.join(BASE_DIR, <span class="string">'whoosh_index'</span>),  </span><br><span class="line">    &#125;&#125;</span><br><span class="line"><span class="comment">#这里使用django的信号机制，在数据表发生改动时自动更新whoosh的查询索引</span></span><br><span class="line">HAYSTACK_SIGNAL_PROCESSOR = <span class="string">'haystack.signals.RealtimeSignalProcessor'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里要注意的是，我们使用的引擎为<code>whoosh_cn_backend</code></p>
<p>本身的<code>whoosh</code>引擎名为：<code>whoosh_backend</code></p>
<p><code>whoosh_cn_backend</code>将在接下来我们对安装目录下的引擎文件复制修改得来</p>
</blockquote>
<ul>
<li>在项目的路由文件下配置查询的路由映射</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include,re_path</span><br><span class="line">urlpatterns = [   </span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),  </span><br><span class="line">    re_path(<span class="string">'^search/'</span>,include(<span class="string">'haystack.urls'</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当查询条件被提交时，会跳转至<code>search</code>路由</p>
<p>并且查询条件会作为<code>get</code>请求时的连接参数传入，参数<code>key</code>值为<code>q</code></p>
</blockquote>
<h3 id="创建索引文件"><a href="#创建索引文件" class="headerlink" title="创建索引文件"></a>创建索引文件</h3><ul>
<li>接下来，在需要被搜索的<code>app</code>下建立<code>search_indexes.py</code>文件，该文件名不许变更</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#app.models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(models.Model)</span>:</span>    </span><br><span class="line">    <span class="comment"># 用户表 </span></span><br><span class="line">    name = models.CharField(   </span><br><span class="line">        max_length=<span class="number">50</span>,  </span><br><span class="line">        verbose_name=<span class="string">'昵称'</span>  </span><br><span class="line">    )   </span><br><span class="line">    account = models.CharField(max_length=<span class="number">50</span>,verbose_name=<span class="string">'账号'</span>,unique=<span class="literal">True</span>)</span><br><span class="line">    passwd = models.CharField(max_length=<span class="number">50</span>,verbose_name=<span class="string">'密码'</span>) </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>    </span><br><span class="line">        <span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#app.search_indexes.py</span></span><br><span class="line"><span class="keyword">from</span> haystack <span class="keyword">import</span> indexes</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserIndex</span><span class="params">(indexes.SearchIndex, indexes.Indexable)</span>:</span></span><br><span class="line">    text = indexes.CharField(document=<span class="literal">True</span>, use_template=<span class="literal">True</span>) </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_model</span><span class="params">(self)</span>:</span>    </span><br><span class="line">        <span class="keyword">return</span> models.User  <span class="comment"># 当前模型文件下需要被检索的模型类   </span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index_queryset</span><span class="params">(self, using=None)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> self.get_model().objects.all()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该类为索引类，类名为模型类的名称<code>+Index</code>：比如模型类为<code>People</code>,则这里类名为<code>PeopleIndex</code></p>
<p><code>get_model</code>函数用来获取当前索引类所关联的模型类，这里我们关联上面的<code>User</code> 类对象</p>
<p><code>text=indexes.CharField</code>语句指定了将模型类中的哪些字段建立索引，而<code>use_template=True</code>说明后续我们将通过一个<strong>数据模板</strong>文件来指明需要检索的字段</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt; <span class="attribute">document</span>=<span class="literal">True</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>为什么要创建索引：索引就像是一本书的目录，可以为读者提供更快速的导航与查找</p>
</blockquote>
<h3 id="创建模板数据文件"><a href="#创建模板数据文件" class="headerlink" title="创建模板数据文件"></a>创建模板数据文件</h3><ul>
<li>创建数据模板文件</li>
</ul>
<blockquote>
<p>数据模板文件路径：<code>templates/search/indexes/yourapp/note_text.txt</code></p>
<p>放在任何一个你的<code>Django</code>能搜索到的模板文件夹<code>template</code>下面均可，这个文件主要确定要检索的字段，为他们建立索引</p>
<p>文件名必须为要索引的类名<code>_text.txt</code>，比如这里我们检索的类名是<code>User</code>，那么对应的数据模板文件名为<code>user_text.txt</code>，文件名小写即可</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#template</span><span class="selector-class">.search</span><span class="selector-class">.indexes</span><span class="selector-class">.people</span><span class="selector-class">.user_text</span><span class="selector-class">.txt</span></span><br><span class="line">&#123;&#123; <span class="selector-tag">object</span><span class="selector-class">.name</span> &#125;&#125;</span><br><span class="line">&#123;&#123; <span class="selector-tag">object</span><span class="selector-class">.account</span> &#125;&#125;</span><br><span class="line">&#123;&#123; <span class="selector-tag">object</span><span class="selector-class">.online_time</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在数据模板文件中使用模板语法，写入需要建立索引的字段，这里我们将模型类中<code>name</code>、<code>account</code>以及<code>online_time</code>字段设置索引，当检索时会对这三个字段去做全文检索</p>
</blockquote>
<blockquote>
<p>接下来创建一个搜索结果展示页面</p>
</blockquote>
<h3 id="检索结果模板页面"><a href="#检索结果模板页面" class="headerlink" title="检索结果模板页面"></a>检索结果模板页面</h3><ul>
<li>创建检索结果展示页面</li>
</ul>
<blockquote>
<p>检索结果展示页面，需要在固定的目录路径下进行模板页面的编写</p>
<p>路径为：<code>templates/search/</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&#123;% if query %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>搜索结果如下：<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    &#123;% for result in page.object_list %&#125;</span><br><span class="line">        &#123;&#123; result.object.name &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        &#123;&#123; result.object.account &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        &#123;&#123; result.object.online_time &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;% empty %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>没找到<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    </span><br><span class="line">    &#123;% if page.has_previous or page.has_next %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            &#123;% if page.has_previous %&#125;</span><br><span class="line">            	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"?q=&#123;&#123; query &#125;&#125;&amp;amp;page=&#123;&#123; page.previous_page_number &#125;&#125;"</span>&gt;</span></span><br><span class="line">            		上一页</span><br><span class="line">            	<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">            &#123;% if page.has_next %&#125;</span><br><span class="line">            	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"?q=&#123;&#123; query &#125;&#125;&amp;amp;page=&#123;&#123; page.next_page_number &#125;&#125;"</span>&gt;</span></span><br><span class="line">            		下一页</span><br><span class="line">            	<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个模板页面中已经自带了分页功能，可以按照需求修改</p>
</blockquote>
<ul>
<li>创建检索模板页面内容</li>
</ul>
<blockquote>
<p>还需要有一个表单，提交检索信息</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">'get'</span> <span class="attr">action</span>=<span class="string">"/search/"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"q"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"查询"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这部分检索的模板页面内容可以在你的项目中进行添加，查询方式为<code>get</code>，并且检索输入的表单框<code>name</code>属性必须为<code>q</code></p>
</blockquote>
<h3 id="中文分词配置"><a href="#中文分词配置" class="headerlink" title="中文分词配置"></a>中文分词配置</h3><ul>
<li>接下来，需要创建有关中文检索的配置文件，这里的配置文件创建为全局</li>
</ul>
<blockquote>
<p>进入到<code>python</code>的安装目录下，比如我的目录为：<code>C:\Python37\Lib\site-packages\haystack\backends</code></p>
<p>在该路径下创建名为<code>ChineseAnalyzer.py</code>的中文分词文件</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">from</span> whoosh.analysis <span class="keyword">import</span> Tokenizer, Token</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChineseTokenizer</span><span class="params">(Tokenizer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, value, positions=False, chars=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                 keeporiginal=False, removestops=True,start_pos=<span class="number">0</span>, start_char=<span class="number">0</span>, mode=<span class="string">''</span>, **kwargs)</span>:</span></span><br><span class="line">        t = Token(positions, chars, removestops=removestops, mode=mode, **kwargs)</span><br><span class="line">        seglist = jieba.cut(value, cut_all=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> seglist:</span><br><span class="line">            t.original = t.text = w</span><br><span class="line">            t.boost = <span class="number">1.0</span></span><br><span class="line">            <span class="keyword">if</span> positions:</span><br><span class="line">                t.pos = start_pos + value.find(w)</span><br><span class="line">            <span class="keyword">if</span> chars:</span><br><span class="line">                t.startchar = start_char + value.find(w)</span><br><span class="line">                t.endchar = start_char + value.find(w) + len(w)</span><br><span class="line">            <span class="keyword">yield</span> t</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ChineseAnalyzer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ChineseTokenizer()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个文件中，定义了一个<code>ChineseAnalyzer</code>的函数，这个函数将替代搜索引擎配置文件中的分词方式</p>
</blockquote>
<ul>
<li>复制引擎文件，修改分词方式为中文</li>
</ul>
<blockquote>
<p>同样在该文件夹下<code>C:\Python37\Lib\site-packages\haystack\backends</code>，复制<code>whoosh_backend.py</code>文件，创建一个新的文件名为<code>whoosh_cn_backend.py</code>，这里复制出一份文件也是为了之后如果不需要使用中文分词，可以直接在<code>settings</code>配置文件中修改引擎为<code>&#39;ENGINE&#39;:&#39;haystack.backends.whoosh_backend.WhooshEngine&#39;,</code></p>
</blockquote>
<blockquote>
<p>修改该引擎配置文件中的：<code>analyzer=StemmingAnalyzer()</code>变为<code>analyzer=ChineseAnalyzer()</code></p>
<p>并且要记得在头部引入刚才所编写的中文分词文件</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#whoosh_cn_backend.py</span></span><br><span class="line"><span class="keyword">from</span> .ChineseAnalyzer <span class="keyword">import</span> ChineseAnalyzer</span><br></pre></td></tr></table></figure>

<h3 id="初始化索引"><a href="#初始化索引" class="headerlink" title="初始化索引"></a>初始化索引</h3><ul>
<li>最后，初始化索引数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py rebuild_index</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Admin</title>
    <url>/Django%E4%B8%AD%E7%9A%84Admin%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="Admin"><a href="#Admin" class="headerlink" title="Admin"></a>Admin</h2><blockquote>
<p><code>Django-admin</code>界面是框架为我们提供的<code>Web-APP</code>的管理工具</p>
<p>在之前的练习中，我们已经多次使用它进行<code>APP</code>中表的<code>DML</code>语句操作</p>
<p>接下来，我们可以继续来学习，如何将<code>Admin</code>界面进行优化扩展，更加方便我们后台管理</p>
</blockquote><a id="more"></a>
<h3 id="admin注册设置"><a href="#admin注册设置" class="headerlink" title="admin注册设置"></a>admin注册设置</h3><blockquote>
<p>在<code>admin</code>界面中，我们可以通过继承<code>admin.ModelAdmin</code>类进行自定义<code>admin</code>类的编写，用作控制展示后台所显示的数据，以及排序规则等等属性，基本语法像是下面这样</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">	name = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#admin.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    fields = (<span class="string">'name'</span>,<span class="string">'age'</span>)</span><br><span class="line">    <span class="comment"># 控制admin界面模型类展示字段</span></span><br><span class="line">admin.site.register(User, UserAdmin)</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="常用字段"><a href="#常用字段" class="headerlink" title="常用字段"></a>常用字段</h4><ul>
<li><code>list_display</code>：在<code>admin</code>控制台数据列表页面展示更多的字段</li>
<li><code>list_display_links</code>：用来设置当前列表中由<code>list_display</code>所设置的字段哪些可以点击</li>
<li><code>fieldsets</code>：将<code>admin</code>界面下的表单输入栏进行分块</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    fields = (<span class="string">'name'</span>,<span class="string">'age'</span>)</span><br><span class="line">    fieldsets = (</span><br><span class="line">    	(<span class="string">'第一个区域'</span>，</span><br><span class="line">        	&#123;</span><br><span class="line">                <span class="string">'fields'</span>: (<span class="string">'name'</span>,)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">       	(<span class="string">'第二个区域'</span>，</span><br><span class="line">        	&#123;</span><br><span class="line">                <span class="string">'fields'</span>: (<span class="string">'age'</span>,)</span><br><span class="line">            &#125;</span><br><span class="line">        )     </span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>search_fields</code>：在<code>admin</code>数据展示页，设置一个搜索框，设置的分段是可查找的属性</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">search_fields</span> =（<span class="string">'name'</span>，）</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>list_filter</code>：以什么分解进行过滤，在<code>admin</code>页面上方展示</p>
</li>
<li><p><code>ordering</code>：数据列表可以通过某些细分进行排序</p>
</li>
</ul>
<h3 id="利用现有用户系统"><a href="#利用现有用户系统" class="headerlink" title="利用现有用户系统"></a>利用现有用户系统</h3><blockquote>
<p><code>from django.contrib.auth.models import User</code></p>
</blockquote>
<h4 id="用户字段"><a href="#用户字段" class="headerlink" title="用户字段"></a>用户字段</h4><ul>
<li><p><code>username</code></p>
<blockquote>
<p>必选。少于等于30个字符。用户名可以包含字母，数字，<code>_</code>， ，<code>@</code>，。<code>+</code>状语从句：<code>-</code>字符</p>
</blockquote>
</li>
<li><p><code>first_name</code></p>
<blockquote>
<p>任选。等于等于30个字符</p>
</blockquote>
</li>
<li><p><code>last_name</code></p>
<blockquote>
<p>可选。可以输入30个字符</p>
</blockquote>
</li>
<li><p><code>email</code></p>
<blockquote>
<p>任选。邮箱地址</p>
</blockquote>
</li>
<li><p><code>password</code></p>
<blockquote>
<p>必选。密码的哈希及元数据。（<code>Django</code>不保存原始密码）。原始密码可以无限长而且可以包含任意字符</p>
</blockquote>
</li>
<li><p><code>is_staff</code></p>
<blockquote>
<p>布尔值。指示用户是否可以访问<code>Admin</code>站点</p>
</blockquote>
</li>
<li><p><code>is_active</code></p>
<blockquote>
<p>布尔值。用户的账号是否激活。长使用这个标志为False来代替删除账号</p>
</blockquote>
</li>
<li><p><code>is_superuser</code></p>
<blockquote>
<p>布尔值。指定这个用户拥有所有的权限而不需要给他们分配明确的权限</p>
</blockquote>
</li>
<li><p><code>last_login</code></p>
<blockquote>
<p>用户最后一次登录的时间。如果这个用户没有登录过，这个细分将会是<code>null</code></p>
<p>之前版本默认设置为的当前的<code>datetime</code></p>
</blockquote>
</li>
<li><p><code>date_joined</code></p>
<blockquote>
<p>帐户创建的时间。当账号创建时，替代设置为当前的<code>datetime</code></p>
</blockquote>
</li>
</ul>
<h4 id="用户实例方法"><a href="#用户实例方法" class="headerlink" title="用户实例方法"></a>用户实例方法</h4><ul>
<li><p><code>get_username()</code></p>
<blockquote>
<p>获取到当前的用户的用户名属性</p>
</blockquote>
</li>
<li><p><code>is_authenticated()</code></p>
<blockquote>
<p>检查用户是否已通过认证</p>
</blockquote>
</li>
<li><p><code>is_anonymous()</code></p>
<blockquote>
<p>检查用户是否未通过认证</p>
</blockquote>
</li>
<li><p><code>set_password(password)</code></p>
<blockquote>
<p>设置保存用户的密码，和会负责密码的哈希加密工作</p>
<p>通常修改密码之后还需要调用<code>save()</code>方法进行数据更新</p>
</blockquote>
</li>
</ul>
<h4 id="用户表方法"><a href="#用户表方法" class="headerlink" title="用户表方法"></a>用户表方法</h4><ul>
<li><p><code>create_user(username, email=None, password=None, **extra_fields)</code></p>
<blockquote>
<p><code>django</code>的用户创建需要使用<code>User</code>表管理器中的<code>create_user</code>函数进行</p>
<p>该函数可以创建并保存一个用户</p>
</blockquote>
</li>
<li><p><code>create_superuser(username, email, password, **extra_fields)</code></p>
<blockquote>
<p>与上一个创建用户函数功能相同，但是额外会设置用户的<code>is_staff</code>及<code>is_superuser</code>属性为<code>True</code></p>
<p>创建一个<code>admin</code>后台超级用户</p>
</blockquote>
</li>
</ul>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul>
<li><p><code>authenticate(username,password)</code></p>
<blockquote>
<p>验证是否为合法用户，如果用户存在合法则返回一个用户对象</p>
</blockquote>
</li>
<li><p><code>logout()</code></p>
<blockquote>
<p>清除当前浏览器下用户<code>session</code></p>
</blockquote>
</li>
<li><p><code>login(request,user)</code></p>
<blockquote>
<p>登录并保存当前用户<code>session</code></p>
<p>接受参数为<code>HttpRequest</code>请求及一个<code>User</code>用户对象</p>
<p>参数<code>user</code>必须为使用<code>authenticate</code>验证过后的用户对象</p>
</blockquote>
</li>
</ul>
<h4 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h4><ul>
<li>登陆所需表单类</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#forms.py</span></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span><span class="params">(forms.Form)</span>:</span></span><br><span class="line">	username = forms.CharField(label=<span class="string">"用户名"</span>,required=<span class="literal">True</span>,)</span><br><span class="line">    password = forms.CharField(</span><br><span class="line">        widget=forms.PasswordInput(),</span><br><span class="line">        label=<span class="string">'密码'</span>,</span><br><span class="line">        required=<span class="literal">True</span>,</span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_username</span><span class="params">(self)</span>:</span></span><br><span class="line">        username = self.cleaned_data.get(<span class="string">"username"</span>).strip()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            User.objects.get(username=username)</span><br><span class="line">        <span class="keyword">except</span> User.DoesNotExist:</span><br><span class="line">            <span class="keyword">raise</span> forms.ValidationError(<span class="string">"用户名 %s 不存在"</span> % username)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> username</span><br></pre></td></tr></table></figure>

<ul>
<li>登录所需模板页面</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">'/login/'</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">		&#123;% csrf_token %&#125;</span><br><span class="line">		&#123;&#123; errors &#125;&#125;</span><br><span class="line">			&#123;% for field in form %&#125;</span><br><span class="line">				<span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">				&#123;% if field.errors %&#125;</span><br><span class="line">				<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">					&#123;% for error in field.errors%&#125;</span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; error &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					&#123;% endfor %&#125;</span><br><span class="line">				<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">				&#123;% endif %&#125;</span><br><span class="line">				<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; field.label &#125;&#125;: &#123;&#123; field &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		&#123;% endfor %&#125;</span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>登陆主要视图逻辑</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> authenticate,logout <span class="keyword">as</span> auth_logout,login <span class="keyword">as</span> auth_login</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">		form = userForm()</span><br><span class="line">		<span class="keyword">return</span> render(request, <span class="string">"login.html"</span>,&#123;<span class="string">'form'</span>:form&#125;)</span><br><span class="line">	form = userForm(request.POST)</span><br><span class="line">    username = form.data[<span class="string">'username'</span>]</span><br><span class="line">    password = form.data[<span class="string">'password'</span>]</span><br><span class="line">    user = authenticate(username=username,password=password)</span><br><span class="line">    <span class="comment"># 验证当前账号密码是否匹配合法</span></span><br><span class="line">    <span class="keyword">if</span> user <span class="keyword">and</span> user.is_active:</span><br><span class="line">        auth_login(request, user)</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">'/'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> render(request, <span class="string">"login.html"</span>,&#123;<span class="string">'form'</span>:form,<span class="string">'errors'</span>:<span class="string">'用户名或密码错误'</span>&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在用户登录成功之后，将会重新进入主页，主页展示当前登录用户</p>
<p>登录用户可以直接在<code>request.user</code>属性中获取到，主页的模板内容如下</p>
</blockquote>
<ul>
<li>主页模板</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	欢迎你: &#123;&#123; user &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>主页视图函数可以通过装饰器<code>@login_required</code>或判断<code>is_authenticated</code>状态来查看用户是否登录</p>
<p>只有登录用户可以访问该站点</p>
<p>使用当装饰器<code>@login_required</code>时，在需要<code>settings</code>下设置<code>LOGIN_URL = &#39;/login/&#39;</code></p>
<p>引入属性设置为登录路由</p>
</blockquote>
<ul>
<li>首页视图函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.decorators <span class="keyword">import</span> login_required</span><br><span class="line"><span class="comment">#@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.user.is_authenticated():</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">"index.html"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">'/login/'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="注册功能"><a href="#注册功能" class="headerlink" title="注册功能"></a>注册功能</h4><ul>
<li>注册所需表单</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#forms.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterForm</span><span class="params">(forms.Form)</span>:</span></span><br><span class="line">    username = forms.CharField(label=<span class="string">"用户名"</span>,</span><br><span class="line">        max_length=<span class="number">30</span>,</span><br><span class="line">        required=<span class="literal">True</span>,</span><br><span class="line">        error_messages=&#123;<span class="string">'max_length'</span>:<span class="string">'账号长度最长为30'</span>&#125;,</span><br><span class="line">    )</span><br><span class="line">    password = forms.CharField(label=<span class="string">"密码"</span>,</span><br><span class="line">        min_length=<span class="number">6</span>, max_length=<span class="number">30</span>, </span><br><span class="line">        widget=forms.PasswordInput(), </span><br><span class="line">        required=<span class="literal">True</span>,</span><br><span class="line">            error_messages=&#123;<span class="string">'min_length'</span>:<span class="string">'密码长度最短为6'</span>&#125;,</span><br><span class="line">        )</span><br><span class="line">	check_password = forms.CharField(label=<span class="string">"重复密码"</span>, </span><br><span class="line">		min_length=<span class="number">6</span>, max_length=<span class="number">30</span>, </span><br><span class="line">		widget=forms.PasswordInput(), </span><br><span class="line">		required=<span class="literal">True</span>,</span><br><span class="line">		error_messages=&#123;<span class="string">'min_length'</span>:<span class="string">'密码长度最短为6'</span>&#125;,</span><br><span class="line">	)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">clean_check_password</span><span class="params">(self)</span>:</span></span><br><span class="line">		password = self.cleaned_data.get(<span class="string">'password'</span>)</span><br><span class="line">		check_password = self.cleaned_data.get(<span class="string">'check_password'</span>)</span><br><span class="line">		<span class="keyword">if</span> password != check_password <span class="keyword">and</span> password <span class="keyword">and</span> check_password:</span><br><span class="line">			<span class="keyword">raise</span> ValidationError(<span class="string">"重复输入密码错误"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">clean_username</span><span class="params">(self)</span>:</span></span><br><span class="line">		username = self.cleaned_data.get(<span class="string">'username'</span>)</span><br><span class="line">		<span class="keyword">if</span> username[:<span class="number">1</span>] == <span class="string">'_'</span>:</span><br><span class="line">			<span class="keyword">raise</span> forms.ValidationError(<span class="string">"用户名不能以下划线打头"</span>)</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			User.objects.get(username=username)</span><br><span class="line">		<span class="keyword">except</span> User.DoesNotExist:</span><br><span class="line">			<span class="keyword">return</span> username </span><br><span class="line">		<span class="keyword">raise</span> forms.ValidationError(<span class="string">"用户名已存在"</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>表单中，将对用户两次输入的密码进行校验和判断是否为空，而且分开下划线作为用户名的开头字符</p>
</blockquote>
<ul>
<li>注册主要视图函数逻辑</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        form = RegisterForm(request.POST)</span><br><span class="line">        <span class="keyword">if</span> form.is_valid():</span><br><span class="line">            username = form.cleaned_data[<span class="string">'username'</span>]</span><br><span class="line">            password = form.cleaned_data[<span class="string">'password'</span>]</span><br><span class="line">            User.objects.create_user(username=username,password=password)</span><br><span class="line">            user = authenticate(username=username,password=password)</span><br><span class="line">            auth_login(request, user)</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">'/'</span>)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        form = RegisterForm()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"register.html"</span>,&#123;<span class="string">'form'</span>:form&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过表单验证，并获取到对应的用户账号密码，创建成功之后，验证并登录，并重定向到首页</p>
</blockquote>
<ul>
<li>主页模板页面</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	&#123;% if request.user.is_authenticated %&#125;</span><br><span class="line">	 	<span class="tag">&lt;<span class="name">p</span>&gt;</span>您已登录:<span class="tag">&lt;/<span class="name">p</span>&gt;</span> &#123;&#123; user &#125;&#125;</span><br><span class="line">	&#123;% else %&#125;</span><br><span class="line">	<span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">'/register/'</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">		&#123;% csrf_token %&#125;</span><br><span class="line">		&#123;% for field in form %&#125;</span><br><span class="line">			<span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">			&#123;% if field.errors %&#125;</span><br><span class="line">			<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">			&#123;% for error in field.errors%&#125;</span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; error &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				&#123;% endfor %&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">			&#123;% endif %&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; field.label &#125;&#125;: &#123;&#123; field &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		&#123;% endfor %&#125;</span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"注册"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">	&#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当用户已经登录时，显示当前登录用户，反之则展示表单，以供用户填写</p>
</blockquote>
<h3 id="重载admin用户系统"><a href="#重载admin用户系统" class="headerlink" title="重载admin用户系统"></a>重载admin用户系统</h3><blockquote>
<p><code>django</code>自带的<code>admin</code>模块下的用户系统主要负责用户帐户，组，权限和基于<code>cookie</code>的会话等业务</p>
<p>认证系统由以下部分组成：</p>
<p>用户：包含用户数据细分，是实现业务功能逻辑的基础</p>
<p>权限：控制用户进入否可以执行某项任务的二进制（是/否）标志。</p>
<p>组：一种为多个用户加上标签和权限的常用方式。</p>
<p>消息：一种为指定用户生成简单消息嵌入的方式</p>
</blockquote>
<h4 id="默认字段"><a href="#默认字段" class="headerlink" title="默认字段"></a>默认字段</h4><ul>
<li><p><code>username</code></p>
<blockquote>
<p>必选项，小于等于30个字符；只能是字母数字（字母，数字和下划线）</p>
</blockquote>
</li>
<li><p><code>first_name</code></p>
<blockquote>
<p>可选项，等于等于30个字符</p>
</blockquote>
</li>
<li><p><code>last_name</code></p>
<blockquote>
<p>可选项，等于等于30个字符</p>
</blockquote>
</li>
<li><p><code>email</code></p>
<blockquote>
<p>可选项。电子邮件地址</p>
</blockquote>
</li>
<li><p><code>password</code></p>
<blockquote>
<p>必选，密码（哈希值，元数据）</p>
<p><code>Django</code>不储存原始密码</p>
<p>原始密码可以是任意长度的，包含任何字符</p>
<p>密码由哈希类型，盐值和哈希值组成，用美元符合分隔</p>
</blockquote>
</li>
<li><p><code>is_staff</code></p>
<blockquote>
<p>布尔值，指明这个用户是否可以进入管理站点的权限</p>
</blockquote>
</li>
<li><p><code>is_active</code></p>
<blockquote>
<p>布尔值，指明这个用户帐户是否是活动的</p>
<p>我们建议把这个标记设置为<code>False</code>来代替删除用户帐户，这样就不会影响指向用户的外键</p>
<p>这个属性不控制用户是否可以登录。登录验证时不会核查<code>is_active</code>标志。</p>
<p>因此，如果在登录时需要检查<code>is_active</code>标志，需要你在自己的登录视图中实现</p>
<p>用于<a href="http://docs.oneele.com/django/topics/auth.html#django.contrib.auth.views.login" target="_blank" rel="noopener"><code>login()</code></a>视图的<a href="http://docs.oneele.com/django/topics/auth.html#django.contrib.auth.forms.AuthenticationForm" target="_blank" rel="noopener"><code>AuthenticationForm</code></a>会执行这个检查，判断用户是否是活跃账户</p>
</blockquote>
</li>
<li><p><code>is_superuser</code></p>
<blockquote>
<p>布尔值，规范用户拥有所有权限（包括显式赋予和非显式赋予的）</p>
</blockquote>
</li>
<li><p><code>last_login</code></p>
<blockquote>
<p>预期情况下设置为用户最后一次登录的日期时间</p>
</blockquote>
</li>
<li><p><code>date_joined</code></p>
<blockquote>
<p>预期情况下设置为用户帐户创建的日期时间</p>
</blockquote>
</li>
</ul>
<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><blockquote>
<p>在项目中，我们将使用电子邮件作为用户的用户名，那么可以在自带用户表中写明</p>
<p><code>USERNAME_FIELD = &#39;email&#39;</code></p>
<p>该属性设置当前表的登陆细分</p>
</blockquote>
<blockquote>
<p>描述我们自定义用户模型上作的唯一标识符分割名称的字符串，分段必须是唯一的，在定义中设置<code>unique=True</code></p>
<p><code>REQUIRED_FIELDS = [&#39;username&#39;]</code></p>
<p>设置当前该基线为必填细分</p>
</blockquote>
<ul>
<li><p><code>is_authenticated()</code></p>
<blockquote>
<p>判断用户是否已通过身份验证的方法，不意味任何权限，而且不检查用户的活动状态</p>
</blockquote>
</li>
<li><p><code>get_username()</code></p>
<blockquote>
<p>返回由USERNAME_FIELD制定的细分的值</p>
</blockquote>
</li>
<li><p>get_full_name（）</p>
<blockquote>
<p>返回<code>first_name</code>加上<code>last_name</code></p>
<p>中间加上一个空格，由于我们重新设置了表分区，那么这个变量函数需要我们重新给定返回值</p>
</blockquote>
</li>
<li><p><code>get_short_name()</code></p>
<blockquote>
<p>一个短的且非正式用户的标识符，返回<code>first_name</code></p>
<p>当你的项目重写该静态或直接去掉了<code>first_name</code>，所以我们必须重新给定这个函数的返回值</p>
</blockquote>
</li>
<li><p><code>set_password()</code></p>
<blockquote>
<p>将用户的密码设置为给定的字符串</p>
</blockquote>
</li>
<li><p><code>has_perm(perm, obj=None)</code></p>
<blockquote>
<p>用户是否具有某个权限，如果给定<code>obj</code>，则需要根据特定对象实例检查权限</p>
</blockquote>
</li>
<li><p><code>has_module_perms(app_label)</code></p>
<blockquote>
<p>如果用户有权访问给定应用中的模型，则返回<code>True</code></p>
<p>这里我们这两个分区都设置为<code>True</code>，可以让用户访问任一<code>APP</code></p>
</blockquote>
</li>
<li><p><code>is_staff()@property</code></p>
<blockquote>
<p>如果用户允许访问管理网站，则返回<code>True</code></p>
<p>这里我们返回<code>is_admin</code>的随机属性即可</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>关于细分属性，如果需要进行高度扩展</p>
<p>可以使用继承<code>AbstractBaseUser</code>这个类</p>
<p>这个类中只含有<code>password</code>， ，<code>last_login</code>以及<code>is_active</code>三个字段属性</p>
</blockquote>
<h4 id="重载管理器"><a href="#重载管理器" class="headerlink" title="重载管理器"></a>重载管理器</h4><blockquote>
<p>由于已经覆盖了替代的<code>admin</code>用户表，现在需要将其对应的管理器函数进行编写</p>
<p>编写时主要关注一下两个父类函数的重写</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create_user(username_field,password_filed=<span class="literal">None</span>,**other_fields)</span><br><span class="line">	normalize_email()将邮件地址规范化的类方法</span><br><span class="line">	user.save(using=self._db)</span><br><span class="line">create_superuser(username, email, password)</span><br><span class="line">	<span class="comment">#用户创建，is_admin设置为True即可</span></span><br><span class="line">    user.save(using=self._db)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> BaseUserManager</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUserManager</span><span class="params">(BaseUserManager)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_user</span><span class="params">(self, username, email, password=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> email :</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Users must have an email address'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> username:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Users must have an username'</span>)</span><br><span class="line">        <span class="comment">#判断邮件和用户名是否具有</span></span><br><span class="line">        now = timezone.now()</span><br><span class="line">        <span class="comment">#获取当前django的时间</span></span><br><span class="line">        user = self.model(</span><br><span class="line">            username=username,</span><br><span class="line">            email=self.normalize_email(email),</span><br><span class="line">            date_joined=now, </span><br><span class="line">            last_login=now,</span><br><span class="line">        )</span><br><span class="line">        user.set_password(password)</span><br><span class="line">        user.save(using=self._db)</span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_superuser</span><span class="params">(self, username, email, password)</span>:</span></span><br><span class="line">        user = self.create_user(username,</span><br><span class="line">            email,</span><br><span class="line">            password=password,</span><br><span class="line">        )</span><br><span class="line">        user.is_admin = <span class="literal">True</span></span><br><span class="line">        user.save(using=self._db)</span><br><span class="line">        <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重新定义新用户表的管理器之后，想要生效，还需要在对应的模型类表中覆盖<code>objects</code>属性</p>
</blockquote>
<ul>
<li><code>objects = MyUserManager()</code></li>
</ul>
<h4 id="重载表"><a href="#重载表" class="headerlink" title="重载表"></a>重载表</h4><blockquote>
<p>下面是一个真实的重载自带用户表的模型类</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> AbstractBaseUser</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Member</span><span class="params">(AbstractBaseUser)</span>:</span></span><br><span class="line">    <span class="comment">#AbstractBaseUser中只含有3个field: password, last_login和is_active.</span></span><br><span class="line">    email = models.EmailField(verbose_name=<span class="string">'邮箱'</span>,max_length=<span class="number">255</span>,unique=<span class="literal">True</span>,)</span><br><span class="line">    username = models.CharField(verbose_name=<span class="string">"用户名"</span>, max_length=<span class="number">16</span>, unique=<span class="literal">True</span>)</span><br><span class="line">    weibo_id = models.CharField(verbose_name=<span class="string">"新浪微博"</span>, max_length=<span class="number">30</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    blog = models.CharField(verbose_name=<span class="string">"个人网站"</span>, max_length=<span class="number">200</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    location = models.CharField(verbose_name=<span class="string">"城市"</span>, max_length=<span class="number">10</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    profile = models.CharField(verbose_name=<span class="string">"个人简介"</span>, max_length=<span class="number">140</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    avatar = models.CharField(verbose_name=<span class="string">"头像"</span>, max_length=<span class="number">128</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    au = models.IntegerField(verbose_name=<span class="string">"用户活跃度"</span>, default=<span class="number">0</span>)</span><br><span class="line">    last_ip = models.IPAddressField(verbose_name=<span class="string">"上次访问IP"</span>, default=<span class="string">"0.0.0.0"</span>)</span><br><span class="line">    email_verified = models.BooleanField(verbose_name=<span class="string">"邮箱是否验证"</span>, default=<span class="literal">False</span>)</span><br><span class="line">    date_joined = models.DateTimeField(verbose_name=<span class="string">"用户注册时间"</span>, default=timezone.now)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    topic_num = models.IntegerField(verbose_name=<span class="string">"帖子数"</span>, default=<span class="number">0</span>)</span><br><span class="line">    comment_num = models.IntegerField(verbose_name=<span class="string">"评论数"</span>, default=<span class="number">0</span>)</span><br><span class="line">    is_active = models.BooleanField(default=<span class="literal">True</span>)</span><br><span class="line">    is_admin = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    objects = MyUserManager()</span><br><span class="line">    <span class="comment">#objects就是我们之前一直使用的管理器</span></span><br><span class="line">    <span class="comment">#管理器用来维护我们的增删改查</span></span><br><span class="line"></span><br><span class="line">    USERNAME_FIELD = <span class="string">'email'</span></span><br><span class="line">    REQUIRED_FIELDS = [<span class="string">'username'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.username</span><br><span class="line">    <span class="comment">#标签中的数据实例</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_email_verified</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.email_verified</span><br><span class="line">    <span class="comment">#我们可以在模板中，通过实例出来的对象数据进行这个函数的调取，获取他是否验证过</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_weibo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weibo_id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_username</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.username</span><br><span class="line">        <span class="comment">#方法的圆括号在templates标签中必需省略！！</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_email</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.email</span><br><span class="line">        <span class="comment">#方法的圆括号在templates标签中必需省略！！</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_full_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># The user is identified by their email address</span></span><br><span class="line">        <span class="keyword">return</span> self.email</span><br><span class="line">        <span class="comment">#get_full_name本来是获取first_name和last_name的</span></span><br><span class="line">        <span class="comment">#但是由于我们重新设置了表结构，那么这个函数必须自定义</span></span><br><span class="line">        <span class="comment">#方法的圆括号在templates标签中必需省略！！</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_short_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># The user is identified by their email address</span></span><br><span class="line">        <span class="keyword">return</span> self.username</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_perm</span><span class="params">(self, perm, obj=None)</span>:</span></span><br><span class="line">        <span class="string">"Does the user have a specific permission?"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_module_perms</span><span class="params">(self, app_label)</span>:</span></span><br><span class="line">        <span class="string">"Does the user have permissions to view the app `app_label`?"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_au</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        计算活跃度</span></span><br><span class="line"><span class="string">        公式：Topic * 5 + Comment * 1</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.au = self.topic_num * <span class="number">5</span> + self.comment_num * <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.au</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="comment">#类中函数可以直接做为属性使用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_staff</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"Is the user a member of staff?"</span></span><br><span class="line">        <span class="comment"># Simplest possible answer: All admins are staff</span></span><br><span class="line">        <span class="keyword">return</span> self.is_admin</span><br></pre></td></tr></table></figure>

<h4 id="重载Admin表单"><a href="#重载Admin表单" class="headerlink" title="重载Admin表单"></a>重载Admin表单</h4><blockquote>
<p>由于修改了默认的<code>django</code>表结构，此时在<code>admin</code>界面修改密码或添加用户数据已经不能再按照之前的表单系统啦</p>
<p>需要在<code>app</code>的<code>admin.py</code>中重写<code>UserCreationForm</code>和<code>UserChangeForm</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户创建表单</span></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.admin <span class="keyword">import</span> UserAdmin</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.forms <span class="keyword">import</span> ReadOnlyPasswordHashField</span><br><span class="line"><span class="keyword">from</span> people.models <span class="keyword">import</span> Member, Follower</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCreationForm</span><span class="params">(forms.ModelForm)</span>:</span></span><br><span class="line">    <span class="string">"""A form for creating new users. Includes all the required</span></span><br><span class="line"><span class="string">    fields, plus a repeated password."""</span></span><br><span class="line">    password1 = forms.CharField(label=<span class="string">'密码'</span>, widget=forms.PasswordInput)</span><br><span class="line">    password2 = forms.CharField(label=<span class="string">'确认密码'</span>, widget=forms.PasswordInput)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Member</span><br><span class="line">        fields = (<span class="string">'email'</span>, <span class="string">'username'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_password2</span><span class="params">(self)</span>:</span></span><br><span class="line">        password1 = self.cleaned_data.get(<span class="string">"password1"</span>)</span><br><span class="line">        password2 = self.cleaned_data.get(<span class="string">"password2"</span>)</span><br><span class="line">        <span class="keyword">if</span> password1 <span class="keyword">and</span> password2 <span class="keyword">and</span> password1 != password2:</span><br><span class="line">            <span class="keyword">raise</span> forms.ValidationError(<span class="string">"两次输入验证失败"</span>)</span><br><span class="line">        <span class="keyword">return</span> password2</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#在form中的clean__field函数会在is_valid()函数验证时自动调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, commit=True)</span>:</span></span><br><span class="line">        user = super(UserCreationForm, self).save(commit=<span class="literal">False</span>)</span><br><span class="line">        user.set_password(self.cleaned_data[<span class="string">"password1"</span>])</span><br><span class="line">        <span class="comment">#set_password将会采用django的加密算法将密码设置到对应的模型实例中</span></span><br><span class="line">        <span class="comment">#在内存中创建的好的对象只有通过commit=True才被真正执行到数据库上</span></span><br><span class="line">        <span class="keyword">if</span> commit:</span><br><span class="line">            user.save()</span><br><span class="line">        <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 密码改变时的展示表单</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserChangeForm</span><span class="params">(forms.ModelForm)</span>:</span></span><br><span class="line">    password = ReadOnlyPasswordHashField()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Member</span><br><span class="line">        fields = (<span class="string">'email'</span>, <span class="string">'password'</span>, <span class="string">'username'</span>, <span class="string">'is_active'</span>, <span class="string">'is_admin'</span>,)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_password</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.initial[<span class="string">"password"</span>]</span><br><span class="line">    <span class="comment">#使用默认的save函数即可</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 真正的用户admin界面管理方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUserAdmin</span><span class="params">(UserAdmin)</span>:</span></span><br><span class="line">    form = UserChangeForm</span><br><span class="line">    add_form = UserCreationForm</span><br><span class="line">    list_display = (<span class="string">'id'</span>, <span class="string">'email'</span>, <span class="string">'username'</span>, <span class="string">'email_verified'</span>, <span class="string">'last_login'</span>,<span class="string">'is_active'</span>,<span class="string">'is_admin'</span>,<span class="string">'last_ip'</span>)</span><br><span class="line">    list_display_links = (<span class="string">'id'</span>, <span class="string">'email'</span>, <span class="string">'username'</span>)</span><br><span class="line">    list_filter = (<span class="string">'email'</span>, <span class="string">'email_verified'</span>,)</span><br><span class="line">    fieldsets = (</span><br><span class="line">        (<span class="literal">None</span>, &#123;<span class="string">'fields'</span>: (<span class="string">'username'</span>, <span class="string">'email'</span>, <span class="string">'date_joined'</span>, <span class="string">'password'</span>,<span class="string">'is_active'</span>,<span class="string">'is_admin'</span>,<span class="string">'avatar'</span>)&#125;),</span><br><span class="line">        (<span class="string">'状态'</span>, &#123;<span class="string">'fields'</span>: (<span class="string">'email_verified'</span>, <span class="string">'last_ip'</span>, <span class="string">'au'</span>, <span class="string">'topic_num'</span>, <span class="string">'comment_num'</span>)&#125;),</span><br><span class="line">        (<span class="string">'社交网络'</span>, &#123;<span class="string">'fields'</span>: (<span class="string">'weibo_id'</span>, <span class="string">'blog'</span>)&#125;),</span><br><span class="line">    )</span><br><span class="line">    add_fieldsets = (</span><br><span class="line">        (<span class="literal">None</span>, &#123;</span><br><span class="line">            <span class="string">'classes'</span>: (<span class="string">'wide'</span>,),</span><br><span class="line">            <span class="comment">#admin样式设置</span></span><br><span class="line">            <span class="comment">#Fieldsets 使用 wide 样式将会有额外的水平空格.</span></span><br><span class="line">            <span class="string">'fields'</span>: (<span class="string">'email'</span>, <span class="string">'username'</span>, <span class="string">'password1'</span>, <span class="string">'password2'</span>,<span class="string">'is_active'</span>,<span class="string">'is_admin'</span>)&#125;</span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line">    search_fields = (<span class="string">'id'</span>, <span class="string">'email'</span>, <span class="string">'username'</span>)</span><br><span class="line">    ordering = (<span class="string">'id'</span>, <span class="string">'email'</span>, <span class="string">'email_verified'</span>)</span><br><span class="line">    filter_horizontal = ()</span><br><span class="line">    <span class="comment">#这个字段为了设置与groups关联的多选框</span></span><br><span class="line">admin.site.register(Member, MyUserAdmin)</span><br><span class="line">admin.site.register(Follower)</span><br></pre></td></tr></table></figure>

<h4 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h4><blockquote>
<p>还需要在<code>settings.py</code>文件下进行设置，覆盖最小的<code>User</code>模型</p>
</blockquote>
<ul>
<li><code>AUTH_USER_MODEL = &#39;people.Member&#39;</code></li>
</ul>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django邮件发送及华丽呼哨的邮件格式</title>
    <url>/Django%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E5%8F%8A%E5%8D%8E%E4%B8%BD%E5%91%BC%E5%93%A8%E7%9A%84%E9%82%AE%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h2><blockquote>
<p><code>django</code>中内置了许多方法可以使开发者方便的进行邮件发送</p>
</blockquote><h3 id="邮件配置"><a href="#邮件配置" class="headerlink" title="邮件配置"></a>邮件配置</h3><blockquote>
<p>发送邮件，首先需要在项目的<code>settings.py</code>文件下配置邮件服务器连接等信息</p>
</blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">EMAIL_USE_SSL = <span class="literal">True</span> <span class="comment"># Secure Sockets Layer 安全套接层, 取决于邮件服务器是否开启加密协议</span></span><br><span class="line">EMAIL_HOST = <span class="string">'smtp.qq.com'</span>  <span class="comment"># 邮件服务器地址</span></span><br><span class="line">EMAIL_PORT = <span class="number">465</span> <span class="comment"># 邮件服务器端口 </span></span><br><span class="line">EMAIL_HOST_USER = <span class="string">'account@qq.com'</span> <span class="comment"># 登陆邮件服务器的账号</span></span><br><span class="line">EMAIL_HOST_PASSWORD = <span class="string">'password'</span>  <span class="comment"># 登陆邮件服务器的密码</span></span><br><span class="line">DEFAULT_FROM_EMAIL = EMAIL_HOST_USER <span class="comment"># 邮件的发送者</span></span><br></pre></td></tr></table></figure><a id="more"></a>



<blockquote>
<p><strong>注意</strong>：<code>EMAIL_HOST_PASSWORD</code>所设置的登陆邮件服务器的密码为邮件客户端后台所设置的第三方客户端登陆密码，这个值并非直接账号密码</p>
<p>如：<code>QQ</code>邮箱的该值密码在网页版<code>QQ</code>邮件客户端的设置<code>-&gt;</code>帐户<code>-&gt;</code>开启<code>POP3/SMTP服务|IMAP/SMTP服务</code></p>
</blockquote>
<h3 id="发送文本邮件"><a href="#发送文本邮件" class="headerlink" title="发送文本邮件"></a>发送文本邮件</h3><blockquote>
<p>发送普通邮件可以使用<code>django.core.mail</code>模块下的<code>send_mail</code>函数进行</p>
</blockquote>
<ul>
<li><p><code>send_mail(subject, message, from_email, recipient_list, fail_silently=False, html_message=None)</code></p>
<blockquote>
<p>将邮件发送至<code>recipient_list</code>中的每一个收件人处</p>
</blockquote>
<blockquote>
<p><code>subject</code>：发送邮件标题</p>
<p><code>message</code>：发送邮件正文</p>
<p><code>from_email</code>：发件人邮箱地址</p>
<p><code>recipient_list</code>：一个字符串列表，每一个数据为接收者的邮箱地址</p>
<p><code>html_message</code>：如果指定该值，则发送的内容类型为<code>text/html</code>为一个<code>html</code>邮件内容</p>
</blockquote>
</li>
<li><p>发送普通邮件视图函数</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">(request)</span>:</span></span><br><span class="line">    subject = <span class="string">'邮件测试'</span></span><br><span class="line">    message = <span class="string">'&lt;a href="http://www.python.org"&gt;学习Python，我很快乐&lt;/a&gt;'</span></span><br><span class="line">    send_mail(</span><br><span class="line">        subject = subject,</span><br><span class="line">        message = message,</span><br><span class="line">        from_email = <span class="string">'from@qq.com'</span>,</span><br><span class="line">        recipient_list = [<span class="string">'recv@qq.com'</span>,<span class="string">'recv1@qq.com'</span>]</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Down'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="发送HTML邮件"><a href="#发送HTML邮件" class="headerlink" title="发送HTML邮件"></a>发送HTML邮件</h3><blockquote>
<p>发送这里的邮件内容为一个<code>HTML</code>的<code>a</code>标签，但是真正接收者接到该邮件时，<code>a</code>标签并不会解释称为真正的<code>a</code>标签，只是一个普通的字符串，这是因为当前发送邮件的类型为<code>text/plain</code>，可以使用<code>html_message</code>参数进行<code>HTML</code>内容的发送</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">(request)</span>:</span>    </span><br><span class="line">    subject = <span class="string">'邮件测试'</span></span><br><span class="line">    message = <span class="string">'&lt;a href="http://www.python.org"&gt;学习Python，我很快乐&lt;/a&gt;'</span></span><br><span class="line">    send_mail(</span><br><span class="line">        subject = subject,</span><br><span class="line">        message = <span class="string">''</span>, <span class="comment"># 该参数为必须参数，必须填写</span></span><br><span class="line">        html_message = message,</span><br><span class="line">        from_email = <span class="string">'from@qq.com'</span>,</span><br><span class="line">        recipient_list =[<span class="string">'recv@qq.com'</span>,<span class="string">'recv1@qq.com'</span>]</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Down'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>发送<code>html</code>格式邮件还可以使用<code>django.core.mail</code>模块下的<code>EmailMultiAlternatives</code>类进行邮件体的构造，然后进行邮件发送</p>
</blockquote>
<ul>
<li><p><code>EmailMultiAlternatives(subject=&#39;&#39;, body=&#39;&#39;, from_email=None, to=None)</code></p>
<blockquote>
<p><code>subject</code>：邮件标题</p>
<p><code>body</code>：邮件内容</p>
<p><code>from_email</code>：邮件发送者</p>
<p><code>to</code>：邮件接收人列表</p>
</blockquote>
</li>
<li><p><code>EmailMultiAlternatives.attach_alternative(content, mimetype)</code></p>
<blockquote>
<p>向<code>EmailMultiAlternatives</code>实例中添加<code>mimetype</code>支持的邮件内容</p>
<p><code>content</code>：添加的邮件内容</p>
<p><code>mimetype</code>：添加内容的<code>mime</code>类型</p>
</blockquote>
</li>
<li><p><code>EmailMultiAlternatives.send()</code></p>
<blockquote>
<p>发送邮件</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> EmailMultiAlternatives</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">(request)</span>:</span></span><br><span class="line">    subject = <span class="string">'邮件测试'</span></span><br><span class="line">    text_message = <span class="string">'学习Python，我很快乐'</span></span><br><span class="line">    html_message = <span class="string">'&lt;a href="http://www.python.org"&gt;学习Python，我很快乐&lt;/a&gt;'</span></span><br><span class="line">    email = EmailMultiAlternatives(</span><br><span class="line">        subject = subject,</span><br><span class="line">        body = text_message,</span><br><span class="line">        from_email = <span class="string">'1747266529@qq.com'</span>,</span><br><span class="line">        to = [<span class="string">'recv@qq.com'</span>,<span class="string">'recv1@qq.com'</span>]</span><br><span class="line">    )</span><br><span class="line">    email.attach_alternative(html_message,<span class="string">'text/html'</span>) <span class="comment"># 添加HTML邮件部分</span></span><br><span class="line">    email.send() <span class="comment"># 发送邮件</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Down'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="发送富文本邮件"><a href="#发送富文本邮件" class="headerlink" title="发送富文本邮件"></a>发送富文本邮件</h3><blockquote>
<p>经常需要我们在邮件中加入图片等静态资源</p>
<p>需要用到<code>python</code>中<code>email.mime.image</code>模块下的<code>MIMEImage</code>类进行图片内容的构造</p>
<p>这里发送邮件使用<code>EmailMessage</code>类，来自于<code>django.core.mail</code>模块下</p>
<p>并在使用对应该类实例的<code>attach</code>添加图片资源数据</p>
<p>最后使用实例的<code>send</code>函数发送邮件</p>
</blockquote>
<ul>
<li><p><code>EmailMessage(subject=&#39;&#39;, body=&#39;&#39;, from_email=None, to=None)</code></p>
<blockquote>
<p>``subject`：邮件标题</p>
<p><code>body</code>：邮件内容</p>
<p><code>from_email</code>：邮件发送者</p>
<p><code>to</code>：邮件接收人列表</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sendmailpro.settings <span class="keyword">import</span> STATICFILES_DIRS</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> email.mime.image <span class="keyword">import</span> MIMEImage</span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> EmailMessage</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">(request)</span>:</span></span><br><span class="line">    subject = <span class="string">'图片邮件测试'</span></span><br><span class="line">    file_1 = os.path.join(STATICFILES_DIRS[<span class="number">0</span>],<span class="string">'img/1.png'</span>)</span><br><span class="line">    <span class="keyword">with</span> open(file_1, <span class="string">'rb'</span>) <span class="keyword">as</span> fp: </span><br><span class="line">        <span class="comment"># 打开第一张图片</span></span><br><span class="line">        image_1 = MIMEImage(fp.read())</span><br><span class="line">        </span><br><span class="line">    file_2 = os.path.join(STATICFILES_DIRS[<span class="number">0</span>],<span class="string">'img/2.png'</span>)</span><br><span class="line">    <span class="keyword">with</span> open(file_2, <span class="string">'rb'</span>) <span class="keyword">as</span> fp: </span><br><span class="line">        <span class="comment"># 打开第二张图片</span></span><br><span class="line">        image_2 = MIMEImage(fp.read())</span><br><span class="line">        </span><br><span class="line">    body = <span class="string">"&lt;img src='cid:first_id'&gt;&lt;br&gt;&lt;img src='cid:sec_id'&gt;"</span></span><br><span class="line">    <span class="comment"># 发送邮件主体内容</span></span><br><span class="line">    </span><br><span class="line">	image_1.add_header(<span class="string">'Content-ID'</span>,<span class="string">'&lt;%s&gt;'</span> % <span class="string">'first_id'</span>) </span><br><span class="line">    <span class="comment"># 通过 CID 对称图片在邮件内容中的位置</span></span><br><span class="line">    image_2.add_header(<span class="string">'Content-ID'</span>,<span class="string">'&lt;%s&gt;'</span> % <span class="string">'sec_id'</span>)</span><br><span class="line">    </span><br><span class="line">    message = EmailMessage( <span class="comment"># 构建发送的邮件主体</span></span><br><span class="line">                subject=subject,</span><br><span class="line">                body=body,</span><br><span class="line">                from_email=<span class="string">'from@qq.com'</span>,</span><br><span class="line">                to=[<span class="string">'recv@qq.com'</span>,<span class="string">'recv1@qq.com'</span>]</span><br><span class="line">            )</span><br><span class="line">    message.content_subtype = <span class="string">'html'</span></span><br><span class="line">    message.attach(image_1) <span class="comment"># 添加两张图片</span></span><br><span class="line">    message.attach(image_2)</span><br><span class="line">    message.send() <span class="comment"># 发送邮件</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Down'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="发送附件邮件"><a href="#发送附件邮件" class="headerlink" title="发送附件邮件"></a>发送附件邮件</h3><blockquote>
<p>发送附件，也可以使用<code>django.core.mail</code>模块下的<code>EmailMessage</code>类进行附件邮件体构造</p>
<p>通过<code>EmailMessage</code>实例的<code>attach|attach_file</code>两个函数在邮件主体中添加附件内容</p>
<p><code>attach_file</code>添加邮件附件直接加入路径即可，但是<code>attach</code>添加附件内容需要提供附件内容</p>
</blockquote>
<ul>
<li><p><code>attach(filename=None, content=None, mimetype=None)</code></p>
<blockquote>
<p>添加附件内容</p>
</blockquote>
<blockquote>
<p><code>filename</code>：附件文件名称</p>
<p><code>content</code>：附件内容</p>
<p><code>mimetype</code>：附件的<code>MIME</code>类型</p>
</blockquote>
</li>
<li><p><code>attach_file(path, mimetype=None)</code></p>
<blockquote>
<p>直接通过路径添加附件</p>
</blockquote>
<blockquote>
<p><code>path</code>：附件路径</p>
<p><code>mimetype</code>：附件的<code>MIME</code>类型</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sendmailpro.settings <span class="keyword">import</span> STATICFILES_DIRS</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> email.mime.image <span class="keyword">import</span> MIMEImage</span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> EmailMessage</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">(request)</span>:</span></span><br><span class="line">    subject = <span class="string">'附件邮件测试'</span></span><br><span class="line">    email = EmailMessage(</span><br><span class="line">        subject=subject,</span><br><span class="line">        body=<span class="string">'这是一封具有图片附件的邮件'</span>,</span><br><span class="line">        from_email=<span class="string">'from@qq.com'</span>,</span><br><span class="line">        to=[<span class="string">'recv@qq.com'</span>,<span class="string">'recv1@qq.com'</span>]</span><br><span class="line">    )</span><br><span class="line">    file_1 = os.path.join(STATICFILES_DIRS[<span class="number">0</span>],<span class="string">'img/1.png'</span>)</span><br><span class="line">    image_1 = open(file_1,<span class="string">'rb'</span>).read()</span><br><span class="line">    email.attach(<span class="string">'1.png'</span>,image_1,<span class="string">'image/png'</span>) <span class="comment"># 使用attach实例函数添加附件内容</span></span><br><span class="line"></span><br><span class="line">    file_2 = os.path.join(STATICFILES_DIRS[<span class="number">0</span>],<span class="string">'img/2.png'</span>)</span><br><span class="line">    email.attach_file(file_2,mimetype=<span class="string">'image/png'</span>) <span class="comment"># 使用attach_file实例函数添加附件路径</span></span><br><span class="line"></span><br><span class="line">    email.send()</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Down'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django缓存系统</title>
    <url>/Django%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><blockquote>
<p><code>Django</code> 是动态<code>Web</code>后台框架，需要实时生成用户访问的页面，进行多次的数据库操作，但是多次的数据库访问操作对于整个<code>Web</code>系统来说，会影响效率，尤其是当访问量增大时，数据库的压力也会越来越大。</p>
<p>相对于磁盘及内存操作，数据库的访问操作付出的成本要大的多</p>
</blockquote><a id="more"></a>
<blockquote>
<p>浏览器第一次请求时，<code>cache</code>会缓存单个变量或整个网页等内容到硬盘或者内存中，同时设置<code>response</code>头部</p>
<p>当浏览器再次发起请求时，会与缓存中的过期时间相比较，如果缓存时间比较新，则会重新请求数据，并缓存起来然后返回<code>response</code>给客户端，如果缓存没有过期，则直接从缓存中提取数据，返回给<code>response</code>给客户端</p>
</blockquote>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><blockquote>
<p><code>HTTP</code>协议头<code>Cache-Control</code>，<code>Cache-Control</code>与<code>Expires</code>的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过<code>Cache-Control</code>的选择更多，设置更细致，如果同时设置的话，其优先级高于<code>Expires</code></p>
</blockquote>
<blockquote>
<p>在<code>python</code>中使用<code>memcached</code>需要我们额外安装<code>memcached</code>作为<code>memcache</code>客户端的支持</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">pip3 install python-memcached -<span class="selector-tag">i</span> https:<span class="comment">//pypi.tuna.tsinghua.edu.cn/simple</span></span><br></pre></td></tr></table></figure>

<h3 id="Cache设置"><a href="#Cache设置" class="headerlink" title="Cache设置"></a>Cache设置</h3><h4 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h4><ul>
<li><p>安装<code>memcached</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">apt-get install memcached</span><br><span class="line"><span class="comment"># debian</span></span><br><span class="line">yum install memcached </span><br><span class="line"><span class="comment"># centos</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件：<code>/etc/memcached.conf</code></p>
<blockquote>
<p>配置文件中有两个可能需要修改的参数</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">-m <span class="number">64</span> #memcached所能使用的内存大小</span><br><span class="line">-l <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> #监听的IP地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启|关闭<code>memcached</code>服务</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> memcached <span class="comment"># 开启</span></span><br><span class="line">systemctl <span class="literal">stop</span> memcached <span class="comment"># 关闭</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看服务状态</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">systemctl status memcached</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="settings配置"><a href="#settings配置" class="headerlink" title="settings配置"></a>settings配置</h4><blockquote>
<p>使用<code>memcached</code>缓存，首先需要在项目的<code>settings</code>文件下进行配置</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.core.cache.backends.memcached.MemcachedCache'</span>,  </span><br><span class="line">        <span class="comment"># 指定缓存使用的引擎</span></span><br><span class="line">        <span class="string">'LOCATION'</span>:<span class="string">'172.16.19.26:11211'</span>, </span><br><span class="line">        <span class="comment"># 指定缓存服务器地址，常为本机地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="视图缓存"><a href="#视图缓存" class="headerlink" title="视图缓存"></a>视图缓存</h4><blockquote>
<p>可以只为某些视图函数进行缓存</p>
<p>使用<code>django.views.decorators.cache</code>下的装饰器<code>cache_page</code>进行视图函数装饰即可</p>
</blockquote>
<ul>
<li>模型类的表代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>,verbose_name=<span class="string">'名字'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>视图函数代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.cache <span class="keyword">import</span> cache_page</span><br><span class="line"></span><br><span class="line"><span class="meta">@cache_page(10) # 缓存10秒</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    print(<span class="string">'视图函数被调用'</span>)</span><br><span class="line">    ss = models.People.objects.all()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'index.html'</span>, locals())</span><br></pre></td></tr></table></figure>

<ul>
<li>模板页面代码</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>展示数据<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;% for s in ss %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; s.name &#125;&#125; <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在第一次刷新浏览器之后，</p>
<p>立即在数据库中添加一个新的数据对象</p>
<p>接着继续刷新浏览器，前端页面将会读取缓存中的结果，而不会显示刚才添加的用户</p>
</blockquote>
<blockquote>
<p>除了在视图函数上使用装饰器进行缓存设置，还可以在路由匹配部分使用相同装饰器函数进行设置</p>
</blockquote>
<h4 id="全站缓存"><a href="#全站缓存" class="headerlink" title="全站缓存"></a>全站缓存</h4><blockquote>
<p>将整站所有视图设置缓存，需要在配置文件的中间件设置首尾部分添加如下内容</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">'django.middleware.cache.UpdateCacheMiddleware'</span>, <span class="comment"># 首部要添加的中间件</span></span><br><span class="line">    <span class="comment"># 将response缓存起来 </span></span><br><span class="line">    <span class="string">'django.middleware.security.SecurityMiddleware'</span>,</span><br><span class="line">	...</span><br><span class="line">    <span class="string">'django.middleware.cache.FetchFromCacheMiddleware'</span>,<span class="comment"># 尾部要添加的中间件</span></span><br><span class="line">    <span class="comment"># 将缓存的response取出来</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以及搭配设置当前全站缓存有效时间的全局变量</p>
</blockquote>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">CACHE_MIDDLEWARE_SECONDS</span> = <span class="number">10</span> <span class="comment"># 每页页面缓存的秒数，默认为600</span></span><br></pre></td></tr></table></figure>

<h4 id="局部缓存"><a href="#局部缓存" class="headerlink" title="局部缓存"></a>局部缓存</h4><blockquote>
<p>局部缓存主要为在模板页面，选择某个区域进行缓存，当用户再次访问相同页面时，如设置缓存未过期，则渲染时局部缓存不会重新生成</p>
</blockquote>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">load</span></span> cache %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">	局部缓存首先需要加载cache标签</span></span><br><span class="line"><span class="xml">	</span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">cache</span> sec key %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">endcache</span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以时间模板变量为例，做一个简单的测试，后台视图函数每次在访问时，返回当前时间</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time </span><br><span class="line">now = time.strftime(<span class="string">'%H:%M:%S'</span>, time.localtime())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>模板页面在使用时的代码</p>
</blockquote>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">load</span></span> cache %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是未缓存的时间:</span><span class="template-variable">&#123;&#123; now &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">cache</span> 10 time %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是缓存的时间:</span><span class="template-variable">&#123;&#123; now &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">endcache</span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure>

<h4 id="手动缓存"><a href="#手动缓存" class="headerlink" title="手动缓存"></a>手动缓存</h4><blockquote>
<p>除了以上应用于各个业务中的缓存方式，还可以使用<code>django</code>所提供的<code>cache</code>接口进行缓存设置以及获取</p>
</blockquote>
<ul>
<li>设置缓存</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.cache <span class="keyword">import</span> cache</span><br><span class="line"><span class="comment">#存储缓存数据</span></span><br><span class="line">cache.set(<span class="string">'cache_key'</span>,data,<span class="number">60</span>*<span class="number">15</span>)</span><br><span class="line"><span class="comment">#cache_key为存储在缓存中的唯一值，data为存储的数据，60*15为缓存有效时间</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取缓存</li>
</ul>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#获取缓存数据</span></span><br><span class="line">cache.<span class="keyword">get</span>(<span class="string">'cache_key'</span>,<span class="string">'获取不到的默认值'</span>)</span><br><span class="line"><span class="meta">#cache_key为储存缓存数据的唯一值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>避免<code>key</code>值重复导致更新缓存，可以使用<code>cache.add</code>函数，基本用法与<code>set</code>相同</li>
</ul>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">status = cache.add(<span class="string">'add_key'</span>, <span class="string">'New value'</span>)</span><br><span class="line"># 当指定key值的缓存存在，add方法不会尝试更新缓存</span><br><span class="line"># 返回值status为<span class="literal">True</span>时，代表存储成功，<span class="literal">False</span>代表存储失败</span><br></pre></td></tr></table></figure>

<ul>
<li>清除缓存，通过<code>cache.delete</code>方法，该方法接收一个缓存<code>key</code>值</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">cache.<span class="keyword">delete</span>(<span class="string">'cache_key'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>清空缓存，通过<code>cache.clear</code>方法，直接从缓存中清除所有</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">cache.<span class="built_in">clear</span>()</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p><code>memcached</code>不允许使用超过<code>250</code>个字符或包含空格或控制字符的缓存键值</p>
<p>使用这样的键值将会导致异常</p>
</blockquote>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django的消息框架(message)与Django分页组件(paginator)</title>
    <url>/Django%E7%9A%84%E6%B6%88%E6%81%AF%E6%A1%86%E6%9E%B6(message)%E4%B8%8EDjango%E5%88%86%E9%A1%B5%E7%BB%84%E4%BB%B6(paginator)/</url>
    <content><![CDATA[<h2 id="Messages消息框架"><a href="#Messages消息框架" class="headerlink" title="Messages消息框架"></a>Messages消息框架</h2><blockquote>
<p>在网页应用中，你经常需要在处理完表单或其它类型的用户输入后。显示一个通知消息（也叫做<code>flash message</code>给用户</p>
<p>对于这个功能，<code>Django</code>提供基于<code>Cookie</code> 和会话的消息，无论是匿名用户还是认证的用户。</p>
<p>其消息框架允许你临时将消息存储在请求中，并在接下来的请求（通常就是下一个请求）中提取它们并显示。每个消息都带有一个特定<code>level</code> 标签，表示其优先级（例如<code>info</code>、<code>warning</code> 或<code>error</code>）</p>
</blockquote><a id="more"></a>
<blockquote>
<p><code>django-admin startproject</code> 创建的默认<code>settings.py</code> 已经包含启用消息框架功能需要的所有的设置</p>
</blockquote>
<blockquote>
<ul>
<li><code>INSTALLED_APPS</code> 中的<code>&#39;django.contrib.messages&#39;</code>。</li>
<li><code>MIDDLEWARE_CLASSES</code> 中的<code>&#39;django.contrib.sessions.middleware.SessionMiddleware&#39;</code> 和<code>&#39;django.contrib.messages.middleware.MessageMiddleware&#39;</code></li>
</ul>
<p>默认的后端存储 依赖<code>[sessions]</code></p>
<p>所以<code>MIDDLEWARE_CLASSES</code> 中必须启用<code>SessionMiddleware</code> 并出现在<code>MessageMiddleware</code> 之前</p>
<ul>
<li><code>TEMPLATES</code> 设置中定义的<code>DjangoTemplates</code> 的<code>&#39;context_processors&#39;</code> 选项包含<code>&#39;django.contrib.messages.context_processors.messages&#39;</code></li>
</ul>
</blockquote>
<h3 id="消息级别"><a href="#消息级别" class="headerlink" title="消息级别"></a>消息级别</h3><blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">from</span> django.contrib <span class="keyword">import</span> messages</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>messages.debug</code></li>
<li><code>messages.info</code></li>
<li><code>messages.success</code></li>
<li><code>messages.warning</code></li>
<li><code>messages.error</code></li>
</ul>
<h3 id="使用消息框架"><a href="#使用消息框架" class="headerlink" title="使用消息框架"></a>使用消息框架</h3><blockquote>
<p>视图函数只需要创建<code>messages</code>消息对象即可</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">messages.warning(request,<span class="string">'登陆失败，用户名或密码无效'</span>)</span><br><span class="line"><span class="keyword">return</span> render(request,<span class="string">'login.html'</span>,locals())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>前端模板中判断是否含有<code>messages</code>消息，遍历取出即可</p>
<p>也可以结合<code>bootstrap</code>框架让提示消息变得更加美丽</p>
</blockquote>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> messages %&#125;</span><span class="xml">   </span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">for</span></span> message <span class="keyword">in</span> messages %&#125;</span><span class="xml">  </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"alert alert-</span></span></span><span class="template-variable">&#123;&#123; message.tags &#125;&#125;</span><span class="xml"><span class="tag"><span class="string"> fade in"</span>&gt;</span>   </span></span><br><span class="line"><span class="xml"></span><span class="template-variable">&#123;&#123; message &#125;&#125;</span><span class="xml">     </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endfor</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：<code>messages</code>对象是一个数据集，并不是单独的一条消息，需要我们在使用时，必须通过<code>for</code>循环进行访问</p>
</blockquote>
<h2 id="Paginator分页组件"><a href="#Paginator分页组件" class="headerlink" title="Paginator分页组件"></a>Paginator分页组件</h2><blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">from</span> django.core.paginator <span class="keyword">import</span> Paginator, EmptyPage, PageNotAnInteger</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Paginator</span></span><br></pre></td></tr></table></figure>

<p>：创建分页对象</p>
<h3 id="分页对象内置属性"><a href="#分页对象内置属性" class="headerlink" title="分页对象内置属性"></a>分页对象内置属性</h3></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_ = models.objects.all()p = Paginator(all_, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 分页all_数据，每页显示10条数据</span></span><br><span class="line">p.count</span><br><span class="line"><span class="comment"># 总数据量</span></span><br><span class="line">p.num_pages() </span><br><span class="line"><span class="comment"># 分页数</span></span><br><span class="line">p.page_range() </span><br><span class="line"><span class="comment"># 列表形式返回当前可有的页数 [1,2,3]</span></span><br><span class="line">page_1 = p.page(<span class="number">1</span>) </span><br><span class="line"><span class="comment"># 选择第一页，返回第一页数据对象</span></span><br><span class="line">page_1.object_list</span><br><span class="line"><span class="comment"># 返回第一页所有数据</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> page_1:</span><br><span class="line">    print(var)ABC...</span><br></pre></td></tr></table></figure>

<h3 id="某一页内置属性"><a href="#某一页内置属性" class="headerlink" title="某一页内置属性"></a>某一页内置属性</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">page_1.number </span><br><span class="line"><span class="comment"># 当前页的页码</span></span><br><span class="line">page_1.has_next() </span><br><span class="line"><span class="comment"># 是否有下一页</span></span><br><span class="line">page_1.has_previous()</span><br><span class="line"><span class="comment"># 是否有上一页</span></span><br><span class="line">page_1.has_other_pages()</span><br><span class="line"><span class="comment"># 是否含有其他页</span></span><br><span class="line">page_1.next_page_number() </span><br><span class="line"><span class="comment"># 下一页的页码</span></span><br><span class="line">page_1.previous_page_number()</span><br><span class="line"><span class="comment"># 上一页的页码</span></span><br><span class="line">page_1.start_index() </span><br><span class="line"><span class="comment"># 该页第一个数据的索引</span></span><br><span class="line">page_1.end_index()</span><br><span class="line"><span class="comment"># 该页最后一个数据的索引</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>EmptyPage</code>：取不到页面数据，抛出该异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_ = models.objects.all()</span><br><span class="line">p = Paginator(all_, <span class="number">10</span>)<span class="keyword">try</span>:   </span><br><span class="line">    list_ = p.page(page_num)</span><br><span class="line">    <span class="keyword">except</span> EmptyPage:	</span><br><span class="line">        <span class="comment">#没有第page_num页   </span></span><br><span class="line">        list_ = paginator.page(<span class="number">1</span>) </span><br><span class="line">        <span class="comment"># 取不到该也数据，直接返回第一页数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>PageNotAnInteger</code>：当页数是一个非整数类型时，抛出该异常</p>
</li>
</ul>
<h3 id="模板页面基本使用方式"><a href="#模板页面基本使用方式" class="headerlink" title="模板页面基本使用方式"></a>模板页面基本使用方式</h3><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> topic_list.has_previous %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 当前页是否含有上一页 --&gt;</span>	</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"?page=</span></span></span><span class="template-variable">&#123;&#123; list_.previous_page_number &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span>上一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span>	</span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 连接传参形式传递上一页的页码ID --&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> topic_list.has_next %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 当前页是否含有下一页 --&gt;</span> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"?page=</span></span></span><span class="template-variable">&#123;&#123; list_.next_page_number &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span>下一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 连接传参形式传递下一页的页码ID --&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django的CBV类视图</title>
    <url>/Django%E7%9A%84CBV%E7%B1%BB%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="CBV"><a href="#CBV" class="headerlink" title="CBV"></a>CBV</h2><blockquote>
<p><strong>CBV（class base views）</strong> 就是在视图里使用类处理请求</p>
<p>之前的代码中，我们的视图函数都是通过函数来进行<code>request</code>的响应以及<code>response</code>的返回，并且通常我们需要判断的请求方式<code>get</code>或是<code>post</code>都需要我们在代码中通过<code>if</code>进行条件判断，这样的视图功能编写就叫做<code>FBV</code></p>
</blockquote><a id="more"></a>
<blockquote>
<p>但现在在<code>django</code>中还提供了一种方式叫做<code>CBV</code>，在类中编写视图功能， 并且将传统的<code>get</code>、<code>post</code>判断设置为了类中函数，这样当用户发起不同的请求，会自动进入到对应的类中函数上，像是下面这样</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleView</span><span class="params">(View)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span>   </span><br><span class="line">        <span class="keyword">raise</span> Http404   </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> request.is_ajax():  </span><br><span class="line">                id_ = request.POST.get(<span class="string">'id_'</span>)    </span><br><span class="line">                result = models.Article.objects.get(id=id_).content    </span><br><span class="line">                data = result.replace(<span class="string">'\r\n'</span>,<span class="string">'&lt;br&gt;'</span>)  </span><br><span class="line">                <span class="keyword">return</span> HttpResponse(json.dumps(data,ensure_ascii=<span class="literal">False</span>) )  </span><br><span class="line">            <span class="keyword">raise</span> Http404</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过将请求类型定义为函数，可以更加方便进行请求方式判断</p>
<p>用户访问时，会经由<code>View</code>基类中的<code>as_view -&gt; dispatch</code>进行判断，通过请求类型分发到不同对应请求的函数名下；也就是通过<code>get</code>方式访问，那么对应会调用到名为<code>get</code>的函数</p>
<p>此外，类中函数必须为小写，</p>
</blockquote>
<ul>
<li>对应路由此时设置为，需要使用试图类的<code>as_view</code>函数进行实例化</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#url.py</span></span><br><span class="line">path(<span class="string">'article/'</span>,ajaxviews.ArticleView.as_view())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过类视图可以方便我们进行请求条件的判断</p>
<p>并且可以在进行接口开发时，实现同一资源路由在使用不同请求访问时的功能解耦和</p>
<p>意思就是不用再把所有的功能都堆到一个视图函数里啦。多方便！</p>
<p>并且，在<code>Django-Restframework</code>框架中，也将频繁使用<code>CBV</code>形式进行视图编写</p>
</blockquote>
<h4 id="类视图装饰器"><a href="#类视图装饰器" class="headerlink" title="类视图装饰器"></a>类视图装饰器</h4><blockquote>
<p>在类视图中使用为函数视图准备的装饰器时，不能直接添加装饰器</p>
<p>需要使用method_decorator将其转换为适用于类视图方法的装饰器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>全部装饰</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(func)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nei</span><span class="params">(request)</span>:</span> </span><br><span class="line">        <span class="comment"># dispatch函数有参数request</span></span><br><span class="line">        print(<span class="string">'这是装饰器在调用'</span>)  </span><br><span class="line">        <span class="keyword">return</span> func(request) </span><br><span class="line">    <span class="keyword">return</span> nei@method_decorator(my_decorator, name=<span class="string">'dispatch'</span>)</span><br><span class="line"><span class="comment"># 为全部请求方法添加装饰器class DemoView(View): </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span>    </span><br><span class="line">    print(<span class="string">'get方法'</span>)     </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span>    </span><br><span class="line">    print(<span class="string">'post方法'</span>)     </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>为部分装饰，只需要通过<code>method_decorator</code>方法的<code>name</code>参数选择装饰的函数名即可</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@method_decorator(my_decorator, name='post')</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoView</span><span class="params">(View)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span>  </span><br><span class="line">        print(<span class="string">'get方法'</span>)       </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span>     </span><br><span class="line">        print(<span class="string">'post方法'</span>)       </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>为特定的多个类视图函数进行装饰，只需要在每个函数上使用<code>method_decorator</code>装饰器即可</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoView</span><span class="params">(View)</span>:</span>  </span><br><span class="line"><span class="meta">    @method_decorator(my_decorator) </span></span><br><span class="line">    <span class="comment"># 为get方法添加了装饰器  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)</span><br><span class="line"><span class="meta">    @method_decorator(my_decorator) </span></span><br><span class="line">    <span class="comment"># 为post方法添加了装饰器    </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="类视图csrf-token装饰"><a href="#类视图csrf-token装饰" class="headerlink" title="类视图csrf_token装饰"></a>类视图<code>csrf_token</code>装饰</h4><blockquote>
<p>当类视图需要允许跨站提交数据时，使用<code>csrf_exempt</code>装饰器装饰函数可以被跨域访问</p>
<p>但是使用上面的方法进行<code>csrf_exempt</code>是不行的，需要在类视图基类的<code>dispatch</code>函数上进行装饰</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="comment">#@method_decorator(csrf_exempt,name='dispatch')</span></span><br><span class="line"><span class="comment"># 直接加载类视图上也是可以修饰的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoView</span><span class="params">(View)</span>:</span> </span><br><span class="line"><span class="meta">    @method_decorator(csrf_exempt)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span><span class="params">(self, request, *args, **kwargs)</span>:</span> </span><br><span class="line">        <span class="keyword">return</span> super(DemoView,self).dispatch(request, *args, **kwargs) </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span> </span><br><span class="line">        print(<span class="string">'get方法'</span>)    </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span>   </span><br><span class="line">        print(<span class="string">'post方法'</span>)      </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>csrf</code>装饰只能在类视图的<code>dispatch</code>函数上才能被生效</p>
</blockquote>
<blockquote>
<p>除了在类视图的<code>dispatch</code>函数上进行装饰，在路由映射处使用<code>csrf_exempt</code>函数修饰路由规则也是可以的</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line">urlpatterns = [  </span><br><span class="line">    ...   </span><br><span class="line">    path(<span class="string">''</span>,csrf_exempt(ajaxviews.DemoView.as_view()))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django初识</title>
    <url>/Django%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<h2 id="开始玩耍Django"><a href="#开始玩耍Django" class="headerlink" title="开始玩耍Django"></a>开始玩耍Django</h2><blockquote>
<p><em>Django</em>是一个开放源代码的<code>Web</code>应用框架，由<code>Python</code>写成。采用了<code>MVT</code>的框架模式；最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是<code>CMS</code>（内容管理系统）软件</p>
<p>框架是以比利时的吉普赛爵士吉他手<code>Django Reinhardt</code>来命名的</p>
</blockquote><a id="more"></a>
<h3 id="django安装"><a href="#django安装" class="headerlink" title="django安装"></a>django安装</h3><blockquote>
<p><code>pip install django==2.0.4</code>(版本号)</p>
<p><code>pip install django</code>默认安装最新版本</p>
</blockquote>
<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> django-admin startproject myproject</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="开启开发服务器"><a href="#开启开发服务器" class="headerlink" title="开启开发服务器"></a>开启开发服务器</h3><blockquote>
<p><code>cd myproject</code>：进入项目目录</p>
<p><code>python manage.py runserver</code>：开启服务</p>
<p><code>python manage.py runserver 7000</code>：改变服务监听端口</p>
<p><code>python manage.py runserver 0:8000</code>：改变服务监听IP:端口</p>
</blockquote>
<h3 id="项目文件夹"><a href="#项目文件夹" class="headerlink" title="项目文件夹"></a>项目文件夹</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">manage.<span class="keyword">py</span>：用来管理当前项目的一个命令行工具</span><br><span class="line">myproject/： 项目主文件夹</span><br><span class="line">myproject/__init__.<span class="keyword">py</span>：空文件，用来指明当前的myproject为一个可导入的模块包</span><br><span class="line">myproject/settings.<span class="keyword">py</span>：项目主要配置文件myproject/urls.<span class="keyword">py</span>：项目主要路由配置文件myproject/wsgi.<span class="keyword">py</span>：项目部署WSGI并发服务器时所需要的配置文件</span><br></pre></td></tr></table></figure>

<h3 id="Settings-py"><a href="#Settings-py" class="headerlink" title="Settings.py"></a>Settings.py</h3><blockquote>
<p>该文件是整个项目的主控文件，其中相关配置选项如下</p>
<p><a href="https://docs.djangoproject.com/zh-hans/2.0/ref/settings/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.0/ref/settings/</a></p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>BASE_DIR: 当前项目工作目录，用来在每一次开启项目时动态找到相关资源路径</span><br><span class="line"><span class="bullet">- </span>SECRET_KEY: 加密的hash值以及保护某些签名数据的关键密钥</span><br><span class="line"><span class="bullet">- </span>DEBUG: 调试模式</span><br><span class="line"><span class="bullet">- </span>ALLOWED_HOSTS: 有哪些主机或域名可以访问当前django站点，如设置为*代表全部可访问。</span><br><span class="line"><span class="bullet">- </span>INSTALL_APPS: django项目中所有使用的应用名称，自创建子应用也要加到这里，不然ORM数据库无法被识别到！</span><br><span class="line"><span class="bullet">- </span>MIDDLEWARE: django中间件，用来在request或reponse过程中添加功能，比如确保安全性，传输保存Session等</span><br><span class="line"><span class="bullet">- </span>SecurityMiddleware: xss脚本过滤，一些安全设置	</span><br><span class="line"><span class="bullet">- </span>SessionMiddleware: session支持中间件，在每次用户访问django项目时，添加session对每一个浏览器</span><br><span class="line"><span class="bullet">- </span>CommonMiddleware: 通用组件，比如为路由添加末尾斜杠</span><br><span class="line"><span class="bullet">- </span>CsrfViewMiddleware: 防跨站请求伪造令牌，为客户端添加csrf_token密钥，在表单提交时需提交该值</span><br><span class="line"><span class="bullet">- </span>AuthenticationMiddleware: admin用户组件，每个request对象都会被添加admin下的user属性</span><br><span class="line"><span class="bullet">- </span>MessageMiddleware: 消息中间件 展示一些后台消息给前端</span><br><span class="line"><span class="bullet">- </span>XFrameOptionsMiddleware: 防止欺骗点击攻击出现；自身页面被嵌入到他人页面中，点击欺骗</span><br><span class="line"><span class="bullet">- </span>ROOT_URLCONF: 主路由配置文件，字符串填写url.py文件路径</span><br><span class="line"><span class="bullet">- </span>TEMPLATES: 模板文件配置项</span><br><span class="line"><span class="bullet">- </span>WSGI_APPLICATION: WSGI服务器配置项，找到当前django下的wsgi引入APP文件</span><br><span class="line"><span class="bullet">- </span>DATABASES: 数据库配置项，默认使用SQLite3，一个本地文件数据库</span><br><span class="line"><span class="bullet">- </span>AUTH<span class="emphasis">_PASSWORD_</span>VALIDATORS: 检查用户密码强度的验证程序列表，不过是针对admin界面下的用户，而非自定义</span><br><span class="line"><span class="bullet">- </span>LANGUAGE_CODE: django所使用语言文件</span><br><span class="line"><span class="bullet">- </span>TIME_ZONE: django所使用时区</span><br><span class="line"><span class="bullet">- </span>USE_I18N: 国际化支持 18表示Internationalization这个单词首字母I和结尾字母N之间的字母有18个</span><br><span class="line"><span class="bullet">- </span>USE_L10N: 是localization的缩写形式，意即在l和n之间有10个字母</span><br><span class="line"><span class="bullet">- </span>USE_TZ:开启了Time Zone功能，则所有的存储和内部处理，包括print显示的时间将是是UTC时间格式</span><br><span class="line"><span class="bullet">- </span>STATIC_URL: URL访问静态资源时的路径</span><br></pre></td></tr></table></figure>

<h2 id="来搞个Hello-world"><a href="#来搞个Hello-world" class="headerlink" title="来搞个Hello world"></a>来搞个Hello world</h2><h3 id="django创建子应用"><a href="#django创建子应用" class="headerlink" title="django创建子应用"></a>django创建子应用</h3><blockquote>
<p>项目和应用有啥区别？</p>
<p>应用是一个专门做某件事的网络应用程序：比如博客系统，或者公共记录的数据库，或者简单的投票程序</p>
<p>项目则是一个网站使用的配置和应用的集合。项目可以包含很多个<code>app</code>应用，应用可以被很多个项目使用</p>
</blockquote>
<ul>
<li><p><code>python manage.py startapp myapp</code></p>
<blockquote>
<p>创建子应用</p>
</blockquote>
</li>
</ul>
<h3 id="app目录"><a href="#app目录" class="headerlink" title="app目录"></a>app目录</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">- admin<span class="selector-class">.py</span>: app在admin注册展示时需要的文件</span><br><span class="line">- views<span class="selector-class">.py</span>: app的功能视图函数文件</span><br><span class="line">- models<span class="selector-class">.py</span>: app需要使用数据库时的文件</span><br><span class="line">- urls<span class="selector-class">.py</span>: 当使用include路由分发时，每个app应该有他自己的子路由文件，这个是默认没有创建好的</span><br></pre></td></tr></table></figure>

<h3 id="视图函数"><a href="#视图函数" class="headerlink" title="视图函数"></a>视图函数</h3><blockquote>
<p>打开<code>app</code>下的<code>views.py</code>文件</p>
<p><code>Web</code>访问起始就是通过一个<code>URL</code>连接地址访问到服务器上的一个函数</p>
<p>在<code>views.py</code>中我们通过编写函数的形式，接收用户请求的<code>request</code>并返回一个<code>response</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每一个视图函数都需要有一个必须参数 </span></span><br><span class="line">request,用来接收用户访问时的请求内容</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span>   </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"&lt;h1&gt;Hello world&lt;/h1&gt;"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>HttpResponse</code>函数用来向用户返回一个字符串</li>
</ul>
<h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><blockquote>
<p>创建好了一个可以在请求时返回<code>H1</code>标签的视图函数，但是现在通过浏览器还是访问不到</p>
<p>需要我们为这个<code>app</code>下的函数进行路由配置</p>
</blockquote>
<blockquote>
<p>第一种简单的路由配置，直接在主控路由文件下，找到这个视图函数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#myproject/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [    path(<span class="string">'admin/'</span>, admin.site.urls), </span><br><span class="line">               <span class="comment">#admin控制界面路由   </span></span><br><span class="line">               path(<span class="string">''</span>,views.index)  </span><br><span class="line">               <span class="comment">#path函数第一个参数为访问地址，空字符串代表：当用户直接访问首页时  </span></span><br><span class="line">               <span class="comment">#第二个参数代表访问该地址时对应的视图函数，我们引入了app下的views中的index视图函数</span></span><br><span class="line">              ]</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来访问<code>127.0.0.1:8000</code>，那么你会看到一个非常大的<code>Hello world</code></li>
</ul>
<blockquote>
<p>以上将视图函数的查找直接写到主控路由并不是最好的办法</p>
<p>我们的项目通常会有非常多的路由配置项，如果都堆到这个文件中肯定是非常乱的，难以维护</p>
</blockquote>
<ul>
<li>我们可以在对应<code>app</code>下创建一个子路由控制文件，并在其中设置视图的路由配置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#myapp/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [    path(<span class="string">""</span>,views.index)]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>现在虽然配置了<code>app</code>下的路由文件，但是访问时，是看不到对应视图的结果</p>
<p>这是因为默认的<code>url</code>查找动作将会从主控路由文件开始，我们还需要在主控路由文件下进行路由分发设置</p>
<p>让主控路由可以找到子<code>app</code>下的路由映射文件</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#myproject/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [    path(<span class="string">'admin/'</span>, admin.site.urls),  </span><br><span class="line">               <span class="comment">#path('',views.index)   </span></span><br><span class="line">               path(<span class="string">''</span>,include(<span class="string">"myapp.urls"</span>)), </span><br><span class="line">               <span class="comment"># 函数 include() 允许引用其它 URLconfs</span></span><br><span class="line">              ]</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来再次尝试，在浏览器中访问主机域名；如果可以看到的话，恭喜你，效果已经很棒了！</li>
</ul>
<h4 id="路由查找流程"><a href="#路由查找流程" class="headerlink" title="路由查找流程"></a>路由查找流程</h4><ol>
<li>查找主控路由文件下的<code>urlpatterns</code>全局变量，这是一个序列数据类型，其中每一个元素都是对应的一个路由匹配规则</li>
<li>如果在规则中查找到符合匹配规则的，则执行其中的对应执行函数</li>
<li>如果对应的不是一个执行函数，而是一个<code>include</code>路由包含，那么截断与此项匹配的<code>URL</code>的部分，并将剩余的路由字符串发送到<code>include</code>所包含的子路由文件中以供进一步处理</li>
<li>如果没有匹配到的任何结果，<code>django</code>默认抛出<code>Page not found (404)</code></li>
</ol>
<blockquote>
<p><strong>注意</strong>：<code>Django</code>的路由不考虑HTTP请求方式，仅根据<code>URL</code>进行路由，即，只要<code>URL</code>相同，无论<code>POST</code>、<code>GET</code>等哪种请求方式都指向同一个操作函数</p>
</blockquote>
<h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><blockquote>
<p><code>path</code>函数用来处理一个路由对应的视图映射</p>
</blockquote>
<ul>
<li><p><code>path(route, view, name)</code></p>
<blockquote>
<p><code>route</code>： 匹配规则，是一个字符串</p>
<p><code>view</code>：对应的视图函数</p>
<p><code>name</code>：未来我们会用到他，用来为匹配规则命名，这样方便日后修改路由而不影响全局下的路由使用</p>
</blockquote>
</li>
</ul>
<h4 id="re-path"><a href="#re-path" class="headerlink" title="re_path"></a>re_path</h4><blockquote>
<p><code>re_path</code>是<code>path</code>函数的加强版</p>
<p>可以在<code>re_path</code>函数的第一个位置的字符串参数，是一个标准<code>Python</code>正则表达式，其余参数与<code>path</code>相同</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：匹配模式的最开头不需要添加<code>/</code>，因为默认情况下，每个<code>url</code>都带一个最前面的<code>/</code>，既然大家都有的部分，就不用浪费时间特别写一个了，所以一定要注意在写路由映射关系时，记得加末尾的<code>/</code></p>
</blockquote>
<h3 id="模板页面"><a href="#模板页面" class="headerlink" title="模板页面"></a>模板页面</h3><blockquote>
<p>返回一个字符串这肯定是不行的，太<code>low</code>了，也不好看，现在来返回一个正式的<code>HTML</code>页面</p>
<p>并在<code>HTML</code>页面中加入模板变量，由视图函数动态传递值；</p>
</blockquote>
<ul>
<li>配置<code>django</code>中模板页面的保存路径，在项目目录下的<code>settings.py</code>文件中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#myproject/settings.py</span></span><br><span class="line">TEMPLATES = [  </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.template.backends.django.DjangoTemplates'</span>,  </span><br><span class="line">        <span class="string">'DIRS'</span>: [os.path.join(BASE_DIR,<span class="string">'template'</span>)], </span><br><span class="line">        <span class="comment"># 就是这一行 设置静态模板路径   </span></span><br><span class="line">        <span class="string">'APP_DIRS'</span>: <span class="literal">True</span>,     </span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;       </span><br><span class="line">            <span class="string">'context_processors'</span>: [        </span><br><span class="line">                <span class="string">'django.template.context_processors.debug'</span>, </span><br><span class="line">                <span class="string">'django.template.context_processors.request'</span>,    </span><br><span class="line">                <span class="string">'django.contrib.auth.context_processors.auth'</span>, </span><br><span class="line">                <span class="string">'django.contrib.messages.context_processors.messages'</span>,  </span><br><span class="line">            ],    </span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>创建template</code>目录并在其中创建<code>index.html</code>文件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>HTML</code>页面中，我们并没有明确指出<code>H1</code>标签的内容；通过一个``来等待接收视图函数传来的数据，在<code>HTML</code>页面中这样的变量也叫做<strong>模板变量</strong>，双大括号为使用语法</p>
</blockquote>
<ul>
<li>接下来修改之前的视图函数，由视图函数传递变量给到<code>HTML</code>页面</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#myapp/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span> </span><br><span class="line">    <span class="comment">#return HttpResponse("&lt;h1&gt;Hello world&lt;/h1&gt;")  </span></span><br><span class="line">    content = &#123;       </span><br><span class="line">        <span class="string">"message"</span>:<span class="string">"你好，世界"</span> <span class="comment">#此处的key值message对应页面中我们写的&#123;&#123; message &#125;&#125;     </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'index.html'</span>,content)</span><br></pre></td></tr></table></figure>

<h4 id="render"><a href="#render" class="headerlink" title="render"></a>render</h4><blockquote>
<p>render函数用来返回一个模板页面，并将一个字典组合成的模板变量传递到模板页面上，完成页面的渲染</p>
</blockquote>
<ul>
<li><p><code>render(request, template_name, context=None)</code></p>
<blockquote>
<p>返回一个HTTP响应</p>
</blockquote>
<blockquote>
<p><code>request</code>： 固定接收<code>request</code>请求</p>
<p><code>template_name</code>： 为一个可以找到的模板页面</p>
<p><code>context</code>： 模板页面所需模板变量</p>
</blockquote>
</li>
</ul>
<h4 id="模板变量"><a href="#模板变量" class="headerlink" title="模板变量"></a>模板变量</h4><blockquote>
<p>在<code>django</code>中的<code>HTML</code>页面，不光可以编写原本的标签等内容，还可以像<code>Vue</code>一样在页面中使用双大括号，来提前定义一些模板变量，之后动态的渲染到<code>HTML</code>模板页面中</p>
</blockquote>
<blockquote>
<p>模板变量可以由后台视图函数构建一个<strong>字典数据类型</strong>传递，</p>
<p>字典的<code>key</code>是模板变量名，<code>value</code>值该模板变量对应的数据</p>
<p>当然，模板变量的内容远不止此，还会再后面继续为大家叙述</p>
</blockquote>
<h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><blockquote>
<p>虽然有了模板页面，可以来展示一些标签的效果，但是整个HTML还是感觉很丑陋</p>
<p>我们还要继续引入一些类似<code>css、img</code>这样的静态资源，来装饰我们的页面</p>
<p>在<code>django</code>中模板页面的静态资源使用，不能像之前写<code>HTML</code>代码直接引入</p>
<p>需要我们首先在项目中创建目录保存对应的静态资源，该目录名常为<code>static</code></p>
</blockquote>
<ul>
<li>在settings中配置静态文件保存目录，<strong>添加</strong>如下内容</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">STATICFILES_DIRS = (    os.path.join(BASE_DIR, <span class="string">'static'</span>),)</span><br><span class="line"><span class="comment"># STATICFILES_DIRS 该配置项用来告诉django在查找静态资源时，应该访问哪个目录</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在项目中创建<code>static</code>目录，<code>static</code>目录下创建专门保存图片的<code>img</code>目录，在里面存一张图片<code>1.jpg</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#此时的目录结构myproject/	myproject/	myapp/	template/	static/		img/			1.jpg</span></span><br></pre></td></tr></table></figure>

<ul>
<li>有了图片，接下来在模板页面中去引入并使用它，打开<code>index.html</code>进行修</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span> </span><br><span class="line">    &#123;% load staticfiles %&#125;<span class="tag">&lt;<span class="name">head</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'&#123;% static "img/1.jpg" %&#125;'</span> <span class="attr">alt</span>=<span class="string">"图片"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml">&gt; 这里用到了一个特殊语法：</span><span class="template-tag">&#123;% <span class="name">tag</span> %&#125;</span><span class="xml"> 这个叫静态标签，静态标签不同于模板变量，静态标签经常用来加载数据，或创建逻辑，比如之后我们要学到的</span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> %&#125;</span><span class="xml">，使用静态标签可以方便我们在模板页面上实现某些只有在后台代码中才可以实现的逻辑功能</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">&gt; 在页面中要引入静态资源：图片，`CSS`，`JS`文件在引入时都需要通过</span><span class="template-tag">&#123;% <span class="name"><span class="name">static</span></span> “path” %&#125;</span><span class="xml">来进行引入</span></span><br><span class="line"><span class="xml">&gt;</span></span><br><span class="line"><span class="xml">&gt; 最后，需要使用静态标签`static`前使用</span><span class="template-tag">&#123;% <span class="name"><span class="name">load</span></span> staticfiles %&#125;</span><span class="xml">标签进行静态资源路径的加载</span></span><br></pre></td></tr></table></figure>

<h3 id="模型数据库"><a href="#模型数据库" class="headerlink" title="模型数据库"></a>模型数据库</h3><blockquote>
<p>有了以上内容的修饰，现在感觉还是缺少一些什么，我们在视图函数中为前端页面返回的是一个提前定义好的变量，这显然在真正开发中是很少出现的，我们的数据大都来自于数据库中，那么现在需要我们在项目中加入数据库，并且在视图函数中通过对数据库的访问来拿到数据</p>
</blockquote>
<ul>
<li>创建数据库，这里使用项目自带的<code>SQLite3</code>数据库，默认已经是配置好的，接下来需要我们进入到<code>app</code>下的<code>models.py</code>文件中，编写一个类，这个类就对应数据库中的一张表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#myapp/models.py</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="comment"># Create your models here.class Weather(models.Model):  </span></span><br><span class="line">weather = models.CharField(max_length=<span class="number">100</span>,verbose_name=<span class="string">"天气"</span>) </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span>      </span><br><span class="line">    verbose_name_plural = <span class="string">"天气"</span>      </span><br><span class="line">    <span class="comment"># 设置当前表名的一个可读的性更好的名字  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> self.weather</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这里我们使用到了<code>django</code>的<code>orm</code>映射关系用来创建数据库表，继承自<code>django</code>的<code>models.Model</code>类，</p>
<p><strong>一个类用来表示一张表，类中的一个属性代表一个字段，</strong></p>
</blockquote>
<blockquote>
<p>这里我们定义了一个类型为<code>CharField</code>，长度为<code>100</code>的字段，用来存储天气</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">&gt; models.<span class="constructor">CharField(<span class="params">max_length</span>=100,<span class="params">verbose_name</span>=<span class="string">"天气"</span>)</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<blockquote>
<p>下面的<code>class Meta</code>是模型类的元类，用来设置当前表的一些属性；</p>
<p>这里我们使用<code>verbose_name_plural</code>属性设置当前表在<code>admin</code>后台查看时的名字</p>
</blockquote>
<blockquote>
<p>在这里我们还定义了一个属于实例的函数<code>__str__</code>，用来描述当前数据在返回时的默认展示结果，为<code>weather</code>字段的值</p>
</blockquote>
<blockquote>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">&gt; django`在创建模型类对应的数据表时，默认使用 `应用名`加`下划线`加`模型类名`作为表的名字；比如当前`Weather`表名为：`myapp_Weather</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><code>orm</code>映射关系，是<code>django</code>与数据库之间的一个桥梁，可以使开发者不再关注如何去编写<code>SQL</code>语句，直接通过一套<code>ORM</code>所提供的<code>API</code>接口即可方便对各种数据库进行交互</p>
</blockquote>
<ul>
<li>当某个子应用<code>APP</code>涉及到了数据库的使用时，要记得在<code>settings</code>文件中进行配置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#myproject/settings.py</span></span><br><span class="line">INSTALLED_APPS = [  </span><br><span class="line">    <span class="string">'django.contrib.admin'</span>, </span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,  </span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,  </span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,  </span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,  </span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,  </span><br><span class="line">    <span class="string">'myapp'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来通过<code>manage.py</code>命令行管理工具提供的两条，创建我们所需要的数据</li>
</ul>
<blockquote>
<p><strong>注意</strong>：默认<code>django</code>本身就已经需要一些数据的创建，所以我们在初次执行以下两条命令时可能会看到很多数据表和字段的创建，不要惊讶，这是正常的</p>
</blockquote>
<blockquote>
<p><code>python manage.py migrate</code>：根据数据库迁移文件生成对应<code>SQL</code>语句并执行</p>
<p>初次执行是为了先把默认django需要的数据库创建出来</p>
</blockquote>
<blockquote>
<p><code>python manage.py makemigrations</code>：创建数据库迁移文件</p>
<p>这次执行是为了创建APP中Weather模型类的迁移文件</p>
</blockquote>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> python manage.py migrate</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>将新添加的模型类迁移文件生成对应<code>SQL</code>，实际创建出对应的<code>Weather</code>表</p>
</blockquote>
<ul>
<li>如果提示结果正常，那么代表相应的数据表已经创建好了，接下来就需要我们去到<code>django</code>为我们提供的<code>admin</code>（数据库管理界面）来进行相关表的操作了！</li>
</ul>
<h3 id="admin控制台"><a href="#admin控制台" class="headerlink" title="admin控制台"></a>admin控制台</h3><blockquote>
<p><code>admin</code>控制台是<code>django</code>为我们提供的一个非常便捷的用来管理数据库的界面</p>
<p>在主控路由文件下，其实你已经看到了它对应的路由设置：<code>path(&#39;admin/&#39;, admin.site.urls),</code></p>
</blockquote>
<blockquote>
<p>进入<code>admin</code>界面，初次访问连接：<code>127.0.0.1/admin</code>，会提示我们输入账号密码，这是因为<code>django</code>的<code>admin</code>界面是需要一个超级管理员来登陆访问的，所以还需要我们创建对应的<code>admin</code>界面下的超级用户</p>
</blockquote>
<ul>
<li>创建<code>admin</code>超级用户，使用<code>manage.py</code>命令行工具执行如下命令</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br><span class="line">Username (leave blank to use <span class="string">'lienze'</span>): rootEmail address:Password:Password (again):This password <span class="keyword">is</span> too short. It must contain at least <span class="number">8</span> characters.This password <span class="keyword">is</span> too common.This password <span class="keyword">is</span> entirely numeric.Password:Password (again):This password <span class="keyword">is</span> too common.This password <span class="keyword">is</span> entirely numeric.Password:Password (again):Superuser created successfully.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上是我们创建超级用户的过程，非常坎坷；</p>
<p>可以看到，在输入太短（不满足8位），或是只包含数字的简单密码，超级用户的创建都是被拒绝的</p>
<p>所以我们把用户账号创建为<code>root</code>，而密码创建为<code>a1234567</code>，</p>
</blockquote>
<ul>
<li>接下来开启测试服务器，并通过创建好的超级用户登陆访问，如果幸运的话，你已经可以看到后台的<code>admin</code>界面啦</li>
</ul>
<blockquote>
<p><code>admin</code>界面已经展示出了默认<code>django</code>所使用的两张表，用户表和组表，用来保存当前管理后台的用户以及对应权限分组，可以点入用户表查看其中我们刚创建的<code>root</code>。</p>
</blockquote>
<h3 id="admin注册表"><a href="#admin注册表" class="headerlink" title="admin注册表"></a>admin注册表</h3><blockquote>
<p>问题还是有的，虽然<code>admin</code>界面已经可以登入，但是为什么看不到刚才创建的<code>Weather</code>表呢</p>
<p>这是因为默认的表创建之后，还需要通过对应app下的<code>admin.py</code>文件进行<code>admin</code>后台注册，只有注册在这个文件中的模型类对应的表才可以在<code>admin</code>界面所看到</p>
</blockquote>
<ul>
<li>在app下的admin.py文件中进行模型类的注册</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#myapp/admin.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> models</span><br><span class="line">admin.site.register(models.Weather)</span><br><span class="line"><span class="comment">#使用register函数接收模型类作为参数即可完成注册</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注册成功之后，在服务器，通过浏览器访问<code>admin</code>界面，就可以看到创建好的<code>Weather</code>表了</p>
</blockquote>
<ul>
<li>鼠标点击进去之后，就可以看到对应的表数据界面；右上角提供了可以添加功能的选项，试试给这个表来一些数据吧，这里我们添加了三条数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">阴天，晴天，打雷了</span><br></pre></td></tr></table></figure>

<h3 id="视图操作模型"><a href="#视图操作模型" class="headerlink" title="视图操作模型"></a>视图操作模型</h3><blockquote>
<p>最终我们希望可以在视图函数中通过<code>orm</code>接口来访问到表中的数据，那么来打开视图文件吧：<code>views.py</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#myapp/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> models</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span>  </span><br><span class="line">    weathers = models.Weather.objects.all()   </span><br><span class="line">    content = &#123;     </span><br><span class="line">        <span class="string">"weathers"</span>:weathers,   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'index.html'</span>, content)</span><br></pre></td></tr></table></figure>

<ul>
<li>光返回是不行的，虽然我们绑定到了模板版变量的字典中，但是还得修改一下对应的要渲染的<code>HTML</code>页面哦：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span> </span><br><span class="line">    &#123;% load staticfiles %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">        &#123;% for weather in weathers %&#125;   </span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; weather &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>   </span><br><span class="line">        &#123;% empty %&#125;    </span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>没有任何天气<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml">&gt; 模板标签</span><span class="template-tag">&#123;% <span class="name"><span class="name">for</span></span> xxx <span class="keyword">in</span> xxxs %&#125;</span><span class="xml">可以用来在模板页面出迭代访问取出每一个数据</span></span><br><span class="line"><span class="xml">&gt;</span></span><br><span class="line"><span class="xml">&gt; 具体对于不同序列数据的访问我们会在后面详细为大家介绍</span></span><br><span class="line"><span class="xml">&gt;</span></span><br><span class="line"><span class="xml">&gt; </span><span class="template-tag">&#123;% <span class="name"><span class="name">empty</span></span> %&#125;</span><span class="xml">标签用来判断当循环访问数据为空时要做的事情，最后循环标签要有</span><span class="template-tag">&#123;% <span class="name"><span class="name">endfor</span></span> %&#125;</span><span class="xml">标签进行结束；因为`HTML`中并没有像`Python`缩进这样的方式来控制代码块。</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>至此，我们的<code>HELLO WORLD</code>项目已经涵盖了<code>django</code>框架中的大部分常用的组件；</p>
<p><strong>路由</strong>、<strong>视图</strong>、<strong>模板</strong>、<strong>静态</strong>、<strong>模型</strong>，<strong>admin</strong></p>
<p>那么其中每一部分都还有很多内容等着我们去了解，在接下来的章节中我们会继续详细给大家介绍！</p>
</blockquote>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django-Views-视图层</title>
    <url>/Django-Views-%E8%A7%86%E5%9B%BE%E5%B1%82/</url>
    <content><![CDATA[<h2 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h2><blockquote>
<p>视图函数一般用来接收一个<code>Web</code>请求<code>HttpRequest</code>，之后返回一个Web响应<code>HttpResponse</code></p>
</blockquote><h3 id="HttpRequest"><a href="#HttpRequest" class="headerlink" title="HttpRequest"></a>HttpRequest</h3><blockquote>
<p>一个视图函数用来响应用户的<code>Request</code>请求，每个视图函数默认的第一个位置参数<code>request</code>用来接收用户发起请求的<code>HttpRequest</code>信息。</p>
<p>视图函数的返回值，为一个<code>HttpResponse</code>值，包括我们要返回给用户的<code>HTML</code>页面或者字符串等等，以及对应的头部字段信息</p>
</blockquote><a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Hello world'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="常见请求方式"><a href="#常见请求方式" class="headerlink" title="常见请求方式"></a>常见请求方式</h3><blockquote>
<p><code>POST</code>和<code>GET</code>是<code>HTTP</code>协议定义的与服务器交互的方法。</p>
<p><code>GET</code>一般用于获取/查询资源信息，而<code>POST</code>一般用于更新资源信息。另外，还有<code>PUT</code>和<code>DELETE</code>方法</p>
</blockquote>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><blockquote>
<p>常用来从指定地址请求数据；</p>
<p>如果需要在请求时提交某些数据，则以路由形式传递参数，查询<code>Query</code>字符串如下格式所示：</p>
</blockquote>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">http<span class="variable">s:</span>//www.baidu.<span class="keyword">com</span>/?key=<span class="keyword">abc</span>&amp;pos=shanxi</span><br></pre></td></tr></table></figure>

<ul>
<li><code>get</code>请求可被浏览器缓存，保存在历史记录中</li>
<li><code>get</code>不应在使用敏感数据时使用，明文包路在请求地址中</li>
<li><code>get</code>有长度限制</li>
</ul>
<h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><blockquote>
<p>向指定的资源提交要被处理的数据</p>
<p>使用<code>POST</code>，提交的数据保存在<code>HTTP</code>协议中的消息主体部分</p>
</blockquote>
<ul>
<li><code>post</code>请求不会被浏览器缓存</li>
<li><code>post</code>提交数据长度无限制</li>
<li><code>post</code>比<code>get</code>更加安全</li>
</ul>
<h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><blockquote>
<p>如果说<code>urls.py</code>是<code>Django</code>中前端页面和后台程序桥梁，那么<code>request</code>就是桥上负责运输的小汽车，可以说后端接收到的来至前端的信息几乎全部来自于<code>requests</code>中</p>
</blockquote>
<h4 id="request-method"><a href="#request-method" class="headerlink" title="request.method"></a>request.method</h4><blockquote>
<p>获取当前用户请求方式，</p>
<p>请求方式字符串为纯大写：<code>&#39;GET&#39;</code>、<code>&#39;POST&#39;</code></p>
<p>如用户以<code>get</code>方式发起请求，对应代码中获取到的结果以及在判断时像是这样</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span>	</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:		</span><br><span class="line">        …</span><br></pre></td></tr></table></figure>

<h4 id="request-GET"><a href="#request-GET" class="headerlink" title="request.GET"></a>request.GET</h4><blockquote>
<p>当用户通过<code>get</code>方式请求站点，并在路由中提供了查询参数，可以通过该属性获取到对应提交的值</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span>   </span><br><span class="line">    print(request.GET) </span><br><span class="line">    <span class="comment"># &lt;QueryDict: &#123;'name': ['jack'], 'id': ['1']&#125;&gt;    </span></span><br><span class="line">    print(type(request.GET))   </span><br><span class="line">    <span class="comment"># &lt;class 'django.http.request.QueryDict'&gt; </span></span><br><span class="line">    name_ = request.GET.get(<span class="string">'name'</span>)   </span><br><span class="line">    id_ = request.GET.get(<span class="string">'id'</span>)  </span><br><span class="line">    content = <span class="string">'%s:%s'</span> % (name_,id_)   </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(content)</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">&gt; request.GET`是一个类似字典的数据类型：`QueryDict</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>其中也支持类似对字典的<code>get</code>或直接<code>dict.[key]</code>键值访问方式，当然使用<code>get</code>方式进行对应<code>key</code>获取会更好，因为<code>get</code>在访问不到时不会报错</p>
</blockquote>
<ul>
<li>如果定义了如上所示的视图函数，那么在访问连接时，我们可以通过路由传参：</li>
</ul>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//127.0.0.1:8000/?name=jack&amp;id=1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这里对应页面会显示的结果：</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">jack:<span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：使用<code>GET</code>方法在连接中进行参数提交，后台接收到的数据类型均是字符串</p>
</blockquote>
<hr>
<h4 id="request-POST"><a href="#request-POST" class="headerlink" title="request.POST"></a>request.POST</h4><blockquote>
<p>获取用户以<code>post</code>形式提交的数据并保存在后台，为类字典数据，这里和<code>request.GET</code>是一个东西；</p>
<p>在网页中，一般我们通过<code>html</code>的表单进行数据的提交，<code>POST</code>方式可以提交空数据</p>
</blockquote>
<ul>
<li>因为涉及到了表单页面，所以我们先来弄一个<code>HTML</code>页面</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一个关于POST的测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span>  </span><br><span class="line">        &#123;% csrf_token %&#125;    </span><br><span class="line">        账号:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"account"</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span>      </span><br><span class="line">        密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"passwd"</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在模板页面中，一旦涉及到了表单提交，那么一定要注意在表单区域添加<code>csrf_token</code>标签进行防跨站伪造令牌的加载，否则表单数据的将被认为是无效的。</p>
</blockquote>
<blockquote>
<p>在接下来的视图函数中会使用到<code>input</code>标签中的<code>name</code>属性；</p>
<p><code>name</code>值属性维护了<code>post</code>的数据传入到后台时的标示，会与表单的数据组合成类字典格式</p>
<p>如<code>name</code>属性为<code>account</code>的输入框中输入了<code>test</code>，那么后台数据接收到的值类似：<code>{&#39;account&#39;:&#39;test&#39;}</code></p>
</blockquote>
<ul>
<li>写一个视图函数用来捕获当前表单使用POST形式提交的数据：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span>   </span><br><span class="line">    <span class="keyword">if</span> request.method=<span class="string">"POST"</span>:</span><br><span class="line">        print(request.POST)    </span><br><span class="line">        print(type(request.POST))   </span><br><span class="line">        account = request.POST.get(<span class="string">"account"</span>)  </span><br><span class="line">        passwd = request.POST.get(<span class="string">"passwd"</span>)   </span><br><span class="line">        content = <span class="string">"%s:%s"</span> % (account,passwd)    </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(content)  </span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">"index.html"</span>) <span class="comment">#在使用get形式请求时，返回表单页面</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果在表单页面中账号填写为test，密码为123456；在视图函数中捕捉到的结果为：</li>
</ul>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">&lt;<span class="symbol">QueryDict</span>: &#123;<span class="string">'csrfmiddlewaretoken'</span>: [<span class="string">'EmyGwsVcrXI2LDkYLS9qflkUH4N7bM1nfTQxr3fsOsZlI4vJFwci7TargtYRAGl2'</span>], <span class="string">'account'</span>: [<span class="string">'test'</span>], <span class="string">'passwd'</span>: [<span class="string">'123456'</span>]&#125;&gt;</span><br></pre></td></tr></table></figure>

<h5 id="表单多值提交"><a href="#表单多值提交" class="headerlink" title="表单多值提交"></a>表单多值提交</h5><blockquote>
<p>在<code>request.POST</code>中需要注意，某些情况下，使用POST提交数据的表单数据可能是多个值，类似复选框<code>CheckBox</code>，直接使用<code>request.POST.get()</code>进行获取是有一些问题的，比如修改模板页面如下所示</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span>  </span><br><span class="line">    &#123;% csrf_token %&#125;    </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"taste"</span> <span class="attr">value</span>=<span class="string">"eat"</span>&gt;</span>吃  </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"taste"</span> <span class="attr">value</span>=<span class="string">"sleep"</span>&gt;</span>睡  </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"taste"</span> <span class="attr">value</span>=<span class="string">"play"</span>&gt;</span>耍  </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是一个<code>name</code>值为<code>taste</code>的兴趣爱好采集的多选框，<code>value</code>值将会作为选中时，提交到后台的值，比如现在我们全选这些表单数据，那么后台接收到的值是这样的</p>
</blockquote>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">&lt;<span class="symbol">QueryDict</span>: &#123;<span class="string">'csrfmiddlewaretoken'</span>: [<span class="string">'nuaLzxc2E0artYKUZiefMPv5iHTX5gLFY1sCu8wi1vrKqpVFTWh7EnlCR64Hua5k'</span>], <span class="string">'taste'</span>: [<span class="string">'eat'</span>, <span class="string">'sleep'</span>, <span class="string">'play'</span>]&#125;&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是问题接踵而至，我们发现使用<code>get</code>函数获取不到对应全选的整个结果，而是只拿到了选中的最后一项</p>
</blockquote>
<ul>
<li><p><code>request.POST.get(key, default=None)</code></p>
<blockquote>
<p>返回对应<code>key</code>值的数据中的<strong>最后一个</strong>数据单独返回；<code>key</code>值不存在，取<code>default</code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>要想真正拿出所有的结果，应该使用<code>getlist</code>函数</p>
</blockquote>
<ul>
<li><p><code>request.POST.getlist(key, default=None)</code></p>
<blockquote>
<p>将对应<code>key</code>值的所有数据以<strong>一个列表</strong>形式返回；<code>key</code>值不存在，取<code>default</code></p>
</blockquote>
</li>
</ul>
<h4 id="request-META"><a href="#request-META" class="headerlink" title="request.META"></a>request.META</h4><blockquote>
<p><code>request.MAT</code>E获取的是一个标准的<code>python</code>字典。它包含了所有的<code>HTTP</code>请求信息</p>
<p>比如用户IP地址和用户<code>Agent</code>（通常是浏览器的名称和版本号）。</p>
<p>注意，<code>Header</code>信息的完整列表取决于用户所发送的<code>Header</code>信息和服务器端设置的<code>Header</code>信息</p>
</blockquote>
<ul>
<li><code>CONTENT_LENGTH</code>：请求的正文的长度，字符串类型</li>
<li><code>CONTENT_TYPE</code>：请求的正文的<code>MIME</code> 类型</li>
<li><code>HTTP_ACCEPT</code>：响应可接收的<code>Content-Type</code></li>
<li><code>HTTP_ACCEPT_ENCODING</code>：响应可接收的编码</li>
<li><code>HTTP_ACCEPT_LANGUAGE</code>：响应可接收的语言</li>
<li><code>HTTP_HOST</code>：客服端发送的<code>HTTP Host</code>头部</li>
<li><code>HTTP_REFERER</code>：请求前的连接地址</li>
<li><code>HTTP_USER_AGENT</code>：客户端的<code>user-agent</code>字符串</li>
<li><code>QUERY_STRING</code>：单个字符串形式的查询字符串（未解析过的形式）</li>
<li><code>REMOTE_ADDR</code>：客户端的IP 地址</li>
<li><code>REMOTE_HOST</code>：客户端的主机名</li>
<li><code>REMOTE_USER</code>：服务器认证后的用户</li>
<li><code>REQUEST_METHOD</code>：一个字符串，例如<code>GET</code> 或<code>POST</code></li>
<li><code>SERVER_NAME</code>：服务器的主机名</li>
<li><code>SE0RVER_PORT</code>：服务器的端口，字符串类型</li>
</ul>
<h4 id="request-FILES"><a href="#request-FILES" class="headerlink" title="request.FILES"></a>request.FILES</h4><blockquote>
<p>接收用户上传文件及相关信息。同样类似于<code>request.POST</code>，提取到的数据为一个类字典的数据类型，包含所有文件上传的信息</p>
</blockquote>
<ul>
<li><p><code>f = request.FILES.get(&#39;upload_file&#39;)</code></p>
<blockquote>
<p><code>file_data = f.read()</code>：读取整个上传文件的内容，适合小文件上传</p>
<p><code>yiled = f.chunks()</code>：返回一个类似生成器<code>（）</code>的数据，每一次读取按块返回文件，可以通过<code>for</code>迭代访问其中数据；适合上传大文件到服务器。</p>
<p><code>f.multiple_chunks()</code>：返回文件大小，当文件大小大于<code>2.5M</code>时，返回<code>True</code>，反之返回<code>False</code>，可以通过该函数来选择是否使用<code>chunks</code>方法或<code>read</code>直接存储。</p>
<p>如果想要修改这个文件判定的默认值，可以通过：<code>FILE_UPLOAD_MAX_MEMORY_SIZE</code>在<code>settings</code>文件下进行设置</p>
<p><code>f.content_type</code>：上传文件时头部中的<code>Content-Type</code>字段值，参考MIME类型</p>
<p><code>f.name</code>：上传文件名字</p>
<p><code>f.charset</code>：上传文件编码</p>
<p><code>f.size</code>： 上传文件大小，字节为单位：<code>byte</code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>创建好静态资源目录，并在下面创建一个<code>img</code>文件夹，保存我们即将上传的图片；</p>
<p>完成上传文件的<code>HTML</code>表单页面</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span> </span><br><span class="line">    &#123;% csrf_token %&#125;   </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"upload_file"</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&#123;% static 'img/1.jpg' %&#125;"</span> <span class="attr">alt</span>=<span class="string">"这是一张图片"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里使用的是即将要上传的文件名字，只做文件是否上传成功的简单测试 --&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：上传文件的页面表单，一定要记得设置属性<code>enctype=&quot;multipart/form-data&quot;</code></p>
</blockquote>
<ul>
<li>视图函数如下编写，接收上传图片，并保存在静态目录下刚才创建好的img目录中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"POST"</span>:   </span><br><span class="line">        f = request.FILES.get(<span class="string">"upload_files"</span>)  </span><br><span class="line">        path = os.path.join(settings.STATICFILES_DIRS[<span class="number">0</span>],<span class="string">'img/'</span>+f.name)  </span><br><span class="line">        <span class="comment"># 上传文件本地保存路径   </span></span><br><span class="line">        <span class="keyword">with</span> open(path,<span class="string">'wb'</span>) <span class="keyword">as</span> fp:     </span><br><span class="line">            <span class="keyword">if</span> f.multiple_chunks: <span class="comment">#判断到上传文件为大于2.5MB的大文件     </span></span><br><span class="line">                <span class="keyword">for</span> buf <span class="keyword">in</span> f.chunks(): <span class="comment">#迭代写入文件      </span></span><br><span class="line">                    fp.write(buf)        </span><br><span class="line">                    <span class="keyword">else</span>:             </span><br><span class="line">                        fp.write(f.read())    </span><br><span class="line">                        <span class="keyword">return</span> HttpResponse(<span class="string">"Success!"</span>)  </span><br><span class="line">                    <span class="keyword">return</span> render(request, <span class="string">'index.html'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试上传一个名为<code>1.jpg</code>的图片，如果成功上传，那么后台<code>static</code>目录下会出现该图片，并且模板页面也可以展示对应图片效果</p>
</blockquote>
<h3 id="HTTPResponse"><a href="#HTTPResponse" class="headerlink" title="HTTPResponse"></a>HTTPResponse</h3><blockquote>
<p>一个视图的返回值经常是为了向用户返回一个<code>HttpResponse</code>响应，</p>
<p>有如下常用的可以返回<code>HttpResponse</code>的函数</p>
</blockquote>
<h4 id="response"><a href="#response" class="headerlink" title="response"></a>response</h4><ul>
<li><p><code>HttpResponse(content=b&#39;&#39;)</code></p>
<blockquote>
<p>返回一个字符串内容</p>
<p><em>from</em> django.http <em>import</em> HttpResponse</p>
</blockquote>
</li>
<li><p><code>render(request,template_name,context=None,content_type=None,status=None)</code></p>
<blockquote>
<p>返回一个可渲染HTML页面，状态码为<code>200</code></p>
<p><em>from</em> django.shortcuts <em>import</em> render</p>
</blockquote>
<blockquote>
<p><code>request</code>：固定参数，响应的<code>request</code>请求，来自于参数部分接收的<code>HttpRequest</code></p>
<p><code>template_name</code>：返回的模板页面路径</p>
<p><code>context</code>：模板页面渲染所需的数据，默认为字典格式</p>
<p><code>content_type</code>：生成之后的结果使用的<code>MIME</code>类型</p>
<p><code>status</code>：响应的状态码，默认为<code>200</code></p>
</blockquote>
</li>
<li><p><code>redirect(to, permanent=False)</code></p>
<blockquote>
<p>一个重定向，浏览器通过该状态码自动跳转到一个新的路由地址，默认返回响应状态码<code>302</code></p>
<p><em>from</em> django.shortcuts <em>import</em> redirect</p>
</blockquote>
<blockquote>
<p><code>to</code>：可以是一个<code>django</code>项目中视图函数的路由映射，也可以是一个<code>reverse</code>的反向路由解析</p>
<p><code>permanent</code>：如果设置为<code>True</code>，将返回<code>301</code>状态码，代表永久重定向</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">302</span>：临时重定向，旧地址资源临时不能用了，搜索引擎只会暂时抓取新地址的内容而保存旧的地址。<span class="number">301</span>：永久重定向，旧地址资源已经不复存在，搜索引擎不光会抓取新地址的内容，还会替换旧地址为新地址</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="视图错误处理"><a href="#视图错误处理" class="headerlink" title="视图错误处理"></a>视图错误处理</h3><blockquote>
<p>为了方便我们开发，<code>django</code>提供了一个异常叫做<code>Http404</code>异常，我们可以在视图函数的代码中按照需求进行抛出，抛出之后<code>django</code>项目会自动捕获该异常，并会展示默认的<code>404</code>页面</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span>   </span><br><span class="line">    <span class="keyword">if</span> request.GET.get(<span class="string">"id"</span>) == <span class="string">"1"</span>:    </span><br><span class="line">        <span class="keyword">raise</span> Http404</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>settings</code>中的<code>debug</code>配置项为<code>false</code>时，访问<code>http://127.0.0.1:8000/?id=1</code>，可以看到<code>django</code>为我们提供的错误页面；</p>
<p>除了<code>django</code>默认提供的，我们还可以可以在模板目录下定义全局<code>404.html</code>进行错误页面的定制</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>    抱歉，找不到你要的东西<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义错误处理视图"><a href="#自定义错误处理视图" class="headerlink" title="自定义错误处理视图"></a>自定义错误处理视图</h4><blockquote>
<p>除去<code>404</code>错误的自定义，<code>django</code>还提供了覆盖默认错误行为处理的办法；</p>
<p>有些时候，<code>django</code>自动的错误处理可能不能满足我们的需求，那么我们可以重新定义一些新的视图函数，</p>
<p>来覆盖掉<code>django</code>所提供的错误处理视图函数，最后在<code>urls.py</code>路由配置文件下通过定义全局变量来重新设置默认的错误处理视图函数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">handler404：覆盖page_not_found()视图。</span><br><span class="line">handler500：覆盖server_error()视图。</span><br><span class="line">handler403：覆盖permission_denied()视图。</span><br><span class="line">handler400：覆盖bad_request()视图</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line">urlpatterns = [    path(<span class="string">'admin/'</span>, admin.site.urls),  </span><br><span class="line">               path(<span class="string">''</span>, include(<span class="string">"viewapp.urls"</span>)),]</span><br><span class="line">handler404 = <span class="string">"viewapp.views.error_404"</span></span><br><span class="line"><span class="comment"># APP.模块.视图函数</span></span><br><span class="line">handler500 = <span class="string">"viewapp.views.error_500"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>相关定义好的错误处理视图函数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_404</span><span class="params">(request)</span>:</span>    </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"这是404错误"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_403</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"这是403错误"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_500</span><span class="params">(request)</span>:</span> </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"这是500错误"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django-Urls-路由层</title>
    <url>/Django-Urls-%E8%B7%AF%E7%94%B1%E5%B1%82/</url>
    <content><![CDATA[<h2 id="路由层"><a href="#路由层" class="headerlink" title="路由层"></a>路由层</h2><blockquote>
<p>路由是Web服务的入口，就好像办事大厅有各个服务窗口一样</p>
</blockquote><blockquote>
<p>Django奉行DRY主义，提倡使用简洁、优雅的URL：</p>
<p> 可以不用<code>.html</code>、<code>.php</code>或<code>.cgi</code>之类后缀</p>
<p> 尽量不要单独使用无序随机数字这样无意义的东西</p>
<p> 让你随心所欲设计你的URL，不受框架束缚</p>
</blockquote><a id="more"></a>

<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="urlpatterns"><a href="#urlpatterns" class="headerlink" title="urlpatterns"></a>urlpatterns</h4><blockquote>
<p>urlpatterns是路由文件中的一个全局变量，用来存放路由及视图函数的映射关系</p>
<p>用户发起的请求<code>URL</code>都会首先进入主控制目录下的这个<code>urls.py</code>文件中进行查找匹配</p>
</blockquote>
<ol>
<li>首先找到<code>urls.py</code>下的<code>urlpatterns</code>全局变量，这是一个路由规则实例的列表数据。</li>
<li>按照先后定义顺序，进行路由匹配。</li>
<li>找到第一个匹配项时停止匹配，执行匹配到的视图函数。</li>
<li>遍历完全，未发现匹配，<code>django</code>进行异常处理</li>
</ol>
<blockquote>
<p>其中<code>urlpatterns</code>中的每一个路由映射规则可以由<code>path</code>或<code>re_path</code>进行构造</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：<code>Django</code>的路由不考虑<code>HTTP</code>请求方式，仅根据URL进行路由；即，只要<code>URL</code>相同，无论<code>POST</code>、<code>GET</code>等哪种请求方式都指向同一个操作函数</p>
</blockquote>
<h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><ul>
<li><p><code>path(regex, view, kwargs=None, name=None)</code></p>
<blockquote>
<p><code>regex</code>：一个匹配对应url地址的规则字符串。</p>
<p><code>view</code>：路由对应的视图函数，并且会自动封装HttpRequest作为第一个参数给这个视图函</p>
<p><code>kwargs</code>：视图函数的关键字参数。</p>
<p><code>name</code>：该路由的全局命名，可以让我们方便的在django项目中任意部分显示的使用，相当于为<code>url</code>取变量名，接下来全局使用该命名值即可；当对应<code>url</code>路由改变之后，结合路由反向解析使用的地方不需要更改路由</p>
<p>此外，<code>django</code>还提供了一个兼容老版本<strong>url</strong>路由配置函数的<strong>re_path</strong>函数；<code>re_path</code>：第一个参数部分为一个正则匹配规则，其他与path同</p>
</blockquote>
</li>
</ul>
<h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><blockquote>
<p>静态路由用来映射对应视图函数，以下是一个简单的例子</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Hello Worlds!'</span>)</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,re_path</span><br><span class="line"><span class="keyword">from</span> urlapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [    path(<span class="string">''</span>,views.index),    re_path(<span class="string">r"^"</span>,views.index),]</span><br></pre></td></tr></table></figure>

<h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><blockquote>
<p>有的时候，我们的路由设置不能一直维持一个一成不变的状态；</p>
<p>比如遇到一些内容翻页的场景，那么我们的连接可能是：<code>xx.com/airticle_list/1/</code>、<code>xx.com/airticle_list/2/</code></p>
<p>那么这样的路由其实对应的都应该是一个视图函数，用以展示页面内容，那么如何设计这样的路由，就要涉及到动态路由及路由传参</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request,x,y)</span>:</span>  </span><br><span class="line">    content = <span class="string">"x:%s\ny:%s"</span> % (x,y)  	</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(content)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>定义如上函数，将会接收连接中的后两部份<code>path</code>值作为参数，分别依次给到<code>x</code>和<code>y</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,re_path</span><br><span class="line"><span class="keyword">from</span> urlapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [    path(<span class="string">'&lt;int:x&gt;/&lt;str:y&gt;/'</span>,views.index), </span><br><span class="line">               <span class="comment">#指明类型    path("&lt;x&gt;/&lt;y&gt;/",views.index)  </span></span><br><span class="line">               <span class="comment">#不指明类型    re_path(r"^(?P&lt;x&gt;\d+)/(?P&lt;y&gt;[a-zA-Z]+)/$"),</span></span><br><span class="line">               <span class="comment"># (?P&lt;name&gt;pattern) 正则分组   </span></span><br><span class="line">               re_path(<span class="string">r"^(\d+)/([a-zA-Z]+)/$"</span>),]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>路由通过尖括号进行分组匹配，使用int以及str内置转换器将连接对应部分的值进行转换；并将匹配到的结果传递到视图函数对应的参数位置上；</p>
<p>访问：<code>http://127.0.0.1:8000/1/abc/</code></p>
<p>其中<code>1</code>将作为x的参数值，<code>abc</code>将作为y的参数</p>
<p>但如果访问连接是：<code>http://127.0.0.1:8000/abc/abc/</code>，这会匹配到第二个路由，第二个路由没有对传递参数的类型进行限定</p>
</blockquote>
<ul>
<li>内置Path转换器：</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">str：匹配除了路径分隔符（`/`）之外的非空字符串，这是默认的形式<span class="built_in">int</span>：匹配正整数，包含<span class="number">0</span>slug：匹配字母、数字以及横杠、下划线组成的字符串uuid：匹配格式化的uuid，如 <span class="number">075194</span>d3<span class="number">-6885</span><span class="number">-417</span>e-a8a8<span class="number">-6</span>c931e272f00path：匹配任何非空字符串，包含了路径分隔符</span><br></pre></td></tr></table></figure>

<h4 id="自定义转换器"><a href="#自定义转换器" class="headerlink" title="自定义转换器"></a>自定义转换器</h4><blockquote>
<p>除了以上<code>django</code>所提供的path转换器，如果还觉得无法实现我们想要的功能，我们可以通过编写一个类进行自定义<code>path</code>转换器</p>
</blockquote>
<ol>
<li><p>定义转换器类，类名随意</p>
</li>
<li><p>定义类中必须属性</p>
<blockquote>
<p><code>regex</code>：一个字符串形式的正则表达式，也是对应的路由规则</p>
<p><code>to_python(self, value)</code>：用于将匹配到的路由字符串转换为<code>Python</code>中的数据类型，并传递给视图函数，<strong>如果转换失败，必须抛出ValueError</strong>，路由映射视图函数时使用</p>
<p><code>to_url(self, value)</code>：将<code>Python</code>数据类型转换为一段url的方法，<code>to_python</code>方法的反向操作，反向解析时使用</p>
</blockquote>
</li>
<li><p>通过django.urls模块中的register_converter函数进行注册</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数第一个参数为转换器类</span><br><span class="line">函数第二个参数为转换器别名</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>以下定义一个路由参数只能是三位字符的路由规则</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先将转换器类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeChar</span>:</span>  </span><br><span class="line">    regex = <span class="string">"[a-zA-Z]&#123;3&#125;"</span>   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_python</span><span class="params">(self,value)</span>:</span>    </span><br><span class="line">        print(<span class="string">"to_python"</span>)       </span><br><span class="line">        <span class="keyword">return</span> str(value)   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_url</span><span class="params">(self,value)</span>:</span>    </span><br><span class="line">        <span class="comment"># 当通过反向路由解析时，将会调用该函数    </span></span><br><span class="line">        print(<span class="string">'to_url'</span>)        </span><br><span class="line">        <span class="keyword">return</span> str(value)[:<span class="number">3</span>]   </span><br><span class="line">    <span class="comment">#此处切片操作是为了当反向路由解析传参字符串长于3时，可以将其截断，符合转换器正则规则#注册转换器</span></span><br><span class="line">    <span class="keyword">from</span> django.urls <span class="keyword">import</span> register_converterregister_converter(ThreeChar,<span class="string">'tc'</span>)</span><br><span class="line">urlpatterns = [    path(<span class="string">'&lt;tc:x&gt;/&lt;tc:y&gt;/'</span>,views.index)]<span class="comment">#127.0.0.1:8000/aaa/bbb/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下里，通过路由进行访问该视图映射时，一定是三个字符所组成的路由才可以，否则是访问不到的</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line">app_name = <span class="string">"app"</span>path(<span class="string">'&lt;tc:x&gt;/&lt;tc:y&gt;/'</span>,</span><br><span class="line">                     views.index, name=<span class="string">"threechr"</span>)</span><br><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="keyword">return</span> redirect(reverse(<span class="string">"app:threechr"</span>,args=(<span class="string">'aaaa'</span>,<span class="string">'bbbb'</span>)))</span><br><span class="line"><span class="comment">#此时会调用three路由规则中的tc转换器中的to_url反向合成路由，并切片只取参数前三位</span></span><br></pre></td></tr></table></figure>

<h3 id="路由分发"><a href="#路由分发" class="headerlink" title="路由分发"></a>路由分发</h3><blockquote>
<p>我们的路由编写都是在项目主要目录下的<code>urls.py</code>文件中，但是如果<code>app</code>有很多的话，这么多路由都写到一起，明显是一件很不方便管理的事情</p>
<p>其实在之前的练习中，我们使用的方式均是路由分发，每个子<code>app</code>都拥有自己独立的<code>urls.py</code>路由映射文件，而主控路由文件里只需要使用<code>include</code>函数导入子<code>app</code>下路由文件即可，这就是路由分发</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line">urlpatterns = [    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">               path(<span class="string">''</span>,include(<span class="string">"urlapp.urls"</span>)) </span><br><span class="line">               <span class="comment"># 使用include 实现路由分发，找到子app下的路由文件</span></span><br><span class="line">              ]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>路由分发为我们带来的好处有很多，可以让我们在多个<code>app</code>的项目中更加方便有效的管理每一个路由</p>
<p>并且也可以让我们的用户在访问时看到浏览器中的<code>URL</code>地址更加<strong>赏心悦目</strong></p>
</blockquote>
<h3 id="路由反向解析"><a href="#路由反向解析" class="headerlink" title="路由反向解析"></a>路由反向解析</h3><blockquote>
<p>到了这里，思考一下，之前我们已经设置过了很多路由；</p>
<p>但是现在会出现一个问题，比如我们把其中某个路由规则进行了修改，把<code>aaa</code>换成了<code>aba</code>，那么现在我们需要回到每一个使用到这个路由的地方进行同步修改，这显然非常麻烦的，如果修改的路由更多，这甚至是一个灾难</p>
</blockquote>
<blockquote>
<p><code>django</code>也为我们提供了一个解决办法，通过为路由映射使用<code>name</code>参数，来为每一个路由映射设置一个独立唯一的变量名</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path(<span class="string">'left/&lt;str:x&gt;/'</span>,views.left, name=<span class="string">"left"</span>),</span><br><span class="line">path(<span class="string">'right/&lt;int:x&gt;/'</span>,views.right, name=<span class="string">"right"</span>),</span><br><span class="line"><span class="comment"># 通过正则命名分组方式</span></span><br><span class="line">re_path(<span class="string">r'^left/([a-zA-Z]+)/$'</span>,views.left,name=<span class="string">"left"</span>),</span><br><span class="line">re_path(<span class="string">r'^right/(?P&lt;x&gt;\d+)/$'</span>,views.right, name=<span class="string">"right"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>两个视图函数对应如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left</span><span class="params">(request,x)</span>:</span></span><br><span class="line">    <span class="comment"># x: str    </span></span><br><span class="line">    content = &#123;        <span class="string">'message'</span>:x,    &#125;    </span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"left.html"</span>, content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right</span><span class="params">(request,x)</span>:</span></span><br><span class="line">    <span class="comment"># x: int</span></span><br><span class="line">    content = &#123;        <span class="string">'message'</span>:x,    &#125;    </span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"right.html"</span>,content)</span><br></pre></td></tr></table></figure>

<ul>
<li>两个HTML页面</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是左页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'right' 123 %&#125;"</span>&gt;</span>右页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ------另一个页面------ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是右页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'left' 'abc' %&#125;"</span>&gt;</span>右页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml">&gt; 在模板页面中，对于已命名路由可以通过</span><span class="template-tag">&#123;% <span class="name"><span class="name">url</span></span> “name” “arg” %&#125;</span><span class="xml">模板标签进行反向解析</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数以空格隔开，在标签后传入</p>
</blockquote>
<ul>
<li>视图函数反向解析</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span>   </span><br><span class="line">    <span class="keyword">return</span> redirect(reverse(<span class="string">"left"</span>,args=(<span class="string">'aaa'</span>,) ))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在视图函数中需要使用到路由命名时，进行反向解析需要我们通过<code>django.shortcuts</code>模块下的<code>reverse</code>函数</p>
</blockquote>
<ul>
<li><code>reverse(viewname,args=None,kwargs=None)</code></li>
</ul>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">参数介绍viewname：视图函数、命名路由映射、或视图函数路径的字符串<span class="built_in">args</span>：元组形式路由传参。kwargs：字典形式路由传参</span><br></pre></td></tr></table></figure>

<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><blockquote>
<p>如果想在多个<code>app</code>下使用相同的<code>name</code>路由命名，那么我们可以通过路由分发过程中的include函数来指定不同<code>app</code>所属的命名空间</p>
</blockquote>
<p>​<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line">urlpatterns = [    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">               path(<span class="string">'app1/'</span>,include((<span class="string">"app1.urls"</span>,<span class="string">'app1'</span>))), </span><br><span class="line">               <span class="comment">#直接传递一个元祖，元祖第一个值为分发路由地址，第二个值为命名空间</span></span><br><span class="line">               path(<span class="string">'app2/'</span>,include((<span class="string">"app2.urls"</span>,<span class="string">'app2'</span>)))]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>当为每个<code>app</code>的路由分发映射设置了命名空间，接下来在模板页面以及视图函数对路由的反向解析将是如下所示的样子，路由解析前加冒号指明命名空间</p>
</blockquote>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml">def index(request):</span></span><br><span class="line"><span class="xml">    return redirect(reverse("app1:left"))</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-tag">&#123;% <span class="name"><span class="name">url</span></span> 'app2:left' %&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span>app2:left<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="应用命名空间：app-name"><a href="#应用命名空间：app-name" class="headerlink" title="应用命名空间：app_name"></a>应用命名空间：app_name</h4><blockquote>
<p>使用<code>app_name</code>指明命名空间，在子<code>app</code>的<code>urls.py</code>文件下配置全局变量<code>app_name</code>，这个值是唯一的</p>
<p>在这个路由文件中定义的其他映射关系，将具有命名空间<code>app1</code></p>
</blockquote>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">app_name</span> = <span class="string">"app1"</span> <span class="comment"># 这个值应该是唯一的urlpatterns = [   	...]</span></span><br></pre></td></tr></table></figure>

<h4 id="实例命名空间：namespace"><a href="#实例命名空间：namespace" class="headerlink" title="实例命名空间：namespace"></a>实例命名空间：namespace</h4><blockquote>
<p>当有多个子<code>app</code>同时引入同一个子路由映射文件，比如这样</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line">urlpatterns = [    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">               path(<span class="string">'app1/'</span>,include(<span class="string">"app1.urls"</span>)),</span><br><span class="line">               path(<span class="string">'app2/'</span>,include(<span class="string">"app1.urls"</span>))]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这就会出现一个问题，不同的路由访问在做路由反向解析时，会造成混淆，</p>
<p>此时需要给每一个路由分发的规则设置<code>namespace</code>属性，为实例进行命名空间</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line">urlpatterns = [    path(<span class="string">'admin/'</span>, admin.site.urls),    path(<span class="string">'app1/'</span>,include(<span class="string">"app1.urls"</span>,namespace=<span class="string">"app1"</span>)),    path(<span class="string">'app2/'</span>,include(<span class="string">"app1.urls"</span>,namespace=<span class="string">"app2"</span>))]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样做的好处，可以在不同路由导向同一<code>app</code>下时，为他们的不同命名空间；</p>
<p>虽然看起来到最后执行的视图函数功能是一样的，但可以分清楚究竟是哪个路由引起视图函数在工作</p>
<p>接下来视图及模板页面中使用<code>namespace</code>的值</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    我是左页面</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    路由参数: &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app1:right' 123 %&#125;"</span>&gt;</span>app1的右页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是右页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app1:left' 'abc' %&#125;"</span>&gt;</span>app1的左页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ----------------------------------------- --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是左页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app2:right' 123 %&#125;"</span>&gt;</span>app2的右页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是右页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app2:left' 'abc' %&#125;"</span>&gt;</span>app2的左页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django-Models-模型层</title>
    <url>/Django-Models-%E6%A8%A1%E5%9E%8B%E5%B1%82/</url>
    <content><![CDATA[<h2 id="模型层"><a href="#模型层" class="headerlink" title="模型层"></a>模型层</h2><blockquote>
<p>该层开发的首要任务就是定义模型类以及属性</p>
<p>每个模型都可以被映射为数据库中的一个数据表，而类属性被映射为为数据字段</p>
</blockquote><h3 id="配置Mysql数据库"><a href="#配置Mysql数据库" class="headerlink" title="配置Mysql数据库"></a>配置Mysql数据库</h3><blockquote>
<p>在确保<code>mysql</code>数据库可以连接使用的情况下；</p>
<p>首先在数据库中创建专为<code>django</code>使用的库<code>django_data</code></p>
</blockquote><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database django_data;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>配置django的settings.py文件中的DATABASES属性如下</p>
</blockquote>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml">DATABASES = &#123;</span></span><br><span class="line"><span class="xml">    'default': &#123;     </span></span><br><span class="line"><span class="xml">    'ENGINE': 'django.db.backends.mysql', # 数据库引擎 </span></span><br><span class="line"><span class="xml">    'NAME': "django_data", # 使用的库名   </span></span><br><span class="line"><span class="xml">    "USER": "root", # 用户名   </span></span><br><span class="line"><span class="xml">    "PASSWORD": "123456", # 数据库密码    </span></span><br><span class="line"><span class="xml">    "HOST": "localhost", # 数据库主机地址    </span></span><br><span class="line"><span class="xml">    "PORT": "3306"  </span></span><br><span class="line"><span class="xml">	&#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于使用<code>django</code>的<code>Python</code>版本为3+；</p>
<p>此时对于<code>mysql</code>的支持已经变为<code>pymysql</code>，而对于<code>django</code>加载数据库引擎时还需要使用2版本的<code>mysqldb</code>名称</p>
<p>现在先需要我们安装<code>pymysql</code>之后在项目中重申mysql引擎</p>
</blockquote>
<ol>
<li><p>首先安装pymysql</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install pymysql -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
</li>
<li><p>项目主目录下的<code>__init__</code>文件中添加如下内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在整个项目的数据库使用已经切换到了<code>mysql</code></p>
</li>
</ol>
<h3 id="模型层字段"><a href="#模型层字段" class="headerlink" title="模型层字段"></a>模型层字段</h3><blockquote>
<p>在模型层类中的字段即是数据库中表的字段，表的字段设计非常重要</p>
<p>每一个字段都是<code>Field</code>基类的一个实例（<code>Field</code>类用来建立字段与数据库之间的映射）</p>
<p>模型字段定义不能以下划线结尾</p>
</blockquote>
<ul>
<li>django会根据在模型类中定义的字段属性来确定以下几点工作<ul>
<li>数据库中使用的数据类型</li>
<li>模型类对应的表单类渲染时使用的表单类型及<code>HTML</code>部件</li>
<li>必填字段等最低限度的验证要求检查，包括<code>admin</code>界面下自动生成的表单</li>
</ul>
</li>
</ul>
<h4 id="BooleanField"><a href="#BooleanField" class="headerlink" title="BooleanField"></a>BooleanField</h4><blockquote>
<p><code>BooleanField(**options)</code>：True/False字段，默认值为None</p>
</blockquote>
<blockquote>
<p>表单类型：<strong>CheckboxInput</strong>，``</p>
</blockquote>
<h4 id="CharField"><a href="#CharField" class="headerlink" title="CharField"></a>CharField</h4><blockquote>
<p><code>CharField(max_length=None)</code>：字符串字段</p>
</blockquote>
<blockquote>
<p>含有一个必须参数：<code>max_length</code>设置最大的<strong>字符数</strong>长度限制；</p>
</blockquote>
<blockquote>
<p>表单类型：<strong>TextInput</strong>，``</p>
</blockquote>
<h4 id="DateField"><a href="#DateField" class="headerlink" title="DateField"></a>DateField</h4><blockquote>
<p><code>DateField(auto_now=False, auto_now_add=False,**options)</code>：以 <code>datetime.date</code>实例表示的日期</p>
</blockquote>
<blockquote>
<p>含有两个可选参数：<code>auto_now</code>、<code>auto_now_add</code></p>
<p><code>auto_now</code>：该值为True时，每次在保存数据对象时，自动设置该字段为当前时间，也可以理解为自动更新最后一次修改时间</p>
<p><code>auto_now_add</code>：该值为<code>True</code>时，该字段设置在第一次数据对象创建时，可以记录当前字段创建的时间值</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：避免矛盾，<code>auto_now</code>，<code>auto_now_add</code>，<code>default</code>不能同时出现，一个字段属性只能有其中一条设置，当设置了<code>auto_now</code>，或<code>auto_now_add</code>时，也会让该字段默认具有<code>blank=True</code>（字段可以为空）属性</p>
</blockquote>
<blockquote>
<p>表单类型：<strong>TextInput</strong>，``</p>
</blockquote>
<h4 id="DatetimeField"><a href="#DatetimeField" class="headerlink" title="DatetimeField"></a>DatetimeField</h4><blockquote>
<p><code>DatetimeField(auto_now=False, auto_now_add=False,**options)</code>：以<code>datetime.datetime</code>实例表示的日期和时间</p>
<p>和<code>DateField</code>具有相同的字段属性</p>
</blockquote>
<h4 id="DecimalField"><a href="#DecimalField" class="headerlink" title="DecimalField"></a>DecimalField</h4><blockquote>
<p><code>DecimalField(max_digits=None,decimal_places=None, **options)</code>：以Decimal实例标示的十进制浮点数类型</p>
</blockquote>
<blockquote>
<p>含有两个可选参数：<code>max_digits</code>、<code>decimal_places</code></p>
<p><code>max_digits</code>：位数总数，包括小数点后的位数，必须大于<code>decimal_places</code>参数</p>
<p><code>decimal_places</code>：小数点后的数字数量，精度</p>
</blockquote>
<blockquote>
<p>表单类型：<strong>TextInput</strong>，``</p>
</blockquote>
<h4 id="EmailField"><a href="#EmailField" class="headerlink" title="EmailField"></a>EmailField</h4><blockquote>
<p><code>EmailField(max_length=254, **option)</code>：<code>CharField</code>子类，表示<code>Email</code>字段，并会检查是否为合法邮箱地址</p>
</blockquote>
<blockquote>
<p>默认参数：<code>max_length</code>，表示邮箱地址长度，默认为254</p>
</blockquote>
<blockquote>
<p>表单类型：<strong>TextInput</strong>，``</p>
</blockquote>
<h4 id="FloatField"><a href="#FloatField" class="headerlink" title="FloatField"></a>FloatField</h4><blockquote>
<p><code>FloatField(**options)</code>：使用<code>float</code>实例来表示的浮点数</p>
</blockquote>
<blockquote>
<p>表单类型：<strong>TextInput</strong>，``</p>
</blockquote>
<h4 id="IntegerField"><a href="#IntegerField" class="headerlink" title="IntegerField"></a>IntegerField</h4><blockquote>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">&gt; IntegerField(**options)`：一个整数，范围由`-<span class="number">2147483648</span>`到`2147483647</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="GenericIPAddressField"><a href="#GenericIPAddressField" class="headerlink" title="GenericIPAddressField"></a>GenericIPAddressField</h4><blockquote>
<p><code>GenericIPAddressField(protocol=both, unpack_ipv4=False, **options)</code>：一个IPV4或IPV6地址的字符串</p>
</blockquote>
<blockquote>
<p>默认参数：<code>protocol</code>、<code>unpack_ipv4</code></p>
<p><code>protocol</code>：IP协议，ipv4或ipv6，默认<code>both</code>为全选</p>
<p><code>unpack_ipv4</code>：解析IP地址，只有当协议为<code>both</code>时才可以使用</p>
</blockquote>
<blockquote>
<p>表单类型：<strong>TextInput</strong>，``</p>
</blockquote>
<h4 id="SlugField"><a href="#SlugField" class="headerlink" title="SlugField"></a>SlugField</h4><blockquote>
<p><code>SlugField(max_length=50, **option)</code>：只包含字母、数字、下划线的字符串，常用来表示连接中的<code>path</code>部分或者一些其他短标题类型数据</p>
</blockquote>
<h4 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h4><blockquote>
<p><code>TextField(**options)</code>：大文本字段</p>
</blockquote>
<blockquote>
<p>表单类型：<strong>Textarea</strong>，<code>...</code></p>
</blockquote>
<h4 id="URLField"><a href="#URLField" class="headerlink" title="URLField"></a>URLField</h4><blockquote>
<p><code>URLField(max_length=200, **options)</code>：<code>CharField</code>的子类，存储URL的字段</p>
</blockquote>
<blockquote>
<p>表单类型：<strong>TextInput</strong>，``</p>
</blockquote>
<h3 id="字段属性"><a href="#字段属性" class="headerlink" title="字段属性"></a>字段属性</h3><blockquote>
<p>以上所介绍的字段，均支持以下属性</p>
</blockquote>
<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><blockquote>
<p>如果该值为<code>True</code>，Django将在数据库中将控制存储为<code>NULL</code></p>
<p>字符串字段<code>CharField</code>与<code>TextField</code>要避免使用<code>null</code>，因为空值字符串将存储空字符串（””）,而不是<code>null</code>值。</p>
<p>对于字符串类型的数据字段，大多数情况下，<code>django</code>使用空字符串代表空值</p>
</blockquote>
<h4 id="blank"><a href="#blank" class="headerlink" title="blank"></a>blank</h4><blockquote>
<p>如果该值为<code>True</code>，则在验证时该字段值可以为空；</p>
<p><code>null</code>为数据库存储层面可以为空，而<code>blank</code>为表单验证层面可以填写空值</p>
</blockquote>
<h4 id="choices"><a href="#choices" class="headerlink" title="choices"></a>choices</h4><blockquote>
<p>一个二元组的列表或元组；</p>
<p>元组中第一个值为真正在数据库中存储的值，第二个值为该选项的描述</p>
<p>该值一旦被设定，表单样式会显示选择框，而不是标准的文本框，选择框内的选项为<code>choices</code>中的元组</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTable</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    CHAR_CHOICE = [     </span><br><span class="line">        (<span class="string">'H'</span>,<span class="string">"非常苦难"</span>),    </span><br><span class="line">        (<span class="string">'M'</span>,<span class="string">"中等难度"</span>),     </span><br><span class="line">        (<span class="string">'S'</span>,<span class="string">"非常简单"</span>),	</span><br><span class="line">    ]	</span><br><span class="line">    choicechar = modesl.CharField(max_length=<span class="number">1</span>,choices=CHAR_CHOICE)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>choices</code>字段也支持分类的写法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CHAR_CHOICE = [	(<span class="string">'A'</span>,	</span><br><span class="line">                 (		</span><br><span class="line">                     (<span class="string">'H'</span>,<span class="string">"Hard"</span>),	</span><br><span class="line">                 )	),	</span><br><span class="line">               (<span class="string">'B'</span>,	</span><br><span class="line">                (		</span><br><span class="line">                    (<span class="string">'M'</span>,<span class="string">"Medium"</span>),	</span><br><span class="line">                )</span><br><span class="line">               ),</span><br><span class="line">               …</span><br><span class="line">              ]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分类的名称作为元组中的第一个值，</p>
<p>元组的第二个值为该分类下的一个新的二元组序列数据</p>
</blockquote>
<h4 id="db-column"><a href="#db-column" class="headerlink" title="db_column"></a>db_column</h4><blockquote>
<p>数据库中用来表示该字段的名称，如果未指定，那么Django将会使用<code>Field</code>名作为字段名</p>
</blockquote>
<h4 id="db-index"><a href="#db-index" class="headerlink" title="db_index"></a>db_index</h4><blockquote>
<p>当该值为<code>True</code>时，为该字段创建索引</p>
</blockquote>
<h4 id="default"><a href="#default" class="headerlink" title="default"></a>default</h4><blockquote>
<p>该字段默认值，可以是一个值或是一个回调函数</p>
<p>当是一个函数对象时，在创建新对象时，函数调用</p>
</blockquote>
<h4 id="editable"><a href="#editable" class="headerlink" title="editable"></a>editable</h4><blockquote>
<p>如果设置该值为False，那么这个字段将不允许被编辑</p>
<p>不会出现在admin后台界面下，以及其他ModelForm表单中，同时也会跳过模型验证</p>
</blockquote>
<h4 id="primary-key"><a href="#primary-key" class="headerlink" title="primary_key"></a>primary_key</h4><blockquote>
<p>设置该值为<code>True</code>时，该字段成为模型的主键字段，<strong>一个模型类同时只能有一个主键</strong></p>
<p>如果一个表中不存在任意一个设置好的主键字段，<strong>django会自动设置一个自增</strong>的<code>AutoField</code>字段来充当主键，该值可以用<code>pk</code>，<code>id</code>方式获取。主键的设置还意味着，<code>null=False</code>，<code>unique=True</code></p>
</blockquote>
<h4 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h4><blockquote>
<p>如果该值为True，代表这个数据在当前的表中有唯一值</p>
<p>这个字段还会在模型层验证存储的数据是否唯一</p>
<p>unique的设置也意味着当前字段具备索引的创建</p>
<p><code>ManyToManyField</code>、<code>OneToOneField</code>与<code>FileField</code>字段不可以使用该属性</p>
</blockquote>
<h4 id="verbose-name"><a href="#verbose-name" class="headerlink" title="verbose_name"></a>verbose_name</h4><blockquote>
<p>对于字段的一个可读性更高的名称</p>
<p>如果没有设置该值，django将字段名中的下换线转换成空格，作为当前字段的数据库中名称</p>
</blockquote>
<h3 id="模型元属性"><a href="#模型元属性" class="headerlink" title="模型元属性"></a>模型元属性</h3><blockquote>
<p>在模型类的<code>Meta</code>类中，可以提供一系列的元选项，可以方便对该模型类进行属性设置或约束等</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTable</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    …	</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span>	</span><br><span class="line">        ordering = [Fields]	</span><br><span class="line">        …</span><br></pre></td></tr></table></figure>

<h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><blockquote>
<p>代表当前模型类为抽象基类，不会创建真正的数据表，只是为了其他模型类继承使用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">abstract = <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h4 id="app-label"><a href="#app-label" class="headerlink" title="app_label"></a>app_label</h4><blockquote>
<p>当模型类被定义在了其他app下，这个属性用来描述当前表属于哪个app应用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app_label = <span class="string">"MyApp"</span></span><br></pre></td></tr></table></figure>

<h4 id="db-table"><a href="#db-table" class="headerlink" title="db_table"></a>db_table</h4><blockquote>
<p>当前模型类所对应的表名，未设置时，django默认将表名与app名由下划线组成，作为表名</p>
<p>需要注意这个表名为真实在数据库中所使用的，所以该元选项的使用应在数据表创建之前</p>
<p>如果在表已经存在的情况下去修改，会导致数据库内表与模型类表名不一致而查找不到报错</p>
</blockquote>
<h4 id="ordering"><a href="#ordering" class="headerlink" title="ordering"></a>ordering</h4><blockquote>
<p>当前表中的数据存储时的排序规则，这是一个字段名的字符串，可以是一个列表或元组；</p>
<p>每一个字符串前可以使用”<code>-</code>“来倒序排序，使用”<code>?</code>“随机排序</p>
<p>ordering排序规则的添加，也会增加数据库的开销</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ordering = [<span class="string">'-birthday'</span>, <span class="string">'age'</span>]</span><br><span class="line"><span class="comment">#先按照birthday倒序排序，再按照age字段进行排序。</span></span><br></pre></td></tr></table></figure>

<h4 id="unique-together"><a href="#unique-together" class="headerlink" title="unique_together"></a>unique_together</h4><blockquote>
<p>用来设置表中的不重复字段组合</p>
<p>格式为一个元组，元组中的每个数据都是一个元组，用来描述不重复的组合字段</p>
<p>如果只处理单一字段组合，可以是一个一维的元组</p>
<p>联合约束</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">unique_together = ((<span class="string">'name'</span>,<span class="string">'phone'</span>),)</span><br></pre></td></tr></table></figure>

<h4 id="verbose-name-1"><a href="#verbose-name-1" class="headerlink" title="verbose_name"></a>verbose_name</h4><blockquote>
<p>一般设置该表展示时所用的名称，名称被自动处理为复数，字符串后加一个”s”</p>
</blockquote>
<h4 id="verbose-name-plural"><a href="#verbose-name-plural" class="headerlink" title="verbose_name_plural"></a>verbose_name_plural</h4><blockquote>
<p>与<code>verbose_name</code>功能相同，但是不会自动在字符串后加”<code>s</code>“以表复数</p>
<p>设置表的复数名称</p>
</blockquote>
<h3 id="模型操作"><a href="#模型操作" class="headerlink" title="模型操作"></a>模型操作</h3><blockquote>
<p>在进行模型操作的学习之前，可以先创建一个测试的数据库模型类，如下所示</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span>	</span><br><span class="line">    name = models.CharField(max_length=<span class="number">10</span>,verbose_name=<span class="string">"姓名"</span>)</span><br><span class="line">    age = models.IntegerField(verbose_name=<span class="string">"年龄"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><blockquote>
<p>django自带了一个数据库测试的shell工具</p>
<p>这是一个非常方便可以让我们对django代码进行测试的环境</p>
<p>可以直接通过<code>python manage.py shell</code>命令行管理工具来打开</p>
</blockquote>
<h5 id="实例save创建数据"><a href="#实例save创建数据" class="headerlink" title="实例save创建数据"></a>实例save创建数据</h5><blockquote>
<p><strong>通过模型类的关键词参数实例化一个对象来进行数据的创建</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> app.models <span class="keyword">import</span> Person</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1 = Person(name=<span class="string">'张三'</span>,age=<span class="number">15</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1.save()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上的代码，在为字段赋予值之后，通过实例的save函数进行该数据的保存</p>
<p>在数据库底层执行了<code>SQL</code>语句中的<code>insert</code>操作，并且，在我们显示调用<code>save</code>之前，<code>django</code>不会访问数据库，实例数据只存在于内存中</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：<code>save</code>函数没有返回值</p>
</blockquote>
<h5 id="create方法创建数据"><a href="#create方法创建数据" class="headerlink" title="create方法创建数据"></a>create方法创建数据</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>P1 = Person.objects.create(name=<span class="string">'李四'</span>,age=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这条语句创建一条数据，并且返回一个数据在内存中的实例P1</p>
<p>之后可以通过这个实例字段P1对数据库中该条数据进行修改或删除操作</p>
<p><code>create</code> 方法一步到位，<code>save</code>方式可以慢悠悠的赋予字段值，最后赋予结束再save</p>
</blockquote>
<h4 id="查找对象"><a href="#查找对象" class="headerlink" title="查找对象"></a>查找对象</h4><blockquote>
<p>接下来，我们将通过模型类中的管理器进行数据的查询；</p>
<p>管理器<code>（Manager）</code>是每一个模型类所具有的，默认名为<code>objects</code></p>
<p>模型类通过模型类调用<code>orm</code>数据接口，其实就是在对数据表进行操作。</p>
<p><strong>注意</strong>，具体的某一条数据无法访问这个管理器</p>
</blockquote>
<h5 id="all"><a href="#all" class="headerlink" title="all()"></a><code>all()</code></h5><blockquote>
<p>获取一个表中的所有数据，返回<code>QuerySet</code>数据对象</p>
</blockquote>
<ul>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_person = Person.objects.all()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="filter-kwargs"><a href="#filter-kwargs" class="headerlink" title="filter(**kwargs)"></a><code>filter(**kwargs)</code></h5><blockquote>
<p>返回一个包含数据对象的集合，满足参数中所给的条件</p>
</blockquote>
<ul>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = Person.objects.all().filter(age__lt=<span class="number">16</span>)</span><br><span class="line">res = Person.objects.filter(age__lt=<span class="number">16</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>我们在查询过程中，除了直接使用字段属性进行验证</p>
<p>还可以在字段名之后使用双下化线来标明更加详细的字段筛选条件（在下一节会有详细的字段筛选条件介绍），也叫做链式过滤</p>
<p>这也是为什么表单类字段不可以以下换线结尾的原因</p>
</blockquote>
<h5 id="exclude-kwargs"><a href="#exclude-kwargs" class="headerlink" title="exclude(**kwargs)"></a><code>exclude(**kwargs)</code></h5><blockquote>
<p>返回一个包含数据对象的集合，数据为不满足参数中所给的条件</p>
</blockquote>
<blockquote>
<p>filter()查询会始终返回一个结果集，哪怕只有一个数据。</p>
<p>但是有些时候，我们对于一些在数据表中的唯一数据进行查询时，可以使用更加合适的<code>get</code>方法</p>
</blockquote>
<hr>
<blockquote>
<p><strong>注意</strong>：创建结果集的过程不涉及任何数据库的操作，查询工作是惰性的，在上面的查询方式中，查询代码不会实际访问数据库，只有查询集在真正使用时，django才会访问数据库</p>
</blockquote>
<h5 id="get-kwargs"><a href="#get-kwargs" class="headerlink" title="get(**kwargs)"></a><code>get(**kwargs)</code></h5><blockquote>
<p>获取唯一单条数据</p>
</blockquote>
<blockquote>
<p>get获取数据只会返回一条匹配的结果，获取的数据只能在数据库中有一条</p>
<p>如果返回多个结果，会引发<code>MultipleObjectsReturned</code>异常</p>
<p>如果没有任何匹配到的结果也会引发<code>DoesNotExist</code>异常</p>
</blockquote>
<ul>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Person.objects.get(pk=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="order-by-field"><a href="#order-by-field" class="headerlink" title="order_by(*field)"></a><code>order_by(*field)</code></h5><blockquote>
<p>默认情况下，数据表使用模型类中的Meta中指定的ordering选项进行排序</p>
<p>现在也可以通过使用order_by函数进行查询结果的排序</p>
</blockquote>
<ul>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Person.objects.order_by(<span class="string">'age'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Person.objects.all().order_by(<span class="string">'-age'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="count"><a href="#count" class="headerlink" title="count()"></a><code>count()</code></h5><blockquote>
<p>返回数据库中对应字段的个数，并且该函数永远不会引发异常</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">models.Person.objects.filter(age=<span class="number">20</span>).count()Person.objects.count()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<code>count</code>函数时，还需要对数据表进行迭代访问</p>
<p>所以有时使用已生产好的结果集，通过len函数获取长度，这种方式效率会更高</p>
<p><code>count</code>方法的调用会导致额外的数据库查询</p>
</blockquote>
<h5 id="values-fields"><a href="#values-fields" class="headerlink" title="values(*fields)"></a><code>values(*fields)</code></h5><blockquote>
<p>返回一个查询集结果，但是迭代访问时返回的是字典，而不是数据实例对象</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">models.Person.objects.all().values()models.Person.objects.values()</span><br></pre></td></tr></table></figure>

<h4 id="链式过滤条件"><a href="#链式过滤条件" class="headerlink" title="链式过滤条件"></a>链式过滤条件</h4><ul>
<li><p><code>exact</code></p>
<blockquote>
<p>如果在查询过程中，没有提供查询类型（没有<code>双下划线</code>），那么查询类型就会被默认指定为<code>exact</code>，这是一种严格查找的方式，用来在数据库中查找和查询时的关键词参数完全一致的内容</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.objects.filter(account=<span class="string">'root'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.objects.filter(account__exact=<span class="string">'root'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>iexact</code></p>
<blockquote>
<p>忽略大小写的匹配</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.objects.filter(account__iexact=<span class="string">'root'</span>)</span><br><span class="line"><span class="comment">#匹配到的结果可能是Root，ROot，ROOt，ROOT</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>startswith、endswith</code></p>
<blockquote>
<p>分别匹配开头和结尾，区分大小写</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.objects.filter(passwd__startswith=<span class="string">'admin'</span>)</span><br><span class="line"><span class="comment">#匹配以admin开头的数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>istartswith、iendswith</code></p>
<blockquote>
<p>分别匹配开头和结尾，忽略大小写</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.objects.filter(passwd__istartswith=<span class="string">'admin'</span>)匹配以不区分大小写的字符串admin为开头的数据</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>gte</code></p>
<blockquote>
<p>大于或等于</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.objects.filter(reg_data__gte=datetime.date.today)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>lte</code></p>
<blockquote>
<p>小于或等于</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.objects.filter(reg_data__lte=datetime.date.today)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="修改对象"><a href="#修改对象" class="headerlink" title="修改对象"></a>修改对象</h4><blockquote>
<p>获取到对应的数据实例之后，通过<code>.</code>的方式访问数据实例中的属性，进行数据的字段修改</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = models.Person.objects.get(pk=<span class="number">1</span>)p.age = <span class="number">21</span>p.save()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对过滤出的结果链式调用<code>update()</code>函数，这样的修改，类似批量修改，<code>update</code>函数会返回成功修改的个数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">models.Person.objects.filter(age__gt=<span class="number">100</span>).update(age=<span class="number">25</span>)<span class="comment"># 将所有年纪小于100的人的年纪改为20</span></span><br></pre></td></tr></table></figure>

<h4 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h4><blockquote>
<p>对于普通的单表数据删除，获取到数据实例对象后调用内置的<code>delete()</code>函数即可</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">models.Person.objects.get(pk=<span class="number">1</span>).delete()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，删除一条数据之后，默认占有的主键ID值并不会被下一个新插入的值所占用</p>
<p>比如 1，2，3，4；删除掉3之后，剩下：1，2，4；下一个值存储时，id是5，3不会被复用</p>
</blockquote>
<h3 id="字段关系"><a href="#字段关系" class="headerlink" title="字段关系"></a>字段关系</h3><ul>
<li>字段关系是<code>django</code>维护表关系的方式；其中主要有一对一，多对一以及多对多，</li>
<li>现在的一对一及多对一关系中需要设置<code>on_delete</code>属性用来描述当关联数据被删除时的操作，有如下一些</li>
</ul>
<blockquote>
<p><strong>models.CASCADE</strong>：删除关联数据,与之关联也删除</p>
<p>models.PROTECT：删除关联数据,引发错误<code>ProtectedError</code></p>
<p><strong>models.SET_NULL</strong>：与之关联的值设置为<code>null</code>（前提<code>FK</code>字段需要设置为可空）</p>
<p>models.SET_DEFAULT： 删除关联数据,与之关联的值设置为默认值（前提FK字段需要设置默认值）</p>
<p>models.DO_NOTHING：删除关联数据,什么也不做</p>
</blockquote>
<h4 id="一对一关系"><a href="#一对一关系" class="headerlink" title="一对一关系"></a>一对一关系</h4><blockquote>
<p>模型类使用<code>OneToOneField</code>用来定义一对一关系；</p>
<p>比如当你拥有一个老师表时，紧接着你还需要一个教授表，那么教授表可能拥有老师表的一系列属性，那么你还不想把老师表中的字段直接复制到教授表那么可以通过<code>OnToOneField</code>来实现教授表继承老师表。</p>
<p>其实，在使用模型类继承时，也隐含有一个一对一关系</p>
</blockquote>
<ul>
<li><code>OneToOneField(to, on_delete, parent_link=False, options)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(models.Model)</span>:</span>  </span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    age = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>     </span><br><span class="line">        <span class="keyword">return</span> self.nameclass Professor(models.Model): </span><br><span class="line">        teacher = models.OneToOneField(Teacher,primary_key=<span class="literal">True</span>,on_delete=models.CASCADE)    big_project = models.CharField(max_length=<span class="number">50</span>) </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>    </span><br><span class="line">            <span class="keyword">return</span> self.teacher.name</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>manage.py shell</code>下进行数据库操作</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = Teacher.objects.create(name=<span class="string">'Jack'</span>,age=<span class="string">'22'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = Teacher.objects.create(name=<span class="string">'Bob'</span>,age=<span class="string">'17'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1 = Professor.objects.create(teacher=t1,big_project=<span class="string">'雾霾净化术'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1.teacher&lt;Teacher: Jack</span><br><span class="line">&gt;&gt;&gt;&gt; p1.teacher = t2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1.teacher&lt;Teacher: Bob&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上面的测试中，看似已经将<code>p1</code>对应的教授变成了<code>Bob</code>；</p>
<p>但是在数据库中之前<code>t1</code>老师所对应的教授信息还存在，此时的赋值操作并不会覆盖掉教授他之前的教授数据，只是重新创建了一条。</p>
<p>正确的做法应该是将某一条数据的一对一关系通过<code>delete</code>关系先删除之后再重新赋予</p>
</blockquote>
<h4 id="多对一关系"><a href="#多对一关系" class="headerlink" title="多对一关系"></a>多对一关系</h4><blockquote>
<p><code>Django</code>使用<code>django.db.models.ForeignKey</code>定义多对一关系。</p>
<p><code>ForeignKey</code>需要一个位置参数：与该模型关联的类</p>
</blockquote>
<blockquote>
<p>生活中的多对一关系：班主任，班级关系。一个班主任可以带很多班级，但是每个班级只能有一个班主任</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Headmaster</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>      </span><br><span class="line">        <span class="keyword">return</span> self.nameclass Class(models.Model):  </span><br><span class="line">        class_name = models.CharField(max_length=<span class="number">50</span>)  </span><br><span class="line">        teacher = models.ForeignKey(Headmaster,null=<span class="literal">True</span>,on_delete=models.SET_NULL)    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>   </span><br><span class="line">            <span class="keyword">return</span> self.class_name</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>H1 = Headmaster(name=<span class="string">'渔夫'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>H1.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>H1&lt;Headmaster: 渔夫</span><br><span class="line">&gt;&gt;&gt;&gt; H2 = Headmaster(name=<span class="string">'农夫'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>H2.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Headmaster.objects.all()[&lt;Headmaster: 渔夫&gt;, &lt;Headmaster: 农夫&gt;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上创建了两条老师数据</p>
<p>由于我们设置外键关联可以为空<code>null=True</code>,所以此时在班级表创建时，可以直接保存，不需要提供老师数据</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C1 = Class(class_name=<span class="string">'一班'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C2 = Class(class_name=<span class="string">'二班'</span>)</span><br><span class="line"><span class="comment">#如果外键设置不为空时，保存会引发以下错误</span></span><br><span class="line"><span class="comment"># IntegrityError: NOT NULL constraint failed: bbs_class.teacher_id</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C1.teacher = H1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C2.teacher = H2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C1.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C2.save()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将老师分配个班级之后，由于班级表关联了老师字段，我们可以通过班级找到对应老师</p>
<p>虽然老师表中没有关联班级字段，但是也可以通过老师找到他所带的班级，这种查询方式也叫作关联查询</p>
<p>通过模型类名称后追加一个’_set’，来实现反向查询</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>H1.class_set.all()&lt;QuerySet [&lt;Class: 一班&gt;]&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于我们这是一个多对一的关系，也就说明我们的老师可以对应多个班级</p>
<p>我们可以继续给H1老师分配新的班级</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C3 = Class(class_name=<span class="string">'三班'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C3.teacher = H1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C3.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>H1.class_set.all()[&lt;Class: 一班&gt;, &lt;Class: 三班&gt;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个班级只能对应一个老师，外键是唯一的，那么你在继续给C1班级分配一个新的老师时，会覆盖之前的老师信息，并不会保存一个新的老师</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>H3 = Headmaster(name=<span class="string">'伙夫'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>H3.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C1.teacher&lt;Headmaster: 渔夫</span><br><span class="line">&gt;&gt;&gt;&gt; C1.teacher=H3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C1.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C1.teacher&lt;Headmaster: 伙夫&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>把这个班级的老师删除，由于设置了外键字段可以为<code>null</code>，此时班级的老师选项为<code>null</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = Headmaster.objects.all().first()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c1 = Class.objects.all().first()&lt;Headmaster: 渔夫</span><br><span class="line">&gt;&gt;&gt;&gt; c1&lt;Class: 一班</span><br><span class="line">&gt;&gt;&gt;&gt; c1.teacher&lt;Headmaster: 渔夫</span><br><span class="line">&gt;&gt;&gt;&gt; t1.delete()(<span class="number">1</span>, &#123;<span class="string">'modelsapp.Headmaster'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c1 = Class.objects.all().first()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c1&lt;Class: 一班</span><br><span class="line">&gt;&gt;&gt;&gt; c1.teacher</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#这里什么都没有，因为此时C1的老师已经是个None了</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>要记得删除之后要重新获取一次数据，否则查看到的结果中还是之前获取到的有老师的班级数据</p>
</blockquote>
<h4 id="多对多关系"><a href="#多对多关系" class="headerlink" title="多对多关系"></a>多对多关系</h4><blockquote>
<p>多对多关系在模型中使用<code>ManyToManyField</code>字段定义</p>
<p>多对多关系可以是具有关联，也可以是没有关联，所以不需要明确指定<code>on_delete</code>属性</p>
</blockquote>
<blockquote>
<p>生活中，多对多关系：一个音乐家可以隶属于多个乐队，一个乐队可以有多个音乐家</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Artist</span><span class="params">(models.Model)</span>:</span>  </span><br><span class="line">    artist_name = models.CharField(max_length=<span class="number">50</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>      </span><br><span class="line">        <span class="keyword">return</span> self.artist_nameclass Band(models.Model):  </span><br><span class="line">        band_name = models.CharField(max_length=<span class="number">50</span>)  </span><br><span class="line">        artist = models.ManyToManyField(Artist)  </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>      </span><br><span class="line">            <span class="keyword">return</span> self.band_name</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建音乐家以及乐队</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bbs.models <span class="keyword">import</span> Artist,Band</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A1 = Artist.objects.create(artist_name=<span class="string">'Jack'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A2 = Artist.objects.create(artist_name=<span class="string">'Bob'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B1 = Band.objects.create(band_name=<span class="string">'FiveMonthDay'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B2 = Band.objects.create(band_name=<span class="string">'SHE'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建出两个乐队之后对其进行音乐家的添加</p>
<p>多对多字段添加时，可以使用<code>add</code>函数进行多值增加</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>B1.artist.add(A1,A2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B2.artist.add(A2)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>B1</code>乐队含有<code>A1</code>,<code>A2</code>两名成员</p>
<p><code>B2</code>乐队含有<code>A1</code>成员</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>B1.artist.all()[&lt;Artist: Bob&gt;, &lt;Artist: Jack&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B2.artist.all()	[&lt;Artist: Jack&gt;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在音乐家表中查找某个乐家属于哪些乐队</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Band.objects.filter(artist=A1) </span><br><span class="line"><span class="comment"># 这里使用的是我们模型类来进行查找。</span></span><br><span class="line">[&lt;Band: SHE&gt;, &lt;Band: FiveMonthDay&gt;] </span><br><span class="line"><span class="comment"># A1乐家属于，SHE以及FiveMonthDay</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Band.objects.filter(artist=A2)[&lt;Band: SHE&gt;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以查找这音乐家在哪个乐队</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A1.band_set.all() </span><br><span class="line"><span class="comment"># 直接通过具体数据对象进行查找</span></span><br><span class="line">[&lt;Band: SHE&gt;, &lt;Band: FiveMonthDay&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A2.band_set.all()[&lt;Band: SHE&gt;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多对多关联字段的删除，要使用<code>remove</code>来进行关系的断开</p>
<p>而不是直接使用<code>delete</code>，<code>remove</code>只会断开数据之间的联系，但是不会将数据删除</p>
<p>现在在B1乐队中删除A1乐家</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>B1.artist.remove(A1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B1.artist.all()&lt;QuerySet [&lt;Artist: Bob&gt;]&gt;</span><br></pre></td></tr></table></figure>

<h3 id="关联表的查询"><a href="#关联表的查询" class="headerlink" title="关联表的查询"></a>关联表的查询</h3><blockquote>
<p>如果想要查询的字段在关联表，则使用<code>表名小写__字段</code>来进行跨表查询操作</p>
</blockquote>
<blockquote>
<p>创建一个多对一关系的父子表，一个父亲可能有多个儿子</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span><span class="params">(models.Model)</span>:</span>	</span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>)	</span><br><span class="line">    age = models.CharField(max_length=<span class="number">30</span>)    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>     </span><br><span class="line">        <span class="keyword">return</span> self.nameclass Son(models.Model):  </span><br><span class="line">        father = models.ForeignKey(Father,on_delete=models.CASCADE)  </span><br><span class="line">        name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>    </span><br><span class="line">            <span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建数据</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1 = Father.objects.create(name=<span class="string">'Jack'</span>,age=<span class="string">'30'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = Son.objects.create(name=<span class="string">'Json'</span>,father=f1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = Son.objects.create(name=<span class="string">'Json2'</span>,father=f1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2 = Father.objects.create(name=<span class="string">'Bob'</span>,age=<span class="string">'40'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3 = Son.objects.create(name=<span class="string">'Json3'</span>,father=f2)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查询所有父亲名字是<code>jack</code>的孩子</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Son.objects.filter(father__name__exact=<span class="string">'Jack'</span>)[&lt;Son: Json&gt;, &lt;Son: Json2&gt;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查询所有儿子名开头为<code>J</code>的父亲</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Father.objects.filter(son__name__startswith=<span class="string">'J'</span>)[&lt;Father: Jack&gt;, &lt;Father: Jack&gt;, &lt;Father: Bob&gt;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取到某一个父亲的所有孩子，通过某一条数据的<code>小写表名_set</code>反向查询</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1.son_set.all()&gt;&gt;&gt; [&lt;Son: Json&gt;, &lt;Son: Json2&gt;]</span><br></pre></td></tr></table></figure>

<h3 id="数据的反向查询"><a href="#数据的反向查询" class="headerlink" title="数据的反向查询"></a>数据的反向查询</h3><blockquote>
<p>默认的，当有某一条数据获取到之后，我们可以通过模型类名称加上一个 <code>_set</code>，来实现反向查询</p>
<p>现在设计两个表为军队和士兵表，并且士兵多对一关联军队</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aramy</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>) </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>      </span><br><span class="line">        <span class="keyword">return</span> self.nameclass Soldier(models.Model): </span><br><span class="line">        aramy = models.ForeignKey(Aramy,on_delete=models.CASCADE)    </span><br><span class="line">        name = models.CharField(max_length=<span class="number">30</span>) </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>	</span><br><span class="line">            <span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建一些数据</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 = Aramy(name=<span class="string">'一军'</span>)&gt;&gt;&gt; a1.save()&gt;&gt;&gt; s1 = Soldier(name=<span class="string">'张三'</span>,aramy=a1)&gt;&gt;&gt; s1.save()&gt;&gt;&gt; s2 = Soldier(name=<span class="string">'李四'</span>,aramy=a1)&gt;&gt;&gt; s2.save()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过<code>soldier_set</code>我们就可以关联到对应的士兵表</p>
<p>并且对应返回结果可以执行我们常用的<code>filter</code>，<code>exclude</code>等查询操作</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1.soldier_set.all()[&lt;Soldier: 张三&gt;, &lt;Soldier: 李四&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1.soldier_set.filter(name=<span class="string">'张三'</span>)[&lt;Soldier: 张三&gt;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以通过定义关联字段中的<code>related_name</code>值，来实现自定义的反向查询名字</p>
<p>且<code>related_name</code>的值必须唯一</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aramy</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>     </span><br><span class="line">        <span class="keyword">return</span> self.nameclass Soldier(models.Model):   </span><br><span class="line">        aramy = models.ForeignKey(Aramy,on_delete=models.CASCADE,related_name=<span class="string">'soldier'</span>)    name = models.CharField(max_length=<span class="number">30</span>)  </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>   </span><br><span class="line">            <span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下来通过某条数据反向查询</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 = Aramy.objects.all()[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = Soldier.objects.get(name=<span class="string">'张三'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1.soldier.all()[&lt;Soldier: 张三&gt;, &lt;Soldier: 李四&gt;]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：<code>related_name</code>一定是一个唯一的值，否则反向查找时会出现二异性错误</p>
<p>也可以将<code>related_name</code>初始化为<code>+</code>，来取消反向查询</p>
</blockquote>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Cookie和Session</title>
    <url>/Cookie%E5%92%8CSession/</url>
    <content><![CDATA[<h2 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h2><blockquote>
<p><code>Cookie</code>及<code>Session</code>一直以来都是Web开发中非常关键的一环，因为<code>HTTP</code>协议本身为无状态，每一次请求之间没有任何状态信息保持，往往我们的Web服务无法在客户端访问过程中得知用户的一些状态信息，比如是否登录等等；那么这里通过引入<code>Cookie</code>或者<code>Seesion</code>来解决这个问题。</p>
</blockquote><a id="more"></a>
<blockquote>
<p>当客户端访问时，服务端会为客户端生成一个<code>Cookie</code>键值对数据，通过<code>Response</code>响应给到客户端。当下一次客户端继续访问相同的服务端时，浏览器客户端就会将这个<code>Cookie</code>值连带发送到服务端。</p>
</blockquote>
<blockquote>
<p><code>Cookie</code>值存储在浏览器下，一般在你的浏览器安装目录的<code>Cookie</code>目录下，我们也可以通过F12或者各种浏览器的开发者工具来获取到</p>
</blockquote>
<blockquote>
<p>因为<code>cookie</code>是保存在浏览器中的一个纯明文字符串，所以一般来说服务端在生成<code>cookie</code>值时不建议存储敏感信息比如密码</p>
</blockquote>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><blockquote>
<p>在<code>django</code>的代码中，我们可以使用一些提供<code>Response</code>响应的类，如：<code>HttpResponse</code>，<code>redirect</code>等实例的内置<code>set_cookie</code>函数来进行<code>django</code>项目中的<code>Cookie</code>设置</p>
</blockquote>
<ul>
<li><p><code>set_cookie(key, value=&#39;&#39;, max_age=None, expires=None, path=&#39;/&#39;,domain=None, secure=False, httponly=False)</code></p>
<blockquote>
<p><code>key</code>：<code>Cookie</code>的<code>key</code>值，未来通过该<code>key</code>值获取到对应设置好的<code>Cookie</code>。</p>
<p><code>value=&#39;&#39;</code>：对应<code>Cookie</code>的<code>key</code>值的<code>value</code>，比如：<code>set_cookie(key=&#39;value&#39;,value=&#39;shuai&#39;)</code></p>
<p><code>max_age=None</code>：<code>Cookie</code>生效的时间，单位为秒，如果<code>Cookie</code>值只持续在客户端浏览器的会话时长，那么这个值应该为<code>None</code>。存在该值时，<code>expires</code>会被计算得到。</p>
<p><code>expires=None</code>：<code>Cookie</code>具体过期日期，是一个<code>datetime.datetime</code>对象，如果该值存在，那么<code>max_age</code>也会被计算得到</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">import</span> datetime</span><br><span class="line">  current_time = datetime.datetime.now()</span><br><span class="line"><span class="comment"># 当前时间</span></span><br><span class="line">  expires_time = current_time + datetime.timedelta(seconds=<span class="number">10</span>)</span><br><span class="line">  <span class="comment"># 向后推延十秒</span></span><br><span class="line">  set_cookie(<span class="string">'key'</span>,<span class="string">'value'</span>,expires=expires_time) </span><br><span class="line">  <span class="comment">#设置Cookie及对应超时时间</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<blockquote>
<p><code>path=&#39;/&#39;</code>：指定哪些<code>url</code>可以访问到<code>Cookie</code>，默认<code>/</code>为所有。</p>
<p><code>domain=None</code>：当我们需要设置的为一个跨域的Cookie值，那么可以使用该参数，比如：<code>domain=&#39;.test.com&#39;</code>，那么这个<code>Cookie</code>值可以被<code>www.test.com</code>、<code>bbs.test.com</code>等主域名相同的域所读取，否则<code>Cookie</code>只被设置的它的域所读取。为<code>None</code>时，代表当前域名下全局生效。</p>
<p><code>secure=False</code>：<code>https</code>加密传输设置，当使用<code>https</code>协议时，需要设置该值，同样的，如果设置该值为<code>True</code>，如果不是<code>https</code>连接情况下，不会发送该<code>Cookie</code>值。</p>
<p><code>httponly=False</code>：<code>HTTPOnly</code>是包含在<code>HTTP</code>响应头部中<code>Set-Cookie</code>中的一个标记。为一个<code>bool</code>值，当设置为<code>True</code>时，代表阻止客户端的<code>Javascript</code>访问<code>Cookie</code>。这是一种降低客户端脚本访问受保护的<code>Cookie</code>数据风险的有效的办法</p>
</blockquote>
<h4 id="设置COOKIE"><a href="#设置COOKIE" class="headerlink" title="设置COOKIE"></a>设置COOKIE</h4><blockquote>
<p>简单的实现一下<code>COOKIE</code>的设置</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse</span><br><span class="line"><span class="comment"># Create your views here.def set_cookie(request): </span></span><br><span class="line"><span class="comment"># 在HTTPResponse部分设置COOKIE值  </span></span><br><span class="line">cookie_reponse = HttpResponse(<span class="string">'这是一个关于cookie的测试'</span>)   cookie_reponse.set_cookie(<span class="string">'test'</span>,<span class="string">'hello cookie'</span>) </span><br><span class="line"><span class="keyword">return</span> cookie_reponse</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上视图函数返回一个<code>HttpResponse</code>对象，并在该对象中集成<code>COOKIE</code>值的设定，设置<code>key</code>值为<code>test</code>，<code>value</code>值为<code>hello cookie</code></p>
</blockquote>
<h4 id="获取COOKIE"><a href="#获取COOKIE" class="headerlink" title="获取COOKIE"></a>获取COOKIE</h4><blockquote>
<p>再来简单的实现一下<code>COOKIE</code>的获取</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cookie</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># 获取cookie值，从request属性中的COOKIE属性中 </span></span><br><span class="line">    cookie_data = request.COOKIES.get(<span class="string">'test'</span>) </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Cookie值为:%s'</span> % cookie_data)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Cookie</code>值存储在，<code>request</code>中的<code>COOKIES</code>属性中</p>
<p>并且该属性获取到的结果与字典类似，直接通过内置函数<code>get</code>获取即可</p>
</blockquote>
<h4 id="删除COOKIE"><a href="#删除COOKIE" class="headerlink" title="删除COOKIE"></a>删除COOKIE</h4><blockquote>
<p>这里通过该视图函数路由进行COOKIE的删除</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_cookie</span><span class="params">(request)</span>:</span>  </span><br><span class="line">    response = HttpResponseRedirect(<span class="string">'/check_cookie/'</span>)</span><br><span class="line">    response.delete_cookie(<span class="string">'test'</span>) </span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>delete_cookie(key, path=&#39;/&#39;, domain=None)</code></p>
<blockquote>
<p>在<code>Cookie</code>中删除指定的<code>key</code>及对应的<code>value</code>，如果<code>key</code>值不存在，也不会引发任何异常。</p>
<p>由于<code>Cookie</code>的工作方式，<code>path</code>和<code>domain</code>应该与<code>set_cookie</code>时使用的值相同，否则<code>Cookie</code>值将不会被删除</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>通过<code>response</code>相应类的<code>delete_cookie</code>方法，本来应该在会话结束之后才消失的<code>Cookie</code>值，现在已经被直接删除掉。后台中通过<code>Request</code>中的<code>Cookie</code>字典获取到值也为<code>None</code></p>
<p>不要忘记字典的get，获取不到结果时，返回<code>None</code></p>
</blockquote>
<blockquote>
<p>但是，现在还有一个问题，我们在用户浏览器存储的Cookei值为明文，具有极大的安全隐患，django也提供了加密的Cookie值存储及获取方式</p>
</blockquote>
<h4 id="防止篡改COOKIE"><a href="#防止篡改COOKIE" class="headerlink" title="防止篡改COOKIE"></a>防止篡改COOKIE</h4><blockquote>
<p>通过<code>set_signed_cookie</code>函数进行持有签名的<code>COOKIE</code>值设置，避免用户在客户端进行修改</p>
<p>要记得，这个函数并不是对<code>COOKIE</code>值进行加密</p>
</blockquote>
<ul>
<li><p><code>HttpResonse.set_signed_cookie(key, value, salt=&#39;&#39;, max_age=None, expires=None, path=&#39;/&#39;, domain=None, secure=None, httponly=True)</code></p>
<blockquote>
<p>为<code>cookie</code>值添加签名，其余参数与<code>set_cookie</code>相同</p>
</blockquote>
</li>
<li><p><code>Request.get_signed_cookie(key, salt=&#39;&#39;, max_age=None)</code></p>
<blockquote>
<p>从用户请求中获取通过salt盐值加了签名的<code>Cookie</code>值。</p>
<p>这里的<code>salt</code>要与之前存储时使用的<code>salt</code>值相同才可以解析出正确结果。</p>
<p>还要注意的是，如果对应的key值不存在，则会引发<code>KeyError</code>异常，所以要记得异常捕获来确定是否含有<code>Cookie</code>值</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_salt_cookie</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        salt_cookie = request.get_signed_cookie(key=<span class="string">'salt_cookie'</span>,salt=<span class="string">'nice'</span>)    </span><br><span class="line">    <span class="keyword">except</span> KeyError: </span><br><span class="line">        <span class="comment">#获取不到该key值的Cookie</span></span><br><span class="line">        response = HttpResponse(<span class="string">'正在设置一个salt Cookie值'</span>)        								response.set_signed_cookie(key=<span class="string">'salt_cookie'</span>,salt=<span class="string">'nice'</span>,value=<span class="string">'salt_cookie'</span>)        	  <span class="keyword">return</span> response    </span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#获取到了对应key值，展示到新的HttpResonse中       </span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'获取到的salt Cookie值:%s'</span> % salt_cookie)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一次访问的时候，还没有加<code>Cookie</code>值，所以我们在获取的时候会抛出<code>KeyError</code>异常</p>
<p>此时捕获异常，并且设置<code>Cookie</code>即可；</p>
<p>再次刷新的时候，因为这里已经给出了<code>Cookie</code>值，则不会引发异常，会在页面中展示获取到的加盐<code>Cookie</code></p>
</blockquote>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><blockquote>
<p>虽然说有了<code>Cookie</code>之后，我们把一些信息保存在客户端浏览器中，可以保持用户在访问站点时的状态，但是也存在一定的安全隐患，<code>Cookie</code>值被曝露，<code>Cookie</code>值被他人篡改，等等。我们将换一种更健全的方式，也就是接下来要说的<code>Session</code>。</p>
<p><code>Session</code>在网络中，又称会话控制，简称会话。用以存储用户访问站点时所需的信息及配置属性。当用户在我们的<code>Web</code>服务中跳转时，存储在<code>Session</code>中的数据不会丢失，可以一直在整个会话过程中存活。</p>
<p>在<code>django</code>中，默认的<code>Session</code>存储在数据库中<code>session</code>表里。默认有效期为<strong>两个星期</strong>。</p>
</blockquote>
<h4 id="session创建流程"><a href="#session创建流程" class="headerlink" title="session创建流程"></a><strong>session创建流程</strong></h4><ol>
<li>客户端访问服务端，服务端为每一个客户端返回一个唯一的<code>sessionid</code>，比如<code>xxx</code>。</li>
<li>客户端需要保持某些状态，比如维持登陆。那么服务端会构造一个<code>{sessionid: xxx }</code>类似这样的字典数据加到<code>Cookie</code>中发送给用户。注意此时，只是一个随机字符串，返回给客户端的内容并不会像之前一样包含实际数据。</li>
<li>服务端在后台把返回给客户端的<code>xxx</code>字符串作为<code>key</code>值，对应需要保存的服务端数据为一个新的字典，存储在服务器上，例如：<code>{xxx : {id:1}}</code></li>
</ol>
<blockquote>
<p>之后的一些客户端数据获取，都是通过获取客户端向服务端发起的<code>HttpRequest</code>请求中里<code>Cookie</code>中的<code>sessionid</code>之后，再用该<code>sessionid</code>从服务端的<code>Session</code>数据中调取该客户端存储的<code>Session</code>数据</p>
</blockquote>
<blockquote>
<p><strong>注意</strong>：补充说明，默认存储在数据库的<code>Session</code>数据，是通过<code>base64</code> 编码的，我们可以通过<code>Python</code>的<code>base64</code>模块下的<code>b64decode()</code>解码得到原始数据</p>
</blockquote>
<blockquote>
<p>整个过程结束之后：客户端浏览器存储的其实也只是一个<strong>识别会话</strong>的随机字符串<code>（xxx）</code></p>
<p>而服务器中是通过这个随机的字符串<code>（xxx:value）</code>进行真正的存储</p>
</blockquote>
<blockquote>
<p><code>Session</code>的使用必须在<code>Settings</code>配置下</p>
</blockquote>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml">INSTALLED_APPS = (</span></span><br><span class="line"><span class="xml">...    'django.contrib.sessions', </span></span><br><span class="line"><span class="xml">...</span></span><br><span class="line"><span class="xml">)</span></span><br><span class="line"><span class="xml">MIDDLEWARE_CLASSES = (  </span></span><br><span class="line"><span class="xml">'django.contrib.sessions.middleware.SessionMiddleware',	</span></span><br><span class="line"><span class="xml">...</span></span><br><span class="line"><span class="xml">)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当<code>settings.py</code>中<code>SessionMiddleware</code>激活后</p>
<p>在视图函数的参数<code>request</code>接收到的客户端发来的<code>HttpResquest</code>请求对象中都会含有一个<code>session</code>属性</p>
<p>这个属性和之前所讨论的<code>Cookie</code>类似，是一个类字典对象，首先支持如下常用字典内置属性</p>
</blockquote>
<h4 id="获取Session"><a href="#获取Session" class="headerlink" title="获取Session"></a>获取Session</h4><ul>
<li><p><code>session_data = request.session.get(Key)</code></p>
</li>
<li><p><code>session_data = request.session[Key]</code></p>
<blockquote>
<p>在<code>Session</code>中获取对应值，<code>get</code>方法获取时，如不存在该<code>Key</code>值，不会引发异常，返回<code>None</code></p>
<p>而第二种直接通过字典获取，如<code>Key</code>值不存在，引发<code>KeyErro</code></p>
</blockquote>
</li>
</ul>
<h4 id="删除Session"><a href="#删除Session" class="headerlink" title="删除Session"></a>删除Session</h4><ul>
<li><code>del request.seesion[Key]</code></li>
</ul>
<blockquote>
<p>删除对应session，<code>Key</code>值不存在时，引发<code>KeyError</code></p>
</blockquote>
<ul>
<li><code>request.session.clear()</code></li>
</ul>
<blockquote>
<p>清空<code>Session</code>中的所有数据。这里客户端还会保留<code>sessionid</code></p>
<p>只不过在服务端<code>sessionid</code>对应的数据没有了。</p>
</blockquote>
<ul>
<li><code>request.session.flush()</code></li>
</ul>
<blockquote>
<p>直接删除当前客户端的的<code>Seesion</code>数据。这里不光服务端<code>sessionid</code>对应的数据没有了，客户端的<code>sessionid</code>也会被删除</p>
</blockquote>
<h4 id="设置有效期"><a href="#设置有效期" class="headerlink" title="设置有效期"></a>设置有效期</h4><ul>
<li><p><code>request.session.set_expiry(value)</code>：</p>
<blockquote>
<p>设置<code>Session</code>的有效时间。</p>
</blockquote>
<blockquote>
<p><code>value</code>：有效时间。</p>
<p><strong>为整数时</strong>：将在<code>value</code>为秒单位之后过期</p>
<p><strong>为0时</strong>：将在用户关闭浏览器之后过期。</p>
<p><strong>为None时</strong>：使用全局过期的设置，默认为两个星期，<code>14</code>天。</p>
<p><strong>为datetime时</strong>：在这个指定时间后过期。</p>
</blockquote>
</li>
<li><p><code>request.session.get_expiry_age()</code></p>
<blockquote>
<p>返回距离过期还剩下的秒数。</p>
</blockquote>
</li>
<li><p><code>request.session.clear_expired()</code></p>
<blockquote>
<p>清除过期的<code>Session</code>会话。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>编写一个简单的视图函数来玩耍<code>Session</code>吧</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponseimport datetime</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_session</span><span class="params">(request)</span>:</span> </span><br><span class="line">    <span class="keyword">if</span> request.session.get(<span class="string">'test_id'</span>): </span><br><span class="line">        session_data = request.session.get(<span class="string">'test_id'</span>)</span><br><span class="line">        <span class="comment"># 用户拿到的的session随机字符串   </span></span><br><span class="line">        session_key = request.session.session_key </span><br><span class="line">        <span class="comment"># 获取客户端浏览器中的SessionID值    </span></span><br><span class="line">        session_expire = request.session.get_expiry_age() </span><br><span class="line">        now = datetime.datetime.now()     </span><br><span class="line">        expire_time = now + datetime.timedelta(seconds=session_expire) </span><br><span class="line">        response = <span class="string">'&lt;div&gt;SessionID : %s&lt;/div&gt;'</span> % session_key + \                   <span class="string">'&lt;div&gt;Session : %s&lt;/div&gt;'</span> % session_data + \                   <span class="string">'&lt;div&gt;ExpireTime : %s&lt;/div&gt;'</span> % expire_time       </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(response)  </span><br><span class="line">    <span class="keyword">else</span>:   </span><br><span class="line">        request.session[<span class="string">'test_id'</span>] = <span class="string">'TEST'</span>    </span><br><span class="line">        request.session.set_expiry(<span class="literal">None</span>)	</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'已设置好Session'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用户在第一次访问时，会走<code>else</code>分支，此时还没有任何服务端的<code>Session</code>及客户端的<code>Cookie</code>值设定</p>
<p>那么我们会通过<code>request.session[Key]</code>的方式来设置一个<code>Session</code>值，值为<code>TEST</code></p>
<p>当用户第二次访问时将展示出所设置好的Session值及在客户端浏览器中存储的sessionid</p>
</blockquote>
<blockquote>
<p>在编写一个删除<code>Session</code>的视图函数吧</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_session</span><span class="params">(request)</span>:</span>   </span><br><span class="line">    <span class="keyword">if</span> request.session.get(<span class="string">'test_id'</span>):  </span><br><span class="line">        <span class="keyword">del</span> request.session[<span class="string">'test_id'</span>]  </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'Session被删了'</span>)   </span><br><span class="line">    <span class="keyword">else</span>:    </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'目前没有任何需要删除的session'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里温柔的使用<code>del request.session[Key]</code>的方式来进行<code>Session</code>的删除</p>
<p>如果存在对应<code>test_id</code>的<code>Session</code>值则删除，反之返回一个字符串</p>
</blockquote>
<h4 id="Session删除总结"><a href="#Session删除总结" class="headerlink" title="Session删除总结"></a>Session删除总结</h4><blockquote>
<p>使用的是<code>del</code>的针对性删除方式，这样不会将整个客户端的<code>session</code>删除掉</p>
<p>使用<code>request.session.clear()</code>，只是清空了服务端<code>Session</code>中的数据，但是客户端的<code>Cookie</code>中还会保存<code>sessionid</code>，只不过这个值对应的字符串所对应的用户数据是一个空</p>
<p>使用<code>request.session.flush()</code>，那么客户端<code>Cookie</code>中保存的<code>sessionid</code>首先会被删除，其次服务端通过<code>sessionid</code>值保存的用户数据也会被全部删除。</p>
</blockquote>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django-Forms-表单层</title>
    <url>/Django-Forms-%E8%A1%A8%E5%8D%95%E5%B1%82/</url>
    <content><![CDATA[<h2 id="Forms"><a href="#Forms" class="headerlink" title="Forms"></a>Forms</h2><blockquote>
<p><code>django</code>提供了一整套健全的机制来帮助我们自动创建对应<code>HTML</code>中的表单，类似序列化器</p>
</blockquote><blockquote>
<p>开发者可以方便的使用已经设定好的一系列字段进行表单的设计</p>
<p>可以在某个<code>app</code>下面新建一个<code>forms.py</code>文件，在这个文件编写<code>django</code>自带表单类的编写</p>
<p>比如像下面这样</p>
</blockquote><a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestForm</span><span class="params">(forms.Form)</span>:</span></span><br><span class="line">    name = forms.CharField(label=<span class="string">'名字:'</span>,max_length=<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个表单类中，设置了一个<code>CharField</code>字段，并且具有<code>label</code>标签值为<code>name</code></p>
<p>此外在``标签处还会设置<code>maxlength=100</code>的属性</p>
<p><code>django</code>在接收到这样表单内的数据时，还将验证数据的长度</p>
<p>实例化该类，然后打印出来查看效果</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"id_name"</span>&gt;</span>名字:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">maxlength</span>=<span class="string">"100"</span> <span class="attr">required</span> <span class="attr">id</span>=<span class="string">"id_name"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在渲染后的结果中不包含提交的按钮，以及外层的form标签，还需要我们自己手动在模板页面中进行添加</p>
</blockquote>
<blockquote>
<p><code>form</code>表单实例的使用也非常简单，直接在模板页面处将表单实例以模板变量形式传递赋值即可</p>
</blockquote>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"># views.py</span></span><br><span class="line"><span class="xml">def index(request):  </span></span><br><span class="line"><span class="xml">form = forms.TestForm()   </span></span><br><span class="line"><span class="xml">return render(request,'index.html',locals())</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span>	</span><br><span class="line">    &#123;% csrf_token %&#125;	</span><br><span class="line">    &#123;&#123; form &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="is-valid"><a href="#is-valid" class="headerlink" title="is_valid"></a>is_valid</h3><blockquote>
<p>每一个<code>form</code>类的实例都具有一个<code>is_valid()</code>方法，验证表单内的字段是否合法，并将表单中合法的的数据将放到表单中的<code>cleaned_data</code>属性中</p>
<p>如果全部数据都没有问题，那么该函数将会返回<code>True</code>，返回的合法数据。结果是一个字典的数据类型</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">form = TestFrom()</span><br><span class="line"><span class="keyword">if</span> form.is_valid():</span><br><span class="line">    data = form.cleaned_data</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_test</span><span class="params">(request)</span>:</span>	</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"POST"</span>:	</span><br><span class="line">        form = TestForm(request.POST)	</span><br><span class="line">        <span class="keyword">if</span> form.is_valid():   </span><br><span class="line">            name = form.cleaned_data.get(<span class="string">'name'</span>)</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">'OK'</span>)	</span><br><span class="line">        <span class="keyword">else</span>:	</span><br><span class="line">            form = TestForm()	</span><br><span class="line">            <span class="keyword">return</span> render(request, <span class="string">"xxx.html"</span>,&#123;<span class="string">"form"</span>:form&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在视图函数中，当用户以post形式提交数据，此时将post数据与表单类进行关联</p>
<p>使用<code>post</code>数据做为类实例化的参数，这种操作也叫作<strong>绑定数据到表单</strong></p>
<p>如果用户在表单中填写张三并提交，那么绑定数据之后的表单实例像是这样</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"id_name"</span>&gt;</span>名字:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"id_name"</span> <span class="attr">maxlength</span>=<span class="string">"100"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"张三"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>input</code>标签中的<code>value</code>值为用户<code>post</code>所提交的数据</p>
<p>如果绑定数据的表单实例经过<code>is_valid</code>函数校验并通过，那么正确的数据将存储在<code>cleaned_data</code>中，<code>cleaned_data</code>中的数据同时也是处理好的<code>Python</code>数据类型，比如这里为一个字典数据类型</p>
<p>接下来在视图函数中可以直接通过字典的操作方式来获取到用户在对应表单标签中所填写的数据</p>
</blockquote>
<h3 id="表单字段类型"><a href="#表单字段类型" class="headerlink" title="表单字段类型"></a>表单字段类型</h3><blockquote>
<p>所有表单字段<code>Field</code>的子类均带有默认参数<code>require</code></p>
</blockquote>
<h4 id="BooleanField"><a href="#BooleanField" class="headerlink" title="BooleanField"></a>BooleanField</h4><blockquote>
<p>控件：<code>CheckboxInput</code></p>
<p>复选框：``</p>
</blockquote>
<blockquote>
<p>空值：<code>False</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; Python`：`<span class="literal">True</span>\<span class="literal">False</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>错误键</strong>：<code>required</code></p>
</blockquote>
<h4 id="CharField"><a href="#CharField" class="headerlink" title="CharField"></a>CharField</h4><blockquote>
<p>控件：<code>TextInput</code></p>
<p>文本输入：``</p>
<p>空值：空字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; Python`：`str</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>错误键</strong>：<code>max_length</code>、<code>min_length</code>、<code>required</code></p>
</blockquote>
<h4 id="ChoiceField"><a href="#ChoiceField" class="headerlink" title="ChoiceField"></a>ChoiceField</h4><blockquote>
<p>控件：<code>Select</code></p>
<p>选择框：<code>...</code></p>
<p>空值：空字符串</p>
<p>Python：<code>Unicode str</code></p>
<p>必选参数：<code>choices</code>，该参数为一个二元组组成的可迭代对象，二元组中的第一个值为获取到的数据，第二个值为表单中展示的内容。</p>
<p><strong>错误键</strong>：<code>required</code>、<code>invalid_choice</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestForm</span><span class="params">(forms.Form)</span>:</span>  </span><br><span class="line">    choices = (        (<span class="string">'0'</span>,<span class="string">'男'</span>),        (<span class="string">'1'</span>,<span class="string">'女'</span>),    )   </span><br><span class="line">    gender = forms.ChoiceField(choices=choices)</span><br></pre></td></tr></table></figure>

<h4 id="DateField"><a href="#DateField" class="headerlink" title="DateField"></a>DateField</h4><blockquote>
<p>控件：<code>DateInput</code></p>
<p>日期以普通的文本框输入：``</p>
<p>空值：<code>None</code></p>
<p>Python：<code>datetime.date</code></p>
<p>验证是否为一个指定日期格式的字符串</p>
<p><strong>错误键</strong>：<code>required</code>、<code>invalid</code></p>
<p>可选参数：<code>input_formats</code>，一个时间格式化字符串，用来将表单中的数据转换为<code>datetime.date</code>对象</p>
<p>可选参数格式参考如下：</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">'%Y-%m-%d',	# '2006-10-25''%m/%d/%Y', # '10/25/2006''%m/%d/%y' 	# '10/25/06'</span><br></pre></td></tr></table></figure>

<h4 id="DateTimeField"><a href="#DateTimeField" class="headerlink" title="DateTimeField"></a>DateTimeField</h4><blockquote>
<p>控件：<code>DateTimeInput</code></p>
<p>日期/时间以普通的文本框输入：&lt;input type=’text’ …&gt;</p>
<p>空值：None</p>
<p>Python：<code>datetime.datetime</code></p>
<p>验证是否为一个指定日期格式的字符串</p>
<p>可选参数：<code>input_formats</code>，一个时间格式化字符串，用来将表单中的数据转换为<code>datetime.datetime</code>对象</p>
<p><strong>错误键</strong>：<code>required</code>、<code>invalid</code></p>
</blockquote>
<h4 id="DecimalField"><a href="#DecimalField" class="headerlink" title="DecimalField"></a>DecimalField</h4><blockquote>
<p>控件：当<code>Field.localize</code> 是<code>False</code> 时为<code>NumberInput</code>，否则为<code>TextInput</code></p>
<p><code>NumberInput</code>文本输入：``</p>
<p><code>TextInput</code>文本输入：``</p>
<p>空值：<code>None</code></p>
<p>Python：<code>decimal</code></p>
<p>验证给定值是否为一个十进制数字</p>
<p>可选参数：<code>max_value</code>、<code>min_value</code>控制大小值范围</p>
<p> <code>max_digits</code>：值允许的最大位数（小数点之前和之后的数字总共的位数，前导的零将被删除）</p>
<p> <code>decimal_places</code>：允许的最大小数位</p>
<p><strong>错误键</strong>：<code>required</code>，<code>invalid</code>， <code>max_value</code>， <code>min_value</code>， <code>max_digits</code>， <code>max_decimal_places</code> max_whole_digits</p>
</blockquote>
<h4 id="EmailField"><a href="#EmailField" class="headerlink" title="EmailField"></a>EmailField</h4><blockquote>
<p>控件：文本输入：``</p>
<p>空值：空字符串</p>
<p>Python：<code>Unicode str</code></p>
<p>使用正则验证给定的值是否为一个合法的邮件地址</p>
<p>可选参数：<code>max_length</code>与<code>min_length</code>，限定邮件地址字符串大小长度。</p>
<p><strong>错误键</strong>：<code>required</code>、<code>invalid</code></p>
</blockquote>
<h4 id="FileField"><a href="#FileField" class="headerlink" title="FileField"></a>FileField</h4><blockquote>
<p>控件：<code>ClearableFileInput</code></p>
<p>文件上传输入：``</p>
<p>空值：<code>None</code></p>
<p>Python：<code>UploadedFile</code></p>
<p>验证非空的文件数据绑定到表单</p>
<p>使用该字段时，在使用表单实例获取上传文件数据时，表单标签中需要具备<code>enctype=&quot;multipart/form-data&quot;</code>属性，此外还需要绑定文件数据在表单上</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">form = TestForm(request.POST,request.FILES)</span><br></pre></td></tr></table></figure>

<h4 id="FloatField"><a href="#FloatField" class="headerlink" title="FloatField"></a>FloatField</h4><blockquote>
<p>控件：当<code>Field.localize</code>是<code>False</code> 时为<code>NumberInput</code>，否则为<code>TextInput</code></p>
<p> <code>NumberInput</code>文本输入：``</p>
<p> <code>TextInput</code>文本输入：``</p>
<p>空值：<code>None</code></p>
<p>Python：<code>Float</code></p>
<p>验证给出的值是一个浮点数，对比<code>float</code>函数</p>
<p>可选参数：<code>max_value</code>、<code>min_value</code>限定大小值范围</p>
<p><strong>错误键</strong>：<code>required</code>， <code>invalid</code>， <code>max_value</code>，<code>min_value</code></p>
</blockquote>
<h4 id="ImageField"><a href="#ImageField" class="headerlink" title="ImageField"></a>ImageField</h4><blockquote>
<p>控件：<code>ClearableFileInput</code></p>
<p>文件上传输入：``</p>
<p>空值：<code>None</code></p>
<p>Python：<code>UploadedFile</code></p>
<p>验证文件数据并且检验是否是一个可以被pillow所解释的图像</p>
<p>使用该字段，需要安装<code>pillow</code>模块。</p>
<p><strong>错误键</strong>：<code>required</code>，<code>invalid</code>，<code>missing</code>，<code>empty</code>，<code>invalid_image</code></p>
</blockquote>
<h4 id="IntergerField"><a href="#IntergerField" class="headerlink" title="IntergerField"></a>IntergerField</h4><blockquote>
<p>控件：当<code>Field.localize</code> 是<code>False</code>时为<code>NumberInput</code>，否则为<code>TextInput</code></p>
<p> <code>NumberInput</code>文本输入：``</p>
<p> <code>TextInput</code>文本输入：``</p>
<p>空值：<code>None</code></p>
<p>Python：<code>int</code></p>
<p>验证给定的值是否是一个整数</p>
<p>可选参数：<code>max_value</code>、<code>min_value</code>限定大小值范围</p>
<p><strong>错误键</strong>：<code>required</code>，<code>invalid</code>，<code>max_value</code>，<code>min_value</code></p>
</blockquote>
<h4 id="GenericIPAddressField"><a href="#GenericIPAddressField" class="headerlink" title="GenericIPAddressField"></a>GenericIPAddressField</h4><blockquote>
<p>控件：<code>TextInput</code></p>
<p>文本输入：``</p>
<p>空值：空字符串</p>
<p>Python：<code>Unicode str</code></p>
<p>可选参数</p>
<p> <code>protocol</code>：默认值为<code>both</code>，可选<code>IPv4</code>或<code>IPv6</code>。</p>
<p><strong>错误键</strong>：<code>required</code>，<code>invalid</code></p>
</blockquote>
<h4 id="MultipleChoiceField"><a href="#MultipleChoiceField" class="headerlink" title="MultipleChoiceField"></a>MultipleChoiceField</h4><blockquote>
<p>控件：<code>SelectMultiple</code></p>
<p> <code>...</code></p>
<p>空值：一个空列表</p>
<p>Python：<code>list</code></p>
<p>验证表单中的值是否存在于选择列表中，对比<code>ChoiceField</code>，该字段支持多选</p>
<p>必选参数：<code>choices</code>，与<code>ChoiceField</code>类似，接收一个二元组可迭代对象</p>
<p><strong>错误键</strong>：<code>required</code>，<code>invalid_choice</code>，<code>invalid_list</code></p>
</blockquote>
<h4 id="RegexField"><a href="#RegexField" class="headerlink" title="RegexField"></a>RegexField</h4><blockquote>
<p>控件：<code>TextInput</code></p>
<p>文本输入：``</p>
<p>空值：空字符串</p>
<p>Python：<code>Unicode str</code></p>
<p>验证表单中值与某个正则表达式匹配</p>
<p>必选参数：<code>regex</code>，字符串或编译的正则表达式</p>
<p>可选参数：<code>max_length</code>、<code>min_length</code></p>
<p><strong>错误键</strong>：<code>required</code>，<code>invalid</code></p>
</blockquote>
<h4 id="SlugField"><a href="#SlugField" class="headerlink" title="SlugField"></a>SlugField</h4><blockquote>
<p>控件：<code>TextInput</code></p>
<p>文本输入：``</p>
<p>空值：空字符串</p>
<p>Python：<code>Unicode</code>对象</p>
<p>验证给定的值为<strong>字母</strong>、<strong>数字</strong>、<strong>下划线</strong>及<strong>连字符</strong>组成</p>
<p><strong>错误键</strong>：<code>required</code>，<code>invalid</code></p>
</blockquote>
<h4 id="URLField"><a href="#URLField" class="headerlink" title="URLField"></a>URLField</h4><blockquote>
<p>控件：<code>TextInput</code></p>
<p>文本输入：``</p>
<p>空值：空字符串</p>
<p>Python：<code>Unicode</code>对象</p>
<p>验证给定值是一个有效的<code>URL</code></p>
<p>可选参数：<code>max_length</code>、<code>min_length</code></p>
<p><strong>错误键</strong>：<code>required</code>，<code>invalid</code></p>
</blockquote>
<h4 id="TimeField"><a href="#TimeField" class="headerlink" title="TimeField"></a>TimeField</h4><blockquote>
<p>控件：<code>TextInput</code></p>
<p>文本输入：``</p>
<p>空值：<code>None</code></p>
<p>Python：<code>datetime.time</code></p>
<p>验证给定值是否为一个给定格式的时间字符串</p>
<p>可选参数：<code>input_formats</code>，控制表单输入的格式</p>
</blockquote>
<h3 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h3><ul>
<li><p><code>required</code>：</p>
<blockquote>
<p>表单字段为必填值，当传递数据为一个空值，不管是空字符串还是<code>None</code></p>
<p>在表单验证时，将引发<code>ValidationError</code>异常，这个异常将会在表单上展示错误信息</p>
</blockquote>
</li>
<li><p><code>label</code></p>
<blockquote>
<p>指定当前字段的<code>label</code>标签值，字段默认<code>Label</code>为字段名所有下换线转换为空格</p>
<p>且一个字母大写生成</p>
</blockquote>
</li>
<li><p><code>label_suffix</code></p>
<blockquote>
<p>修改label提示字符串的追加符号，默认表单类实例化过程会自动在<code>label</code>属性后加<code>:</code></p>
</blockquote>
</li>
<li><p><code>initial</code></p>
<blockquote>
<p>字段的初始值。不能将初始值直接作为参数传入，会造成直接验证表单数据而报错。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">form = forms.TestForm(initial=&#123;<span class="string">'name'</span>:<span class="string">'Bob'</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>widget</code></p>
<blockquote>
<p>表单字段渲染时使用的<code>Widget</code>类，如果不想使用默认的表单类型，通过该参数指明所需表单控件</p>
<p>可以使用类似的表单类型，在下面会有详细的介绍。</p>
</blockquote>
</li>
<li><p><code>help_text</code></p>
<blockquote>
<p>指定字段的描述文本，该文本一般会紧挨着字段显示</p>
</blockquote>
</li>
</ul>
<h3 id="表单控件：widget"><a href="#表单控件：widget" class="headerlink" title="表单控件：widget"></a>表单控件：widget</h3><blockquote>
<p>默认<code>django</code>会为每一个表单字段设置默认的<code>HTML</code>控件</p>
<p>控件用来渲染<code>HTML</code>中输入元素与提取提交的原始数据</p>
<p>如果你希望使用一个不同的控件<code>Widget</code>，可以为字段设置<code>widget</code>参数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentForm</span><span class="params">(forms.Form)</span>:</span></span><br><span class="line">    comment = forms.CharField(widget=forms.Textarea)</span><br><span class="line">    <span class="comment">#修改CharField默认控件TextInput为Textarea</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>此外，我们还可以为字段的<code>Widget</code>设置额外的属性</p>
<p>比如一些之后在<code>HTML</code>渲染时候将会使用到的标签<code>class</code>值等等</p>
<p>只需要在<code>widget</code>参数部分使用<code>attrs</code>形参指定即可，该参数设置这个字段控件的对应<code>HTML</code>属性</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = forms.CharField(    max_length=<span class="number">5</span>,    widget=forms.TextInput(attrs=&#123;<span class="string">'class'</span>:<span class="string">'green'</span>&#125;))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>还可以使用日期控件覆盖默认日期控件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">YEARS = (<span class="string">'2016'</span>, <span class="string">'2017'</span>, <span class="string">'2018'</span>)MONTHS = &#123;	<span class="number">1</span>:<span class="string">'一月'</span>, <span class="number">2</span>:<span class="string">'二月'</span>, <span class="number">3</span>:<span class="string">'三月'</span>, <span class="number">4</span>:<span class="string">'四月'</span>,<span class="number">5</span>:<span class="string">'五月'</span>, <span class="number">6</span>:<span class="string">'六月'</span>, <span class="number">7</span>:<span class="string">'七月'</span>, <span class="number">8</span>:<span class="string">'八月'</span>,<span class="number">9</span>:<span class="string">'九月'</span>, <span class="number">10</span>:<span class="string">'十月'</span>, <span class="number">11</span>:<span class="string">'十一月'</span>, <span class="number">12</span>:<span class="string">'十二月'</span>&#125;</span><br><span class="line">birth_year = forms.DateField(widget=froms.SelectDateWidget(years=YEARS,months=MONTHS))</span><br></pre></td></tr></table></figure>

<h4 id="文本输入控件"><a href="#文本输入控件" class="headerlink" title="文本输入控件"></a>文本输入控件</h4><ul>
<li><p><code>TextInput</code></p>
<blockquote>
<p>文本输入：``</p>
</blockquote>
</li>
<li><p><code>NumberInput</code></p>
<blockquote>
<p>文本输入：``</p>
</blockquote>
</li>
<li><p><code>EmailInput</code></p>
<blockquote>
<p>文本输入：``</p>
</blockquote>
</li>
<li><p><code>URLInput</code></p>
<blockquote>
<p>文本输入：``</p>
</blockquote>
</li>
<li><p><code>PasswordInput</code></p>
<blockquote>
<p>密码输入：``</p>
</blockquote>
</li>
<li><p><code>HiddenInput</code></p>
<blockquote>
<p>隐藏输入：``</p>
</blockquote>
</li>
<li><p><code>DateInput</code></p>
<blockquote>
<p>日期以普通的文本框输入：``</p>
<p>可选参数：<code>format</code>，时间的字符串格式</p>
</blockquote>
</li>
<li><p><code>DateTimeInput</code></p>
<blockquote>
<p>日期/时间以普通的文本框输入：``</p>
<p>可选参数：<code>format</code>，时间的字符串格式</p>
</blockquote>
</li>
<li><p><code>TimeInput</code></p>
<blockquote>
<p>时间以普通的文本框输入：``</p>
<p>可选参数：<code>format</code>，时间的字符串格式</p>
</blockquote>
</li>
<li><p><code>Textarea</code></p>
<blockquote>
<p>文本区域：<code>...</code></p>
</blockquote>
</li>
</ul>
<h4 id="选择和复选框"><a href="#选择和复选框" class="headerlink" title="选择和复选框"></a>选择和复选框</h4><ul>
<li><p><code>CheckboxInput</code></p>
<blockquote>
<p>复选框：``</p>
<p>可选参数：<code>check_test</code></p>
<p>这个参数接收一个<strong>函数对象</strong>，函数对象的参数为当前<code>CheckboxInput</code>的值，函数对象如果返回<code>True</code>，该控件在字段渲染时自动勾上。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">comment = forms.CharField(widget=forms.CheckboxInput(check_test=<span class="keyword">lambda</span> *arg: <span class="literal">True</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Select</code></p>
<blockquote>
<p>单选框：<code>...</code></p>
<p>可选参数：<code>choices</code>，与字段设置相同，但是会被字段设置所覆盖。</p>
</blockquote>
</li>
<li><p><code>NullBooleanSelect</code></p>
<blockquote>
<p>单选框：选项为<code>Unknown</code>、<code>Yes</code>和<code>No</code>，<code>Unknown</code>也代表<code>False</code>。</p>
</blockquote>
</li>
<li><p><code>SelectMultiple</code></p>
<blockquote>
<p>多选框：<code>...</code></p>
</blockquote>
</li>
<li><p><code>RadioSelect</code></p>
<blockquote>
<p>单选框，与<code>select</code>类似，但是会将选择渲染为一个<strong>单选按钮列表</strong></p>
</blockquote>
</li>
<li><p><code>CheckboxSelectMultiple</code></p>
<blockquote>
<p>多选框：与<code>SelectMultiple</code>类似，但是会渲染为一个<strong>复选框列表</strong>/</p>
</blockquote>
</li>
</ul>
<h4 id="复合控件"><a href="#复合控件" class="headerlink" title="复合控件"></a>复合控件</h4><ul>
<li><p><code>SelectDateWidget</code></p>
<blockquote>
<p>封装了三个<code>Widget</code>，分别用于年、月、日</p>
<p>可选参数：可以来指定日期表单的选择</p>
<p> <code>years</code>：一个列表或元组的序列数据类型，用来确定年的选择。</p>
<p> <code>months</code>：一个字典数据类型，字典的key值为月份数字，从1开始，value值为在表单中渲染展示的字符串，比如</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MONTHS = &#123;	<span class="number">1</span>:<span class="string">'一月'</span>, <span class="number">2</span>:<span class="string">'二月'</span>, <span class="number">3</span>:<span class="string">'三月'</span>, <span class="number">4</span>:<span class="string">'四月'</span>,	<span class="number">5</span>:<span class="string">'五月'</span>, <span class="number">6</span>:<span class="string">'六月'</span>, <span class="number">7</span>:<span class="string">'七月'</span>, <span class="number">8</span>:<span class="string">'八月'</span>,	<span class="number">9</span>:<span class="string">'九月'</span>, <span class="number">10</span>:<span class="string">'十月'</span>, <span class="number">11</span>:<span class="string">'十一月'</span>, <span class="number">12</span>:<span class="string">'十二月'</span>&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="表单API"><a href="#表单API" class="headerlink" title="表单API"></a>表单API</h3><blockquote>
<p>表单类的实例，只有两种，一种是绑定了数据的，一种是未绑定的。都可以渲染成为<code>html</code></p>
</blockquote>
<ul>
<li><p><code>Form.is_valid()</code></p>
<blockquote>
<p>对于绑定了数据的表单，进行验证并返回一个数据是否合法的布尔值</p>
<p>并在<strong>所有数据</strong>有效时将数据放入<code>cleaned_data</code>中</p>
</blockquote>
</li>
<li><p><code>Form.is_bound()</code></p>
<blockquote>
<p>区分绑定表单和未绑定表单，当表单类绑定数据时，返回<code>True</code></p>
</blockquote>
</li>
<li><p><code>Form.errors</code></p>
<blockquote>
<p>当验证发生错误时的错误信息的字典，字典<code>key</code>值为字段名称，<code>value</code>为报错信息列表，可能有多个报错</p>
<p>表单的数据将会在调用<code>is_valid</code>时或访问<code>errors</code>属性时验证</p>
<p>并且验证过程只会调用一次，不论访问<code>errors</code>和调用<code>is_valid</code>多少次</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestForm</span><span class="params">(forms.Form)</span>:</span></span><br><span class="line">    name = forms.CharField(max_length=<span class="number">5</span>,)</span><br><span class="line">    email = forms.EmailField(required=<span class="literal">True</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_name</span><span class="params">(self)</span>:</span>	</span><br><span class="line">        cleaned_data = super(TestForm,self).clean()   </span><br><span class="line">        <span class="keyword">if</span> self.cleaned_data.get(<span class="string">'name'</span>) == <span class="string">'小红'</span>: </span><br><span class="line">            <span class="keyword">raise</span> forms.ValidationError(<span class="string">"不允许小红"</span>)    </span><br><span class="line">            <span class="keyword">return</span> cleaned_data</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = forms.TestForm(&#123;<span class="string">'name'</span>:<span class="string">'小红'</span>,<span class="string">'emali'</span>:<span class="string">'123'</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.errors&#123;<span class="string">'name'</span>: [<span class="string">'不允许小红'</span>], <span class="string">'email'</span>: [<span class="string">'This field is required.'</span>]&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Form.errors.as_data</code></p>
<blockquote>
<p>返回报错信息的字典，映射字段报错信息到一个ValidationError实例</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.errors.as_data()&#123;	<span class="string">'name'</span>: [ValidationError([<span class="string">'不允许小红'</span>])], 	<span class="string">'email'</span>: [ValidationError([<span class="string">'This field is required.'</span>])]&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Form.errors.as_json(escape_html=False)</code></p>
<blockquote>
<p>以<code>json</code>格式返回错误信息</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.errors.as_json()</span><br><span class="line"><span class="string">'&#123;	"name": [&#123;"message": "\\u4e0d\\u5141\\u8bb8\\u5c0f\\u7ea2", "code": ""&#125;],	"email": [&#123;"message": "This field is required.", "code": "required"&#125;]&#125;'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Form.initial</code></p>
<blockquote>
<p>声明当前表单类的默认数据，参数为一个字典数据类型</p>
<p><code>key</code>对应需要填充默认数据的表单字段，<code>value</code>值为实际数据</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestForm</span><span class="params">(forms.Form)</span>:</span>	name = forms.CharField(max_length=<span class="number">5</span>,initial=<span class="string">'Jack'</span>,)</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = TestForm(initial=&#123;<span class="string">'name'</span>:<span class="string">'Bob'</span>&#125;)</span><br><span class="line">&gt;&gt;&gt; print(f)&lt;tr&gt;&lt;th&gt;&lt;label for="id_name"&gt;Name:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input id="id_name" maxlength="5" name="name" type="text" value="Bob" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Form.has_changed()</code></p>
<blockquote>
<p>检查表单当前的数据是否与默认值不同</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = TestForm(data=&#123;<span class="string">'name'</span>:<span class="string">'Jack'</span>&#125;,initial=&#123;<span class="string">'name'</span>:<span class="string">'Bob'</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.has_changed()<span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Form.cleaned_data</code></p>
<blockquote>
<p>在对绑定数据的表单实例进行<code>is_valid</code>验证之后，如果数据无误</p>
<p>那么返回的数据将保存在<code>cleaned_data</code>中</p>
<p>如果有部分数据没有经过验证，那么<code>cleaned_data</code>中也会保留合法的字段</p>
<p>并且，<code>在cleaned_data</code>属性中获取到的数据，只包含表单类中含有的字段</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestForm</span><span class="params">(forms.Form)</span>:</span>	</span><br><span class="line">    name = forms.CharField(max_length=<span class="number">5</span>,)	</span><br><span class="line">    email = forms.EmailField(required=<span class="literal">True</span>)	</span><br><span class="line">    active = forms.BooleanField()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = &#123;...</span><br><span class="line">            <span class="string">'name'</span>:<span class="string">'Jack'</span>, </span><br><span class="line">            ...   </span><br><span class="line">            <span class="string">'email'</span>:<span class="string">'111'</span>,... </span><br><span class="line">            <span class="string">'active'</span>:<span class="literal">True</span>,... &#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = TestForm(data=data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.is_valid()<span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.cleaned_data&#123; <span class="string">'name'</span>:<span class="string">'Jack'</span>, <span class="string">'active'</span>: <span class="literal">True</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Form.as_p()</code></p>
<blockquote>
<p>将表单渲染为一系列的``标签，每个标签内含一个字段porm.as_ul()`</p>
</blockquote>
<blockquote>
<p>渲染表单为一系列的<code>标签，并且不包含</code>标签，可以自行指定``的<code>HTML</code>属性</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(f.as_ul())&lt;li&gt;&lt;label for="id_name"&gt;Name:&lt;/label&gt; &lt;input id="id_name" maxlength="5" name="name" type="text" /&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p><code>Form.as_table()</code></p>
<blockquote>
<p>渲染表单为`标签</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(f.as_table())&lt;tr&gt;&lt;th&gt;&lt;label for="id_name"&gt;Name:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input id="id_name" maxlength="5" name="name" type="text" /&gt;&lt;/td&gt;&lt;/tr&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>配置表单元素的<code>HTML id</code>值与默认自带的<code>label</code>标签</p>
<p>通过表单类进行渲染时，默认会包含以下属性</p>
</blockquote>
<ul>
<li>表单元素的<code>HTML id</code>属性</li>
<li>辅助的<code>label</code>标签</li>
</ul>
<blockquote>
<p>有些时候，想要设置自定义HTML id值或者取消label标签，可以使用如下内置函数</p>
</blockquote>
<ul>
<li><p><code>Form.auto_id=True</code></p>
<blockquote>
<p>修改对应渲染表单属性</p>
<p>当<code>auto_id</code>值为<code>False</code>时，表单类的渲染将不会包含``以及<code>id</code>属性</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = TestForm(auto_id=<span class="literal">False</span>)</span><br><span class="line">&gt;&gt;&gt; print(f)&lt;tr&gt;&lt;th&gt;Name:&lt;/th&gt;&lt;td&gt;&lt;input maxlength="5" name="name" type="text" /&gt;&lt;/td&gt;&lt;/tr&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="模板中表单实例属性"><a href="#模板中表单实例属性" class="headerlink" title="模板中表单实例属性"></a>模板中表单实例属性</h3><blockquote>
<p>模板页面接收到的<code>form</code>表单实例支持循环遍历访问</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> field <span class="keyword">in</span> form %&#125;	&#123;&#123; field &#125;&#125;&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中<code>for</code>迭代访问之后的每一个表单字段又支持如下操作</p>
</blockquote>
<ul>
<li><p>``：字段的label，例如Email address。</p>
</li>
<li><p>``：包含在HTML 标签中的字段值。</p>
</li>
<li><p>``：这个字段的ID值。</p>
</li>
<li><p>``：字段的值</p>
</li>
<li><p>``：该字段的标签中name属性使用的值。</p>
</li>
<li><p>``：该字段的帮助文档。</p>
</li>
<li><p>``：字段的验证错误信息，字段标签会在</p>
</li>
</ul>
<ul>
<li><p>``：如果该字段为隐藏字段，返回True。反之返回False。</p>
</li>
<li><p>``：获取当前字段实例，可以用该属性来访问字段实例的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123; field.field.max_length &#125;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="与模型类关联的表单"><a href="#与模型类关联的表单" class="headerlink" title="与模型类关联的表单"></a>与模型类关联的表单</h3><blockquote>
<p>除了以上我们自定义表单类来进行表单的初始化</p>
<p><code>django</code>还提供了另外一种表单类的创建方法，可以通过与模型关联来构建表单</p>
<p>这种办法可以更加省时省力，直接使用模型类中已经定义好的字段来进行表单字段的生成</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTable</span><span class="params">(modes.Model)</span>:</span>	</span><br><span class="line">    name = models.CharField(max_length=<span class="number">10</span>)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestTableForm</span><span class="params">(forms.ModelForm)</span>:</span>	</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">            model = TestTable	</span><br><span class="line">            fields = [<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>生成的表单实例将具备模型类中的字段，表单生成的字段顺序也与模型类中的定义顺序相同</p>
<p><code>fields</code>属性用来显示的设置所有需要在表单中处理的字段</p>
<p>也可以直接为该字段设置<code>fields = &#39;__all__&#39;</code>来使用所有模型类中的字段作为未来的表单字段</p>
</blockquote>
<ul>
<li><p>注意</p>
<p>：</p>
<ul>
<li>如果模型类中字段定义了<code>blank=True</code>，那么对应关联的表单类中字段会默认具有<code>require=False</code>的属性</li>
<li>模型类中字段的<code>verbose_name</code>属性对应关联表单类字段的Label属性</li>
<li>如果模型类字段中设置了<code>choices</code>值，那么对应关联表单字段的<code>widget</code>将会设置为<code>select</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>当然，除了根据关联模型类来创建表单类，还可以在关联表单类中选择性的覆盖某些字段的设置</p>
<p>比如使用表单类<code>Meta</code>元类中的<code>widgets</code>属性可以以字典形式设置对应字段的控件</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTableForm</span><span class="params">(forms.ModelForm)</span>:</span>	</span><br><span class="line">    name = forms.URLField()	</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span>	</span><br><span class="line">        model = TestTable	</span><br><span class="line">        fields = [<span class="string">'name'</span>]   </span><br><span class="line">        widgets = &#123;        </span><br><span class="line">            <span class="string">'name'</span>:forms.Textarea(attrs=&#123;<span class="string">'class'</span>:<span class="string">'green'</span>&#125;)   </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除此之外，还可以指定<code>labels</code>、<code>help_texts</code>和<code>error_messages</code>等信息</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTableForm</span><span class="params">(forms.ModelForm)</span>:</span>	</span><br><span class="line">    name = forms.URLField()	</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span>	</span><br><span class="line">        model = TestTable	</span><br><span class="line">        fields = [<span class="string">'name'</span>]   </span><br><span class="line">        labels = &#123;        </span><br><span class="line">            <span class="string">'name'</span>:<span class="string">'您的名字'</span>        &#125; </span><br><span class="line">        help_texts = &#123;     </span><br><span class="line">            <span class="string">'name'</span>:<span class="string">'请输入您的名字'</span>        &#125;   </span><br><span class="line">        error_messages = &#123;   </span><br><span class="line">            <span class="string">'name'</span>:&#123;             </span><br><span class="line">                <span class="string">'required'</span>:<span class="string">'你必须填写这个名字'</span>,     </span><br><span class="line">                <span class="string">'max_length'</span>:<span class="string">'你的名字太长了'</span>      </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="与模型关联的表单验证"><a href="#与模型关联的表单验证" class="headerlink" title="与模型关联的表单验证"></a>与模型关联的表单验证</h3><blockquote>
<p>表单的验证在我们调用<code>is_valid</code>函数时执行，也可以通过访问<code>errors</code>属性或调用<code>full_clean</code>函数</p>
<p>验证的出错会引发<code>ValidationError</code>异常，该异常会向表单传达一个错误信息</p>
</blockquote>
<blockquote>
<p>验证的步骤主要分为两步，表单验证，如果关联了模型，则还会进行模型验证</p>
</blockquote>
<ul>
<li><p><strong>表单字段的验证</strong>分为以下过程</p>
<ol>
<li><p>字段<code>to_python</code>，这个方法将字段的值根据字段的类型转换为Python中的数据类型，如果不能转换则引发<code>ValidationError</code>异常</p>
</li>
<li><p>字段的<code>clean</code>函数，该函数用来运行对应的验证器，根据顺序执行<code>to_python</code>，<code>validate</code>特异性验证，以及<code>run_validators</code>（用于将错误信息汇总）验证，如果有任何验证过程引发了<code>ValidationError</code>异常，验证都将停止。其余通过验证的字段数据插入到表单的cleaned_data字典中</p>
</li>
<li><p>表单中的字段<code>clean</code>函数，这个验证用于完成特定属性，与表单字段类型无关；比如我们经常需要验证用户输入的字段值不能为小红，那么可以编写字段的<code>clean</code>函数，函数命名为<code>clean_</code>，<code>fileds_name</code>为字段名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTableForm</span><span class="params">(forms.ModelForm)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_name</span><span class="params">(self)</span>:</span></span><br><span class="line">      name = self.cleaned_data.get(<span class="string">'name'</span>)</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">'小红'</span>:      </span><br><span class="line">          <span class="keyword">raise</span> forms.ValidationError(<span class="string">'不允许小红'</span>)  </span><br><span class="line">            <span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ul>
<ol start="4">
<li><p>表单的<code>clean</code>函数，这个方法进行表单中多个字段值的联合验证，验证之后的数据返回为<code>cleaned_data</code>，可以通过重写该函数来提供的额外验证方法，并且为了维持<code>clean</code>方法的验证行为，在代码中，表单类需要调用父类的<code>clean</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean</span><span class="params">(self)</span>:</span></span><br><span class="line">    cleaned_data = super(TestTableForm,self).clean() </span><br><span class="line">    name = cleaned_data.get(<span class="string">'name'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'1'</span> <span class="keyword">in</span> name:   </span><br><span class="line">        cleaned_data[<span class="string">'name'</span>] = name.replace(<span class="string">'1'</span>,<span class="string">'一'</span>)   </span><br><span class="line">        <span class="keyword">return</span> cleaned_data</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>最后总结的来说：</p>
<p> 一个表单在验证时，首先验证每一个字段，接着调用字段的<code>clean_fields</code>函数，最后使用表单类的<code>clean</code>函数进行验证</p>
</blockquote>
<blockquote>
<p>如果表单与模型关联，那么现在还有第二步验证，模型的验证</p>
</blockquote>
<ul>
<li><p><strong>模型的验证</strong>为如下过程</p>
<ol>
<li><p>验证关联模型的字段及相关属性：<code>Model.clean_fields(exclud=None)</code>，该方法将验证模型的所有字段属性，如果有字段验证错误，引发<code>ValidationError</code>异常</p>
</li>
<li><p>验证模型的完整性：<code>Model.clean(exclude=None)</code>，可以对模型做整体的检验，如果想要自己验证模型中通过属性校验的数据，可以在模型类中重新定义这个函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> ValidationError</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTable</span><span class="params">(models.Model)</span>:</span> </span><br><span class="line">  name = models.CharField(max_length=<span class="number">10</span>,verbose_name=<span class="string">'名字'</span>,unique=<span class="literal">True</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">'$'</span> <span class="keyword">in</span> self.name:  </span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">'无法使用$符号'</span>)</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ul>
<ol start="3">
<li>验证模型的唯一性：<code>Model.validate_unique(exclude=None)</code>，如果模型中所有唯一约束性，比如使用类似<code>unique</code>属性，会校验表单中的值是否唯一</li>
</ol>
<blockquote>
<p>并且，除了通过绑定模型的表单实例<code>is_valid</code>函数可以来进行以上的验证过程，如果想自己控制验证</p>
<p>可以直接使用模型的<code>full_clean(exclude=None,validate_unique=True)</code>方法进行以上三个步骤的验证</p>
</blockquote>
<h3 id="与模型关联的表单保存"><a href="#与模型关联的表单保存" class="headerlink" title="与模型关联的表单保存"></a>与模型关联的表单保存</h3><blockquote>
<p>与模型关联的表单，在校验成功之后，表单实例可以直接通过<code>save</code>函数来进行表单数据的保存数据库</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">form_test</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"POST"</span>:	</span><br><span class="line">        form = TestTableForm(request.POST,request.FILES)	</span><br><span class="line">        <span class="keyword">if</span> form.is_valid():	</span><br><span class="line">            form.save()	<span class="keyword">return</span> HttpResponse(<span class="string">'OK:%s'</span> % value)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>该函数也支持在模型类中进行重写，但是要切记使用父类的save方法，确保数据可以正确存储到数据库中</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, *args, **kwargs)</span>:</span>	</span><br><span class="line">    <span class="keyword">if</span> self.name == <span class="string">'abc'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span><span class="comment">#不做存储	</span></span><br><span class="line">    <span class="keyword">else</span>:		</span><br><span class="line">        super(TestTable,self).save(*args, **kwargs)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax及Axios异步请求，接口数据序列化处理</title>
    <url>/Ajax%E5%8F%8AAxios%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><blockquote>
<p><code>ajax</code>可以使当前浏览器不需要整个重新加载，只是局部刷新，给用户的体验良好，也因为只是刷新局部页面，相对而言效率更高一些</p>
<p>同步交互：客户端发出一个请求后，需要等待服务器相应结束后，才可以发起第二个请求</p>
<p>异步交互：客户端发出一个请求后，无需等待该次服务器的相应，即可发起第二个请求</p>
</blockquote><a id="more"></a>
<h3 id="json数据类型"><a href="#json数据类型" class="headerlink" title="json数据类型"></a>json数据类型</h3><ul>
<li>数据在键值对中</li>
<li>数据由逗号分隔</li>
<li>花括号存储数据</li>
<li>方括号保存数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[    &#123; <span class="string">"name"</span>:<span class="string">"Bill"</span>, <span class="string">"age"</span>:<span class="number">1</span> &#125;,    &#123; <span class="string">"name"</span>:<span class="string">"George"</span>, <span class="string">"age"</span>:<span class="number">2</span> &#125;,    &#123; <span class="string">"name"</span>:<span class="string">"Thomas"</span>, <span class="string">"age"</span>: <span class="number">3</span> &#125;];</span><br></pre></td></tr></table></figure>

<h3 id="jQuery-Ajax"><a href="#jQuery-Ajax" class="headerlink" title="jQuery-Ajax"></a>jQuery-Ajax</h3><blockquote>
<p>使用<code>ajax</code>进行<code>django</code>后台数据的异步获取，<code>django</code>只是提供的数据，并不承担前端页面的渲染工程</p>
<p>这里使用<code>jQuery</code>所提供的<code>ajax</code>方法进行异步通信</p>
</blockquote>
<ul>
<li>首先测试数据库中模型类定义如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">50</span>,verbose_name=<span class="string">"标题"</span>)</span><br><span class="line">    author = models.CharField(max_length=<span class="number">20</span>,verbose_name=<span class="string">"作者"</span>)</span><br><span class="line">    date = models.DateField(auto_now_add=<span class="literal">True</span>,verbose_name=<span class="string">"发表日期"</span>)</span><br><span class="line">    content = models.TextField(verbose_name=<span class="string">"文章内容"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>        </span><br><span class="line">        <span class="keyword">return</span> self.title</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试数据可由用户自行添加，非常简单</p>
</blockquote>
<ul>
<li>编写主页视图函数，返回所有数据库中内容</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    articles = models.Article.objects.all()</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'ajax/index.html'</span>,locals())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此处的<code>index.html</code>页面不光承担所有数据的渲染工作</p>
<p>还将负责未来<code>ajax</code>异步请求，获取对应文章的详细内容</p>
</blockquote>
<ul>
<li><code>index.html</code>页面代码</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span>    </span><br><span class="line"><span class="css">    <span class="selector-tag">label</span>&#123;        <span class="attribute">border</span>: <span class="number">5px</span> outset gray;        <span class="attribute">width</span>: <span class="number">150px</span>;        <span class="attribute">margin-top</span>: <span class="number">10px</span>;     &#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    &#123;% load staticfiles %&#125;    </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Ajax测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"&#123;% static 'js/jquery-1.10.2.min.js' %&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"&#123;% static 'js/jquery.cookie.js' %&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>    <span class="comment">&lt;!-- 该js文件用来引入jquery所提供的获取cookie值的库 为了提取对应csrf_token--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个ajax的请求测试<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line">    &#123;% for article in articles %&#125; </span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"&#123;&#123; article.id &#125;&#125;"</span>&gt;</span></span><br><span class="line">        &#123;&#123; article.author &#125;&#125;:&#123;&#123; article.title &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">"label"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            $.ajax(&#123;</span></span><br><span class="line"><span class="actionscript">                url: <span class="string">'/article/'</span>, <span class="comment">// 请求地址，对应Django某个路由映射</span></span></span><br><span class="line"><span class="actionscript">                type: <span class="string">'POST'</span>, <span class="comment">// 请求方式 post</span></span></span><br><span class="line">                data: &#123;</span><br><span class="line"><span class="javascript">                    <span class="string">'csrfmiddlewaretoken'</span>: $.cookie(<span class="string">'csrftoken'</span>),</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">// 提交数据需有当前csrf_token 防跨站请求伪造令牌</span></span></span><br><span class="line"><span class="javascript">                    <span class="string">'id_'</span>: $(<span class="keyword">this</span>).attr(<span class="string">'class'</span>),</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">// 获取当前的id值 传递到视图后台</span></span></span><br><span class="line">                &#125;, </span><br><span class="line"><span class="actionscript">                success: <span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123; </span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(result)  </span></span><br><span class="line"><span class="actionscript">                    <span class="comment">// 解析获得实际字符串   </span></span></span><br><span class="line"><span class="javascript">                    $(<span class="string">'.content'</span>).html(data)    </span></span><br><span class="line">                    </span><br><span class="line"><span class="actionscript">                    <span class="comment">// 将内容以html形式显示到对应的p标签上  </span></span></span><br><span class="line">                &#125;          </span><br><span class="line">            &#125;)    </span><br><span class="line">        &#125;)   </span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>有了前端页面，并且<code>ajax</code>的请求地址为<code>/article/</code>，那么就需要我们定义一个视图函数返回对应的<code>json</code>数据，并且设置路由为<code>/article/</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#urls.pypath('ajax/',ajaxviews.index),</span><br><span class="line"># 首页路由path('article/',ajaxviews.article)</span><br><span class="line"># ajax请求路由</span><br><span class="line">#views.pydef article(request):</span><br><span class="line"><span class="keyword">if</span> request.is_ajax():</span><br><span class="line"># 判断是否为ajax请求</span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">"POST"</span>:</span><br><span class="line"># 为ajax的post方式请求 </span><br><span class="line"></span><br><span class="line">id_ = request.POST.get(<span class="string">'id_'</span>)   </span><br><span class="line"><span class="keyword">if</span> id_:      </span><br><span class="line">    <span class="keyword">try</span>:    </span><br><span class="line">    content = models.Article.objects.get(id=id_).content.replace('\r\n','&lt;br&gt;')                # 这里还将获取到的文章字符串内容中的换行替换为HTML的换行标签 </span><br><span class="line">    except models.Article.DoesNotExist:   </span><br><span class="line">    raise Http404   </span><br><span class="line">    <span class="keyword">else</span>:          </span><br><span class="line">    data = json.dumps(content,ensure_ascii=False,cls=JsonEncoder)     </span><br><span class="line"># 返回get对应取到的实际属性      </span><br><span class="line"><span class="keyword">return</span> HttpResponse(data)  </span><br><span class="line">raise Http404</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>这里要注意的是，后端返回的数据得是序列化之后的才可以被前端<code>js</code>所解析，直接返回一个<code>django model</code>数据实例是不行的。所以需要我们视图函数对需要返回的数据进行序列化操作</p>
</blockquote>
<blockquote>
<p>对于数据的序列化操作主要有以下两种</p>
</blockquote>
<h4 id="json序列化"><a href="#json序列化" class="headerlink" title="json序列化"></a>json序列化</h4><blockquote>
<p>普通<code>Python</code>数据直接使用<code>json</code>模块进行序列化</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">content = models.Article.objects.get(id=id_).content.replace(<span class="string">'\r\n'</span>,<span class="string">'&lt;br&gt;'</span>)</span><br><span class="line"><span class="comment">#这里将文章内容对应返回，之所以有replace函数，是因为文章数据是通过admin后台复制添加，需要将其中的\r\n换行转换为HTML可以解析的&lt;br&gt;标识符data = json.dumps(content,ensure_ascii=False)# 第二个参数是因为序列化时对中文默认使用的ascii编码，此时需要将该值设置为False，这样前端接收到时才是一个正常中文结果return HttpResponse(data)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>但如果要序列化的数据中包含时间类型<code>date</code> 或<code>datetime</code>时，这种办法就会报错啦</p>
</blockquote>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; TypeError: Object of type date <span class="keyword">is</span> <span class="keyword">not</span> JSON serializable</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonEncoder</span><span class="params">(json.JSONEncoder)</span>:</span></span><br><span class="line">    <span class="comment"># 自定义json处理器 </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">default</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(obj, datetime):</span><br><span class="line">            <span class="comment"># 如果判断到类型为datetime格式   </span></span><br><span class="line">            <span class="keyword">return</span> obj.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)        </span><br><span class="line">        <span class="comment"># 处理为字符串类型的 (年-月-日 时:分:秒)  </span></span><br><span class="line">        <span class="keyword">elif</span> isinstance(obj, date):          </span><br><span class="line">            <span class="comment"># 如果判断到json处理数据为date类型     </span></span><br><span class="line">            <span class="keyword">return</span> obj.strftime(<span class="string">'%Y-%m-%d'</span>)     </span><br><span class="line">        <span class="keyword">else</span>:           </span><br><span class="line">            <span class="keyword">return</span> json.JSONEncoder.default(self,obj)   </span><br><span class="line">        <span class="comment"># 其他数据类型按照默认的序列化方式处理即可</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<code>cls</code>指定序列化方式，即可轻松解决特殊格式没有办法被<code>json</code>序列化的问题</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">content = models.Article.objects.get(id=id_).data</span><br><span class="line">data = json.dumps(content,ensure_ascii=<span class="literal">False</span>,cls=JsonEncoder)</span><br><span class="line"><span class="comment"># 通过json.dumps的cls参数指明所使用的自定义序列化类</span></span><br><span class="line"><span class="keyword">return</span> HttpResponse(data)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对应前端接收展示</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(result) </span><br><span class="line"><span class="comment">// 普通json传输方式$('.content').html(data)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果返回的数据并不是一个单独的数据属性，那么也可以通过<code>json</code>进行处理，以一个数据列表的形式返回</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">content = models.Article.objects.filter(id=id_).values()</span><br><span class="line"><span class="comment"># ----------------------------------------------# </span></span><br><span class="line">content = models.Article.objects.all().values()</span><br><span class="line"><span class="comment"># ----------------------------------------------</span></span><br><span class="line">data = json.dumps(list(content),ensure_ascii=<span class="literal">False</span>,cls=JsonEncoder)<span class="keyword">return</span> HttpResponse(data)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对应前端接收展示</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里用到的不是之前的p标签 而是一个div容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">success: function (result) &#123;   </span><br><span class="line">var data = JSON.parse(result)[0]['content']  </span><br><span class="line">$('.content').html(data.replace(/\r\n/g,"<span class="tag">&lt;<span class="name">br</span>&gt;</span>"))&#125;</span><br><span class="line">// ---------------------------------------------</span><br><span class="line">// 如果需要展示的是所有的结果，可以通过js的for循环</span><br><span class="line">success: function (result) &#123;  </span><br><span class="line">var data = JSON.parse(result)   </span><br><span class="line">var tag = '' </span><br><span class="line">for (var i = 0, len = data.length; i &lt; len; i++) &#123;        tag += '&lt;p&gt;' + data[i]['content'].replace(/\r\n/g, "&lt;br&gt;") + '&lt;/p&gt;'        tag += '&lt;hr&gt;'    &#125;    $('.content').html(tag)&#125;</span><br><span class="line">                                           // ----------------------------------------------</span><br></pre></td></tr></table></figure>

<h3 id="Vue-Axios"><a href="#Vue-Axios" class="headerlink" title="Vue-Axios"></a>Vue-Axios</h3><blockquote>
<p>除去<code>jQuery</code>所提供的异步通信<code>ajax</code>方法</p>
<p>在<code>Vue</code>中也提供了<code>ajax</code>的异步通信方法，叫做<code>Axios</code></p>
<p><code>Axios</code>会自动转换<code>json</code>数据</p>
</blockquote>
<blockquote>
<p>简单的来编写一个视图函数</p>
<p> <code>get</code>：返回当前页面</p>
<p> <code>post</code>：返回一条<code>json</code>数据</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">new</span> Vue(&#123; </span><br><span class="line">        el: <span class="string">'#content'</span>, </span><br><span class="line">        <span class="comment">// Vue接管的区域  </span></span><br><span class="line">        data: &#123;    </span><br><span class="line">            message: <span class="string">'这个是表单内容'</span>,  </span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;   </span><br><span class="line">            getajax() &#123;   </span><br><span class="line">                </span><br><span class="line">                axios.get(<span class="string">'/get_ajax/'</span>, &#123;    </span><br><span class="line">                    params: &#123;      </span><br><span class="line">                        <span class="comment">// 这部分为get方式进行传参时使用的    </span></span><br><span class="line">                        id: <span class="number">123</span>     </span><br><span class="line">                    &#125;         </span><br><span class="line">                &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;    </span><br><span class="line">                    <span class="built_in">console</span>.log(response) </span><br><span class="line">                    <span class="comment">// 打印输出get方式进行ajax请求时获取到的数据</span></span><br><span class="line">                &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123; </span><br><span class="line">                    <span class="built_in">console</span>.log(error) </span><br><span class="line">                    <span class="comment">// 当get方式ajax请求报错时，会进入该函数 </span></span><br><span class="line">                &#125;)    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;,  </span><br><span class="line">    &#125;)&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对应的<code>HTML</code>页面</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">'getajax'</span>&gt;</span>点我发送ajax的get请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>后台视图函数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> request.method == <span class="string">'GET'</span>:  </span><br><span class="line">    message = request.GET.get(<span class="string">'message'</span>)  </span><br><span class="line">    print(message)  </span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'axios/index.html'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当使用的是<code>post</code>形式获取服务端数据时，首先要注意，<code>axios</code>默认的提交<code>post</code> 数据不是普通的<code>form-data</code></p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">&gt; axios`的`post`使用的是`request payload`方式，参数格式是`application/json<span class="comment">;charset=UTF-8</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>而我们之前的表单提交数据的类型都是<code>application/x-www-form-urlencoded</code>，所以直接再<code>django</code>后台通过<code>request.POST.get</code>是获取不到任何数据的</p>
<p>解决办法，需要我们在<code>axios</code>提交数据时，指明提交时的头部信息</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">new</span> Vue(&#123; </span><br><span class="line">        el: <span class="string">'#content'</span>, </span><br><span class="line">        <span class="comment">// Vue接管的区域 </span></span><br><span class="line">        data: &#123;</span><br><span class="line">            message: <span class="string">'这个是表单内容'</span>, </span><br><span class="line">        &#125;, </span><br><span class="line">        methods: &#123;  </span><br><span class="line">            getajax() &#123;  </span><br><span class="line">                axios(&#123;  </span><br><span class="line">                    method: <span class="string">'post'</span>, </span><br><span class="line">                    url: <span class="string">'/get_ajax/'</span>, </span><br><span class="line">                    data: &#123; </span><br><span class="line">                        message:<span class="keyword">this</span>.message,  </span><br><span class="line">                        name: <span class="string">'张三'</span> </span><br><span class="line">                    &#125;, </span><br><span class="line">                    headers: &#123;  </span><br><span class="line">                        <span class="string">'Content-Type'</span>:<span class="string">'application/x-www-form-urlencoded'</span>,                    &#125;,               </span><br><span class="line">                &#125;).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123; </span><br><span class="line">                    <span class="built_in">console</span>.log(response.data) </span><br><span class="line">                    <span class="keyword">this</span>.message = response.data   </span><br><span class="line">                &#125;)   </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;,    </span><br><span class="line">    &#125;)&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然通过添加头部信息，可以让<code>axios</code>发送的数据被<code>django</code>后台所接收到，但是此时的数据还是有问题的</p>
<p>获取到的<code>POST</code>提交的数据被<code>django</code>打包成了一个<code>QueryDict</code>中的key值，<code>value</code>为空数组</p>
<p>导致后台按照平时的解析方式是获取不到的</p>
<p>解决办法也很简单，把<code>QueryDict</code>单独处理为一个字典</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">    data = eval(list(request.POST.keys())[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 将获取到的数据转换为字典 </span></span><br><span class="line">    message = data.get(<span class="string">'message'</span>)</span><br><span class="line">    data = json.dumps(message + <span class="string">'我被服务端后台修改过'</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(data)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下来，当用户点击按钮时，<code>post</code>提交表单数据，给到<code>django</code>后台，后台追加字符串并返回，返回的数据被<code>then</code>回调函数所接收到，重新赋值给绑定的表单变量中</p>
</blockquote>
<ul>
<li>第二种办法，在前端<code>vue</code>提交数据时，</li>
</ul>
<h3 id="serializer序列化"><a href="#serializer序列化" class="headerlink" title="serializer序列化"></a>serializer序列化</h3><blockquote>
<p><code>serializer</code>是由<code>django</code>所提供的一个专门用来处理<code>django</code>数据对象<code>(django model)</code>变为序列化数据的框架</p>
<p>并且<code>Django</code>的序列化不支持<strong>单个对象</strong>，比如像<code>objects.get</code>获取到的数据，或是<code>Python</code>中的 <code>str</code>等数据类型</p>
<p>该序列化框架所提供的功能类位于<code>django.core.serializers</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#views.py </span></span><br><span class="line"><span class="keyword">from</span> django.core <span class="keyword">import</span> serializers</span><br><span class="line">content = models.Article.objects.filter(id=id_)</span><br><span class="line">data = serializers.serialize(<span class="string">'json'</span>,content,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">return</span> HttpResponse(data)</span><br><span class="line">var data = JSON.parse(result)[<span class="number">0</span>][<span class="string">'fields'</span>][<span class="string">'content'</span>]</span><br><span class="line">// 序列化传输方式</span><br><span class="line">$(<span class="string">'.content'</span>).html(data.replace(/\r\n/g,<span class="string">"&lt;br&gt;"</span>))console.log(data)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结</strong>：通过管理器的<code>get</code>方法获取到的是一个独立的结果，并不是一个<code>QuerySet</code>数据对象，也不是一个普通<code>Python</code>数据类型；只能对数据其中的某条属性进行<code>json</code>格式的处理或是将其变为列表等序列数据类型之后再进行序列化处理</p>
</blockquote>
<h3 id="serializer反序列化"><a href="#serializer反序列化" class="headerlink" title="serializer反序列化"></a>serializer反序列化</h3><blockquote>
<p>序列化：<code>serializers.serialize</code></p>
<p>反序列化：<code>serializers.deserialize</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core <span class="keyword">import</span> serializers</span><br><span class="line">content = models.Article.objects.filter(id=id_) </span><br><span class="line"><span class="comment"># QuerySet</span></span><br><span class="line">data = serializers.serialize(<span class="string">'json'</span>,content,ensure_ascii=<span class="literal">False</span>) </span><br><span class="line"><span class="comment"># str</span></span><br><span class="line">content = serializers.deserialize(<span class="string">"json"</span>, data)</span><br><span class="line"><span class="keyword">return</span> HttpResponse(data)</span><br></pre></td></tr></table></figure>

<h3 id="Ajax跨域"><a href="#Ajax跨域" class="headerlink" title="Ajax跨域"></a>Ajax跨域</h3><blockquote>
<p>浏览器有一个很重要的概念：同源策略<code>(Same-Origin Policy)</code></p>
<p><strong>所谓同源是指，域名，协议，端口相同</strong></p>
<p><strong>不同源的客户端脚本<code>javascript、ActionScript</code>在没明确授权的情况下，不能读写对方的资源</strong></p>
<p>同源：请求资源的地址与请求的发起方都属于同一域名下</p>
</blockquote>
<h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><blockquote>
<p><code>JSONP</code>是<code>JSON with padding</code>（填充式<code>JSON</code> 或参数式 <code>JSON</code>）的简写</p>
<p><strong><code>JSONP</code>实现跨域请求的原理简单的说，就是动态创建<code>标签，然后利用</code>的<code>src</code>不受同源策略约束来跨域获取数据。</strong></p>
<p><code>JSONP</code>由两部分组成：回调函数和数据</p>
<p>回调函数是当响应到来时应该在页面中调用的函数；回调函数的名字一般是在请求中指定的，而数据就是传入回调函数中的参数</p>
</blockquote>
<blockquote>
<p>注意：<code>JSONP</code>方式解决<code>AJAX</code>跨域，必须使用<code>get</code>方式，并且该方式常在一些数据量级比较小的情况下，因为需要服务端后台构建回调函数带参数的字符串，像是下面这样</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span> </span><br><span class="line">    name = request.GET.get(<span class="string">'name'</span>) + <span class="string">'哈哈哈哈哈'</span>   </span><br><span class="line">    callback = request.GET.get(<span class="string">'callback'</span>) </span><br><span class="line">    data = <span class="string">'%s("%s")'</span> % (callback,name) </span><br><span class="line">    <span class="comment"># 这里以前端生成的回调函数名作为函数名，待返回数据作为参数返回    </span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(data)</span><br></pre></td></tr></table></figure>

<ul>
<li>前端代码：点击按钮传送表单的值到后台，并由后台处理后追加内容返回，返回的结果展示再<code>p</code>标签处</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">id</span>=<span class="string">'ajax_data'</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>    按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Ajax</code>代码，获取当前表单数据，并使用<code>get</code>方式传递到服务端</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    $(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  </span><br><span class="line">        $.ajax(&#123;   </span><br><span class="line">            url: <span class="string">'http://127.0.0.1:8000/axios/'</span>, </span><br><span class="line">            <span class="comment">// 请求地址，对应Django某个路由映射 </span></span><br><span class="line">            type: <span class="string">'get'</span>,</span><br><span class="line">            <span class="comment">// 请求方式 post  </span></span><br><span class="line">            dataType: <span class="string">"jsonp"</span>, </span><br><span class="line">            <span class="comment">// 指定服务端返回的数据为jsonp格式  </span></span><br><span class="line">            data: &#123;  </span><br><span class="line">                <span class="string">'name'</span>: $(<span class="string">'#ajax_data'</span>).val(),</span><br><span class="line">            &#125;,     </span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;   </span><br><span class="line">                <span class="built_in">console</span>.log(result)  </span><br><span class="line">                $(<span class="string">'#content'</span>).html(result) </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;)  </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>ajax</code>发起请求，并指定服务端返回数据类型为<code>jsonp</code>格式</p>
</li>
<li><p>服务端构建函数包含参数的字符串，为<code>jsonp</code>请求发起时，给定的回调参数名，参数为要返回的数据</p>
</li>
<li><p>客户端先会调用回调函数，然后会调用</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">success</span></span><br></pre></td></tr></table></figure>

<p>回调函数可以接收处理服务端返回的数据</p>
<ul>
<li><code>success</code>回调函数是成功返回数据后必定会调用的函数</li>
</ul>
</li>
</ol>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><blockquote>
<p>跨域资源共享<code>CORS(Cross-Origin Resource Sharing)</code>是一种机制，它使用额外的<code>HTTP</code>头来告诉浏览器，让运行在一个 <code>origin</code> (<code>domain</code>) 上的<code>Web</code>应用被<strong>准许</strong>访问<strong>来自不同源服务器</strong>上的指定的资源</p>
<p>当一个资源从与该资源本身所在的服务器<strong>不同的域、协议或端口</strong>请求一个资源时，资源会发起一个<strong>跨域 HTTP 请求</strong></p>
</blockquote>
<ul>
<li><strong>注意</strong>：不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了</li>
</ul>
<blockquote>
<p>实现<code>CORS</code>通信的关键是服务器。只要服务器实现了<code>CORS</code>接口，就可以跨源通信</p>
</blockquote>
<ul>
<li>这里需要我们将后端视图函数在接收到请求时，返回结果指明头部信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cors</span><span class="params">(View)</span>:</span>	</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span>	</span><br><span class="line">        <span class="comment">#判断是否为ajax请求	</span></span><br><span class="line">        name = request.POST.get(<span class="string">'name'</span>)	</span><br><span class="line">        response = HttpResponse(json.dumps(<span class="string">'OK'</span>))</span><br><span class="line">        response[<span class="string">"Access-Control-Allow-Origin"</span>] = <span class="string">"http://127.0.0.1:5500"</span>	</span><br><span class="line">        <span class="comment"># 允许可以跨域请求的站点</span></span><br><span class="line">        response[<span class="string">"Access-Control-Allow-Methods"</span>] = <span class="string">"POST, GET, OPTIONS"</span>	</span><br><span class="line">        <span class="comment"># 允许可以跨域访问的请求方式</span></span><br><span class="line">        response[<span class="string">"Access-Control-Allow-Headers"</span>] = <span class="string">"*"</span>	</span><br><span class="line">        <span class="comment"># 允许可以跨域请求时的头部字段	</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<ul>
<li>前端页面的<code>ajax</code>代码正常提交数据即可</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Page Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/jquery-1.10.2.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">'name'</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">'button'</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="javascript">    $(<span class="string">'#button'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;  </span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;     </span></span><br><span class="line"><span class="actionscript">            url: <span class="string">'http://127.0.0.1:8000/'</span>,    </span></span><br><span class="line"><span class="actionscript">            type: <span class="string">'post'</span>,  </span></span><br><span class="line">            data: &#123;        </span><br><span class="line"><span class="javascript">                name: $(<span class="string">'#name'</span>).val()     </span></span><br><span class="line">            &#125;,      </span><br><span class="line"><span class="actionscript">            success: <span class="function"><span class="keyword">function</span><span class="params">(result)</span></span>&#123;    </span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(result)  </span></span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;)   </span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="django-cors-headers"><a href="#django-cors-headers" class="headerlink" title="django-cors-headers"></a>django-cors-headers</h4><blockquote>
<p>除了以上手动构建返回结果的头部信息用来解决跨域问题</p>
<p>在<code>django</code>中还可以通过一个先成可以自动添加<code>CORS-Header</code>的中间件，只需要在<code>settings.py</code>中做一些简单的配置即可</p>
<p>要想使用该中间件需要安装<code>django</code>的三方插件</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install django-cors-headers</span><br></pre></td></tr></table></figure>

<ul>
<li>安装完成之后，在<code>django</code>的<code>settings</code>文件中加载<code>app</code></li>
</ul>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"># settings.pyINSTALLED_APPS = [	...    'django.contrib.staticfiles',    'corsheaders',]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>接下来在中间件配置部分加载该插件所提供的中间件</li>
</ul>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"># settings.pyMIDDLEWARE = [    'django.middleware.security.SecurityMiddleware',    'django.contrib.sessions.middleware.SessionMiddleware',    'corsheaders.middleware.CorsMiddleware', # 顺序需要在common组件之前    'django.middleware.common.CommonMiddleware',    #'django.middleware.csrf.CsrfViewMiddleware',    'django.contrib.auth.middleware.AuthenticationMiddleware',    'django.contrib.messages.middleware.MessageMiddleware',    'django.middleware.clickjacking.XFrameOptionsMiddleware',]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>继续配置允许跨站请求的白名单设置等属性</li>
</ul>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"># settings.pyCORS_ORIGIN_ALLOW_ALL = False # 是否允许其他所有站点发起跨站请求CORS_ORIGIN_WHITELIST = (    'http://127.0.0.1:5500',) # 跨站请求白名单</span></span><br><span class="line"><span class="xml">CORS_ALLOW_METHODS = (    'POST',) #  允许跨站访问的请求方式</span></span><br><span class="line"><span class="xml">CORS_ALLOW_HEADERS = (    '*',) # 允许跨站请求头中的字段类型</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注：其中某些设置的默认值为如下所示</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">default_headers = (  </span><br><span class="line">    <span class="string">'accept'</span>, </span><br><span class="line">    <span class="string">'accept-encoding'</span>, </span><br><span class="line">    <span class="string">'authorization'</span>, </span><br><span class="line">    <span class="string">'content-type'</span>, </span><br><span class="line">    <span class="string">'dnt'</span>,  </span><br><span class="line">    <span class="string">'origin'</span>,</span><br><span class="line">    <span class="string">'user-agent'</span>,</span><br><span class="line">    <span class="string">'x-csrftoken'</span>,  </span><br><span class="line">    <span class="string">'x-requested-with'</span>,)</span><br><span class="line">default_methods = ( </span><br><span class="line">    <span class="string">'DELETE'</span>,   </span><br><span class="line">    <span class="string">'GET'</span>,  </span><br><span class="line">    <span class="string">'OPTIONS'</span>,  </span><br><span class="line">    <span class="string">'PATCH'</span>,    </span><br><span class="line">    <span class="string">'POST'</span>,</span><br><span class="line">    <span class="string">'PUT'</span>,)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
</search>

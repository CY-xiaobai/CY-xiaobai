{"meta":{"title":"哼着自己旳小调调","subtitle":"Happy hum their own small tune","description":null,"author":"哼着自己旳小调调","url":"https://cy-blogs.cn","root":"/"},"pages":[{"title":"","date":"2019-12-20T03:47:41.432Z","updated":"2019-12-20T03:47:41.432Z","comments":true,"path":"404.html","permalink":"https://cy-blogs.cn/404.html","excerpt":"","text":"L2Dwidget.init({\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\",\"tagMode\":false});"},{"title":"关于个人","date":"2019-10-13T09:46:28.000Z","updated":"2019-10-21T06:01:26.819Z","comments":true,"path":"about/index.html","permalink":"https://cy-blogs.cn/about/index.html","excerpt":"","text":"个人信息："},{"title":"分类","date":"2016-03-24T16:00:00.000Z","updated":"2019-10-21T03:46:43.274Z","comments":true,"path":"categories/index.html","permalink":"https://cy-blogs.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-21T03:40:22.000Z","updated":"2019-10-21T06:01:32.661Z","comments":true,"path":"tags/index.html","permalink":"https://cy-blogs.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis 心跳检测","slug":"redis的心跳检测","date":"2019-12-20T03:23:07.031Z","updated":"2019-12-20T03:22:12.655Z","comments":true,"path":"redis的心跳检测/","link":"","permalink":"https://cy-blogs.cn/redis的心跳检测/","excerpt":"","text":"Redis 心跳检测 在命令传播阶段，从服务器默认以每秒一次的频率，向主服务器发送命令： *REPLCONF ACK * //replication_offset是从服务器当前的复制偏移量。 心跳检测的作用：检测主服务器的网络连接状态；辅助实现min-slaves选项；检测命令丢失。 检测主从服务器的网络连接状态 通过向主服务器发送INFO replication命令，可以列出从服务器列表，可以看出从最后一次向主发送命令距离现在过了多少秒。 lag的值应该在0或1之间跳动，如果超过1则说明主从之间的连接有故障。 辅助实现min-slaves选项 Redis可以通过配置防止主服务器在不安全的情况下执行写命令； min-slaves-to-write 3 min-slaves-max-lag 10 上面的配置表示：从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时，主服务器将拒绝执行写命令。这里的延迟值就是上面INFOreplication命令的lag值。 检测命令丢失 如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器。 主服务器向从服务器补发缺失数据这一操作的原理和部分重同步操作的原理非常相似，它们的区别在于：补发缺失数据操作在主从服务器没有断线的情况下执行，而部分重同步操作则在主从服务器断线并重连之后执行。","categories":[{"name":"Redis","slug":"Redis","permalink":"https://cy-blogs.cn/categories/Redis/"}],"tags":[{"name":"Redis 心跳检测","slug":"Redis-心跳检测","permalink":"https://cy-blogs.cn/tags/Redis-心跳检测/"}]},{"title":"Redis 哨兵机制","slug":"Redis的哨兵机制","date":"2019-12-20T03:23:07.006Z","updated":"2019-12-20T03:21:50.304Z","comments":true,"path":"Redis的哨兵机制/","link":"","permalink":"https://cy-blogs.cn/Redis的哨兵机制/","excerpt":"Redis 哨兵机制什么是哨兵机制？ Redis 的哨兵（sentinel）系统用于管理多个 Redis 服务器，哨兵是redis集群架构中非常重要的一个组件，该系统执行以下三个任务： 监控（Monitoring）：哨兵（sentinel）会不断地检查你的 Master 和Slave 是否运作正常。 提醒（Notification）：当别监控的某个 Redis 出现问题时，哨兵（sentinel）可以通过 API 向管理员或者其他应用程序发送通知。 自动故障迁移（Automatic failover）：当一个Master 不能正常工作时，哨兵（sentinel）会开始一次自动故障迁移操作，它会将失效 Master 的其中一个 Slave 升级为新的 Master，并让失效 Master 的其他 Slave 改为复制新的 Master；当客户端视图连接失败的 Master时，集群也会向客户端返回新 Master 的地址，使得集群可以使用 Master 代替失效 Master。 哨兵（sentinel）是一个分布式系统，作为一个哨兵集群去运行的，相互协同工作，你可以在一个架构中运行多个哨兵（sentinel）进程 ​ (1)故障转移时，判断一个master node宕机了，需要大部分哨兵都同意才行，涉及到分布式选举问题。​ (2)及时部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身就是单点，那么就不靠谱。 ​ 这些进程使用留言协议（gossipprotocols）来接收关于Master 是否下线的信息，并使用投票协议 （agreementprotocols）来决定是否执行自动故障迁移，以及选择哪个 Slave 作为新的 Master。 ​ 每个哨兵（sentinel）会向其它哨兵（sentinel）、master、slave定时发送消息，以确认对方是否 “活“ **着，如果发现对方在指定时间（可配置）内未响应，则暂时认为对方已挂（所谓的”主观认为冗机“**Subjective Down,简称sdown)） ​ 若“哨兵群”中的多数据sentinel，都报告某一 master 没响应，系统才认为该 master “彻底死亡”(即:客观上的真正down机,Objective Down,简称odown),通过一定的vote算法,从剩下的slave节点中,选一台提升为master,然后自动修改相关配置。 ​ 虽然哨兵(sentinel) *释出为一个单独的可执行文件 *redis-sentinel **,但实际上它只是一个运行在特殊模式下的 Redis 服务器，你可以在启动一个普通 Redis 服务器时通过给定 –sentinel** 选项来启动哨兵(sentinel)。 ​ 哨兵(sentinel) 的一些设计思路和zookeeper非常类似","text":"Redis 哨兵机制什么是哨兵机制？ Redis 的哨兵（sentinel）系统用于管理多个 Redis 服务器，哨兵是redis集群架构中非常重要的一个组件，该系统执行以下三个任务： 监控（Monitoring）：哨兵（sentinel）会不断地检查你的 Master 和Slave 是否运作正常。 提醒（Notification）：当别监控的某个 Redis 出现问题时，哨兵（sentinel）可以通过 API 向管理员或者其他应用程序发送通知。 自动故障迁移（Automatic failover）：当一个Master 不能正常工作时，哨兵（sentinel）会开始一次自动故障迁移操作，它会将失效 Master 的其中一个 Slave 升级为新的 Master，并让失效 Master 的其他 Slave 改为复制新的 Master；当客户端视图连接失败的 Master时，集群也会向客户端返回新 Master 的地址，使得集群可以使用 Master 代替失效 Master。 哨兵（sentinel）是一个分布式系统，作为一个哨兵集群去运行的，相互协同工作，你可以在一个架构中运行多个哨兵（sentinel）进程 ​ (1)故障转移时，判断一个master node宕机了，需要大部分哨兵都同意才行，涉及到分布式选举问题。​ (2)及时部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身就是单点，那么就不靠谱。 ​ 这些进程使用留言协议（gossipprotocols）来接收关于Master 是否下线的信息，并使用投票协议 （agreementprotocols）来决定是否执行自动故障迁移，以及选择哪个 Slave 作为新的 Master。 ​ 每个哨兵（sentinel）会向其它哨兵（sentinel）、master、slave定时发送消息，以确认对方是否 “活“ **着，如果发现对方在指定时间（可配置）内未响应，则暂时认为对方已挂（所谓的”主观认为冗机“**Subjective Down,简称sdown)） ​ 若“哨兵群”中的多数据sentinel，都报告某一 master 没响应，系统才认为该 master “彻底死亡”(即:客观上的真正down机,Objective Down,简称odown),通过一定的vote算法,从剩下的slave节点中,选一台提升为master,然后自动修改相关配置。 ​ 虽然哨兵(sentinel) *释出为一个单独的可执行文件 *redis-sentinel **,但实际上它只是一个运行在特殊模式下的 Redis 服务器，你可以在启动一个普通 Redis 服务器时通过给定 –sentinel** 选项来启动哨兵(sentinel)。 ​ 哨兵(sentinel) 的一些设计思路和zookeeper非常类似 哨兵的核心知识 哨兵至少需要3个实例，来保证自己的健壮性。 哨兵+redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用性 对于哨兵+redis主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充分的测试和演练。 redis哨兵主备切换的数据丢失问题 两种丢失情况： 异步复制导致的数据丢失 ​ 因为master-&gt;slave的复制是异步的，所 以可能有部分数据还没复制到slave，master就宕机了，这些数据就丢失了。 脑裂导致的数据丢失 ​ 脑裂，也就是说，某个master所在机器 突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着 ​ 这个时候，集群中就会出现两个master。 ​ 此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续写向旧master数据可能就会丢失。 ​ 因此master在恢复的时候，会被作为一个slave挂到新的master上，自己的数据会被清空，从新的master复制数据 解决异步复制和脑裂导致的数据丢失 min-slaves-to-write 1 min-slaves-max-lag 10 要求至少有1个slave，数据复制和同步的延迟不能超过10秒 如果说一旦所有slave，数据复制和同步的延迟都超过了10秒钟，那么这个时候，master就不会再接收任何请求了。 （1）减少异步复制的数据丢失 有了min-slaves-max-lag这个配置，就可以确保说，一旦slave复制数据和ack延时太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求，这样可以把master宕机时由于部分数据未同步到slave导致的数据丢失降低的可控范围内 （2）减少脑裂的数据丢失 如果一个master出现了脑裂，跟其他slave丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的slave发送数据，而且slave超过10秒没有给自己ack消息，那么就直接拒绝客户端的写请求 这样脑裂后的旧master就不会接受client的新数据，也就避免了数据丢失 上面的配置就确保了，如果跟任何一个slave丢了连接，在10秒后发现没有slave给自己ack，那么就拒绝新的写请求 因此在脑裂场景下，最多就丢失10秒的数据 集群脑裂导致的数据丢失问题.png 脑裂导致数据丢失的问题如何降低损失.png 异步复制导致的数据丢失问题.png 哨兵模式的配置修改 实现步骤 拷贝到etc目录 cp sentinel.conf /usr/local/redis/etc 修改sentinel.conf配置文件 sentinel monitor mymast 192.168.110.133 6379 1 #主节点 名称 IP 端口号 选举次数 #配置主服务器的密码(如没设置密码，可以省略) sentinel auth-pass mymaster 123456 修改心跳检测 5000毫秒 sentinel down-after-milliseconds mymaster 5000 做多多少合格节点 sentinel parallel-syncs mymaster 2 启动哨兵模式 ./redis-server /usr/local/redis/etc/sentinel.conf –sentinel &amp; 注意： 1.当启动哨兵模式之后，如果你的master服务器宕机之后，哨兵自动会在从redis服务器里面 投票选举一个master主服务器出来；这个主服务器也可以进行读写操作！ 2.如果之前宕机的主服务器已经修好，可以正式运行了。那么这个服务器只能进行读的操作，会自动跟随由哨兵选举出来的新服务器！ 3.大家可以进入./redis-cli，输入info，查看你的状态信息； 哨兵(Sentinel)总结 1、Sentinel的作用： A、Master 状态监测 B、如果Master 异常，则会进行Master-slave 转换，将其中一个Slave作为Master，将之前的Master作为Slave C、Master-Slave切换后，master_redis.conf、slave_redis.conf和sentinel.conf的内容都会发生改变，即master_redis.conf中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换 2、Sentinel的工作方式: 1)：每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令。 2)：如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。 3)：如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。 4)：当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 。 5)：在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 。 6)：当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 。 7)：若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。 若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。 最后，如果大家看不太懂，推荐大家看两个博客，就明白了！ 1.http://blog.csdn.net/zbw18297786698/article/details/528916952.http://blog.csdn.net/candy_rainbow/article/details/52842402","categories":[{"name":"Redis","slug":"Redis","permalink":"https://cy-blogs.cn/categories/Redis/"}],"tags":[{"name":"Redis 哨兵机制","slug":"Redis-哨兵机制","permalink":"https://cy-blogs.cn/tags/Redis-哨兵机制/"}]},{"title":"Redis 主从复制","slug":"Redis主从复制","date":"2019-12-20T00:52:31.992Z","updated":"2019-12-20T01:59:27.187Z","comments":true,"path":"Redis主从复制/","link":"","permalink":"https://cy-blogs.cn/Redis主从复制/","excerpt":"Redis 主从复制 参考链接： Redis主从复制和哨兵 参考1 Redis主从复制和哨兵 参考2 Redis主从架构和主从从架构集群搭建详细步骤 Redis主从复制原理 Redis复制官方文档翻译","text":"Redis 主从复制 参考链接： Redis主从复制和哨兵 参考1 Redis主从复制和哨兵 参考2 Redis主从架构和主从从架构集群搭建详细步骤 Redis主从复制原理 Redis复制官方文档翻译 ​ Redis 的定位是一个高可用的数据服务器，可是实际生产环境下，单机的 redis 服务器是无法满足真正意义上的高可用性的， ​ 第一，单机的 redis 服务器很容易发生单点故障，即使 redis 提供了各种持久化的方法来避免数据的丢失，但是物理机上的故障（硬板损坏等）还是无法完全避免的。 ​ 第二，如果单台机器的性能进行纵向扩展，无论是CPU，内存还是磁盘容量都很容易达到瓶颈，无法满足实际需求。 ​ 针对这些问题，Redis提供了复制（replication）的功能，通过 “主从（一主多从）” 和 （集群（多住多从））的方式对 redis的服务进行水平扩展，用多台 redis 服务器共同构建一个高可用的 redis 服务系统。 ​ 主从复制，是指将一台Redis服务器的数据，复制到其它的 Redis服务器。前者称为主节点（master/leader），后者称为从节点（slave/follower）；数据的复制是单向的，只能由主节点到从节点。 ​ 默认情况下，每台 Redis服务器都是主节点；且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。 主从复制的作用 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。 负载均衡 ：在主从复制的基础上，配合读写分离，可以由主节点提供服务，由从节点提供读服务（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。 读写分离：可以用于实现读写分离，主库写，从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量。 高可用基石 ：主从复制还是哨兵和肌群能够实施的基础，因此说主从复制是 Redis高可用的基础。 主从括扑结构 一主一从：用于节点故障转移从节点，当主节点的 写 命令并发高且需要持久化，可以值在从节点开启AOF （主节点不需要），这样保证了数据的安全性，也避免持久化对主节点的影响。 一主多从 ：针对 读较多的场景， 读由多个从节点来分担，但节点越多，主节点同步到多节点的次数也越多，影响带宽，也加重主节点的稳定 ​ 树状主从 ：一主多从的缺点（住节点推送次数多压力大）可用些方案解决，主节点只推送一次数据到从节点B，再由从节点B推送到C，减轻主节点推送的压力。 Redis 主从复制启用 主从复制的开启，完全是在从节点发起的；不需要我们在主节点做任何事情。 从节点开启主从复制，有三种方式： 配置文件：在从服务器的配置文件中加入：slaveof 启动命令： redis-server 启动命令后加入 –slaveof 客户端命令：Reids 服务器启动后，直接通过客户端执行命令： slaveof ,则该Redis实例成为从节点。 通过 info relication 命令可以看到复制的一些信息 断开主从复制 ​ 通过 slaveof 命令建立主从复制关系以后，可以通过slaveof no one断开。 ​ 从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化。 Redis 主从复制原理 主从复制过程大体可以分为3个阶段：连接建立阶段（即准备阶段）、数据同步阶段、命令传播阶段： 在从节点执行 slaveof 命令后，复制过程便开始运作，下图大概可以看到, 从图中可以看出复制过程大致分为 6 个过程 从服务器故障后处理 当从服务器崩溃之后，重启之后进行初始化，会自动的同步主服务器的数据。在 redis的2.8版本之后，redis 采用了 **增量复制** 的方式优化了从服务器的初始化同步数据的过程。 主服务器故障后处 当主服务器崩溃之后，首先需要手动的选择一个从服务器升级为主服务器（需要手动调整所有相关的服务器），然后启动之前已经崩溃的主服务器做为从服务回到系统中。 可以看到，redis 在主服务器崩溃之后需要繁琐的人工预来恢复服务，特别是在主数据库进制了持久化之后，上述步骤不能错乱，否则会导致主数据库重启后恢复了错误数据，进而导致从数据库也同步错误数据这一灾难性后果。为此，redis 提供了哨兵机制，用于自动化的监控和维持分布式 redis 系统的良好运转。 连接建立阶段step1：保存主节点信息​ 从节点服务器内部维护了两个字段，即masterhost和masterport字段，用于存储主节点的ip和port信息。 ​ slaveof是异步命令，从节点完成主节点ip和port的保存后，向发送slaveof命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。 step2：建立socket连接​ 从节点每秒1次调用复制定时函数replicationCron()，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。 如果连接成功： ​ 从节点：为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。 ​ 主节点：接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。 step3：发送ping命令​ 从节点成为主节点的客户端之后，发送ping命令进行首次请求，目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求。 从节点发送ping命令后，可能出现3种情况： 返回ping：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。 超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。 返回ping以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。 step4：身份验证如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。 从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。 如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。 step5：发送从节点端口信息身份验证之后，从节点会向主节点发送其监听的端口号，主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。 数据同步阶段主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。 具体执行的方式是：从节点向主节点发送psync命令，开始同步。 数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为全量复制和部分复制。 在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端。原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。 命令传播阶段​ 数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。 ​ 在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。 PS： ​ 延迟与不一致：命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关。 ​ repl-disable-tcp-nodelay no：该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY；默认no，即不禁止TCP_NODELAY。当设置为yes时，TCP会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no。 【数据同步阶段】全量复制和部分复制在Redis2.8以前，从节点向主节点发送sync命令请求同步数据，此时的同步方式是全量复制； 在Redis2.8以后，从节点可以发送psync命令请求同步数据，此时根据主从节点当前状态的不同，同步方式可能是全量复制或部分复制。 全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。 部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。 全量复制Redis通过psync命令进行全量复制的过程如下： 从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行全量复制； 主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令。 主节点的bgsave执行完成后，将RDB文件发送给从节点；从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态。 主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态。 如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态。 通过全量复制的过程可以看出，全量复制是非常重型的操作： 主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的； 主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗。 从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗。 部分复制​ 由于全量复制在主节点数据量较大时效率太低，因此Redis2.8开始提供部分复制，用于处理网络中断时的数据同步。 ​ 部分复制的实现，依赖于三个重要的概念：复制偏移量，复制积压缓冲区，服务器运行ID offset 复制偏移量​ 在主从复制的Master(主节点)和Slave(从节点)双方都会各自维持一个offset，代表的是主节点向从节点传递的字节数；Master成功发送N个字节的命令后会将Master的offset加上N，Slave在接收到N个字节命令后同样会将Slave的offset增加N。Master和Slave如果状态是一致的那么它的的offset也应该是一致的。 ​ offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。 复制积压缓冲区 复制积压缓冲区是由Master(主节点)维护的一个固定长度的FIFO队列(先进先出)，默认大小1MB；当主节点开始有从节点时创建，它的作用是缓存已经传播出去的命令。当Master进行命令传播时，不仅将命令发送给所有Slave，还会将命令写入到复制积压缓冲区里面。注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。 ​ 除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。 ​ 由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。 从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制： 如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制； 如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。 runid 服务器运行ID​ 每个Redis服务器(无论主从)在启动时都会自动生成一个表明自己身份的随机ID(每次启动都不一样)，由40个随机的十六进制字符组成。在PSYNC中发送的这个ID是指之前连接的Master的ID，如果没保存这个ID，PSYNC命令会使用”PSYNC ? -1” 这种形式发送给Master，表示需要全量复制。 ​ 每个Redis节点，在启动时都会自动生成一个随机ID，由40个随机的十六进制字符组成； runid用来唯一识别一个Redis节点。通过info Server命令，可以查看节点的runid。 ​ 主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点； 主节点根据runid判断能否进行部分复制： 如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)； 如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。 PSYNC命令 Redis在2.8版本提供了PSYNC命令来带代替SYNC命令，为Redis主从复制提供了部分复制的能力。 PSYNC命令格式123PSYNC &lt;runid&gt; &lt;offset&gt;# runid:主服务器ID# offset:从服务器最后接收命令的偏移量 PSYNC执行过程中比较重要的概念有3个：runid、offset（复制偏移量）以及复制积压缓冲区。 psync命令的执行 首先从节点根据当前状态，决定如何调用psync命令： 如果从节点之前未执行过slaveof或最近执行了slaveof no one，则从节点发送命令为psync ? -1，向主节点请求全量复制； 如果从节点之前执行了slaveof，则发送命令为 psync **，其中runid为上次复制的主节点的runid，offset**为上次复制截止时从节点保存的复制偏移量。 主节点根据收到的psync命令，及当前服务器状态，决定执行全量复制还是部分复制： 如果主节点版本低于Redis2.8，则返回-ERR回复，此时从节点重新发送sync命令执行全量复制； 如果主节点版本够新，且runid与从节点发送的runid相同，且从节点发送的offset之后的数据在复制积压缓冲区中都存在，则回复+CONTINUE，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可； 如果主节点版本够新，但是runid与从节点发送的runid不同，或从节点发送的offset之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，则回复+FULLRESYNC ，表示要进行全量复制，其中runid表示主节点当前的runid，offset表示主节点当前的offset，从节点保存这两个值，以备使用。 【命令传播阶段】心跳机制在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。心跳机制对于主从复制的超时判断、数据安全等有作用。 主-&gt;从：PING每隔指定的时间，主节点会向从节点发送PING命令，这个PING命令的作用，主要是为了让从节点进行超时判断。 PING发送的频率由 repl-ping-slave-period 参数控制，单位是秒，默认值是10s。 从-&gt;主：REPLCONF ACK在命令传播阶段，从节点会向主节点发送REPLCONF ACK命令，频率是每秒1次； 命令格式为： 1REPLCONF ACK &#123;offset&#125; # offset指从节点保存的复制偏移量。 REPLCONF ACK命令的作用包括： 实时监测主从节点网络状态：该命令会被主节点用于复制超时的判断。此外，在主节点中使用info Replication，可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1。 检测命令丢失：从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会推送缺失的数据（这里也会利用复制积压缓冲区）。 注意：offset和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的。 辅助保证从节点的数量和延迟：Redis主节点中使用min-slaves-to-write和min-slaves-max-lag参数，来保证主节点在不安全的情况下不会执行写命令；所谓不安全，是指从节点数量太少，或延迟过高。例如min-slaves-to-write和min-slaves-max-lag分别是3和10，含义是如果从节点数量小于3个，或所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。而这里从节点延迟值的获取，就是通过主节点接收到REPLCONF ACK命令的时间来判断的，即前面所说的info Replication中的lag值。 开启主从复制从节点开启主从复制，有3种方式： 配置文件：在从服务器的配置文件中加入：slaveof 启动命令：redis-server启动命令后加入： –slaveof 客户端命令：Redis服务器启动后，直接通过客户端执行命令：slaveof ，则该Redis实例成为从节点。 修改配置文件方法：1. 配置从服务配置文件redis.conf1234567slaveof 192.168.1.9 6379 #添加属于某台主机的从 服务masterauth 123456 #从服务连接主服的密码（访问主服务器的密码）slave-read-only yes #从服务只读，不可在命令行写入数据5.0.4以后：replicaof &lt;masterip&gt; &lt;masterport&gt;replica-read-only yes 2. 重新启动从服务即实现主从连接121. ./bin/redis-cli # 启动redis客户端2. 输入 info replication # 查看与复制相关的状态，了解主从节点的当前状态 输入info replication 后显示的内容： 12345678910111213141516171819# Replicationrole:slave # 表示此台服务器是主是从master_host:39.107.38.62 # 主服务器ipmaster_port:6379 # 主服务器端口号master_link_status:up # 与主服务器是否连接成功 up为成功 down失败master_last_io_seconds_ago:9master_sync_in_progress:0slave_repl_offset:808slave_priority:100slave_read_only:1connected_slaves:0master_replid:ea5230cc485f9c6f372b2c89a65613fb075aff8bmaster_replid2:0000000000000000000000000000000000000000master_repl_offset:808second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:15repl_backlog_histlen:794 遇到的报错：1. Error condition on socket for SYNC: Connection refused 出现原因： ​ redis主服务器绑定了127.0.0.1，跨服务器IP的访问就会失败，只能本机才能访问，外部请求会被过滤。 1234解决方法：1. 主服务器绑定ip: bind 39.107.38.623. bind 0.0.0.02. 注释bind # 会报下面的错↓ 2. ‘-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connec 出现原因： ​ 处于保护模式，只能本地链接。没有绑定ip 没有设置验证密码。 123解决方法：1. 主服务器绑定ip： bind 39.107.38.622. 设置主服务器访问密码：requirepass 12345 3. (error) READONLY You can’t write against a read only replica.​ 出现原因： ​ 从库只可读不可写 12解决方法：1. 设置slave-read-only no # 代表不限于只读 断开主从复制​ 通过slaveof 命令建立主从复制关系以后，可以通过slaveof no one断开。 从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化。 Redis 哨兵 哨兵的介绍 ​ redis 的设计者为了让 redis 能够在主从模式下实现故障恢复的自动化，为此提供了 redis 的哨兵功能。哨兵是一个独立于数据服务器的进程，用于监控 redis 数据服务器的状态，当主从模式下最关键的主服务器出现故障时，能够被哨兵自动的察觉。同时哨兵会在剩余的从服务器中“选择”出新的主服务器，达到自动化恢复系统的目的。 哨兵的使用 ​ redis 提供了redis-setine 脚本用于部署哨兵，启动时通过指定的哨兵配置文件来对哨兵的行为进行灵活的控制。哨兵的配置文件中至少需要包含被哨兵监控的主服务器IP、端口、投票决定数目，当然可以配置诸如 down-after-milliseconds （发送ping命令的时间间隔，用于监听）等选项。 ​ sentinel monitor *”master_name” “IP” “PORT”*** ​ down-after-milliseconds *”milliseconds”* (“milliseconds”大于1000时，默认为1000) 哨兵的工作方式 ​ 哨兵启动时会与主服务器建立连接，并且间接的获得所属从服务器信息，完成哨兵的初始化。哨兵初始化完成之后，会周期性的和主从服务器、其他哨兵节点（通过消息频道的订阅）进行通信。 ​ 哨兵每10秒会向所有服务器发送一次INFO命令，获得相关 redis 服务器的当前状态以便决定是否需要故障恢复。 ​ 当一个哨兵在down-after-milliseconds规定时间内未收到主服务器的响应，则当前哨兵“主观”认为主服务器下线，同时和监视当前系统的其它哨兵进行投票决定，当超过当前哨兵配置中投票决定的数目时，则当前哨兵“客观”认为主服务器下线，哨兵集群会选举出领导哨兵来进行主从服务器集群主从状态的切换(使用Raft算法)。 redis主从复制总结 乐观复制策略 ​ redis的主从复制采用的是乐观复制的策略，在一定的时间内允许主从服务器的数据不完全一致，但是保持主从数据库数据的最终一致性(按照CAP定理,放弃了C(强一致性))。 这意味着redis主从服务器之间的数据复制操作时异步的，主服务器不等待从服务器返回复制的结果，可以立即处理新的写入命令。这一策略使得主服务器的性能在复制时不会受到太大影响，但是从服务器会出现短时间内数据不一致的情况。redis允许用户配置主库的min-slaves-to-write(代表至少N台从服务器完成复制，才允许主服务器写入)和min-slaves-max-lag(允许从服务器断开连接的时间)这两个配置项来控制分区中数据不一致的影响。 和集群的区别 redis的主从复制特性为redis带来了很高的读取可用性，但是对于海量数据的持久化存储是力不从心的。因为主从复制结构下，任意的节点都保存了100%的存储数据，所以能够存储的数据规模还是受限于单例服务器存储容量的大小。 为此，在单主多从结构的基础上，redis还提供了集群特性。通过将存储数据合理的分片存储在不同的redis节点上，通过集群水平扩容之后的redis集群拥有了极高的读写可用性和分区容错性。理解redis的主从复制原理是理解更为复杂的集群特性的基础。","categories":[{"name":"Redis","slug":"Redis","permalink":"https://cy-blogs.cn/categories/Redis/"}],"tags":[{"name":"Redis 主从复制","slug":"Redis-主从复制","permalink":"https://cy-blogs.cn/tags/Redis-主从复制/"}]},{"title":"Docker 存储","slug":"docker存储","date":"2019-12-16T03:17:54.956Z","updated":"2019-12-17T11:03:08.457Z","comments":true,"path":"docker存储/","link":"","permalink":"https://cy-blogs.cn/docker存储/","excerpt":"#Docker 存储Docek 镜像层的镜像分层结构 docker的镜像分层结构，如下所示： docker镜像中引入层layer概念，镜像的制作过程中的每一步都会生产一个新的镜像层 容器读写层的工作原理 我们刚刚在说镜像的分层特性的时候说到镜像是只读的。而事实上当我们使用镜像启动一个容器的时候，我们其实是可以在容器里随意读写的，从结果上看，似乎与镜像的只读特性相悖。 我们继续看上面的图，其实可以看到在镜像的最上层，还有一个读写层。而这个读写层，即在容器启动时为当前容器单独挂载。每一个容器在运行时，都会基于当前镜像在其最上层挂载一个读写层。而用户针对容器的所有操作都在读写层中完成。一旦容器销毁，这个读写层也随之销毁。 知识点： 容器=镜像+读写层 而我们针对这个读写层的操作，主要基于两种方式：写时复制和用时分配。","text":"#Docker 存储Docek 镜像层的镜像分层结构 docker的镜像分层结构，如下所示： docker镜像中引入层layer概念，镜像的制作过程中的每一步都会生产一个新的镜像层 容器读写层的工作原理 我们刚刚在说镜像的分层特性的时候说到镜像是只读的。而事实上当我们使用镜像启动一个容器的时候，我们其实是可以在容器里随意读写的，从结果上看，似乎与镜像的只读特性相悖。 我们继续看上面的图，其实可以看到在镜像的最上层，还有一个读写层。而这个读写层，即在容器启动时为当前容器单独挂载。每一个容器在运行时，都会基于当前镜像在其最上层挂载一个读写层。而用户针对容器的所有操作都在读写层中完成。一旦容器销毁，这个读写层也随之销毁。 知识点： 容器=镜像+读写层 而我们针对这个读写层的操作，主要基于两种方式：写时复制和用时分配。 容器 容器由最上面一个可写的容器层和若干个只读的镜像层组成，容器的数据就存在这些层中。这种分层结构最大的特点是Copy-on-Write。 新数据会直接存放在最上面的容器层 修改现有数据会从镜像层复制文件到容器中，再在容器层修改并保存，镜像层的数据不会发生改变 若多个层中有命名相同的文件，用户只能看到最上面一层的文件 分层结构使镜像和容器的创建、共享以及分发变得非常高效，而这些都要归功于 Docerk stoage driver。正是 storage driver 实现了多层数据的堆叠并为用户提供一个单一的合并之后的统一视图。 Docker 为容器提供了两种存放数据的资源： 由storage driver（存储驱动） 管理的镜像层和容器层 用来放一些无状态的数据 对于某些容器，直接将数据放在由 storage driver 维护的层中是很好的选择，比如那些无状态的应用。无状态意味着容器没有需要持久化的数据，随时可以从镜像直接创建。即存在与否依赖镜像的存在。 Data Volume。（数据卷） 用来放一些有状态的数据，例如数据库 本质上是 Docker Host （主机）文件系统中的目录或文件，能够直接被 ** mount （挂载）到容器的文件系统中**。 关于docker镜像的三问 基于镜像A创建镜像B时是否会拷贝A镜像中的所有文件：是不会的 基于镜像创建容器时是否会拷贝镜像中的所有文件至文件层：不会的 容器与镜像在结构上有什么区别：没有区别容器会比镜像多了一个 merged文件 在讲原理前，先讲下写时复制和写时分配 写时复制（CoW） 所有驱动都用到的技术——写时复制（CoW）。CoW就是copy-on-write，表示只在需要写时才去复制，这个是针对已有文件的修改场景比如基于一个image启动多个Container，如果为每个Container都去分配一个image一样的文件系统，那么将会占用大量的磁盘空间。而CoW技术可以让所有的容器共享image的文件系统，所有数据都从image中读取，只有当要对文件进行写操作时，才从image里把要写的文件复制到自己的文件系统进行修改。所以无论多少个容器共享同一个image，所作的写操作都是从image中复制到自己的文件系统中的复制本上进行，并不会修改image的源文件，且多个容器操作同一个文件，会在每个容器的文件系统里生成一个复本，每个容器修改的都是自己的复本，相互隔离的，相互不影响。使用CoW可以有效的提高磁盘的利用率。 用时分配（allocate-on-demand） 而用时分配是用在原本没有这个文件的场景，只有在要新写入一个文件时才分配空间，这样可以提高存储资源的利用率。比如启动一个容器，并不会为这个容器预分配一些磁盘空间，而是当有新文件写入时，才按需分配新空间。 Docker存储驱动的作用 将这些分层的镜像文件堆叠起来，并且提供统一的视图.使container的文件系统看上去和我们普通的文件系统没什么区别。当创建一个新的容器的时候,实际上是在镜像的分层上新添加了一层container layer（容器层）.之后所有对容器产生的修改,实际都只影响这一层。 注意 容器层：读写层(可写层)镜像层：只读层 Docker 支持多种 storage driver，有 AUFS 、Device Mapper 、Btrfs 、OverlayFS 、VFS 和ZFS。它们都能实现分层的架构，同时又有各自的特性。对于Docker 用户来说，具体选择使用哪个 storage driver 是一个难题，因为： ​ 没有哪个driver 能够适应所有的场景。 ​ driver 本身在快速发展和迭代。 优先使用 Linux 发行版默认的 storage driver。Docker 安装时会根据当前系统的配置选择默认的 driver。默认 driver 具有最好的稳定性，因为默认 driver 在发行版上经过了严格的测试。 运行docker info可以查看可查看当前系统使用的Storage driver。 123456789101112131415161718&gt; &gt; [root@izbp1dg6m4eebtcm77n0smz ~]# docker info&gt; &gt; Client:&gt; &gt; Debug Mode: false&gt; &gt; &gt; &gt; Server:&gt; &gt; Containers: 6&gt; &gt; Running: 4&gt; &gt; Paused: 0&gt; &gt; Stopped: 2&gt; &gt; Images: 4&gt; &gt; Server Version: 19.03.5&gt; &gt; Storage Driver: overlay2&gt; &gt; Backing Filesystem: extfs&gt; &gt; Supports d_type: true&gt; &gt; Native Overlay Diff: false&gt; &gt; Logging Driver: json-file&gt; &gt; Cgroup Driver: cgroupfs&gt; &gt; Ubuntu 用的 AUFS，底层文件系统是 extfs，各层数据存放在 /var/lib/docker/aufs。centos默认的driver用的是overlay2，底层的文件系统是xfs,各层数据存放在/var/lib/docker 而写时分配是用在原本没有这个文件的场景，只有在要新写入一个文件时才分配空间，这样可以提高存储资源的利用率。 比如启动一个容器，并不是为这个容器预分配一些磁盘空间，而是当有新文件写入时，才按需分配新空间。 docker提供了多种的存储驱动来实现不同的方式存储镜像 Docker五种存储驱动原理及应用场景和性能测试对比 Docker 最开始采用AUFS作为文件系统，也得益于AUFS分层的概念，实现了多个Container可以共享同一个image。但由于AUFS 为并入 Linux内核，且只支持 Ubuntu，考虑到兼容的问题，在 Docker 0.7 版本中引入了存储驱动，就如Docker官网上说的，没有单一的驱动适应所有的应用场景，要根据不同的场景选择合适的存储驱动，才能有效的提高Docker 的性能。如何选择适合的存储驱动，要先了解存储驱动原理才能更好的判断。 接下来我们说说这些分层的镜像是如何在磁盘中存储的。 docker 提供了多种存储驱动来实现不同的方式存储镜像 下列出了 Docker 中支持的存储驱动程序： 技术 存储驱动成名称 OverlayFS overlay 或 overlay2 AUFS aufs Btrfs btrfs Device Mapper devicemapper VFS vfs ZFS zfs AUFS AUFS（AnotherUnionFS）是一种 Union FS ，是文件级的存储驱动。AUFS 是一个能透明覆盖一个或多个县有文件系统的层状文件系统，把多层合并成文件系统的单层表示。简单来说就是支持将不同目录挂载到同一个虚拟文件系统下的文件系统。这种文件可以一层一层地叠加修改文件。无论低下有多少层都是只读的，只有最上层的文件系统是可写的。当需要修改文件时，AUFS创建该文件的一个副本，使用CoW将文件从只读层复制到可写层进行修改，结果保存在可写层。在Docker中，低下的只读层就是image，可写层就是Container。结构如下图所示： 历史：aufs驱动老早就在Docker中存在了！其实，他在使用graphdriver这个名字之前久存在了。如果你查看项目在那（即首次使用graphdriver名称）提交之前的历史，之前项目中当时只有一个aufs的实现。下边devicemapper部分会讲到更多关于graphdriver这个名称诞生的历史。 实现：Aufs最初代表的意思“另一个联合文件系统（another union filesystem）”，试图对当时已经存在的UnionFS实现进行重写。正如你期望的那样，它是一个传统意义的上层覆盖，通过利用aufs称作为“分支（branch）”的特性，让堆叠的目录合并成一个堆叠内容单一挂载点视图。此驱动会将父级信息组合一个有序列表，并把它作为挂载参数，然后把重活移交给aufs来把这些分层组装成一个联合视图。更多的细节信息可以在aufs的帮助文档上看到。 优点：这可能是历史最久且测试最完善的graphdriver后端了。它拥有不错的性能，也比较稳定，适用于广泛的场景。尽管它只在Ubuntu或者Debian的内核上才可以启用（下边有说明），但是这两个发行版和Docker一起使用的场景已经非常多，这让它在广阔的环境中得到了验证。同时，通过让不同的容器从同一个分层里面加载相同的库（因为他们在磁盘上是相同的inode）达到了共享内存页的效果。 缺点：Aufs从来没有被上游Linux内核社区接受。多年来Ubuntu和Debian都需要往内核集成一个历史久远的补丁包，且原作者已经放弃了让它被内核采纳的努力。可能与IPV4和IPv6的辩论有些类似，人们担心某一天内核更新后会出现难以整合aufs的补丁的情况，从而导致aufs没得玩。但是就如IPv6，替换aufs势在必行的决心讲了一年又一年。除此之外，它面临着很多其他比较棘手的问题。其中一个最麻烦的、也是比较有历史的问题（尽管某种程度上这是一个安全的特性），是关于在高层更改向上拷贝的文件的权限的，这个问题困扰了不少用户。最终在2015年早期的时候通过编号为#11799的PR使用aufs的dirperm1特性修复了。自然，这需要内核中有具有dirperm1能力aufs，然而这在今天任何较新版本的Ubuntu或者Debian上都已经不成问题了。 总结：如果你在使用Ubtuntu或者Debian，那默认的graphdriver就是aufs，它能满足你绝大多数需求。有人期望有一天它能被overlay的实现取代，但是考虑到overlay文件系统的诸多问题，以及在上游内核中的成熟程度等挑战，这尚未实现。最后，aufs中没有配额的支持。 Overlay Overlay 是Linux内核3.18后支持的，也是一种Union FS，和AUFS的多层不同的是Overlay只有两层：一个upper文件系统和一个lower文件系统，分别代表Docekr的镜像层和容器层。当需要修改一个文件时，使用CoW将文件从只读的lower复制到可写的upper进行修改，结果也保存在upper层。在Docekr中，底下的只读层就是image，可写层就是Container。目前最新的OverlayFS为Overlay2。结构图如下所示： 历史：2014年8月，Red Hat的 Alex Larsson在编号为453552c8384929d8ae04dcf1c6954435c0111da0的代码提交中添加了针对OverlayFS（最初的上游内核的名称）的graphdriver。 实现：Overlay是一个联合文件系统，它的概念较之aufs的分支模型更为简单。Overlay通过三个概念来实现它的文件系统：一个“下层目录（lower-dir）”，一个“上层目录（upper-dir）”，和一个做为文件系统合并视图的“合并（merged）”目录。受限于只有一个“下层目录”，需要额外的工作来让“下层目录”递归嵌套（下层目录自己又是另外一个overlay的联合），或者按照Docker的实现，将所有位于下层的内容都硬链接到“下层目录”中。正是这种可能潜在的inode爆炸式增长（因为有大量的分层和硬连接）阻碍了很多人采用Overlay。Overlay2通过利用更高内核（4.0以及以上的版本）中提供了的更优雅处理多个位于下层分层的机制解决了这个问题。 优点：Overlay作为一个合并进主线Linux内核的一个有完整支持的联合文件系统有望成为人们的焦点。与aufs类似，通过使用磁盘上相同的共享库，它也能让分散的容器实现内存共享。Overlay同时有很多的上游Linux内核基于现代的应用场景，如Docker，被持续开发（参看overlay2）。 缺点：硬链接的实现方式已经引发了 inode耗尽的问题，这阻碍了它的大规模采用。inode耗尽并不是唯一的问题，还有其他一些与用户命名空间、SELinux支持有关的问题，且整体的成熟状况不足也阻碍着overlay直接取代aufs成为Docker默认的graphdriver。随着很多问题的解决，特别是在最新的内核发新版中，overlay的可用度越来越高了。如今出现的Overlay2修复了inode耗尽的问题，应该是从Docker 1.12版本之后的焦点，成为overlay驱动的后续开发对象。出于向后兼容的原因，overlay驱动将会继续留在Docker引擎中继续支持现有的用户。 总结：考虑到aufs没有足够多的发行版的支持，能有一个上游集成的联合文件系统且拥有Linux内核文件系统社区的支持，overlay驱动的加入是一个重大进步。Overlay在过去的18-24个月已经成熟了很多，并且随着overlay2的出现，它之前一些麻烦的问题已经解决了。希望overlay（或者更具可能性的overlay2）会成为未来默认的graphdriver。为了overlay最好的体验，上游内核社区在4.4.x的内核系列里面修复了很多overlay实现中存在的问题；选择该系列中更新的版本可以获得overlay更好的性能和稳定性。 Overlay2 历史：Derek McGowan在编号为#22126的PR中添加了overlay2的graphdriver，在2016年6月被合并进Docker 1.12版本，正如该PR的标题注明的，要取代之前overlay的主要原因是它能“支持多个下层目录”，能解决原先驱动中inode耗尽的问题。 实现：在上面的overlay部分已经讲述了Linux内核中的Overlay的框架。上面链接的PR中改进了原有的设计，基于Linux内核4.0和以后版本中overlay的特性，可以允许有多个下层的目录。 优点：overlay2解决了一些因为最初驱动的设计而引发的inode耗尽和一些其他问题。Overlay2继续保留overlay已有的优点，包括在同一个引擎的多个容器间从同一个分层中加载内库从而达到内存共享。 缺点：现在可能唯一能挑出overlay2的问题是代码库还比较年轻。很多早期的问题已经在早期测试过程中发现并被及时解决了。但是Docker 1.12是第一个提供overlay2的发行版本，随着使用量的增长，相信可能还会发现其他问题。 总结：将Linux内核中的一个现代的、广受支持的联合文件系统，和一个和Docker中一个性能优秀的graphdriver结合起来，这应该是Docker引擎未来打造默认的graphdriver最好的道路，只有这样才能获得各种Linux发行版广泛的支持。 Device mapper Device mapper 是Linux 内核 2.6.9 后支持的，提供的一种从逻辑设备到物理设备的映射框架机制，在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略。前面讲的 AUFS 和 OverlayFS 都是文件级存储，而 Device mapper 是块级存储，所有的操作都是直接对块进行操作，而不是文件。Device mapper 驱动会先在块设备上创建一个资源池，然后在资源池上创建一个带有文件系统的基本设备，所有镜像都是这个基本设备的快照，而容器则是镜像的快照。所以在容器里看到文件系统是资源池上基本设备的文件系统的快照，并不有为容器分配空间。当要写入一个新文件时，在容器的镜像内为其分配新的块并写入数据，这个用时分配。当要修改已有文件时，再使用 CoW 为容器快照分配块空间，将要修改的数据复制在容器快照中新的块里在进行修改。Device mapper 驱动默认会创建一个 100 G 的文件包含镜像和容器。每个容器被限制在 10G 大小的卷内，可以自己设置调整。结构如下图所示： 历史：Devicemapper很早就以Ｃ代码的包装器面貌存在了，用来和libdevmapper进行交互； 是2013的９月Alex Larsson在编号为 739af0a17f6a5a9956bbc9fd1e81e4d40bff8167的代码提交中添加的。几个月后的重构了才诞生了我们现在所知道的“graphdriver”这个词；Solomon Hykes在2013年10月份早期代码合并的注释中说：将devmapper和aufs整合进通用的“graphdriver”框架。 实现：devicemapper这个graphdriver利用了Linux中devicemapper代码中众多特性之一，“轻配置（thin provisioning）”，或者简称为“thinp”。（译注：根据Wikipedia，“thin provisioning是利用虚拟化技术，让人觉得有比实际可用更多的物理资源。如果系统的资源足够，能同时满足所有的虚拟化的资源，那就不能叫做thin-provisioned。”） 这与之前提到的联合文件系统不同，因为devicemapper是基于块设备的。这些“轻配置（thin-provisioned）”的块设备带来的是如联合文件系统所提供的一样轻量的行为，但是最重要的一点是，他们不是基于文件的（而是基于块设备的）。正如你能推测的，这让计算分层之间的差别变得不再容易，也丧失了通过在容器间使用同样的库片段而共享内存的能力。 优点：Devicemapper在过去的年间也被一些人感到不屑，但是它提供的一个非常重要的能力让红帽系（Fedora,RHEL，Project Atomic）也有了一个graphdriver。因为它是基于块设备而不是基于文件的，它有一些内置的能力如配额支持，而这在其他的实现中是不容易达到的。 缺点：使用devicemapper没有办法达到开箱立即唾手可得很好的性能。你必须遵循安装和配置指示才能得到性能还可以的配置。并且最重要的是，在任何需要用Docke引擎来做点正事的地方，都不要使用“虚拟设备（loopback）”模式（对于运行有devicemapper且负载高的系统，如延迟删除（ deferred removal）这样的特性绝对有必要的，这能减少引擎看起来好似夯住了一样的悲剧。）。它的一些特性依赖libdevmaper特定的版本，并且需要比较高级的技能来验证系统上所有的设置。同时，如果Docker Engine的二进制是静态编译的话，devicemapper会完全无法工作，因为它需要udev sync的支持，而这不能被静态编译进引擎中。 总结：对于红帽类发行版本来说，devicemapper已经成为“可以直接用”的选择，并且在过去几年间里得到了红帽团队的大力支持和改进。它质量上有优点也有缺点，如果安装/配置过程中没有特别格外注意的话，可能导致和其他选项比较起来性能低下、质量不高。鉴于overlay和overlay2受到了Fedora和RHEL最新的内核的支持，并且拥有SELinux的支持，除非在Red Hat场景中有某种必须使用devicemapper的需求，我想随着用户的成熟他们会转向overlay的怀抱。 Btrfs Btrfs 被称为下一代写时复制文件系统，并入Linux内核，也是文件级存储，但可以向 Device mapper 一直操作底层设备。 Btrfs 把文件系统的一部分配置为一个完整的子文件系统，称为 subvolume。那么采用 subvolume ，一个大的文件系统可以被划分为很多个子文件系统，这些子文件系统共享底层的设备空间，在需要磁盘空间使用时便从底层设备中分配，类似应用程序调用 malloc（）分配内存一样。为了灵活利用设备空间， Btrfs 将磁盘空间划分为多个 chunk。每个 chunk 可以使用不同的磁盘空间分配策略。比如某些 chunk 只存放 metadata ，某些chunk 只存放数据。这种模型有很多优点，比如 Btrfs 支持动态添加设备。用户在系统中添加新的磁盘之后，可以使用 Btrfs 的命令将该设备添加到文件系统中。Btrfs 把一个大的文件系统当成一个资源池，配置成多个完整的子文件系统，还可以往资源池里加新的子文件系统，而基础镜像则是子文件系统的快照，每个子镜像和容器都有自己的快照，这些快照都是 subvolume 的快照。 当写入一个新文件时，为在容器的快照里为其分配一个新的数据块，文件写在这个空间里，这个叫做分配。而当要修改已有文件时，使用 CoW 复制分配一个新的原始数据和快照，在这个新分配的空间变更数据，变结束再跟新相关的数据结构指向新子文件系统和快照，原来的原始数据和快照没有指针指向，被覆盖。 历史：2013年12月较晚的时候，Red Hat公司的Alex Larsson在编号为e51af36a85126aca6bf6da5291eaf960fd82aa56的提交中，让使用btrfs作为管理/var/lib/docker的文件系统成为可能。 实现：Btrfs的原生特性中，有两个是“子卷（subvolumes）”和“快照（snapshots）”。（译注：根据Wikipedia，“子卷在btrfs中不是一个块设备，也不应该被当做是一个块设备。相反，子卷可以被想象成POSIX文件的命名空间。这个命名空间可以通过顶层的子卷来访问到，也可以独立地被挂载。快照在Btrfs中实际上是一个子卷，通过使用Btrfs的写时复制来和其他的子卷共享数据，对快照的更改不会影响原先的子卷。” ） graphdriver实现中主要结合了这两个能力，从而提供了堆叠和类似写时复制的特性。当然，graphdriver的根（默认情况下是：/var/lib/docker）需要是一个被btrfs文件系统格式化的磁盘。 优点：Btrfs几年前发布的时候（2007-2009时代），它被视作一个未来的Linux文件系统并受到了大量的关注。如今在上游Linux内核中，该文件系统已经比较健壮，并受到良好的支持，是众多可选的文件系统之一。 缺点：但是Btrfs并没有成为Linux发行版的主流选择，所以你不大可能已经有一个btrfs格式化的磁盘。因为这种在Linux发行版中采用不足的原因，它并没有受到类似其他graphdriver一样的关注和采用。 总结：如果你正在使用btrfs，那很显然的这个graphdriver应该迎合了你的需求。在过去几年有过很多Bug，并且有一段时间缺乏对SELinux的支持，但是这已经被修复了。同时，对btrfs配额的支持也直接加进了docker守护进程中，这是Zhu Guihua在编号为#19651的PR中添加的，这个特性包含在了Docker 1.12版本中。 ZFS ZFS 文件系统是一个革命性的全新的文件系统，它从根本上改变了文件系统的管理方式， ZFS 完全抛弃了 “ 卷管理 ” ，不再创建虚拟的卷，而是把所有设备集中到一个存储池中进行管理，用 “ 存储池 ” 的概念来管理物理存储空间。过去，文件系统都是构建在物理设备之上的，为了管理这些物理设备，并为数据提供冗余，“ 卷管理 ” 的概念提供了一个单设备的映射。而 ZFS 创建在虚拟的，被称为 “ zpools ” 的存储池之上。每个存储池由若干虚拟设备（ virtual devices ，vdevs ）组成。这些虚拟设备可以是原始磁盘，也节能是一个RAID1 镜像设备，或是非标准 RAID 等级的多磁盘组。 于是 zpool 上的文件系统可以使用这些虚拟设备的总存储容量。 下面看一下Docker 里ZFS的使用。首先从 zpool里分配一个ZFS 文件系统给镜像的基础层，而其他镜像层则是这个 ZFS 文件系统快照的克隆，快照是只读的，而克隆是可写的，当容器启动时则在镜像的顶层生成一个可写层。如下图所示： d当要写一个新文件时，使用按需分配，一个新的数据块从 zpool 里生成新的数据写入这个块，而这个新空间存于容器（ ZFS 的克隆 ）里。 当要修改一个已存在的文件时，使用写时复制，分配一个新空间并把原始数据复制到新空间完成修改。 历史：ZFS的graphdriver是由Arthur Gautier和Jörg Thalheim一起在#9411的PR中实现的，在2014年的5月被合并进了Docker引擎里面，并且从Docker 1.7版本开始用户可以使用。该实现依赖Go的一个三方包go-zfs进行相关zfs命令的交互。 实现：与btrfs和devicemapper类似，要使用zfs驱动必需要有一个ZFS格式化的块设备挂载到graphdriver路径（默认是/var/lib/docker）。同时也需要安装好zfs工具（在绝大多数的发行版上是一个名为zfs-utils的包）供zfs Go库调用来执行相关操作。ZFS有能力创建快照（与btrfs类似），然后以快照的克隆作为分享层的途径（在ZFS的实现中成了一个快照）。因为ZFS不是一个基于文件的实现，aufs和overlay中所拥有的内存共享能力在ZFS是没有的。 优点：ZFS正在受到越来越多的欢迎，在Ubuntu 16.04中，在Ubuntu的LXC/LXD中已经被使用。最初由Sun创建，ZFS已经存在很长的时间了，并且在Solaris和很多BSD的衍生版中使用，并且它的Linux移植版实现看起来也比较稳定，对于容器文件系统的场景也有足够合理性能。ZFSgraphdriver也很及时的在Dockr 1.12中通过PR #21946添加了配额的支持，这让它在配额支持方面和btrfs、devicemapper站在了同一起跑线上。 缺点：除了没有基于文件（inode）的共享达到内库共享之外，很难说ZFS和其它同样基于块设备的实现相比有什么缺点。通过比较，ZFS看起来欢迎程度越来越高。对于那些完全支持或者正在使用ZFS的Linux发行版或者UNIX衍生版而言，zfs graphdriver可以是一个非常好的选择。 总结：ZFS的支持为Docker引擎中稳定的graphdriver加了分。对于那些ZFS的使用者，或者那些ZFS扮演了更要角色的发行版来说，Docker能直接支持该文件系统，对这些社区来说是一个好消息。对于那些默认文件系统是ext4和xfs的发行版，默认采用overlay驱动的用户来说，时间会告诉我们他们是否会对zfs驱动产生更多的兴趣。 存储驱动的对比及适应场景 存储驱动 特点 优点 缺点 适用场景 AUFS 联合文件系统、未并入内核主线、文件级存储 作为docker的第一个存储驱动，已经有很长的历史，比较稳定，且在大量的生产中实践过，有较强的社区支持 有多层，在做写时复制操作时，如果文件比较大且存在比较低的层，可能会慢一些 大并发但少IO的场景 overlayFS 联合文件系统、并入内核主线、文件级存储 只有两层 不管修改的内容大小都会复制整个文件，对大文件进行修改显示要比小文件消耗更多的时间 大并发但少IO的场景 Devicemapper 并入内核主线、块级存储 块级无论是大文件还是小文件都只复制需要修改的块，并不是整个文件 不支持共享存储，当有多个容器读同一个文件时，需要生成多个复本，在很多容器启停的情况下可能会导致磁盘溢出 适合io密集的场景 Btrfs 并入linux内核、文件级存储 可以像devicemapper一样直接操作底层设备，支持动态添加设备 不支持共享存储，当有多个容器读同一个文件时，需要生成多个复本 不适合在高密度容器的paas平台上使用 ZFS 把所有设备集中到一个存储池中来进行管理 支持多个容器共享一个缓存块，适合内存大的环境 COW使用碎片化问题更加严重，文件在硬盘上的物理地址会变的不再连续，顺序读会变的性能比较差 适合paas和高密度的场景 AUFS VS Overlay AUFS和Overlay都是联合文件系统，但AUFS有多层，而Overlay只有两层，所以在做写时复制操作时，如果文件比较大且存在比较低的层，则AUSF可能会慢一些。而且Overlay并入了linux kernel mainline，AUFS没有，所以可能会比AUFS快。但Overlay还太年轻，要谨慎在生产使用。而AUFS做为docker的第一个存储驱动，已经有很长的历史，比较的稳定，且在大量的生产中实践过，有较强的社区支持。目前开源的DC/OS指定使用Overlay。 Overlay VS Device mapper Overlay是文件级存储，Device mapper是块级存储，当文件特别大而修改的内容很小，Overlay不管修改的内容大小都会复制整个文件，对大文件进行修改显示要比小文件要消耗更多的时间，而块级无论是大文件还是小文件都只复制需要修改的块，并不是整个文件，在这种场景下，显然device mapper要快一些。因为块级的是直接访问逻辑盘，适合IO密集的场景。而对于程序内部复杂，大并发但少IO的场景，Overlay的性能相对要强一些。 Device mapper VS Btrfs Driver VS ZFS Device mapper和Btrfs都是直接对块操作，都不支持共享存储，表示当有多个容器读同一个文件时，需要生活多个复本，所以这种存储驱动不适合在高密度容器的PaaS平台上使用。而且在很多容器启停的情况下可能会导致磁盘溢出，造成主机不能工作。Device mapper不建议在生产使用。Btrfs在docker build可以很高效。ZFS最初是为拥有大量内存的Salaris服务器设计的，所在在使用时对内存会有影响，适合内存大的环境。ZFS的COW使碎片化问题更加严重，对于顺序写生成的大文件，如果以后随机的对其中的一部分进行了更改，那么这个文件在硬盘上的物理地址就变得不再连续，未来的顺序读会变得性能比较差。ZFS支持多个容器共享一个缓存块，适合PaaS和高密度的用户场景。 IO性能对比 测试工具：IOzone（是一个文件系统的benchmark工具，可以测试不同的操作系统中文件系统的读写性能）测试场景：从4K到1G文件的顺序和随机IO性能测试方法：基于不同的存储驱动启动容器，在容器内安装IOzone，执行命令： 1./iozone -a -n 4k -g 1g -i 0 -i 1 -i 2 -f /root/test.rar -Rb ./iozone.xls 测试项的定义和解释 Write：测试向一个新文件写入的性能。Re-write：测试向一个已存在的文件写入的性能。Read：测试读一个已存在的文件的性能。Re-Read：测试读一个最近读过的文件的性能。Random Read：测试读一个文件中的随机偏移量的性能。Random Write：测试写一个文件中的随机偏移量的性能。 测试数据对比 Write： Re-write: Read： Re-Read： Random Read： Random Write： 通过以上的性能数据可以看到： AUFS在读的方面性能相比Overlay要差一些，但在写的方面性能比Overlay要好。 device mapper在512M以上文件的读写性能都非常的差，但在512M以下的文件读写性能都比较好。 btrfs在512M以上的文件读写性能都非常好，但在512M以下的文件读写性能相比其他的存储驱动都比较差。 ZFS整体的读写性能相比其他的存储驱动都要差一些。 简单的测试了一些数据，对测试出来的数据原理还需要进一步的解析。 Docker 提供了可插拔的存储驱动程序架构。它使我们能够灵活地 插入 Docker中的存储驱动程序。他完全基于Linux文件系统 。 要实现这一功能，我们必须 在docker 守护进程的开始时就设置驱动程序。 Docker 守护程序只能运行一个存储驱动程序，并且该守护程序实例创建的所有容器使用相同的存储驱动程序。 当前存储驱动 查看守护程序使用哪个存储驱动程序，可以使用一下命令。 1$ docker info 可以看到上面的命令显示了守护进程使用的存储驱动程序。备份文件系统 extfs 。 extfs 表示覆盖存储驱动程序在文件系统的顶部运行。 后备文件系统实质用于在 /var/lib/docker 录下创建 Docker 主机的本地存储区域的文件系统。 下表包含必须与主机备份文件系统相匹配的存储驱动程序。 存储驱动 常用 已禁用 overlay ext4xfs btrfs aufs overlayzfs eCryptfs overlay2 ext4xfs btrfs aufs overlayzfs eCryptfs aufs ext4xfs btrfs aufs eCryptfs aufs btrfsonly N/A devicemapper Direct-lvm N/A vfs debugging only N/A N/A 注意 ：- “已禁用/Disabled on” 表示某些存储驱动程序无法在某些后台文件系统上运行 设置存储驱动程序 可以通过 dockersd命令按指定名称来设置存储驱动程序。以下命令启动守护程序并设置新的驱动程序。 1$ dockerd --storage-driver=devicemapper 稍后，可以通过 docker info 命令检查 docker 服务驱动程序 对于某些容器，直接将数据放在由 storage driver 维护的层中是很好的选择，比如那些无状态的应用。无状态意味着容器没有需要持久化的数据，随时可以从镜像直接创建。即存在与否依赖镜像的存在。 1234# 如一些工具箱，启动是为了执行命令，不需要保存数据供以后使用，使用完直接退出，容器删除时存在容器层的工作数据也一起删除，这没问题，下次启动新容器即可。# 但对于另一类应用这种方式就不合适了，它们有持久化数据的需求，容器启动时需要加载已有的数据，容器销毁时希望保留产生的新数据，也就是说，这类容器是有状态的，例如数据库。这就要用到docker 的另一个存储机制：data volume Data Volume（数据卷） 对于有些容器，我们可能会持久化数据的需求，也就是容器启动时需要加载已有的数据，容器销毁时希望保留产生的数据，也就是说这类容器是有状态的。 这就需要用到 Docker 的 Data Volume 存储机制。Data Volume本质上是 Docker host文件系统中的目录或文件，能够直接被 mount 到容器的文件系统。 在具体的使用上，Docekr 提供了两种类型的Volume：bind mount 和docker managed volume。 附：bind mount 与 docker managed volume 的区别 这两种 data volume 实际上都是使用 host 文件系统的中的某个路径作为 mount 源。它们不同之处在于： 不同点 bind mount docker managed volume volume 位置 可任意指定 /var/lib/docker/volumes/… 对已有mount point 影响 隐藏并替换为 volume 原有数据复制到 volume 是否支持单个文件 支持 不支持，只能是目录 权限控制 可设置为只读，默认为读写权限 无控制，均为读写权限 移植性 移植性弱，与 host path 绑定 移植性强，无需指定 host 目录 什么是数据卷 Data Volume 数据卷 ：是可以存放在一个或多个容器内的 特定的目录，提供独立于容器之外的持久化存储；是经过特殊设计的目录，可以绕过联合文件系统（UFS），为一个或多个容器提供访问； 12345678910Docker Contrainer面向对象中的对象对象一旦被销毁，数据就不存在了容器一旦被销毁，则容器内的数据将一并被删除服务器中的图案也会一并销毁容器中的数据不是持久化状态的 不使用 volume的时候，对容器进行的改动是不会被保存的，使用 volume可以实现持久化存储；比如运行一个数据的操作，数据库的一个容器，数据库的数据应该被持久化存储的，volume就可以实现这个，并且 volume可以提供容器与容器之间的共享数据； Docker 的理念之一： 就是将其应用于其运行的环境打包，因此，通过Docker 容器的生存周期，都是与容器中运行的程序相一致的，而我们对数据的要求通常是持久化的；另一方面，docker容器之间也需要有一个 共享数据的渠道 ，而这些需求就催生出了docker数据卷的产生； 数据卷的设计的目的： 在于 数据的永久化 ，它完全独立于容器的生存周期，因此，Docekr不会在容器删除时删除其挂载的数据卷，也不会存在类似垃圾收集机制，对容器引用的数据卷进行处理了； 数据卷特点： Docker数据卷是独立于Docker的存在，它存在于Docker host（宿主机）中，因此，它与容器的生存周期是分离的； Docker数据卷本质上是存在于Docker宿主机的本地文件系统中； Docker 数据卷可以是目录也可以是文件；（不是块设备） Docker 容器可以利用数据卷的技术与容器宿主机进行数据共享； 同一个目录或者文件，可以支持多个容器进行访问，这样其实实现了容器的数据共享和交换； 数据卷是在容器启动是进行初始化的，那么如果容器使用的镜像包含了的数据也会在容器启动时拷贝到容器的数据卷中； 数据卷可以在容器之间共享和重用； 数据卷的修改会立马生效；容器可以对数据卷里的内容直接修改；容器对数据卷进行的修改是及时的，所有的修改都会直接体现在数据卷中； 数据卷的更新不会影响镜像；因为文件不会写到镜像中去，数据卷是独立于联合文件系统的，而镜像本身基于联合文件系统，so镜像与数据卷之间不会有相互影响的情况； 数据卷会一直存在，即使挂载数据卷的容器已经删除因为数据均本质上是宿主机上的一个目录，同时为了提供数据的永久化，它的生存周期与容器是完全隔离的； Docker 容器中的数据操作经过了UFS 的，UFS 会在宿主机中写一次文件，这个文件在宿主机上是临时的，这时候就出现了重复写的情况，会影响系统的性能；此外，删除容器的时候，就没有人能够通过UFS 在访问到宿主机中的文件了； 容器卷可以绕过 UFS 直接操作主机上的文件，当容器删除的时候，宿主机上的文件还在，就在指定的目录下，在重新创建容器的时候们可以指定容器继续读取宿主机上的文件； 创建一个数据卷 包含数据卷挂载的容器在容器关闭时，如果修改了宿主机下的数据卷会，容器里面会产生改变吗？ bind mount 数据卷 使用docker run –name nginx-test -p 8080:80 -d -v ~/myvolume:/usr/share/nginx/html nginx 创建一个bind mount 数据卷 是宿主机的存储位置必须是绝对路径。目录不存在则会生成 12345678# 以下两种情况创建的数据卷如果浏览器访问宿主机的ip:8080 会出现报错，因为这是创建的时候清空了容器数据卷下index.html# 创建的宿主机和容器的数据卷都有读写的权限$ docker run --name nginx-test -p 8080:80 -d -v ~/myvolume:/usr/share/nginx/html nginx# 这样执行后的文件宿主机的~/myvolume 文件如果不存在直接创建，容器的文件路径不存在也会直接创建，如果/usr/share/nginx/html文件存在里面内容会清空# 给容器里面的数据卷加权限$ docker run --name nginx-test -p 8080:80 -d -v ~/myvolume:/usr/share/nginx/html:ro nginx# 如果执行这个 :/usr/share/nginx/html:ro这个地方加的是 :ro 是设置的只有读取权限 123456789101112131415# 运行dockers inspect 容器名称或容器（ID） 是将容器的配置文件已json字符串的形式返回\"Binds\": [ \"/root/myvolume:/usr/share/nginx/html\" # 宿主机数据卷位置: 容器的目录位置 ],\"Mounts\": [ &#123; \"Type\": \"bind\", \"Source\": \"/root/myvolume\", # 是宿主机数据卷的存储位置 \"Destination\": \"/usr/share/nginx/html\", \"Mode\": \"\", \"RW\": true, # 权限 true是可以读写 fales 是只读 \"Propagation\": \"rprivate\" &#125; ], 123# 在宿主机的数据卷下执行:vim index.html # 在文件里写入hello ， 你在访问的时候就可以在页面上看到你写入得数据了 执行 docker exec -it 容器名称（容器ID） bahs进入到容器里面，每个容器都会包含一个迷你版的linux系统 执行 cd /usr/share/nginx/html 执行 ls 你会看到容器目录里会有我们刚才创建好的文件 index.html 执行 cat index.html 可以看到里面我们加入的数据 如果是挂载数据卷的时候加 :ro 容器内修改文件，发现会提示该文件是只读的 docker managed volume 数据卷 创建出来的两个都是有读写权限的 使用docker run –name nginx-test2 -p 8080:80 -d -v /usr/share/nginx/html nginx 创建一个docker managed volume 数据卷 这种命令创建是不用指定宿主机数据卷存储位置的默认在 /var/lib/docker/volumes/ 下的文件名是经过sha256 摘要过的 查看宿主机创建出来的数据卷 123456$ cd /var/lib/docker/volumes/$ ls 8d668720aaeccee44b5fb554571912a6a257eb3a28cecf334203805a0c9b6fd3 #这是自己创建出来的数据卷# 执行 cd _data 进入这这个文件夹里面$ ls50x.html index.html # 这两个文件是把容器里文件给拷贝了出来 可以在宿主机或者容器里面都可以对文件进行读写操作 挂载多个目录实现数据卷的 就是执行多个 -v 就可以 容器间的数据共享 数据卷容器挂载了一个本地文件系统的目录，其它容器通过挂载这个数据卷容器来实现容器间的数据的共享； 容器间挂载 创建数据卷，只要在docker run命令后面跟上-v参数即可创建一个数据卷，当然也可以跟多个-v参数来创建多个数据卷，当创建好带有数据卷的容器后，就可以在其他容器中通过--volumes-from参数来挂载该数据卷了，而不管该容器是否运行。 1docker run -tid --rm --volumes-from nginx-test --name nginx-test3 nginx -i : 以交互模式运行容器，通常与 -t 同时使用； -t : 为容器重新分配一个伪输入终端，通常与 -i 同时使用； -d : 后台运行容器，并返回容器ID； 再创建一个nginx-test4，挂载nginx-test3中从nginx-test挂载的数据卷，当然也可以直接挂载初识的nginx-test容器的数据卷 12* 即使删除了初始的数据卷容器 nginx-test，或者是删除了其他容器，但只要是有容器在使用该数据卷，那么它里面的数据就不会丢失* 命令中的rm表示当容器退出即停止的时候，会自动删除该容器 备份数据卷 创建一个容器container1，包含两个数据卷/usr/share/nginx/html1和/usr/share/nginx/html2（这两个目录是在容器里的数据卷路径） 12345678910$ docker run -tid -v /usr/share/nginx/html1 -v /usr/share/nginx/html2 --name container1 -p 8080:80 nginx# 创建容器container1$ docker exec -it container1 bash #进入创建好的容器里面$ cd html1/ # 进入到html1数据卷中 $ echo html1 &gt;&gt; 1.text # 向 1.text 文件中追加数据，文件不存在则会创建文件$ cd html2/ # 进入到html2数据卷中$ echo html2 &gt;&gt; 2.text # 向 2.text 文件中追加数据，文件不存在则会创建文件 接下来进行数据卷的备份操作 使用 - -volumes-from 来创建一个加载 container1 容器卷的容器，并从宿主机挂载当前所在目录到容器的 /backup 目录，容器内会 tar 压缩 /var/colume1 目录下的文件到 /backup/backup1.tar，因为宿主机当前目录已经映射到 /backup 目录了，因此会在宿主机当前目录也存在该压缩包。备份完毕后 -rm 自动删除该创建的容器。 备份container1容器中的/usr/share/nginx/html1数据卷数据 123456789101112# 备份container1容器中的/usr/share/nginx/html1数据卷数据# -tid 这个参数加不加都可以# --rm 加上，备份后就会自动删除这个容器，如果不加这个 --rm 参数，name备份后的容器就会保留，docker ps -a就会查看到）# $(pwd) [root@iz2zefaujekcdpmfw1qs4az ~]# pwd/root[root@iz2zefaujekcdpmfw1qs4az ~]# docker run -tid --rm --volumes-from container1 -v $(pwd):/backup nginx tar cvf /backup/backup1.tar /usr/share/nginx/html1b3663a3bdd302a38036d6a156471cd448c8e5b9333a20f9480b3c61cbd9270df[root@iz2zefaujekcdpmfw1qs4az ~]# lsbackup1.tar –volumes-from [containerName]：这个命令来指定需要备份的容器的名字；（数据卷容器的名字） -v $(pwd):/backup:权限：使用-v命令来指定希望备份文件存放的位置；本地存放目录：容器存放目录：读写权限；（默认权限是读写） tar cvf /backup/backup.tar [container data volume]：tar表示执行备份的操作是：压缩文件的命令； /backup/backup.tar是文件存放的地址， [container data volume]指定需要备份的目录； tar cvf 压缩；tar xvf解压缩； 备份container1容器中的/usr/share/nginx/html2数据卷数据 12345678910111213# 备份container1容器中的/usr/share/nginx/html2数据卷数据[root@iz2zefaujekcdpmfw1qs4az ~]# pwd/root[root@iz2zefaujekcdpmfw1qs4az ~]# docker run -tid --rm --volumes-from container1 -v $(pwd):/backup nginx tar cvf /backup/backup2.tar /usr/share/nginx/html2001129bc393d5d0ed4665d053d4ca7972584cf2bd56980064be182ec758138cd[root@iz2zefaujekcdpmfw1qs4az ~]# lltotal 22464-rw-r--r-- 1 root root 10240 Dec 16 18:52 backup1.tar # 文件1-rw-r--r-- 1 root root 10240 Dec 16 19:05 backup2.tar # 文件2drwxr-xr-x 2 root root 4096 Dec 16 16:45 myvolume-rw-r--r-- 1 root root 22973527 Mar 26 2019 Python-3.7.3.tgz 备份container1 容器中的 /usr/share/nginx/html1 和 /usr/share/nginx/html2 数据卷数据 123456789101112131415# 备份container1 容器中的 /usr/share/nginx/html2 和 /usr/share/nginx/html2 数据卷数据[root@iz2zefaujekcdpmfw1qs4az ~]# pwd/root[root@iz2zefaujekcdpmfw1qs4az ~]# docker run -tid --rm --volumes-from container1 -v $(pwd):/backup nginx tar cvf /backup/backup.tar /usr/share/nginx/html1/usr/share/nginx/html2441df929e123cbe51564ca3d6bf3f06a5ea415298a34bb9871f1ed2b68a60102[root@iz2zefaujekcdpmfw1qs4az ~]# lltotal 22476-rw-r--r-- 1 root root 10240 Dec 16 18:52 backup1.tar-rw-r--r-- 1 root root 10240 Dec 16 19:05 backup2.tar-rw-r--r-- 1 root root 10240 Dec 16 19:09 backup.tardrwxr-xr-x 2 root root 4096 Dec 16 16:45 myvolume-rw-r--r-- 1 root root 22973527 Mar 26 2019 Python-3.7.3.tgz 恢复数据给同一个容器 之前的数据卷是从 container1 中备份的，现在模拟 container1 数据卷丢失，然后直接用之前备份的 backup.tar 进行恢复 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 为了测试恢复，先删除容器里原先的数据（注意：数据卷目录不能删除，只能删除其中的数据）[root@iz2zefaujekcdpmfw1qs4az ~]# docker exec -it container1 bash #进入到创建的容器里root@6869560e6ff5:/# lsbin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr varroot@6869560e6ff5:/# cd /usr/share/nginx #进入到容器里面的数据卷所在的目录root@6869560e6ff5:/usr/share/nginx# lshtml html1 html2 root@6869560e6ff5:/usr/share/nginx# cd html1# 进入到 html1 数据卷目录root@6869560e6ff5:/usr/share/nginx/html1# ls1.textroot@6869560e6ff5:/usr/share/nginx/html1# rm -rf 1.text # 删除 1.text 文件root@6869560e6ff5:/usr/share/nginx/html1# lsroot@6869560e6ff5:/usr/share/nginx# cd html2# 进入到 html2 的数据卷目录root@6869560e6ff5:/usr/share/nginx/html2# ls2.textroot@6869560e6ff5:/usr/share/nginx/html2# rm -rf 2.text # 删除 2.text 文件root@6869560e6ff5:/usr/share/nginx/html2# ls# 进行数据卷恢复，恢复数据卷中的所有数据注意-C后面的路径，表示将数据恢复到容器里的路径直接使用压缩包中文件的各个路径。比如压缩包中的结果如下：tar -xvf backup.tar #解压压缩文件# 数据1usr/share/nginx/html1/1.text--usr --share --nginx --html1 --1.text# 数据2 usr/share/nginx/html2/2.text--usr --share --nginx --html2 --2.text# 直接将文件解压到 /usr/share/nginx/html1 和 /usr/share/nginx/html2 目录[root@iz2zefaujekcdpmfw1qs4az ~]# docker run --rm --volumes-from container1 -v $(pwd):/backup nginx tar xvf /backup/backup.tar -C /usr/share/nginx/html1/usr/share/nginx/html1/1.textusr/share/nginx/html2/usr/share/nginx/html2/2.text# 直接进入容器查看[root@iz2zefaujekcdpmfw1qs4az ~]# docker exec -it container1 bashroot@6869560e6ff5:/# cd /usr/share/nginx/ root@6869560e6ff5:/usr/share/nginx# lshtml html1 html2# 查看数据是否存在root@6869560e6ff5:/usr/share/nginx# ls html11.textroot@6869560e6ff5:/usr/share/nginx# ls html22.textroot@6869560e6ff5:/usr/share/nginx# cat html1/1.text html1root@6869560e6ff5:/usr/share/nginx# cat html2/2.text html2 ! 如果你备份的数据里面有，不是设置的数据卷里面的数据，使用这个命令是恢复不了的（恢复的是设置的数据卷里面的数据） 你可以创一个新的容器多一个，你数据卷挂载你备份数据时候，备份的文件的路径就可以解决了 恢复数据给新的容器1234567891011121314151617181920212223242526272829303132333435363738# 新建一个容器container2[root@iz2zefaujekcdpmfw1qs4az ~]# docker run -tid -v /usr/share/nginx/html1 -v /usr/share/nginx/html2 --name container2 nginx89abb55858fb1e3dddc07c2066d05614349aaf78ba446a1ea12f1241b98e4896[root@iz2zefaujekcdpmfw1qs4az ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES89abb55858fb nginx \"/bin/bash\" 9 seconds ago Up 8 seconds 80/tcp container26869560e6ff5 nginx \"/bin/bash\" 2 hours ago Up 2 hours 80/tcp container1# 开始恢复数据[root@iz2zefaujekcdpmfw1qs4az ~]# pwd/root[root@iz2zefaujekcdpmfw1qs4az ~]# lltotal 22476-rw-r--r-- 1 root root 10240 Dec 16 18:52 backup1.tar-rw-r--r-- 1 root root 10240 Dec 16 19:05 backup2.tar-rw-r--r-- 1 root root 10240 Dec 16 19:09 backup.tardrwxr-xr-x 2 root root 4096 Dec 16 16:45 myvolume-rw-r--r-- 1 root root 22973527 Mar 26 2019 Python-3.7.3.tgz# 恢复数据[root@iz2zefaujekcdpmfw1qs4az ~]# docker run --rm --volumes-from container2 -v $(pwd):/backup nginx tar xvf /backup/backup.tar -C /usr/share/nginx/html1/usr/share/nginx/html1/1.textusr/share/nginx/html2/usr/share/nginx/html2/2.text# 查看确实已经恢复了[root@iz2zefaujekcdpmfw1qs4az ~]# docker exec -it container2 bashroot@89abb55858fb:/# ls /usr/share/nginx/html html1 html2root@89abb55858fb:/# ls /usr/share/nginx/html11.textroot@89abb55858fb:/# ls /usr/share/nginx/html22.textroot@89abb55858fb:/# cat /usr/share/nginx/html1/1.text html1root@89abb55858fb:/# cat /usr/share/nginx/html2/2.text html2 注意： –volumes-from [containerName]：这个命令来指定需要备份的容器的名字；（数据卷容器的名字） -v $(pwd):/backup:权限：使用-v命令来指定希望备份文件存放的位置；本地存放目录：容器存放目录：读写权限；（默认权限是读写） tar cvf /backup/backup.tar [container data volume]：tar表示执行备份的操作是：压缩文件的命令； /backup/backup.tar是文件存放的地址， [container data volume]指定需要备份的目录； tar cvf 压缩；tar xvf解压缩； 新容器创建时挂载的数据卷路径最好和之前备份的数据卷路径一致 新容器创建时，如果挂载的数据卷只是备份卷的一部分，那么恢复的时候也只是恢复一部分数据。 比如新建容器挂载数据卷为 -v /usr/share/nginx/html1 ,那么使用 backup.tar 恢复时，只会恢复 /usr/share/nginx/html1 的数据， /usr/share/nginx/html2 的数据是不会恢复的 比如新容器创建时挂载的数据卷目录和备份的数据卷目录不一致，那么数据恢复不了，除非修改 - C 后面的路径，比如新建容器时指定数据卷目录为 /usr/share/nginx/html ，恢复时也是用 -C /usr/share/nginx/html，则是可以成功恢复的 删除数据卷123docker volume ls 列出所有的数据卷docker volume ls --filter dangling=true 过滤不在使用的数据卷docker volume rm [volume name] 删除一个数据卷，容器正在使用的数据卷不能删除，绑定挂载的数据卷无法删除 1docker volume rm my-volio 删除数据卷 my-volio 数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。 无主的数据卷可能会占据很多空间，要清理请使用以下命令 1$ docker volume prune","categories":[{"name":"Docker","slug":"Docker","permalink":"https://cy-blogs.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://cy-blogs.cn/tags/Docker/"}]},{"title":"Linux用户组及权限管理","slug":"Linux用户组及权限管理","date":"2019-12-11T05:10:16.031Z","updated":"2019-12-11T04:56:36.622Z","comments":true,"path":"Linux用户组及权限管理/","link":"","permalink":"https://cy-blogs.cn/Linux用户组及权限管理/","excerpt":"用户和组 Linux 是哟个多用户的操作系统，引入用户，可以更加方便管理 Linux 服务器 系统默认需要以一个用户的身份登入，而且在系统上启动进程也需要以一个用户身份器运行，用户可以限制某些进程对特定资源的权限控制","text":"用户和组 Linux 是哟个多用户的操作系统，引入用户，可以更加方便管理 Linux 服务器 系统默认需要以一个用户的身份登入，而且在系统上启动进程也需要以一个用户身份器运行，用户可以限制某些进程对特定资源的权限控制 Linux用户及组 Linux 操作系统对多用户的管理，是非常繁琐的，所以用组的概念来管理用户就变到的简单，每个用户可以在一个独立的组，每个组也可以有零个用户或者多个用户。 Linux 系统用户是根据用户 ID 来识别的，默认 ID 长度为 32 位，默认 ID 编号从 0 开始，但是为了和老式系统兼容，用户 ID限制在 60000一下， Linux 用户总共分为三种，分别如下： 超级用户： root， ID 为0 系统用户：ID 从1 到499 普通用户：ID为500以上 Linux 系统中的每个文件或者文件夹，都有一个所属用户及所属组 使用 ID 命令可以显示当前用户的信息，使用 passwd 命令可以修改当前用户密码。 Linux操作系统用户的特点如下 每个用户拥有一个 UserID，操作系统实际读取的是 UID，而非用户名； 每个用户属于一个主组；属于一个或多个附属组，一个用户最多有 31个附属组； 每个组用有一个 GroupID; 每个进程以一个用户身份进行，该用户可以对进程拥有资源控制权限； 每个可登录用户拥有一个指定的 Shell环境 创建新用户 1useradd usertest # 创建用户usertest 创建新用户，可以使用命令useradd，执行命令即可创建新用户 同时会创建一个同名的组，默认该用户属于该用户组 创建用户，会根据如下步骤进行操作 在/etc/passwd文件中添加用户信息 如使用passwd命令创建密码，密码会被加密保存在/etc/shdaow中 为用户创建家目录：/home/usertest，创建目录操作应操作系统而异 将/etc/skel中的.bash开头的文件复制至用户家目录 创建与用户名相同的组，该用户默认属于这个同名组，组信息保存在/etc/group配置文件中 其他命令可选参数如下所示 12-d # 指定新用户的主目录-G # 指定新用户的组列表-s # 新用户所使用的shell环境useradd usertest -s /bin/bash -d /home/usertest# 创建新用户usertest，指定shell环境为bash，主目录在/home/usertest 删除用户 1userdel # 保留用户的家目录userdel –r usertest # 删除用户及用户家目录，用户login系统无法删除userdel –rf usertest # 强制删除用户及该用户家目录，不论是否login系统 当一个用户创建之后，我们可以通过usermod命令来修改用户及组的属性 linux下命令选项 12选项： -c, --comment 注释 GECOS 字段的新值 -d, --home HOME_DIR 用户的新主目录 -e, --expiredate EXPIRE_DATE 设定帐户过期的日期为 EXPIRE_DATE -f, --inactive INACTIVE 过期 INACTIVE 天数后，设定密码为失效状态 -g, --gid GROUP 强制使用 GROUP 为新主组 -G, --groups GROUPS 新的附加组列表 GROUPS -a, --append GROUP 将用户追加至上边 -G 中提到的附加组中， 并不从其它组中删除此用户 -h, --help 显示此帮助信息并推出 -l, --login LOGIN 新的登录名称 -L, --lock 锁定用户帐号 -m, --move-home 将家目录内容移至新位置 (仅于 -d 一起使用) -o, --non-unique 允许使用重复的(非唯一的) UID -p, --password PASSWORD 将加密过的密码 (PASSWORD) 设为新密码 -R, --root CHROOT_DIR chroot 到的目录 -s, --shell SHELL 该用户帐号的新登录 shell -u, --uid UID 用户帐号的新 UID -U, --unlock 解锁用户帐号 -Z, --selinux-user SEUSER 用户账户的新 SELinux 用户映射groups username# 查看用户所属组 修改用户所属组 123usermod usertest -G old_normal# 将用户usertest修改加入old_normal组中usermod usertest -a -G other_normal# 将用户追加至other_normal组中，且不影响原有组状态cat /etc/group | grep usertest # 可以查看到usertest用户当前所属组的情况 修改用户家目录及启动shell 1usermod usertest -d /home/user -s /bin/sh 修改用户名 1usermod -l new old# 将old用户名变为new 锁定/解锁用户 1usermod -L usertest;# 锁定usertest用户usermod -U usertest;# 解锁usertest用户 Linux组管理 所有的Linux或者Windows系统都有组的概念，通过组可以更加方便的管理用户 组的概念应用于各行行业，例如企业会使用部门、职能或地理区域的分类方式来管理成员，映射在Linux系统，同样可以创建用户，并用组的概念对其管理 Linux组有如下特点 每个组有一个组ID 组信息保存在/etc/group中 每个用户至少拥有一个主组，同时还可以拥有31个附属组 创建新组 12groupadd normal # 创建normal组groupadd -g 1000 normal # 创建ID为1000的分组 其他组属性 常见参数 123-r # 系统账户-f # 如果指定的组已经存在，则退出-g # 指定当前组id-n --new --old # 修改组名groupmod -n old_normal normal# 修改normal组名为old_normalgroupmod -g 1001 old_normal# 修改old_normal组id为1001 权限 设置好了用户和组，那么接下来就可以对其进行权限控制 由于linux下处处皆文件，所谓权限也就是对文件的读、写、执行，至少这三种 当操作系统下某个进程在运行时，进程的权限，也相当于这个进程的运行用户身份权限 权限 文件 目录 r 读取文件 列出目录 w 修改文件 修改目录内文件 x 执行文件 进入目录 权限分组 默认的linux的权限分为三种角色 12&gt; user`、`group`、`other&gt; 每个文件将基于UGO三种权限进行设置 一般一个文件创建之后，谁创建该文件，默认成为该文件的所有者 用户及组权限 12ls -ahl# 查看文件所有者chmod g+rwx file# 给file文件增加rwx权限chmod g-x file# 给file文件减少x权限 用户及组修改 修改某个文件或目录所属用户或组 12chown -R root file# 修改file文件所属用户为rootchown -R :root file# 修改file文件所属用户为rootchgrp -R root file# 修改file文件所属组为root 二进制权限 linux下具备权限设置为1，反之为0，那么一个权限按照二进制位数来计算，如下所示 1--x: 001 1-wx: 011 3rwx: 111 7 很清晰，对应的权限位置所代表的数字分别是：r=4，w=2，x=1 1chmod 775 file# 修改file文件权限为 rwxrwxr-x 权限掩码 神奇的事情需要我们考虑，每次创建文件，默认都会具备一定的权限，而这个权限是如何分配而来的呢？ 是通过一个叫做权限掩码的东西来维护的，这个码可以通过umask命令看到 默认系统的掩码是022 文件权限由默认权限减去掩码 文件默认权限：666那么创建一个文件真实的权限是：666-022=644 目录的默认权限：777 一个目录的真实权限是：777-022=755 设置默认掩码 1umask -S 011 特殊权限 权限 对文件的影响 对目录的影响 suid 以文件的所属用户身份执行，而非执行文件的用户 无 sgid 以文件所属组身份去执行 在该目录中创建任意新文件的所属组与该目录的所属组相同 sticky 无 对目录拥有写入权限的用户仅可以删除其拥有的文件，无法删除其他用户所拥有的文件","categories":[{"name":"Linux","slug":"Linux","permalink":"https://cy-blogs.cn/categories/Linux/"}],"tags":[{"name":"Linux用户组及权限管理","slug":"Linux用户组及权限管理","permalink":"https://cy-blogs.cn/tags/Linux用户组及权限管理/"}]},{"title":"Linux常用命令","slug":"linux常用命令","date":"2019-12-11T05:10:16.027Z","updated":"2019-12-11T03:56:22.829Z","comments":true,"path":"linux常用命令/","link":"","permalink":"https://cy-blogs.cn/linux常用命令/","excerpt":"Linux 随着IT产业的不断发展，linux 操作系统应用领域越来越广泛，尤其是近年来 linux在服务器领域飞速的发展，主要得益于 linux操作系统具备的如下优点","text":"Linux 随着IT产业的不断发展，linux 操作系统应用领域越来越广泛，尤其是近年来 linux在服务器领域飞速的发展，主要得益于 linux操作系统具备的如下优点 开源免费 系统迭代更新 系统性能稳定 安全性高 多任务/多用户 耗资源小，无需图形化界面 内核小 应用领域广泛 使用及入门容易 操作系统分类介绍 学习 Linux 操作系统，需要悬着不同的发行版本 Linux 操作系统是一个大类别， Linux 操作系统主流发型版本包括： Red Hat Linux 、 CentOS , Ubuntu , SUSE Linux , Fedore Linux 等，具体发行版本区别如下 Red Hat Linux Red Hat Linux 是最早的 Linux 发行版本之一 同时也是最著名的 Linux 版本， Red Hat Linux 已经创造了自己的品牌，也是读者经常听到的 ’‘ 红帽操作系统’‘ Red Hat 1994 年创立，目前公司全世界有 3000 多人，一直致力于开放的源代码体系，向用户提供一套完整的服务，这使得它特别适合在公共网络中使用 这个版本的 Liunx 也使用最新的内核，还拥有大多数人都需要使用的主要软件包 Centos 社区企业版操作系统（Community Enterprise Operating System，CentOS）是Linux发行版之一，它是来自于Red Hat Enterprise Linux依照开放源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以CentOS替代商业版的Red Hat Enterprise Linux使用。 CentOS于Red Hat Linux不同之处在于CentOS并不包含封闭的源代码软件，可以开源免费使用，得到运维人员、企业、程序员的青睐，CentOS发行版操作系统是目前企业使用最多的系统之一 2016年12月12日，CentOS基于Red Hat Enterprise Linux的CentOS Linux 7 (1611)系统正式对外发布 Ubuntu Ubuntu是一个以桌面应用为主的Linux操作系统，其名称来自非洲南部祖鲁语或豪萨语的“ubuntu”一词（译为吾帮托或乌班图），意思是“人性”、“我的存在是因为大家的存在”，是非洲传统的一种价值观 Ubuntu基于Debian发行版和GNOME桌面环境，Ubuntu发行版操作系统的目标在于为一般用户提供一个最新的、同时稳定的以开放自由软件构建而成的操作系统，目前Ubuntu具有庞大的社区力量，用户可以方便地从社区获得帮助 SUSE Linux SUSE(发音 /ˈsuːsə/)，SUSE Linux出自德国，SuSE Linux AG公司发行维护的Linux发行版，是属于此公司的注册商标2003年11月4日，Novell表示将会对SUSE提出收购。收购的工作于2004年1月完成。 Novell也向大家保证SUSE的开发工作仍会继续下去，Novell更把公司内全线电脑的系统换成SUSE LINUX，并同时表示将会把SUSE特有而优秀的系统管理程序 - YaST2以GPL授权释出 Fedora Linux Fedora是一个知名的Linux发行版，是一款由全球社区爱好者构建的面向日常应用的快速、稳定、强大的操作系统。 它允许任何人自由地使用、修改和重发布，无论现在还是将来。它由一个强大的社群开发。 这个社群的成员以自己的不懈努力，提供并维护自由、开放源码的软件和开放的标准。Fedora约每六个月会发布新版本 Linux命令 cd 目录切换 1234cd .. #上一层目录cd # 家目录cd ~ # 家目录cd / # 根目录 ls 浏览目录下的文件或文件夹 1234ls -a # 列举所有文件或目录，包含.开头的隐藏文件ls -l # 详细信息列举文件或目录ls -i # 列出每个文件的Inode号ls -t # 根据修改时间列出文件 pwd 显示当前所处目录 mkdir 创建目录 12mkdir a # 创建a目录mkdir -p a/b/c # 递归创建目录 rm 删除文件或目录 123rm a # 删除a文件rm -r a # 删除a 目录rm -rf a # 强制删除a 文件，不提示确认 cp 拷贝或备份文件 1cp /root/1.py /hoom/1.py # 拷贝文件至新目录下 mv 重命名或移动文件或目录 1mv /root/1.py /hoome/1.py.bak # 移动文件并重命名 touch 创建普通文件 1touch 1.py # 创建1.py文件 cat 查看文件内容 123cat /etc/redis/redis.conf # 查看redis.conf文件car -n # 对输出所有进行编号car -b # 对输出非空进行编号 head 查看文件头部内容，通常为十行 123head -3 /etc/memcached.conf # 查看前三行head -n 100 # 查看前100行head -c 3 # 查看前三字节 tail 查看文件头部内容，通常为十行 12tail -n 3 1.txt # 查看后3行tail -f # 阻塞并即时输出文件变化后追加的数据 chmod 修改文件或目录权限 1chmod 775 1.py # 赋予文件775权限 rwx rwx r-w chown 修改文件或目录所属组及所属用户 1chown -R root.root /tmp/test.txt # 文件所属用户及所属组均为root df 磁盘信息查询 12df -h # 查询磁盘使用量df -i # 分区Inode使用量 du 查看文件大小 1du -h 1.txt # 查看1.txt文件大小 echo 打印或输出内容 123echo 'hello' # 输出helloecho 'hello' &gt; 1.md # 以hello内容覆盖1.mdecho 'hello' &gt;&gt; 1.md # 以hello追加至1.md文件中 tar 解压或压缩文件 12tar -jxvf # 解压bz2属性的压缩包tar -zxvf # 解压gz属性的压缩包 12tar -czcf # 使用gzip格式压缩文件tar -cjvf # 使用bzip2格式压缩文件","categories":[{"name":"Linux","slug":"Linux","permalink":"https://cy-blogs.cn/categories/Linux/"}],"tags":[{"name":"Linux常用命令","slug":"Linux常用命令","permalink":"https://cy-blogs.cn/tags/Linux常用命令/"}]},{"title":"Ansible-PlayBook","slug":"Ansible-PlayBook","date":"2019-12-11T05:10:16.013Z","updated":"2019-12-11T05:03:39.327Z","comments":true,"path":"Ansible-PlayBook/","link":"","permalink":"https://cy-blogs.cn/Ansible-PlayBook/","excerpt":"ansible-playbook 在之前的ansible使用中，我们都是通过命令行的形式实现对应远程主机的响应管理 但这样的工作方式功能上来说还是有一定的局限性，并且维护并不方便，引入playbook可以更加方便我们对于功能的编写维护，并且具有良好的灵活性 playbook也可以理解为命令行功能的一个合集脚本，用来编写更加复杂的业务","text":"ansible-playbook 在之前的ansible使用中，我们都是通过命令行的形式实现对应远程主机的响应管理 但这样的工作方式功能上来说还是有一定的局限性，并且维护并不方便，引入playbook可以更加方便我们对于功能的编写维护，并且具有良好的灵活性 playbook也可以理解为命令行功能的一个合集脚本，用来编写更加复杂的业务 yaml语法 Yaml为通用数据串行化格式语法，简洁而强大 ansible中的配置文件就采用了Yaml格式语法存在，以下就是对Yaml语法的介绍 1yaml 基本语法规则如下 大小写敏感 使用缩进表示层级关系 缩进的空格数目不唯一，只要相同层级元素左侧对齐即可 #号表示注释 1yaml 语法支持的数据结构有三种： 键值对：相当于hash表映射关系，字典 序列：相当于数组或列表 纯量（标量）：单独的值，无法继续拆分，比如字符串、整数、浮点数、Null、布尔值（true、false） 字符串 字符串定义时，默认可以不使用引号标注 12str_1: abc&#123;'str_1': 'abc',&#125; # 对应Python中数据类型 如字符串中出现特殊字符或包含空格，需要使用引号标注 12str_2: 'abc: bbb'&#123;'str_2': 'abc: bbb'&#125; # 对应Python中数据类型 双引号不会对字符串中特殊字符进行转义 123str_3: 'abc: \\n bbb'str_4: \"abc: \\n bbb\"&#123;'abc: \\\\n bbb', 'str_4': 'abc: \\n bbb'&#125; # 对应Python中数据类型 单引号字符串还有引号，需要使用两个单引号进行转义 12str_5: 'a''b'&#123;'str_5': \"a'b\"&#125; # 对应Python中数据类型 当字符串需要换行时，从第二行开始的下面几行，需要有对齐缩进，换行会被解释为空格，其余缩进前空格会忽略 12345str_6: 'abc aaa bbb ccc'&#123;'str_6': 'abc aaa bbb ccc'&#125; # 对应Python中数据类型 多行字符串可以使用 |保留换行符形成段落，或使用&gt;将换行符替换为空格 123456789str_7: &gt; bbb aaastr_8: | bbb aaa&#123;'str_7': 'bbb aaa\\n', 'str_8': 'bbb\\naaa\\n'&#125; # str_7: &gt; bbb aaastr_8: | bbb aaa&#123;'str_7': 'bbb aaa\\n', 'str_8': 'bbb\\naaa\\n'&#125; # 对应Python中数据类型对应Python中数据类型 +表示保留字符串末位的换行，-表示删除字符串末位的换行 123456str_9: |+ aaabbbstr_10: |- aaabbb'str_9': 'aaabbb\\n', 'str_10': 'aaabbb'&#125; # 对应Python中数据类型 键值对 Yaml中的键值对数据通过冒号定义，冒号后的数据与冒号之间存在一个空格 1234567dict_1: adict_2: &#123; 1 : a &#125;dict_3: dict_1: adict_2: &#123; 1 : a &#125;dict_3: a: 1 b: 2&#123;'dict_1': 'a', 'dict_2': &#123;1: 'a'&#125;, 'dict_3': &#123;'a': 1, 'b': 2&#125;&#125; # 对应Python中数据类型 a: 1 b: 2&#123;'dict_1': 'a', 'dict_2': &#123;1: 'a'&#125;, 'dict_3': &#123;'a': 1, 'b': 2&#125;&#125; # 对应Python中数据类型 序列1234567- list_1- list_2- - a_1 - a_2['list_1', 'list_2', ['a_1', 'a_2']] # 对应Python中数据类型- list_1- list_2- - a_1 - a_2['list_1', 'list_2', ['a_1', 'a_2']] # 对应Python中数据类型 数据嵌套使用1234567- test_1: - a - b- test_2: var_1: true var_2: 0.2[&#123;'test_1': ['a', 'b']&#125;, &#123;'test_2': &#123;'var_1': True, 'var_2': 0.2&#125;&#125;] # 对应Python中数据类型 playbook playbook的编写使用yaml语法规则，先来看一下最简单的playbook 12345678---- hosts: all remote_user: root tasks: - name: Yum Install Apache yum: name=httpd state=installed - name: Start Apache Server service: name=httpd state=started 第一行：---指明Ymal将文件解释为正确的文档的要求，Yaml允许可以有多个文档同时出现在一个文件里，每个文档之间由---进行分割，目前我们的playbook中只需要有一个文档即可 第二行：hosts指明当前playbook将要操作的目标主机有哪些，这里我们选择全部 第三行：remote_user指明当前操作所使用的远程主机用户 第四行：tasks为任务列表，playbook将按照从上到下的定义顺序执行其中的模块对应的操作，name属性为一个字符串用以标示当前任务的介绍，第一个任务将使用yum模块安装apache服务，第二个任务使用ansible模块service，使httpd服务启动 执行playbook使用ansible-playbook 1ansible-playbook /etc/ansible/playbook.yml 包含 当遇到较为复杂的情况时，单独的playbook可能无法应对业务需求，那么可能需要编写多个playbook 这时，如果在playbook中的handlers或tasks可能在多个playbook中重复使用，就可以通过ansible所提供的include功能，将复用的部分单独写成一个文件，在需要的地方include包含进来即可 比如有这样的一个功能是需要多次复用的，这个文件叫做tasks.yaml 123--- - name: Yum Install Nginx yum: name=nginx state=installed 那么在一个主要playbook文件中可以这样引入 1234---- hosts: all tasks: - include: tasks.yml 执行该playbook 1ansible-playbook /etc/ansible/playbook.yml include包含的其他playbook支持模板变量，可以通过定义vars变量覆盖，或者像这样 123---- name: Yum Install Nginx yum: name=&#123;&#123; server_name &#125;&#125; state=installed playbook文件 123- hosts: all tasks: - include: tasks.yml server_name=nginx 此外在1.4及以上版本中，还支持字典、列表形式的参数传递 123--- -name: Yum Install Nginx yum: name=&#123;&#123; server_name &#125;&#125; state=installed 1234--- -hosts: all tasks: - &#123; include: tasks.yml, server_name: nginx &#125; 角色 除去通过include功能将不同的任务分别写入不同的文件，然后按需include包含进来，在ansible中还有一种标准规范叫做role角色 通过不同级别的层级目录和文件来对变量、任务、配置模板等进行拆分管理，提高扩展性和可维护性 一般来说，一个role角色定义目录结构如下 1234567role_name/ # 角色名目录，playbook调用时需要 file/ # 存放copy或script等模块调用文件 tasks/ # 存放各种task任务，需要包含一个main.yml handlers/ # 存放各种handlers任务，需要包含一个main.yml vars/ # 存放定义好的变量，需要包含一个main.yml templates/ # 存放需要使用到的配置模板 meta/ # 当前角色的特殊设定及其依赖，需要包含一个main.yml 角色目录存放的路径可以在ansible的配置文件中定义 1# /etc/ansible/ansible.cfgroles_path = /etc/ansible/roles 示例目录结构 任务tasks目录下main文件内容 1# tasks/main.yml- name: Install Apache Server yum: name=httpd state=installed- name: Write Apache Config template: src=httpd.j2 dest=/etc/httpd/conf/httpd.conf notify: Restart Apache Server handlers目录下main文件内容 1# handlers/main.yml- name: Restart Apache Server service: name=httpd state=restarted templates下配置模板 1# templates/httpd.j2#上面内容太多省略，只保留模板变量部分Listen &#123;&#123; listen_port &#125;&#125; 变量vars目录下main文件 1# vars/main.ymllisten_port: 8000 调用role的playbook文件内容 1- hosts: all remote_user: root roles: - apache 在执行角色role此处为apache任务时，会将文件夹下的main.yml文件自动导入合并，执行结果如下","categories":[{"name":"Linux","slug":"Linux","permalink":"https://cy-blogs.cn/categories/Linux/"}],"tags":[{"name":"Linux,Ansible-PlayBook","slug":"Linux-Ansible-PlayBook","permalink":"https://cy-blogs.cn/tags/Linux-Ansible-PlayBook/"}]},{"title":"Paramiko","slug":"Paramiko","date":"2019-12-11T05:10:16.009Z","updated":"2019-12-11T05:09:54.323Z","comments":true,"path":"Paramiko/","link":"","permalink":"https://cy-blogs.cn/Paramiko/","excerpt":"Paramiko Paramiko是SSHv2协议的Python实现，提供客户端和服务器功能 Paramiko本身是一个围绕SSH网络概念的纯Python接口 利用paramiko我们可以通过Python方便的进行ssh操作","text":"Paramiko Paramiko是SSHv2协议的Python实现，提供客户端和服务器功能 Paramiko本身是一个围绕SSH网络概念的纯Python接口 利用paramiko我们可以通过Python方便的进行ssh操作 +++ paramiko包含两个核心组件：SSHClient和SFTPClient SSHClient+++ SSHClient的作用类似于Linux的ssh命令，是对SSH会话的封装 该类封装了传输Transport，通道Channel及SFTPClient建立的方法open_sftp，通常用于执行远程命令 API class paramiko.client.SSHClient 创建SSH客户端实例 SSHClient.connect(hostname, port=22, username=None, password=None, pkey=None, key_filename=None, timeout=None, allow_agent=True, look_for_keys=True, compress=False..) 1234567891011# 参数解释- hostname：连接的目标主机- port=SSH_PORT：指定端口- username=None：验证的用户名- password=None：验证的用户密码- pkey=None：私钥方式用于身份验证- key_filename=None：一个文件名或文件列表，指定私钥文件- timeout=None：可选的tcp连接超时时间- allow_agent=True：是否允许连接到ssh代理，默认为True 允许- look_for_keys=True：是否在~/.ssh中搜索私钥文件，默认为True 允许- compress=False：是否打开压缩 通过验证连接远程服务端 SSHClient.exec_command(command, bufsize=-1, timeout=None, get_pty=False, environment=None) 123456# 参数解释- command：要执行的命令- bufsize：与Python中文件对象的同名函数解释相同，缓冲区大小- timeout：设置命令的超时相应事件- get_pty：从服务器请求一个伪终端（默认为假）- environment：一个当前shell环境的字典，远程命令的默认执行环境 command参数为要执行的shell命令，打开一个新通道并执行请求的命令 该函数的返回结果为一个元组，其中包含stdin、stdout和stderr，也就是我们常见的标准输入，输出以及出错 一般来说，命令的结果我们将通过stdout进行获取 SSHClient.close() 关闭SSH连接 SSHClient.invoke_shell(term=’vt100’, width=80, height=24, width_pixels=0, height_pixels=0, environment=None) 1234567# 参数解释- term：模拟终端类型- width：终端长度- height：终端宽度- width_pixels：终端的像素宽度- height_pixels：终端的像素高度- environment：命令的shell环境 在ssh服务器上启动交互式shell会话 一个新的通道被打开并连接到，使用请求的终端类型和大小的伪终端，并作为返回值 换句通俗的话来讲，就是创建了一个实际的shell窗口空间进行命令交互 SSHClient.set_missing_host_key_policy(policy) 设置连接到没有已知主机密钥的服务器时要使用的策略 常见使用策略为paramiko.client.AutoAddPolicy，其意义为自动将主机名和新主机密钥添加到本地主机密钥对象并保存 实例代码 以下是一个简单的通过SSHClient建立的通道进行命令的传输与返回结果的获取的代码！ 1234567891011121314151617181920212223242526272829import paramiko def connect(hostname,username,password): client = paramiko.SSHClient() # 初始化 client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) # 设置密钥策略 client.connect(hostname,username=username,password=password) # 连接主机 return clientdef exec_cmd(client,cmd): stdin,stdout,stderr = client.exec_command(cmd) return stdout.read().decode(),stderr.read().decode()def main(): hostname = '192.168.0.104' username = 'pi' password = '123456' cmd = 'ps -aux' client = connect(hostname,username,password) res = exec_cmd(client, cmd) if res[0]: print(res[0]) if res[1]: print('[E]:\\n',res[1]) client.close()if __name__ == '__main__': main() 上面的代码通过默认建立好的连接对象进行命令的传输以及返回结果的获取 invoke_shell 接下来使用invoke_shell进行虚拟终端的连接，首先初始化SSH通道 12345678910class SSHChannle: def __init__(self, host, username, password, port=22): ''' 初始化SSH通道 ''' self.sh = paramiko.SSHClient() self.sh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) self.sh.connect(host, username=username, password=password) self.channle = self.sh.invoke_shell() self.cmd = '' 思路为开启两个线程，分别负责命令的接收与命令的发送 12345678910111213def get_ssh_recv(self): ''' 接收SSH通道中发来的消息 ''' while not self.channle.exit_status_ready(): # 如果远程进程已退出并返回退出状态，则返回true time.sleep(0.1) try: buf = self.channle.recv(1024).decode('utf-8') print(buf,end='') except Exception as ex: print(ex) sys.stdout.flush() 1234567891011def send_ssh_cmd(self): ''' 发送命令给SSH通道 ''' while not self.channle.exit_status_ready(): self.cmd = input() try: self.channle.send(self.cmd + '\\r') except Exception as ex: print(ex) # sys.stdin.flush() 在实例中定义run函数用来开启两个线程并负责线程的资源回收以及SSH通道的关闭 12345678910def run(self): ssh_recv_thread = threading.Thread(target=self.get_ssh_recv) ssh_send_thread = threading.Thread(target=self.send_ssh_cmd) ssh_recv_thread.start() ssh_send_thread.start() ssh_recv_thread.join() ssh_send_thread.join() self.sh.close() # 关闭通道 在win下的CMD中查看效果，其中的乱码格式其实为连接后命令传输的特殊标记格式，可以在后面结合前端中类似xterm.js等插件查看到实际花里胡哨的效果 SFTPClient SFTPClient的作用类似与Linux的sftp命令，是对SFTP客户端的封装 用以实现远程文件操作，如文件上传、下载、修改文件权限等操作 API 官方文档 docs.paramiko.org/en/2.4/api/sftp.html sftp=paramiko.SFTPClient.from_transport(t,window_size=None,max_packet_size=None) 1# 参数解释- t：该参数可以通过paramiko.Transport( (ip,port ))，创建一个已通过验证的传输通道，参数为IP和端口的二元组 根据参数t指定的已验证传输通道进行SFTP客户端的创建 sftp.put(localpath, remotepath, callback=None, confirm=True) 上传本地路径为localpath的文件到目标主机remotepath处 sftp.get(remotepath, localpath, callback=None) 下载远程路径为remotepath路径的的文件到本地主机localpath处 open(filename, mode=’r’, bufsize=-1) 打开位于远程主机上的文件，与open函数类似，返回文件对象 listdir(path=&#39;.&#39;) 返回给定路径下文件及目录的列表，默认路径为当前工作目录 chdir(path=None) 修改当前SFTP连接会话的工作目录 lstat(path) 检索当前path所指向的文件信息 mkdir(path,mode=511) 根据path在目标主机创建默认权限为511的目录 rmdir(path) 删除给定path所指向的目录 remove(path) 删除给定path所指向的文件 实例代码 以下是一个比较简陋的关于SFTPClient的测试代码 12345678910111213141516171819202122232425import paramikodef connecnt(hostname,username,password): #创建连接对象 client = paramiko.Transport( (hostname,22)) try: client.connect(username=username,password=password) except paramiko.SSHException: return None sftp_client = paramiko.SFTPClient.from_transport(client) return sftp_clientdef main(): hostname = '192.168.0.104' username = 'pi' password = '123456' sftp_client = connecnt(hostname,username,password) remotefile_path = '/home/pi/test' # 目标主机文件路径 localfile_path = '/home/test' # 本地主机文件路径 sftp_client.put(localfile_path, remotefile_path) #上传本地test文件到远程 sftp_client.get(remotefile_path, localfile_path) #下载远程test文件到本地 print(sftp_client.listdir()) print('--------------------') print(sftp_client.lstat(remotefile_path)) print('--------------------') with sftp_client.open(remotefile_path) as fp:","categories":[{"name":"Linux","slug":"Linux","permalink":"https://cy-blogs.cn/categories/Linux/"}],"tags":[{"name":"Paramiko","slug":"Paramiko","permalink":"https://cy-blogs.cn/tags/Paramiko/"}]},{"title":"Ansible","slug":"Ansible","date":"2019-12-10T12:35:38.500Z","updated":"2019-12-10T12:35:24.192Z","comments":true,"path":"Ansible/","link":"","permalink":"https://cy-blogs.cn/Ansible/","excerpt":"Ansible ansible基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能在使用时，ansible不需要在被控制安装客户端，ansible工作基于ssh，只要被控制端服务器有ssh服务，加上一个Python环境，就可以使用ansible另外，ansible在15年的时候，以1.5亿美元被RedHat公司收购，新版的RedHat操作系统内置ansible软件，很厉害的","text":"Ansible ansible基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能在使用时，ansible不需要在被控制安装客户端，ansible工作基于ssh，只要被控制端服务器有ssh服务，加上一个Python环境，就可以使用ansible另外，ansible在15年的时候，以1.5亿美元被RedHat公司收购，新版的RedHat操作系统内置ansible软件，很厉害的 ##Ansible部署 ansible安装可以通过源码，yum源以及python所提供的pip管理工具进行安装 使用pip管理工具进行安装 1pip3 install ansible 使用yum进行安装 12yum install epel-release # 安装扩展源yum install ansible Ansible配置 安装之后，默认ansible工具的配置文件在/etc/ansible下 如通过pip命令安装，是没有这个目录的，需要我们手动创建，其中所需主要配置文件如下 ansible.cfg：ansible主配置文件 hosts：被管理主机IP或者主句名列表文件，也是比较重要的一个文件 roles：角色或插件目录（默认为空） 此外除了默认的ansible的配置文件路径，关于ansible的配置文件路径选择还有如下几种，按照序列表示优先级 export ANSIBLE_CONFI：指定的全局变量 ./ansible.cfg：当前目录下的配置文件 ~/.ansible.cfg：当前用户目下的配置文件 /ext/ansible/ansible.cfg：etc目录下的配置文件 如果以上四个路径下均没有cfg配置文件，则使用默认配置 如果通过源码进行安装，那么在/etc/ansible目录下会自动包含ansible.cfg文件 也可以通过访问在线的配置文件地址进行获取 https://raw.githubusercontent.com/ansible/ansible/devel/examples/ansible.cfg ansible配置文件中可以进行ansible的各项参数的设置，包括并发线程数量、用户、模块路径、调优等等 defaluts：默认的配置项，一般不需要修改 privilege_escalation：执行命令的用户权限设置 paramiko_connection：paramiko插件设置 ssh_connection：ssh连接设置 默认ansible使用hosts文件列举监控主句，格式为ini，可以进行IP的分组以及IP规则设置，比如如下的例子 12[webserver]192.168.1.1001:22 ansible支持很多模块来进行对被控制主机的管理，包括：command、shell、script、yum、copy、File、async、docker、cron、mysql_user、ping、sysctl、user、acl、add_host、easy_install、haproxy等。默认在执行命令时，使用模块为、command，接下来会进行介绍 Ansible使用参数 ansible在工作时，需要使用我们安装好的、ansible来执行命令 经常在使用、ansible模块进行工作时，可能还需要额外提供一些参数来辅助工作，下面是常用参数 命令参数 解释 -v 打印详细信息 -m 指定使用的模块，默认为 command模块 -k 要求输入远程主机密码 -a 将参数或命令传入模块 -c 测试执行过程，但不真正执行 -sudo 基于 sudo用户执行 --list-hosts 列举命令生效的主机 -l 限制匹配规则的主机数 -i 指定 hosts文件路径 -u SSH 连接所使用用户 现在看到这些命令参数你可能有一些懵，不过不要着急，结合模块使用，你将很快了解这些参数的实际意义 配置免密登陆 由于 ansible是通过 ssh 服务进行命令下达执行，那避免不了用户认证 但是在批量执行时，多次的重复认证会导致我们的效率极其低下，这里可以通过配置主控端与被控端知己之间 SSH 免密登陆来实现用户认证的跳过，可谓是一次配置，轻松很久 在主控服务器 192.168.1.104 下生成密钥 12ssh-keygen -t rsa# -t 指定加密的方式，默认为rsa 进行秘钥的分布 1ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.1.101 输入对应远程主机的 ssh 账号密码之后，接下来在主控服务器就可以不进行 SSH 的用户认证也可以访问到被控制端，这里测试主机为 192.168.1.104 （主控）， 192.168.1.101 （被控） 定义主机及组规则 ansible 通过定义好的主句以组规则（Inventory） 在执行命令时通过匹配进行远程操作 这个文件默认就是我们上面所说的 /etc/ansible/hosts 文件，其中定义的几种方式如下 直接 IP 写入 1192.168.1.101 规则分组 123[webserver]192.168.1.101:2333www.example.com 可以在规则的 IP 后指定端口 规则命名 123myhost ansible_ssh_host=192.168.1.101[webservers]myhost 在使用时，直接利用myhost即可 除去示例中的指定方式，还有如下一些参数可以利用 ansible_ssh_host：目标主机地址 ansible_ssh_port：目标主机ssh服务端口 ansible_ssh_user：目标主机ssh登录用户 ansible_ssh_pass：目标主机ssh登录密码 ansible_connection：连接类型：local、ssh、paramiko ansible_ssh_priveate_key_file：连接所需ssh私钥文件； ansible_shell_type：目标主机的shell类型：ash、bash（默认使用的shell，可以结合help查看帮助文档）、ksh（支持42个内部命令）、csh、zsh（最庞大的shell，支持84个内部命令） 正则规则 1[webservers][a:z]bc.example.com192.168.1.10[1:5] 在主机处填写对应的正则规则，可以更加方便的映射某个网段下的ip地址 Ping模块 ping模块可以判断被控主机是否在线， 返回值为changed和ping 首先在/etc/ansible/hosts文件下添加被控主机，并建立分组为webservers 1[webservers]192.168.1.101:22 ping命令的用法，要进入到python安装目录下，找到对应的ansible可执行文件 1./ansible all -m ping 返回值ping如果为pong则代表可以ping通 ansible命令行第二个参数可以是一个主机的正则规则，all代表所有hosts文件下IP，也可以指定使用某个分组 1./ansible webservers -m ping Command模块 通过ansible执行命令时，默认使用command模块，该模块主要用于执行linux基础命令 注意：对比之后的Shell及Script功能模块，Command模块不支持管道 command支持的额外参数 1./ansible-doc -s command# 文档 参数 解释 chdir 执行命令时，先进入到该目录下 creates 给定文件存在时，不执行该命令 free_form 需要执行的脚本 removes 给定文件存在，则执行该命令 对远程主机执行命令 1./ansible webservers -m command -a \"ifconfig\" 执行命令时更改工作目录 1./ansible webservers -m command -a \"ls chdir=/home/\" Shell模块 shell使用远程主机下的/bin/sh进行命令执行，支持比command模块更多的命令，常用参数如下 1./ansible-doc -s shell# 文档 额外参数 参数 解释 chdir 执行命令时，先进入到该目录下 creates 给定文件存在时，不执行该命令 free_form 需要执行的脚本 removes 给定文件存在，则执行该命令 executable 更换执行命令所使用的shell环境 远程主机编写sh脚本，向屏幕输出hello 1echo \"hello\" 执行远程主机的shell脚本 1./ansible webservers -m shell -a \"sh ~/test.sh\" Script模块 该模块可以方便运行当前管理机上的脚本直接到远程被控端，而不需要先将脚本拷贝到远程主机后在执行 在主控制home目录下创建sh脚本 1echo \"this is Control\" 将这个sh脚本通过script模块执行到远程被控端 1./ansible webservers -m script -a \"/root/test.sh\" Copy模块 copy模块可以方便的将当前主机下文件拷贝到远程主机，类似scp命令等 1./ansible-doc -s copy# 文档地址 支持的参数 参数 解释 src 将本地路径复制到远程服务器; 可以是绝对路径或相对的。如果是一个目录，它将被递归地复制。如果路径以/结尾，则只有该目录下内容被复制到目的地，如果没有使用/来结尾，则包含目录在内的整个内容全部复制 content 当用content代替src参数的时候，可以把文档的内容设置到特定的值 dest 目标绝对路径。如果src是一个目录，dest也必须是一个目录。如果dest是不存在的路径，并且如果dest以/结尾或者src是目录，则dest被创建。如果src和dest是文件，如果dest的父目录不存在，任务将失败 backup 如果文件修改，则在覆盖之前将原文件备份，备份文件包含时间信息 directory_mode 设定目录的权限，在新建时使用，不会影响已存在的目录 force 当目标内容不同于源时，将替换远程文件。设置为no时，只有在目标文件不存在的情况下才会传输文件 group 设置文件/目录的所属组 mode 设置文件权限 owner 设置文件/目录的所属用户 Copy前备份1./ansible all -m copy -a \"src=/root/ansible_copy_file backup=yes dest=/home/\" 在第一次拷贝时，由于目标主机还并没有这个文件， 备份动作不生效 在对文件内容进行修改后重新执行该命令拷贝文件 此时目标主机下，不光会有我们上传的拷贝文件，还有之前文件的一个备份 覆盖内容 直接通过content参数指定内容，并对目标主机上已存在的test_copy文件进行覆盖 1./ansible all -m copy -a \"content='这是命令修改\\n' dest=/home/test_copy\" 这条命令将会把远程主机home目录下的test_copy文件覆盖为我们的content内容 Stat模块 该模块可以获取远程主机下的文件信息，需要使用path参数指明文件路径 1./ansible all -m stat -a \"path=/home/test_copy\" Yum模块 该模块可以对远程主机上的软件安装、卸载进行管理 1./ansible-doc -s copy# 文档 支持参数 参数 解释 name 必须参数，用于指定需要管理的软件包，比如nginx state 用于指定软件包的状态，默认值为present，表示确保软件包已经安装 除了present，其他可用值有installed、latest、absent、removed 其中installed与present等效，latest表示安装yum中最新的版本，absent和removed等效，表示删除对应的软件包 在远程主机下安装nginx 1./ansible all -m yum -a \"name=nginx state=installed\" 查看nginx服务状态 1systemctl status nginx Service模块 该模块主要用于远程服务器上对应的服务管理，比如开启或关闭apache服务等 1./ansible-doc -s yum# 文档 支持参数 参数 解释 name 需要管理的服务名称，如nginx state 此参数用于指定服务的状态 比如，我们想要启动远程主机中的nginx，则可以将state的值设置为started 如果想要停止远程主机中的服务，则可以将state的值设置为stopped 此参数的可用值有started、stopped、restarted、reloaded enabled 此参数用于指定是否将服务设置为开机启动项，设置为yes表示将对应服务设置为开机启动，设置为no表示不会开机启动 将远程主机下的httpd服务开启 1./ansible all -m service -a \"name=httpd state=started\" File模块 file模块可以帮助我们完成一些对文件的基本操作 比如，创建文件或目录、删除文件或目录、修改文件权限等 1./ansible-doc -s yum# 文档 支持参数 参数 解释 path 指明需要操作的文件或目录路径 state 此参数非常灵活，其对应的值需要根据情况设定。比如，我们想要在远程主机上创建/testdir/a/b目录，那么则需要设置path=/testdir/a/b，但是，我们无法从/testdir/a/b这个路径看出b是一个文件还是一个目录，ansible也同样无法单单从一个字符串就知道你要创建文件还是目录，所以，我们需要通过state参数进行说明 当我们想要创建的/testdir/a/b是一个目录时，需要将state的值设置为directory，directory为目录之意，当它与path结合，ansible就能知道我们要操作的目标是一个目录 当我们想要操作的/testdir/a/b是一个文件时，则需要将state的值设置为touch 当我们想要创建软链接文件时，需将state设置为link；想要创建硬链接文件时，需要将state设置为hard 当我们想要删除一个文件时（删除时不用区分目标是文件、目录、还是链接），则需要将state的值设置为absent，absent为缺席之意，当我们想让操作的目标”缺席”时，就表示我们想要删除目标 src src参数：当state设置为link或者hard时，表示我们想要创建一个软链或者硬链 所以，我们必须指明软链或硬链链接的哪个文件，通过src参数即可指定链接源 force 当state=link的时候，可配合此参数强制创建链接文件，当force=yes时，表示强制创建链接文件。不过强制创建链接文件分为三种情况 情况一：当要创建的链接文件指向的源文件并不存在时，使用此参数，可以先强制创建出链接文件 情况二：当要创建链接文件的目录中已经存在与链接文件同名的文件时，将force设置为yes，会将同名文件覆盖为链接文件，相当于删除同名文件，创建链接文件 情况三：当要创建链接文件的目录中已经存在与链接文件同名的文件，并且链接文件指向的源文件也不存在，这时会强制替换同名文件为链接文件 owner 指定文件所属用户 group 指定文件所属组 mode 指定文件权限 将远程主机下的Python3创建软连接到home目录 1./ansible all -m file -a \"path=/home/python3 state=link src=/usr/local/python3/bin/python3\"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://cy-blogs.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cy-blogs.cn/tags/Linux/"}]},{"title":"GitHub操作","slug":"Git","date":"2019-12-09T11:56:21.542Z","updated":"2019-12-09T11:58:51.734Z","comments":true,"path":"Git/","link":"","permalink":"https://cy-blogs.cn/Git/","excerpt":"GitHub操作起来真的是太简单啦！Git Git是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务。 Git易于学习， 占地面积小，具有闪电般快速的性能。它超越了Subversion，CVS，Perforce和ClearCase等SCM工具，具有廉价本地分支，便捷的临时区域和多个工作流程等功能","text":"GitHub操作起来真的是太简单啦！Git Git是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务。 Git易于学习， 占地面积小，具有闪电般快速的性能。它超越了Subversion，CVS，Perforce和ClearCase等SCM工具，具有廉价本地分支，便捷的临时区域和多个工作流程等功能 git流程 workspace：工作区 Index/Stage：暂存区 Repository：仓库区/本地仓库 Remote：远程仓库 SVN与Git的区别 SVN SVN是集中式版本控制系统，版本库是集中放在中央服务器的、而干活的时候，用的都是自己的电脑 首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器 集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了 Git Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库 这工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了 Git在本地磁盘上就保存着所有有关当前项目的历史更新，并且Git中的绝大多数操作都只需要访问本地文件和资源，不用连网，所以处理起来速度飞快 用SVN的话，没有网络或者断开VPN你就无法做任何事情 但用Git的话，就算你在飞机或者火车上，都可以非常愉快地频繁提交更新，等到了有网络的时候再上传到远程的镜像仓库。换作其他版本控制系统，这么做几乎不可能，抑或是非常麻烦 安装git Windows：https://git-scm.com/downloads Linux： Git配置 git config --global：全局git配置，这台机器所有的Git仓库均会使用这个配置 12git config --global user.name \"eastside\" # 你的名字git config --global user.email \"..@xx.com\" # 你的邮箱 git操作创建版本库 什么是版本库？ 版本库又名仓库，英文名repository 你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件还原 选择，进入某个目录 1mkdir projectcd project 初始化目录为本地仓库 1git init 初始化之后，目录下会多一个隐藏目录.git，该目录是git用来管理版本的， 添加项目文件 以创建django项目为例，在git本地仓库开启一个django项目 1django-admin startproject testpro 添加项目文件或目录至暂存区 1git add testpro 将暂存区内容提交至本地仓库 12git commit -m \"a django project\"$ git commit -m \"a django project\"[master (root-commit) adb00b3] a django project 5 files changed, 172 insertions(+) create mode 100644 testpro/manage.py create mode 100644 testpro/testpro/__init__.py create mode 100644 testpro/testpro/settings.py create mode 100644 testpro/testpro/urls.py create mode 100644 testpro/testpro/wsgi.py -m参数指定提交注释 查看此时仓库状态 12git statuslienze@DESKTOP-BIDA1PF MINGW64 ~/Desktop/project (master)$ git statusOn branch masternothing to commit, working tree clean 文件修改提交 如果在开发过程中，对其中的某个文件进行了修改，那么git在对比文件指纹的过程中发现了差异，此时也需要将新修改的文件进行提交 修改settings.py文件配置 1ALLOWED_HOSTS = [\"*\",]# ALLOWED_HOSTS = [] 查看仓库状态 12git status$ git statusOn branch masterChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: settings.pyno changes added to commit (use \"git add\" and/or \"git commit -a\") 此时仓库说，modified: settings.py，我们对其中某个文件进行了修改 将修改之后的文件加入暂存区 1git add -A 此时查看状态 12git status$ git statusOn branch masterChanges to be committed: (use \"git reset HEAD &lt;file&gt;...\" to unstage) modified: settings.py 将暂存区的内容提交至本地仓库 12git commit -m 'change settings'On branch masternothing to commit, working tree clean 丢弃修改，可以丢弃工作区对于文件的修改 1git checkout -- settings.py 注意：命令git checkout -- settings.py中的--很重要，如果没有--的话，那么命令变成创建分支了 文件删除提交 在django项目的隔壁创建一个1.py文件 1touch 1.py 添加该文件 1git add -Agit commit -m \"add 1.py\" 删除该文件 1rm 1.py 恢复删除文件 1git checkout -- 1.py 提交至本地工作区 1git commit -a -m \"rm 1.py\" git commit -a：提交全部修改 git远程仓库 在团队开发中，我们需要每个开发者彼此配合，对同一款项目代码进行编写，此时需要我们借助线上仓库 github：https://github.com gitee：https://gitee.com 由于网络环境，此处选择gitee 将远程仓库添加到本地 1git remote add edu git@gitee.com:eastside/edu.git 添加一个远程库，库名为edu，地址是git@gitee.com:eastside/edu.git 列举当前所有的远程库 1git remote 删除某个远程库 1git remote remove edu 将本地的仓库推到名为edu的远程仓库中 1# 仓库地址：https://gitee.com/eastside/edu.gitgit push edu master 将远程仓库的代码拉取到本地，在第一次拉取时，可能因为缺少远程服务器上的README.txt文件，而导致远程和本地的分支不一样，通过以下命令 12git pull --rebase origin master # 新建 README文件git pull edu master --allow-unrelated-histories 将远程仓库克隆到本地 1git clone https://gitee.com/eastside/edu.git 这是一个已经和远程仓库master分支关联的本地仓库 git全局配置多个用户名冲突时 1$ git config --global --replace-all user.email \"输入你的邮箱\" $ git config --global --replace-all user.name \"输入你的用户名\" GIT分支 每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支 截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支 我们可以通过checkout命令进行分支的创建及切换 git checkout -b：创建并切换分支 git branch branchname：创建分支 git checkout branchname：切换分支 创建一个测试分支 1git checkout -b testbranch 删除一个分支 1git branch -d testbranch 提交分支代码 1git push --all 合并分支 1git merge testbranch GIT冲突 常见git冲突造成，是由于在多个分支下，或多个仓库中，对同一个文件修改，或添加了新的文件之后 由于某一方对于文件的修改没有及时在另一方生效，当另一方或另一分支在进行提交时，即会出现冲突 在testbranch分支下，修改1.py文件，并提交到云仓库 在master分支下，也修改1.py文件，并尝试提交 此时冲突出现，使用git status命令查看当前仓库状态 查看被修改的文件1.py Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt; testbranch是指fenzhi1上修改的内容，我们可以将差异部分的标注删掉重新提交，或是与对方协商，另行拷贝文件内容，重新clone仓库，将拷贝过的内容添加至内 之后再进行提交 1git add 1.pygit commit -m \"conflict fixed\" 这样就可以搞定了","categories":[{"name":"Git","slug":"Git","permalink":"https://cy-blogs.cn/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://cy-blogs.cn/tags/Git/"}]},{"title":"Vue-Cli","slug":"Vue-Cli","date":"2019-12-09T11:52:36.348Z","updated":"2019-12-09T11:54:42.448Z","comments":true,"path":"Vue-Cli/","link":"","permalink":"https://cy-blogs.cn/Vue-Cli/","excerpt":"组件开发自动化工具 Node.js是一个新的后端(后台)语言，它的语法和JavaScript类似，所以可以说它是属于前端的后端语言 运行环境：后端语言一般运行在服务器端，前端语言运行在客户端的浏览器上 功能：后端语言可以操作文件，可以读写数据库，前端语言不能操作文件，不能读写数据库。","text":"组件开发自动化工具 Node.js是一个新的后端(后台)语言，它的语法和JavaScript类似，所以可以说它是属于前端的后端语言 运行环境：后端语言一般运行在服务器端，前端语言运行在客户端的浏览器上 功能：后端语言可以操作文件，可以读写数据库，前端语言不能操作文件，不能读写数据库。 Node.js如果安装成功，可以查看Node.js的版本,在终端输入如下命令 12node -vnpm 全局安装vue脚手架，vue-cli，这玩意儿可以自动生成项目模板 12vue-clicnpm install --global vue-cli 单页应用 SPWA 单页Web应用（single page web application，SPWA），就是将系统所有的操作交互限定在一个web页面中。 单页应用程序 (SPA)是加载单个HTML页面，系统的不同功能通过加载不同功能组件的形式来切换，不同功能组件全部封装到了js文件中，这些文件在应用开始访问时就一起加载完； 整个系统在切换不同功能时，页面的地址是不变的，系统切换可以做到局部刷新，也可以叫做无刷新，这么做的目的是为了给用户提供更加流畅的用户体验 通过vue-cli脚手架开启一个项目： 1vue init webpack myproject 12345678910111213141516171819202122232425262728- Project name: 项目名称，如果不需要就直接回车。注：此处项目名不能使用大写。- Project description: 项目描述，直接回车- Author：作者- vue build: 构建方式 默认即可- install vue-router? 是否安装vue的路由插件- Use ESLint to lint your code? 是否使用ESLint检测你的代码？ （ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。） - Pick an ESLint preset:选择分支风格 1.standard(https://github.com/feross/standard) js的标准风格 2.Airbnb(https://github.com/airbnb/javascript) JavaScript最合理的方法，这个github 地址说是JavaScript最合理的方法 3.none (configure it yourself) 自己配置 - Setup unit tests? 是否安装单元测试- Pick a test runner 选择一个单元测试运行器 1.Jest（Jest是由Facebook发布的开源的、基于Jasmine的JavaScript单元测试框架） 2.Karma and Mocha 3.none - Setup e2e tests with Nightwatch(Y/n)?是否安装E2E测试框架NightWatch （E2E，也就是End To End，就是所谓的“用户真实场景”。） - Should we run 'npm install' for you after the project has been created?项目创建后是否要为你运行“npm install”? yes,use npm(使用npm) yes,use yarn(使用yarn) no,I will handle that myself(自己操作) 启动开发服务器： 123cd myproject # 进入目录cnpm install # 安装依赖cnpm run dev # 开启服务 vue启动服务之后，是通过一个小型的express服务进行测试开发环境部署，在这个服务中，主要是通过webpack-dev-middleware和webpack-hot-middleware这两个中间件完成，并且会在每次代码对于src目录下的代码进行修改时，服务端会动态检测并让浏览器自动刷新 项目目录介绍 123456- src # 主开发目录，所有的单文件组件都会放在这个目录下- static # 项目静态目录，所有的css、js都会放在这个文件夹下- dist # 项目打包发布文件夹，最后要上线单文件夹项目都在这个文件夹中- node_modules # node的包目录- config # 配置目录，主要用于区分开发环境，测试环境，线上环境的不同- build # 项目打包时依赖的目录 组件开发 将一个组件相关的html结构，css样式，以及交互的JavaScript代码从html文件中剥离出来，合成一个文件，这种文件就是单文件组件，相当于一个组件具有了结构、表现和行为的完整功能，方便组件之间随意组合以及组件的重用，这种文件的扩展名为.vue，比如：menu.vue 组件文件一般定义在src目录下的components文件夹里 template标签定义HTML部分 12345678&lt;teamplate&gt; &lt;div class=&quot;&quot; @click=&quot;&quot;&gt; &lt;label&gt; 账号 &lt;input type=&quot;text&quot;&gt; &lt;/label&gt; &lt;/div&gt;&lt;/teamplate&gt; js写成模块导出的形式 123456789// 使用export default命令，为模块指定默认输出export default&#123; data: function()&#123; return &#123; name:&quot;张三&quot;, age:16, &#125; &#125;&#125; 样式中的编写，如果含有scope关键字，表示这些样式是组件局部的， 12345678&lt;style scoped&gt;.beauty&#123; width:100px; line-height:50px; border-bottom:1px solid #ddd; margin:0px auto;&#125;&lt;/style&gt; 路由配置 当拥有一个组件文件时，要在项目的src目录下的router目录下的index.js文件下 进行组件的路由加载配置 在导入组件文件时，可以使用@符号，代表从src目录起 比如：import index from ‘@/components/index’ 123456789101112131415161718192021import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import HelloWorld from &apos;@/components/HelloWorld&apos;import first from &apos;@/components/first&apos; // 从组件目录下导入组件文件，不需要加后缀import index from &apos;@/components/index&apos;Vue.use(Router)export default new Router(&#123; mode: &apos;history&apos;, routes: [ &#123; path: &apos;/&apos;, component: index, &#125;, &#123; path: &apos;/first&apos;, // 访问路径 component: first &#125; ] &#125;) 当配置好路由之后，需要在最主要的App.Vue文件下进行连接引入 通过&lt;router-link to=&quot;连接地址&quot;&gt;首页&lt;/router-link&gt;标签进行连接引入 通过&lt;router-view&gt;&lt;/router-view&gt;标签进行路由加载，可以简写为：&lt;router-view/&gt; 12345678910111213&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/first&quot;&gt;第一个页面&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在App.Vue文件下的template标签处如果已经引入了其他跳转连接； 那么在子组件的template部分不需要在进行引入 总结 编写components组件 index.js配置路由 在主入口App.vue中加载路由组件&lt;router-view/&gt;，一般默认已经写好","categories":[{"name":"Vue","slug":"Vue","permalink":"https://cy-blogs.cn/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://cy-blogs.cn/tags/Vue/"}]},{"title":"Vue","slug":"Vue","date":"2019-12-09T11:52:36.346Z","updated":"2019-12-09T11:54:39.026Z","comments":true,"path":"Vue/","link":"","permalink":"https://cy-blogs.cn/Vue/","excerpt":"VUE Vue.js是前端三大新框架：Angular.js、React.js、Vue.js之一，Vue.js目前的使用和关注程度在三大框架中稍微胜出，并且它的热度还在递增 Vue的核心库只关注视图层，Vue的目标是通过尽可能简单的API实现响应的数据绑定，在这一点上Vue.js类似于后台的模板语言 Vue也可以将界面拆分成一个个的组件，通过组件来构建界面，然后用自动化工具来生成单页面(SPA - single page application)系统","text":"VUE Vue.js是前端三大新框架：Angular.js、React.js、Vue.js之一，Vue.js目前的使用和关注程度在三大框架中稍微胜出，并且它的热度还在递增 Vue的核心库只关注视图层，Vue的目标是通过尽可能简单的API实现响应的数据绑定，在这一点上Vue.js类似于后台的模板语言 Vue也可以将界面拆分成一个个的组件，通过组件来构建界面，然后用自动化工具来生成单页面(SPA - single page application)系统 Vue.js官方文档： https://cn.vuejs.org/v2/guide/ vue.js下载地址： https://cn.vuejs.org/v2/guide/installation.html npm配置cnpm windows下配置cnmp环境： 默认的使用NPM可能会因为网络问题而导致无法使用或延迟居高，可以使npm升级为cnpm，从国内淘宝镜像中加载所需的npm软件源 1npm install -g cnpm --registry=https://registry.npm.taobao.org 设置安装包缓存路径 1cnpm config set cache \"C:\\nodejs\\node_cache\" 设置安装包位置 1cnpm config set prefix \"C:\\nodejs\\node_global\" 之后使用命令安装的模块存储在C:\\nodejs\\node_global\\node_modules里 请按照个人需求设置你的文件位置 1npm config set cache \"C:\\nodejs\\node_cache\" Vue部署 安装Vue 1cnpm install vue -g 安装vue脚手架 1cnpm install vue-cli -g -g参数代表全局位置安装，这样可以在环境变量生效的情况下直接在命令行等工具下使用vue命令行进行项目的开启 vue-devtools调试工具 vue-devtools可以方便开发者进行Vue中变量等信息的调试跟踪 下载vue-devtools 1git clone https://github.com/vuejs/vue-devtools 进入到vue-devtools目录下安装依赖包 123cd vue-devtools-devcnpm install cnpm run build 注意：在进行调试工具安装时，首先需要修改shells&gt;chrome文件夹下的mainifest.json中的persistent为true 将插件目录下的chrome文件夹拖入到chrome浏览器的扩展程序下，记得打开调试模式 扩展程序可以通过浏览器访问 1chrome://extensions/ Vue-CDN 除去通过npm安装的方式来使用vue，还可以直接使用cdn中的vue.js文件 vue.js：开发版本，包含了有帮助的命令行警告 1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; vue.min.js：生产环境版本，优化了尺寸和速度 1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; Vue语法 每个vue应用都是通过实例化一个新的vue对象开始的 创建第一个模板语法： 1234&lt;div id=\"content\"&gt; &#123;&#123; message &#125;&#125; &lt;!-- 这个也叫做插值表达式 --&gt;&lt;/div&gt; 1234567var vm = new Vue(&#123; // vm这个变量不允许使用连字符，可以使用下划线，比如vm-data是不允许的 el: &quot;#content&quot;, // 对应document中的一个标签，当vue对象创建后，这个标签内的区域就被接管 data: &#123; message: &quot;这是vue里的变量&quot; &#125;&#125;) 当一个vue实例被创建时，vue的响应式系统中加入了对其data对象中能找到的所有属性 当这些属性值被改变时，视图也会发生相应，并将对应属性更新为新的值 也可以通过定义函数来改变实例中data对象中的数据，数据改变，视图中的数据也将改变 12345&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;ChangeMsg&quot;&gt;改变&lt;/button&gt; &lt;!-- 绑定点击事件为定义好的vue函数 --&gt;&lt;/div&gt; 1234567891011121314window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &quot;我对应的是message的变量&quot; &#125;, methods:&#123; // 定义一个函数 并绑定在按钮的点击事件上 ChangeMsg:function()&#123; this.message = &quot;我被改变了&quot;; // 修改当前实例中的message变量 &#125; &#125; &#125;)&#125; 这里的代码，将在点击按钮时，使当前的message变量发生变化 ``这样的语法有点类似一些Web框架，比如django的模板语言中的模板变量 返回值 除了直接定义某个变量的固定值进行页面渲染，模板变量还支持通过函数的返回值进行赋值 12345&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123; classType &#125;&#125;学习&lt;/h1&gt; &lt;p&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt; &lt;span&gt;&#123;&#123; describe() &#125;&#125;&lt;/span&gt;&lt;/div&gt; 1234567891011121314window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#app&quot;, // getElementById(&apos;app&apos;) data: &#123; classType: &quot;vue&quot;, content: &quot;这是vue的一个测试&quot;, &#125;, methods:&#123; describe:function()&#123; return &quot;这是一个函数的返回值&quot; &#125;, &#125; &#125;)&#125; Vue模板指令 模板语法指的是如何将数据放入html中 Vue.js使用了基于HTML的模板语法，允许开发者声明式地将DOM绑定至底层 Vue 实例的数据 所有 Vue.js的模板都是合法的 HTML ，所以能被遵循规范的浏览器和HTML 解析器解析 插入值，模板变量 数据绑定最常见的形式就是使用Mustache语法(双大括号) 的文本插值，也就是上面示例中的`` 内容绑定v-html 将内容按照html格式进行插入 123&lt;div id=&quot;app&quot;&gt; &lt;p v-html=&quot;contetn&quot;&gt;&lt;/p&gt;&lt;/div&gt; 123456var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; content: &quot;&lt;b&gt;段落标签&lt;/b&gt;文本内容&quot; &#125;,&#125;) 在网站上动态渲染任意HTML是非常危险的，因为容易导致XSS攻击 v-html一般只用在可信内容中，永不用在用户提交的内容上 v-text 将内容按照文本格式进行插入，但会覆盖原有标签内的内容，不会有加载的闪烁问题 12345678&lt;div id=&quot;app&quot;&gt; &lt;p v-text=&quot;contetn&quot;&gt;&lt;/p&gt; &lt;p&gt; &#123;&#123; gender ? &apos;男&apos; : &apos;女&apos; &#125;&#125; &lt;!-- ok? true:false --&gt; &lt;/p&gt; &lt;/div&gt; 1234567var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; gender: true, // 变量值为true时，显示模板变量中左边的值 content: &quot;&lt;b&gt;段落标签&lt;/b&gt;文本内容&quot; &#125;,&#125;) v-cloak 解决使用差值表达式时页面渲染过程，由于变量没有初始化而导致的闪烁问题 通俗的来说，比如变量的实际内容没有被创建，那么此时页面只会展示出这样的效果，之后当变量初始化之后，``将变化为实际的值，此时变化的过程我们称作闪烁 这个指令可以隐藏未编译的标签直到实例准备完毕 123456789101112&lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &quot;#app&quot;, data:&#123; message: &quot;测试&quot;, &#125; &#125;)&lt;/script&gt; 在上面的代码中，如果网速够慢的清空下，页面首先加载显示出的内容是`` 解决办法：通过v-clock指令，在使用到模板变量的标签上写入，并设置一个v-clock的类样式 12345&lt;style type=&quot;text/css&quot;&gt; [v-cloak]&#123; display: none; &#125;&lt;/style&gt; 123&lt;div v-cloak id=&quot;app&quot;&gt; &lt;p v-cloak&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt; 属性绑定v-bind 如果我们需要设置的模板变量是一个属性，比如a标签的href属性 12345&lt;div id=&quot;app&quot;&gt; &lt;a v-bind:href=&quot;message&quot;&gt;连接&lt;/a&gt; &lt;a :href=&quot;message +&apos;abc&apos;&quot;&gt;连接&lt;/a&gt; &lt;!-- 属性内的模板变量写法已被移除，使用v-bind:attr 或 :attr --&gt;&lt;/div&gt; 123456var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &quot;https://www.baidu.com&quot; &#125;&#125;) 可以通过v-bind指令或者:的简写对某个dom元素的属性进行绑定 在下面还有更加详细的属性绑定示例 事件绑定v-on 给元素绑定对应事件，以下是对于点击事件的绑定 1234&lt;div id=&quot;app&quot;&gt; &lt;button v-on:click=&quot;show&quot;&gt;按钮&lt;/button&gt; &lt;button @click=&quot;show&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt; 12345678new Vue(&#123; el: &quot;#app&quot;, method: &#123; show: function()&#123; alert(&quot;弹一下&quot;) &#125; &#125;&#125;) 跑马灯效果 这里有一个跑马灯效果可以玩耍 12345&lt;div id=&quot;app&quot;&gt; &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt; &lt;button @click=&quot;start&quot;&gt;开始&lt;/button&gt; &lt;button @click=&quot;stop&quot;&gt;停止&lt;/button&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &quot;这是一个跑马灯&quot;, sT: null, // 定时器实例 &#125;, methods:&#123; work()&#123; this.message = this.message.substring(1) + this.message[0] // 循环定时器所作的事情 &#125;, start()&#123; if (this.sT==null) &#123; // 判断此时是否已有定时器开启 console.log(&quot;开启定时器&quot;) this.sT = setInterval(this.work,400) &#125; else &#123; console.log(&quot;已经开启 不在开启&quot;) &#125; &#125;, stop()&#123; // 关闭定时器 设置定时器变量为null console.log(&quot;关闭定时器&quot;) clearInterval(this.sT) this.sT = null &#125; &#125; 绑定事件修饰符阻止冒泡 比如一个按钮在一个div中，并且按钮和div均有自己的事件，那么此时点击按钮，事件会像冒泡一样从按钮开始一直到div进行触发，.stop修饰符用来阻止默认的事件触发行为 123&lt;div id=&quot;fDiv&quot; @click=&quot;divClick&quot;&gt; &lt;button id=&quot;fBtn&quot; @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt; 12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#fDiv&quot;, // 控制区域 data: &#123;&#125;, methods: &#123; divClick()&#123; console.log(&quot;div被点击了&quot;) &#125;, btnClick()&#123; console.log(&quot;按钮被点击了&quot;) &#125; &#125;, &#125;) &#125;&lt;/script&gt; 通过.stop修饰阻止冒泡 123&lt;div id=&quot;fDiv&quot; @click=&quot;divClick&quot;&gt; &lt;button id=&quot;fBtn&quot; @click.stop=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt; 阻止默认行为 比如像a标签这样的，在点击时他有默认的跳转动作，可以通过.prevent阻止该默认行为 123&lt;div id=&quot;fDiv&quot;&gt; &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent=&quot;aLink&quot;&gt;去百度&lt;/a&gt;&lt;/div&gt; 12345678var vm = new Vue()&#123; el: &quot;#fDiv&quot;, methods:&#123; aLink()&#123; console.log(&quot;连接被点击&quot;) &#125; &#125; &#125; 捕获事件 默认的事件触发处理机制是冒泡机制，capture代表具有该修饰的事件，会优先触发，脱离冒泡顺序； 也可理解为谁有该修饰符，先触发谁的事件 123&lt;div id=&quot;fDiv&quot; @click.capture=&quot;divClick&quot;&gt; &lt;button id=&quot;fBtn&quot; @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt; 12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#fDiv&quot;, // 控制区域 data: &#123;&#125;, methods: &#123; divClick()&#123; console.log(&quot;div被点击了&quot;) &#125;, btnClick()&#123; console.log(&quot;按钮被点击了&quot;) &#125; &#125;, &#125;) &#125;&lt;/script&gt; 自身事件 与capture和冒泡不同，.self只有是自身触发的当前的事件才真正执行处理的回调函数 并且.self只会阻止当前元素的事件触发行为 123&lt;div id=&quot;fDiv&quot; @click.self=&quot;divClick&quot;&gt; &lt;button id=&quot;fBtn&quot; @click.self=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt; 1// 与上同 单次事件 使用.once只触发一次事件函数 1234&lt;div id=&quot;fDiv&quot;&gt; &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent.once=&quot;aLink&quot;&gt;去百度&lt;/a&gt; &lt;!-- 连接无法跳转的阻止事件 只会出现一次 --&gt;&lt;/div&gt; 12345678var vm = new Vue()&#123; el: &quot;#fDiv&quot;, methods:&#123; aLink()&#123; console.log(&quot;连接被点击&quot;) &#125; &#125; &#125; 表单双向绑定v-model 使用v-model指令可以在表单input、textarea以及select元素上创建双向数据绑定 根据表单上的值，自动更新模板变量中的值 v-model会忽略表单的初始值，比如：checked、value、selected，如果需要的话，应该在javascript中首先声明初始值 text1234&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;&lt;/div&gt; 12345678910&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; message: &quot;这是个表单内容&quot;, &#125;, &#125;) &#125;&lt;/script&gt; textarea1234&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt; &lt;textarea v-model=&quot;message&quot;&gt;&lt;/textarea&gt;&lt;/div&gt; 1// 同上 checkbox 单个复选框：数据为绑定为true和false的布尔值 1234&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;checked&quot;&gt;&lt;/h3&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;&lt;/div&gt; 12345678910&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; checked: true, &#125;, &#125;) &#125;&lt;/script&gt; 多个复选框：选中的结果会绑定到同一个数组，将保存的v-model变量创建为数组 123456&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;checked&quot;&gt;&lt;/h3&gt; &lt;input name=&quot;fruit&quot; type=&quot;checkbox&quot; value=&quot;apple&quot; v-model=&quot;checked&quot;&gt;苹果 &lt;input name=&quot;fruit&quot; type=&quot;checkbox&quot; value=&quot;banana&quot; v-model=&quot;checked&quot;&gt;香蕉 &lt;input name=&quot;fruit&quot; type=&quot;checkbox&quot; value=&quot;orange&quot; v-model=&quot;checked&quot;&gt;橘子&lt;/div&gt; 12345678910&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; checked: new Array, &#125;, &#125;) &#125;&lt;/script&gt; radio12345&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;picked&quot;&gt;&lt;/h3&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;junior&quot; v-model=&quot;picked&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;girl&quot; v-model=&quot;picked&quot;&gt;女&lt;/div&gt; 12345678910&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; picked: &quot;哈哈哈哈&quot;, &#125;, &#125;) &#125;&lt;/script&gt; select123456789&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;selected&quot;&gt;&lt;/h3&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;option disabled value=&quot;&quot;&gt;你想去哪&lt;/option&gt; &lt;option value=&quot;山西&quot;&gt;山西&lt;/option&gt; &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 12345678910&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; selected: &quot;&quot;, &#125;, &#125;) &#125;&lt;/script&gt; selects 设置select标签的multiple属性即可设置为多选下拉菜单，按着ctrl键可以多选 12345678&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;selecteds&quot;&gt;&lt;/h3&gt; &lt;select multiple v-model=&quot;selecteds&quot;&gt; &lt;option value=&quot;上衣&quot;&gt;上衣&lt;/option&gt; &lt;option value=&quot;裤子&quot;&gt;裤子&lt;/option&gt; &lt;option value=&quot;鞋&quot;&gt;鞋&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; 12345678910&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; selecteds: new Array, // 多重数据一般都要保存成数组 &#125;, &#125;) &#125;&lt;/script&gt; 修饰符.lazy 默认情况下，v-model在input和textarea表单中进行同步输入框的改动 添加了.lazy修饰符之后，对应的v-model绑定事件触发机制将变为change事件，只有在光标失去焦点时会触发 1234&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt; &lt;input type=&quot;text&quot; v-model.lazy=&quot;message&quot;&gt;&lt;/div&gt; 12345678910&lt;script&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; message: &quot;这是个表单内容&quot;, &#125;, &#125;) &#125;&lt;/script&gt; .number 如果用户希望将输入表单的内容处理为Number类型，可以使用.number给v-model进行修饰；如果表单字符串无法被处理为数字，则返回原始的值 1234&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;typeof message&quot;&gt;&lt;/h3&gt; &lt;input type=&quot;text&quot; v-model.number=&quot;message&quot;&gt;&lt;/div&gt; .trim 使用.trim可以自动过滤输入框的首尾空格 123456&lt;div id=&quot;container&quot;&gt; &lt;input type=&quot;text&quot; v-model.trim=&quot;message&quot;&gt; &lt;br&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &lt;!-- 通过查看另一个表单中同步的缩进 --&gt;&lt;/div&gt; 动态绑定 当某些情况下，无法确定表单中所代表的属性值，可以使用v-bind进行动态绑定，v-model获取到的表单输入此时则是我们定义的v-bind属性值 12345&lt;div id=&quot;container&quot;&gt; &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt; &lt;input type=&quot;radio&quot; v-model=&quot;message&quot; :value=&quot;choiceA&quot;&gt; A &lt;input type=&quot;radio&quot; v-model=&quot;message&quot; :value=&quot;choiceB&quot;&gt; B&lt;/div&gt; 12345678910111213&lt;script&gt; window.onload = function () &#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; message: &quot;&quot;, // 表单绑定变量 choiceA: &quot;Yes!&quot;, // 属性绑定变量，未来不需要修改标签中的value值即可动态修改 choiceB: &quot;No!&quot;, &#125;, &#125;) &#125;&lt;/script&gt; 计算属性 关键词：computed 模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的 在模板中放入太多的逻辑会让模板过重且难以维护 也就是说，某些时候页面中的模板变量如果需要复杂的运算处理，应该使用计算属性，而不是直接在模板位置进行计算。 1234567891011121314151617181920&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; String1:&quot;这是一个字符串&quot;, &#125;, methods: &#123; MreverseString()&#123; return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125; // 定义一个函数进行字符串逆置 &#125;, computed: &#123; CreverseString()&#123; return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125; // 定义一个计算属性进行字符串逆置 &#125; &#125;) &#125;&lt;/script&gt; 12345678&lt;div v-cloak id=&quot;container&quot;&gt; &lt;p&gt;这是一个字符串:&#123;&#123; String1 &#125;&#125; &lt;/p&gt; &lt;p&gt;他的逆置:&#123;&#123; String1.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125;&#125; &lt;/p&gt; &lt;p&gt;他的逆置:&#123;&#123; CreverseString &#125;&#125; &lt;/p&gt; &lt;!-- 计算属性直接写入函数名 --&gt; &lt;p&gt;他的逆置:&#123;&#123; MreverseString() &#125;&#125; &lt;/p&gt; &lt;!-- 普通methods函数调用需加括号 --&gt;&lt;/div&gt; 注意：虽然计算属性和函数都可以达成同样的目的，但是computed会缓存结果，计算属性如果发现依赖的属性message未发生改变，再次访问计算属性不会重复运算函数，而是直接利用已有结果；如果依赖数据发生改动，计算属性函数才会重新运算。 在函数及计算属性中添加日志输出即可看到这个效果： 123456789101112methods: &#123; MreverseString() &#123; console.log(&quot;MreverseString被运算了&quot;) return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125;&#125;,computed: &#123; CreverseString() &#123; console.log(&quot;CreverseString被运算了&quot;) return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125;&#125; 在终端下进行计算属性以及函数的访问即可看到效果。 计算属性SetAttr 默认的计算属性只有获取getattr的方式，我们可以手动为他添加一个setter 1234567891011computed:&#123; CreverseString: &#123; get: function()&#123; return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125; set: function(val)&#123; this.String1 = val.split(&quot;&quot;).reverse().join(&quot;&quot;) // 如果当前的逆置之后字符串为val，那么原本的字符串需要再颠倒一次 &#125; &#125;&#125; 侦听属性 侦听属性的作用是侦听某些属性的变化，从而做相应的操作，进行对数据变化的相应， 侦听属性是一个对象（字典），key值是要监听的元素，值是当监听的元素发生改变时要执行的函数； 监听函数有两个参数，一个是当前值，另一个是变化后的值 比如监听一个变量的变化 1234567891011121314151617&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data:&#123; content: &quot;&quot;, // 表单内容 count: 0, // 记录表单内用户敲了多少次 &#125;, watch:&#123; content:function (oldVal,newVal)&#123; // 只要在文本框输入内容影响到了age数据发生改变，就会触发 this.count += 1 &#125;， &#125;， &#125;) &#125;&lt;/script&gt; 1234&lt;div id=&quot;container&quot;&gt; &lt;p&gt;&lt;label&gt;你敲了:&#123;&#123; count &#125;&#125;次&lt;/label&gt;&lt;/p&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入你的年纪&quot; v-model=&quot;content&quot;&gt;&lt;/div&gt; 属性绑定 使用v-bind:class指令来设置元素的class属性； 属性表达式的类型可以是字符串、对象或数组 数组属性 可以通过为元素绑定一个数组，用来为元素设置单个或多个样式，类名在数组中用单引号 12345678&lt;style type=&quot;text/css&quot;&gt; .fontBold &#123; font-weight: bold; &#125; .fontRed &#123; color: red; &#125;&lt;/style&gt; 123&lt;div id=&quot;container&quot;&gt; &lt;p :class=&quot;[&apos;fontBold&apos;,&apos;fontRed&apos;]&quot;&gt;这是一个段落&lt;/p&gt;&lt;/div&gt; 动态属性 可以通过为元素绑定一个对象，对象的key是样式类，对象的value是true或false来动态切换class 1234567891011121314151617181920&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; flag: true, &#125;, methods: &#123; toggle() &#123; if (this.flag)&#123; // 判断当前toggle变量的属性，对称变换 this.flag = false &#125;else&#123; this.flag = true &#125; &#125; &#125; &#125;) &#125;&lt;/script&gt; 12345&lt;div id=&quot;container&quot;&gt; &lt;p :class=&quot;&#123;fontBold: flag&#125;&quot; @click=&quot;toggle&quot;&gt;这是一个段落&lt;/p&gt; &lt;p :class=&quot;&#123;flag? fontBold:&apos;&apos;&#125;&quot; @click=&quot;toggle&quot;&gt;这是一个段落&lt;/p&gt; &lt;!-- 三元表达式 --&gt;&lt;/div&gt; 样式绑定 使用v-bind:style语法，为元素绑定样式 123&lt;p :style=\"&#123;color:'red','font-weight':'bold'&#125;\"&gt; 一段文字&lt;/p&gt; 也可以在vue的data中定义一个对象，用来描述样式，其中带有连字符的样式属性要加引号 123&lt;div id=&quot;container&quot;&gt; &lt;p :style=&quot;styleObj&quot;&gt;一段文字&lt;/p&gt;&lt;/div&gt; 123456data: &#123; styleObj: &#123; color:&apos;red&apos;, &apos;font-weight&apos;:&apos;bold&apos;, &#125;&#125;, data中的对象也可以通过数组类型绑定到元素上 1234&lt;div id=&quot;container&quot;&gt; &lt;p :style=&quot;[styleObj1,styleObj2]&quot;&gt;一段文字&lt;/p&gt; &lt;!-- 对于js的样式绑定不需要加引号，因为就是一个变量 --&gt;&lt;/div&gt; 12345678styleObj1: &#123; border: &apos;1px solid gray&apos;, width: &apos;100px&apos;,&#125;,styleObj2:&#123; background: &apos;black&apos;, color: &apos;blue&apos;,&#125; 条件渲染 通过条件指令可以控制元素的显示及隐藏，或者说叫做创建和销毁 v-if v-if指令用于条件性的渲染一块内容。这块内容只会在指令的表达式返回truthy值的时候渲染 1234567&lt;div v-cloak id=&quot;container&quot;&gt; &lt;h3 v-if=&quot;oh3&quot;&gt;h3标题&lt;/h3&gt; &lt;p v-if=&quot;gender === &apos;girl&apos;&quot;&gt;你是女的&lt;/p&gt; &lt;p v-else-if=&quot;gender === &apos;boy&apos;&quot;&gt;你是男的&lt;/p&gt; &lt;p v-else&gt;不男不女&lt;/p&gt;&lt;/div&gt; 123456789101112&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data:&#123; oh3:&quot;a&quot;, gender: &apos;other&apos; &#125;, &#125;) &#125;&lt;/script&gt; truthy和ture的区别： 隐含有true属性的变量不可以认为它是true，它不是boolean类型 v-show 与v-if不同的是，v-show 的元素始终会被渲染并保留在DOM中 v-show 只是简单地切换元素的CSS属性 display 1234&lt;div v-cloak id=&quot;container&quot;&gt; &lt;h3 v-if=&quot;oh3&quot;&gt;h3标题&lt;/h3&gt; &lt;h4 v-show=&quot;oh4&quot;&gt;h4标题&lt;/h4&gt;&lt;/div&gt; 123456789101112&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data:&#123; oh3:&quot;1&quot;, // v-if 在该变量不为真时直接消失在document中 oh4:&quot;1&quot;, // v-show 处理不为真的变量条件 绑定元素不会消失 &#125;, &#125;) &#125;&lt;/script&gt; 列表渲染v-for 把一个数组对应为一组元素 用 v-for 指令根据一组数组的选项列表进行渲染 v-for 指令需要使用 item in items 形式的特殊语法，items 是源数据数组并且 item 是数组元素迭代的别名 12345&lt;ol id=&quot;container&quot;&gt; &lt;li v-for=&quot;user in users&quot;&gt; &lt;span&gt;&#123;&#123; user.name &#125;&#125;&lt;/span&gt; &lt;/li&gt;&lt;/ol&gt; 123456789101112131415&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data:&#123; users: [ &#123;name:&quot;张三&quot;,age:18&#125;, &#123;name:&quot;李四&quot;,age:20&#125;, &#123;name:&quot;王五&quot;,age:19&#125;, ] &#125;, &#125;) &#125;&lt;/script&gt; v-for还可以支持将当前循环索引作为渲染时的第二个参数，第二个参数为访问索引位置 123&lt;p v-for=&quot;(user,index) in users&quot;&gt; &#123;&#123; index &#125;&#125;:&#123;&#123; user.age &#125;&#125;&lt;/p&gt; 1234567data:&#123; users: [ &#123;name:&quot;张三&quot;,age:18&#125;, &#123;name:&quot;李四&quot;,age:20&#125;, &#123;name:&quot;王五&quot;,age:19&#125;, ]&#125;, 使用v-for迭代访问一个对象 1234&lt;p v-for=&quot;key in myself&quot;&gt; &#123;&#123; key &#125;&#125; &lt;!-- 当v-for渲染时只有一个参数，此时参数为value值 --&gt;&lt;/p&gt; 1234myself : &#123; name:&quot;赵六&quot;, age:&quot;17&quot;,&#125; v-for支持最多三个参数，同时获取遍历对象的key和value值，以及index索引位置 要注意的是，此时的key和value和python中的顺序是颠倒的，key在后，value在前 123&lt;p v-for=&quot;(value,key,index) in myself&quot;&gt; &#123;&#123; index &#125;&#125;: &#123;&#123; key &#125;&#125; - &#123;&#123; value &#125;&#125;&lt;/p&gt; 1234myself : &#123; name:&quot;孙七&quot;, age:&quot;17&quot;,&#125; v-for进行一段取值 123456&lt;div&gt; &lt;p v-for=&quot;n in 8&quot;&gt; &#123;&#123; n &#125;&#125; &lt;/p&gt; &lt;!-- 1 2 3 4 5 6 7 8 --&gt;&lt;/div&gt; 选项卡练习12345678910&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; choicId: null, &#125; &#125;) &#125;&lt;/script&gt; 12345678910111213141516&lt;style&gt; li&#123; list-style-type: none; border: 3px outset lightgreen; width: 100px; background:lightblue; margin:5px; &#125; li:hover&#123; border: 3px inset gray; cursor: pointer; &#125; [v-cloak]&#123; display: none; &#125;&lt;/style&gt; 123456789101112&lt;div v-cloak id=&quot;container&quot;&gt; &lt;ol list&gt; &lt;li @click=&quot;choicId = 1&quot;&gt;A&lt;/li&gt; &lt;li @click=&quot;choicId = 2&quot;&gt;B&lt;/li&gt; &lt;li @click=&quot;choicId = 3&quot;&gt;C&lt;/li&gt; &lt;li @click=&quot;choicId = 4&quot;&gt;D&lt;/li&gt; &lt;/ol&gt; &lt;p v-show=&quot;choicId == 1&quot;&gt;aaaaaaaaaa&lt;/p&gt; &lt;p v-show=&quot;choicId == 2&quot;&gt;bbbbbbbbbb&lt;/p&gt; &lt;p v-show=&quot;choicId == 3&quot;&gt;cccccccccc&lt;/p&gt; &lt;p v-show=&quot;choicId == 4&quot;&gt;dddddddddd&lt;/p&gt;&lt;/div&gt; js中两个等号和三个等号的区别： ==表示： 如果两边值的类型不同的时候，是要先先进行类型转换后，才能做比较；equality等同 ===表示：不需要做类型转换，如果两边值的类型不同，就表示一定是不等的identity恒等 注意 Vue无法检测到对于数组的索引设置及长度修改以及对于对象属性的删除或添加 但是可以通过以下方式进行属性添加触发状态更新 123Vue.set($vm.Object,&quot;key&quot;,&quot;val&quot;) // 对于对象 这样的添加方式可以触发状态更新Vue.set($vm.Array, index, newVal) // 对于数组 添加元素 触发状态更新// vm.items.splice(newLength) // 设置数组长度 javascript.splice(where, num, [additem1,additem2...] )：删除或添加元素 此外，当v-for与v-if同时使用时，v-for有更高的优先级，这会造成重复遍历得到的元素都要在做一次v-if的判断，如果我们是为了有目的判断当前是否需要渲染这个元素，或是跳过这个循环，可以将v-if放在外层元素，比如template标签中，(template标签无实际意义，默认不展示，但是可以起到包裹作用) 过滤器 Vue.js允许你自定义过滤器，可被用于一些常见的文本，对它们进行格式化 过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持) 过滤器应该被添加在JavaScript表达式的尾部，由管道符号指示 语法 12345&lt;p&gt; &#123;&#123; message | filter &#125;&#125;&lt;/p&gt;&lt;p v-bind:type=&quot;message | filter&quot;&gt; &lt;/p&gt; 过滤器本质上是一个函数，比如我们定义一个将表单输入的内容中所有的字母变大写的过滤器 123456&lt;body&gt; &lt;div v-cloak id=&quot;container&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &lt;p&gt;展示: &#123;&#123; message | toUpper &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 1234567891011121314151617&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; message: &quot;&quot;, &#125;, filters: &#123; toUpper: function (value) &#123; if (!value) return &apos;&apos; // 字符串内容为空 直接返回 console.log(&quot;正在变大小&quot;) return String(value).toUpperCase() &#125; &#125; &#125;) &#125;&lt;/script&gt; 过滤器函数也可以有多个参数 1234&#123;&#123; message | filter(arg1, arg2) &#125;&#125;// message 第一个参数// arg1 第二个参数// arg2 第三个参数 1234&lt;div v-cloak id=&quot;container&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &lt;p&gt;展示: &#123;&#123; message | toLong(&quot;| &quot;,&quot; |&quot;) &#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456filters: &#123; toLong(value,arg1,arg2)&#123; if (!value) return &apos;&apos; return arg1 + value + arg2 &#125;&#125; Vue实例生命周期 每个Vue实例在被创建时都要经过一系列的初始化过程 例如：需要设置数据监听、编译模板、将实例挂载到DOM并在数据变化时更新DOM等 同时在这个过程中会自动运行一些叫做生命周期钩子的函数，我们可以使用这些函数，在实例的不同阶段加上我们需要的代码，实现特定的功能 beforeCreate：数据还没有监听，没有绑定到vue对象实例，同时也没有挂载对象 created：数据已经绑定到了对象实例，但是还没有挂载对象 beforeMount：模板已经编译好了，根据数据和模板已经生成了对应的元素对象，将数据对象关联到了对象的$el属性 $el属性是一个HTMLElement对象，也就是这个阶段，vue实例通过原生的createElement等方法来创建这个html片段，准备注入到我们vue实例指明的el属性所对应的挂载点 mounted： 将$el的内容挂载到了el，相当于我们在jQuery执行了$(el).html($el)，生成页面上真正的dom 上面我们就会发现页面的元素和我们$el的元素是一致的；在此之后，我们能够用方法来获取到el元素下的dom对象，并进行各种操作 beforeUpdate：数据发生变化时调用 updated：由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子 beforeDestroy：Vue实例销毁前 destroyed：Vue实例销毁后 window.$vm.$destroy() 一大段代码进行钩子函数的调用过程监控 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function () &#123; function showData(process, vm) &#123; console.log(process) console.log(&quot;vue数据:&quot;, vm.message) // 当前Vue中的数据 console.log(&quot;Vue挂载el:&quot;) // Vue接管的元素 console.log(vm.$el) console.log(&quot;真实Dom:&quot;) console.log(document.getElementById(&quot;container&quot;).innerHTML) console.log(&apos;-----------------&apos;) &#125; // 这个函数用来输出相关信息的 new Vue(&#123; el: &quot;#container&quot;, data: &#123; message: &quot;aaaaa&quot;, &#125;, beforeCreate: function () &#123; showData(&quot;创建Vue实例前&quot;, this) &#125;, created: function () &#123; showData(&quot;创建Vue实例后&quot;, this) &#125;, beforeMount: function () &#123; showData(&quot;挂载到Dom前&quot;, this) &#125;, mounted: function () &#123; showData(&quot;挂载到Dom后&quot;, this) &#125;, beforeUpdate: function () &#123; showData(&quot;数据发生变化时&quot;, this) &#125;, updated: function () &#123; showData(&quot;数据发生变化后&quot;, this) &#125;, beforeDestroy: function () &#123; showData(&quot;Vue实例销毁前&quot;, this) &#125;, destroyed: function () &#123; showData(&quot;Vue实例销毁后&quot;, this) &#125; &#125;)&#125;&lt;/script&gt; 123&lt;div id=&quot;container&quot;&gt; &lt;p v-html=&quot;message&quot;&gt;&lt;/p&gt;&lt;/div&gt; 组件ES6语法 ES6是JavaScript语言的新版本，它也可以叫做ES2015，之前学习的JavaScript属于ES5，ES6在它的基础上增加了一些语法 ES6是未来JavaScript的趋势，而且vue组件开发中会使用很多的ES6的语法，所以掌握这些常用的ES6语法是必须的 变量声明 let：定义封闭作用域的变量，并且变量只能声明一次 const：定义封闭作用域的常量，并且变量只能声明一次 let和const是新增的声明变量的开头的关键字，在这之前，变量声明是用var关键字 这两个关键字和var的区别是，它们声明的变量没有预解析，无法脱离定义空间使用 let和const的区别是，let声明的是一般变量，const申明的常量，不可修改 12345678910console.log(a) // undefinedconsole.log(b) // b is not definedconsole.log(c) // c is not definedvar a = 1var a = 2let b = 2// let b = 3 // Identifier &apos;b&apos; has already been declaredconst c = 3// const c = 4 // Identifier &apos;c&apos; has already been declaredc = 4 // Assignment to constant variable 箭头函数 可以把箭头函数理解成匿名函数的第二种写法，箭头函数的作用是可以在对象中绑定this 解决了JavaScript中this指定混乱的问题 定义函数的一般方式 123function func()&#123; ...&#125; 匿名赋值创建函数 123var func = function()&#123; ...&#125; 箭头函数的写法 123456var func = (a, b) =&gt; &#123; // 这样的函数在嵌套时，会自动绑定外部作用域下的this&#125;var func = a =&gt; &#123; // 一个参数时，可以省略参数&#125; 123456789101112131415window.onload = function () &#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; message: &quot;abcdef&quot;, &#125;, methods: &#123; show() &#123; console.log(&quot;这是show函数:&quot;, this.message), func = () =&gt; &#123; console.log(&quot;我是内部函数:&quot;, this.message) &#125;, func(), // 调用一下这个内部函数 &#125; &#125; &#125;)&#125; 123&lt;div id=&quot;container&quot;&gt; &lt;button @click=&quot;show&quot;&gt;按钮&lt;/button&gt;&lt;/div&gt; Vue组件 组件Component是Vue.js最强大的功能之一 组件可以扩展HTML元素，封装可重用的代码 所有的Vue组件同时也都是Vue的实例，所以可接受相同的选项对象（除了一些根级特有的选项）并提供相同的生命周期钩子 注册全局组件 注册一个全局组件语法格式如下 123Vue.component(tagName, options)// tagName：组件名// options：配置选项 比如这样一个全局组件 123456789Vue.component(&apos;button_show&apos;, &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;, // 当前组件会需要的数据，定义为函数的返回值 template: &apos;&lt;button @click=&quot;count++&quot;&gt;按钮:&#123;&#123; count &#125;&#125;&lt;/button&gt;&apos; // 组件的标签模板&#125;) 接下来可以在任何Vue接管的元素中使用该组件， 123&lt;div id=&quot;container&quot;&gt; &lt;button_show&gt;&lt;/button_show&gt;&lt;/div&gt; 12345window.onload = function () &#123; var vm = new Vue(&#123; el: &quot;#container&quot;, &#125;)&#125; data必须是函数 组件就是vue的实例，所有vue实例中属性和方法，组件中也可以用 其中data属性必须是一个函数，因为组件会重复使用在多个地方，为了使用在多个地方的组件数据相对独立，data属性需要用一个函数的返回值来将数据处理为不同的每个个体 Prop传递数据 Prop是你可以在组件上注册的一些自定义特性 当一个值传递给一个prop特性的时候，它就变成了那个组件实例的一个属性 为了给组件传递数据，我们可以用一个 props 选项将一些特性值列举在其中 12345678910111213141516171819202122232425&lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&quot;myp&quot;,&#123; props: [&quot;content&quot;,&quot;like&quot;], // 需要两个外界传入的值 template: &quot;&lt;p :class=&apos;like&apos;&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt;&quot; // 组件绑定未来要接受的变量，要用到v:bind &#125;) window.onload = function()&#123; var vm = new Vue(&#123; el: &quot;#container&quot;, data: &#123; content: &apos;这是p段落的文本&apos;, like: &apos;beauty&apos;, // 要传递的变量 &#125; &#125;) &#125;&lt;/script&gt;.beauty&#123; width: 100px; color: red; background: green;&#125;&lt;div id=&quot;container&quot;&gt; &lt;myp :like=&quot;like&quot; :content=&quot;content&quot;&gt;&lt;/myp&gt; &lt;!-- 传递到组件中 --&gt;&lt;/div&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://cy-blogs.cn/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://cy-blogs.cn/tags/Vue/"}]},{"title":"Vue-路由组件","slug":"Vue-路由组件","date":"2019-12-09T11:52:36.344Z","updated":"2019-12-09T11:54:44.642Z","comments":true,"path":"Vue-路由组件/","link":"","permalink":"https://cy-blogs.cn/Vue-路由组件/","excerpt":"Vue-Router Vue-router做路径匹配时支持动态片段、全匹配片段以及查询参数（片段指的是URL中的一部分） 对于解析过的路由，这些信息都可以通过路由上下文对象（从现在起，我们会称其为路由对象）访问。 在使用了vue-router的应用中，路由对象会被注入每个组件中，赋值为this.$route，并且当路由切换时，路由对象会被更新","text":"Vue-Router Vue-router做路径匹配时支持动态片段、全匹配片段以及查询参数（片段指的是URL中的一部分） 对于解析过的路由，这些信息都可以通过路由上下文对象（从现在起，我们会称其为路由对象）访问。 在使用了vue-router的应用中，路由对象会被注入每个组件中，赋值为this.$route，并且当路由切换时，路由对象会被更新 Vue的两种模式 一般单页面应用是(SPA)不会请求页面而是只更新视图 vue-router提供了两种方式来实现前端路由：Hash模式和History模式,可以用mode参数来决定使用哪一种方式 1234export default new Router(&#123; mode: &apos;history&apos;, ...&#125;) hash模式：vue-router默认使用Hash模式，使用 url的hash来模拟一个完整的url；此时url变化时，浏览器是不会重新加载的；Hash(即#)是url的锚点，代表的是网页中的一个位置，仅仅改变#后面部分，浏览器只会滚动对应的位置，而不会重新加载页面。#仅仅只是对浏览器进行指导，而对服务端是完全没有作用的！它不会被包括在http请求中，故也不会重新加载页面。同时hash发生变化时，url都会被浏览器记录下来，这样你就可以使用浏览器的后退了 History模式：如果你不喜欢hash这种#样式，可以使用history模式。这种模式利用了HTML5 History新增的pushState()和replaceState()方法。除了之前的back，forward，go方法；这两个新方法可以应用在浏览器历史记录的增加替换功能上。使用History模式，通过历史记录修改url。但它不会立即向后端发送请求。 注意：虽然History模式可以丢掉不美观的#，也可以正常的前进后退，但是刷新f5后，此时浏览器就会访问服务器，在没有后台支持的情况下，此时就会得到一个404！ 官方文档给出的描述是：不过这种模式要玩好；还需要后台配置支持 因为我们的应用是单个客户端应用，如果后台没有正确的配置，当用户直接访问时,就会返回404，所以，要在服务端增加一个覆盖所有情况的的候选资源。如果url匹配不到任何静态资源；则应该返回同一个index.html页面 路由属性 路由对象this.$route支持属性 $route.path：字符串，等于当前路由对象的路径，会被解析为绝对路径 1/aaa/bbb $route.params：包含路由中的动态片段和全匹配片段的键值对 $route.query：获取连接中查询参数的键值对 123/foo?user=1// 可以获取到$route.query.user == 1 $route.router：路由规则所属的路由器以及其所属的组件 $route.matched：数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象 $route.name：当前路径的名字 路由中设置自定义参数 123456router.map(&#123; &apos;/a&apos;: &#123; component: &#123; ... &#125;, auth: true // 这里 auth 是一个自定义字段 &#125;&#125;) 当 /a 被匹配时，$route.auth 的值将会是 true。我们可以利用这个特性在全局的钩子函数中进行身份验证 12345router.beforeEach(function (transition) &#123; if (transition.to.auth) &#123; // 对用户身份进行验证... &#125;&#125;) 动态路由（:号通配符） 路由中的动态片段使用以冒号开头的路径片段定义 类比django中的路由传参 1path(&apos;&lt;int:name&gt;/&apos;,views.xx), 1234path: &apos;/user/:username&apos;,component: &#123; template: &apos;&lt;p&gt;用户名是&#123;&#123;$route.params.username&#125;&#125;&lt;/p&gt;&apos;&#125; 一条路径中可以包含多个动态片段，每个片段都会被解析成 $route.params 的一个键值对 解析模式 模式 匹配的路径 $route.params /user/:username /user/evan { username: &#39;evan&#39; } /user/:username/post/:post_id /user/evan/post/123 { username: &#39;evan&#39;, post_id: 123 } 全匹配路由（*号通配符） 动态片段只能匹配路径中的一个部分，而全匹配片段则基本类似于它的贪心版 例如 /foo/*bar 会匹配任何以 /foo/ 开头的路径 当使用一个通配符时，$route.params内会自动添加一个名为pathMatch的参数，其中包含了在连接中通过通配符所匹配到的部分 12345&#123; path: &apos;/user/*/cc&apos;, name: &apos;User&apos;, component: User,&#125;, 访问的URL如下 1http://127.0.0.1:8080/user/1231/aaa/cc 那么此时*通配符拿到的部分为 1&#123; \"pathMatch\": \"1231/aaa\" &#125; 具名路径（命名路由） 类似django的路由命名，vue路由映射中也可以为某一个路由通过name属性设置命名 12345&#123; path: &apos;/user/:userid&apos;, name: &apos;User&apos;, component: User,&#125;, 在使用v-link标签进行路由跳转时，就可以更加方便啦 1&lt;router-link :to=&quot;&#123;name: &apos;User&apos;, params: &#123;userid: &apos;zhangsan&apos; &#125;&#125;&quot;&gt;user&lt;/router-link&gt; 也可以在js代码中使用router.go切换到该路径下 1router.go(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;) V-link v-link 是一个用来让用户在vue-router应用的不同路径间跳转的指令。该指令接受一个JavaScript表达式，并会在用户点击元素时用该表达式的值去调用 router.go 12345678&lt;!-- 字面量路径 --&gt;&lt;a v-link=&quot;&apos;home&apos;&quot;&gt;Home&lt;/a&gt;&lt;!-- 效果同上 --&gt;&lt;a v-link=&quot;&#123; path: &apos;home&apos; &#125;&quot;&gt;Home&lt;/a&gt;&lt;!-- 具名路径 --&gt;&lt;a v-link=&quot;&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/a&gt; 应该使用 v-link 而不是 href 来处理浏览时的跳转。原因如下 它在HTML5 history模式和hash模式下的工作方式相同，所以如果你决定改变模式，或者IE9浏览器退化为hash模式时，都不需要做任何改变 在HTML5 history模式下，v-link 会监听点击事件，防止浏览器尝试重新加载页面 在HTML5 history模式下使用 root 选项时，不需要在 v-link 的URL中包含root路径 V-Link其他选项 replace 一个带有 replace: true 的链接被点击时将会触发 router.replace() 而不是 router.go()。由此产生的跳转不会留下历史记录 1&lt;router-link :to=&quot;&#123;name: &apos;User&apos;, params: &#123;userid: &apos;zhangsan&apos; &#125;, replace: true &#125;&quot;&gt;replace&lt;/router-link&gt; append 带有 append: true 选项的相对路径链接会确保该相对路径始终添加到当前路径之后。举例来说，从 /a 跳转到相对路径 b 时，如果没有 append: true 我们会跳转到 /b，但有 append: true 则会跳转到 /a/b 1&lt;router-link :to=&quot;&#123;name: &apos;User&apos;, append: true &#125;&quot;&gt;append&lt;/router-link&gt; 路由钩子 全局的钩子 beforeEach(to, from, next) 添加一个全局的前置钩子函数，这个函数会在路由切换开始时调用。调用发生在整个切换流水线之前。如果此钩子函数拒绝了切换，整个切换流水线根本就不会启动 123const router = new Router(&#123; ...export default router 123456789router.beforeEach((to, from, next) =&gt; &#123; // to and from are both route objects. must call `next`. console.log(to) // to: Route: 即将要进入的目标 路由对象 console.log(&apos;-------------&apos;) console.log(from) // from: Route: 当前导航正要离开的路由 console.log(&apos;-------------&apos;) console.log(next) // 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 &#125;) 路由解析流程 1234567891011121.导航被触发。2.在失活的组件里调用离开守卫。3.调用全局的 beforeEach 守卫。4.在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。5.在路由配置里调用 beforeEnter。6.解析异步路由组件。7.在被激活的组件里调用 beforeRouteEnter。8.调用全局的 beforeResolve 守卫 (2.5+)。9.导航被确认。10.调用全局的 afterEach 钩子。11.触发 DOM 更新。12.用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 使用beforeEach控制路由跳转，拦截路由 1234567891011121314151617router.beforeEach((to, from, next) =&gt; &#123; // to and from are both route objects. must call `next`. let toQuery = JSON.parse(JSON.stringify(to.query)); console.log(toQuery) // 获取连接参数 if(to.meta.requiredAuth == true)&#123; // 如果要进入的路由需要用户登陆 if(window.localStorage.getItem(&apos;username&apos;))&#123; // 获取存储的用户名 next() &#125; else&#123; // 没有获取到，则跳转到登陆页面 next(&#123; path: &apos;/&apos;, query: toQuery, &#125;) &#125; &#125;else&#123; next() &#125;&#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://cy-blogs.cn/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://cy-blogs.cn/tags/Vue/"}]},{"title":"Django-DBrouter","slug":"Django数据库路由器","date":"2019-12-09T11:29:54.640Z","updated":"2019-12-09T11:29:55.065Z","comments":true,"path":"Django数据库路由器/","link":"","permalink":"https://cy-blogs.cn/Django数据库路由器/","excerpt":"DB-router 通过编写db-router可以灵性连接mysql主从复制等情况下的多数据库 假设你已经配置好了类似MYSQL主从复制的服务，如果没有可以参照这里","text":"DB-router 通过编写db-router可以灵性连接mysql主从复制等情况下的多数据库 假设你已经配置好了类似MYSQL主从复制的服务，如果没有可以参照这里 配置Django数据库连接 settings.py 123456789101112131415161718DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'HOST': '192.168.1.101', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123456', 'NAME': 'test1' &#125;, 'slave': &#123; 'ENGINE': 'django.db.backends.mysql', 'HOST': '192.168.1.102', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123456', 'NAME': 'test1' &#125;&#125;DATABASE_ROUTERS = ['pro.utils.MasterSlaveDBRouter'] 编写db-router 1234567891011121314class MasterSlaveDBRouter: \"\"\"数据库主从读写分离路由\"\"\" def db_for_read(self, model, **hints): \"\"\"读数据库\"\"\" return \"slave\" def db_for_write(self, model, **hints): \"\"\"写数据库\"\"\" return \"default\" def allow_relation(self, obj1, obj2, **hints): \"\"\"是否运行关联操作\"\"\" return True 如出现以下错误，修改主库binlog日志格式 1django.db.utils.InternalError: (1665, 'Cannot execute statement: impossible to write to binary log since BINLOG_FORMAT = STATEMENT and at least one table uses a storage engine limited to row-based logging. InnoDB is limited to row-logging when transaction isolation level is READ COMMITTED or READ UNCOMMITTED.') 1binlog_format=mixed 打开日志用以分析 可以通过配置mysql日志记录，用以查看主从在读写情况下的效果 12general_log=1general_log_file=/var/lib/mysql/general.log","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[]},{"title":"Django-DBrouter","slug":"Django-DBrouter","date":"2019-12-09T09:11:32.684Z","updated":"2019-12-09T11:26:02.817Z","comments":true,"path":"Django-DBrouter/","link":"","permalink":"https://cy-blogs.cn/Django-DBrouter/","excerpt":"DB-router 通过编写db-router可以灵性连接mysql主从复制等情况下的多数据库 假设你已经配置好了类似MYSQL主从复制的服务，如果没有可以参照这里","text":"DB-router 通过编写db-router可以灵性连接mysql主从复制等情况下的多数据库 假设你已经配置好了类似MYSQL主从复制的服务，如果没有可以参照这里 配置Django数据库连接 settings.py 123456789101112131415161718DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'HOST': '192.168.1.101', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123456', 'NAME': 'test1' &#125;, 'slave': &#123; 'ENGINE': 'django.db.backends.mysql', 'HOST': '192.168.1.102', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123456', 'NAME': 'test1' &#125;&#125;DATABASE_ROUTERS = ['pro.utils.MasterSlaveDBRouter'] 编写db-router 1234567891011121314class MasterSlaveDBRouter: \"\"\"数据库主从读写分离路由\"\"\" def db_for_read(self, model, **hints): \"\"\"读数据库\"\"\" return \"slave\" def db_for_write(self, model, **hints): \"\"\"写数据库\"\"\" return \"default\" def allow_relation(self, obj1, obj2, **hints): \"\"\"是否运行关联操作\"\"\" return True 如出现以下错误，修改主库binlog日志格式 1django.db.utils.InternalError: (1665, 'Cannot execute statement: impossible to write to binary log since BINLOG_FORMAT = STATEMENT and at least one table uses a storage engine limited to row-based logging. InnoDB is limited to row-logging when transaction isolation level is READ COMMITTED or READ UNCOMMITTED.') 1binlog_format=mixed 打开日志用以分析 可以通过配置mysql日志记录，用以查看主从在读写情况下的效果 12general_log=1general_log_file=/var/lib/mysql/general.log","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"WebSSH","slug":"WebSSH","date":"2019-12-09T09:03:24.475Z","updated":"2019-12-09T11:26:56.071Z","comments":true,"path":"WebSSH/","link":"","permalink":"https://cy-blogs.cn/WebSSH/","excerpt":"WebSSH webssh从而SSH无需Xshell之类的模拟终端工具进行SSH连接，将SSH这一比较低层的操作也从C/S架构扭转成为B/S架构 这样的架构常用在运维制作开发一些堡垒机等系统，或者目前比较新型的在线教育方式，通过WebSSH向学生提供一个可以直接使用浏览器进行相关Linux操作或代码编写的学习方式 WebSSh主要是建立客户端与服务端的即时通信","text":"WebSSH webssh从而SSH无需Xshell之类的模拟终端工具进行SSH连接，将SSH这一比较低层的操作也从C/S架构扭转成为B/S架构 这样的架构常用在运维制作开发一些堡垒机等系统，或者目前比较新型的在线教育方式，通过WebSSH向学生提供一个可以直接使用浏览器进行相关Linux操作或代码编写的学习方式 WebSSh主要是建立客户端与服务端的即时通信 实现方案 此种WebSSH实现方式，将通过结合WebSocket以及逐步的Paramiko来进行实现，所需要的技术栈如下 1234＃前端vue websocket xterm.js 12345# 后端djangodwebsocketparamikothreading 技术介绍 xterm 前端通过xterm插件进行shell黑窗口环境的构建，这个插件会自动解析由后台paramiko返回的带有标记样式的命令结果，并渲染到浏览器中，非常酷炫 websocket 这里通过websocket进行浏览器与django的数据交通同轴，Websocket是什么 paramiko paramiko此时的角色采取承担django与Linux环境的互动，将前端发来的命令发送给后台，将后端发来的命令结果返回到前端的xterm组件中 前端实现 前端xterm组件使用：简单 安装xterm 1cnpm安装xterm --save vue框架中约会xterm的样式文件 1234567891011121314151617// main.js// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from &apos;vue&apos;import App from &apos;./App&apos;import router from &apos;./router&apos;import &apos;xterm/dist/xterm.css&apos; // 看这里，添加xterm css文件样式Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: &apos;#app&apos;, router, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;) 初始化xterm组件并添加两个插件：attach可以将终端附加到websocket流中，fit可以调整终端的大小以及行和列适应父级元素 12345678// index.vueimport &#123; Terminal &#125; from &apos;xterm&apos;import * as attach from &apos;xterm/lib/addons/attach/attach&apos;import * as fit from &apos;xterm/lib/addons/fit/fit&apos;Terminal.applyAddon(attach)Terminal.applyAddon(fit) 构建websocket并绑定到终端，websocket地址为ws协议链接，此时使用的是即将在django中配置Websocket后台视图的路由，这一系列行为将挂载到钩子函数下进行 12345678910111213141516171819mounted () &#123; let terminalContainer = document.getElementById('terminal') this.term = new Terminal(this.terminal) this.term.open(terminalContainer) // open websocket this.terminalSocket = new WebSocket('ws://127.0.0.1:8000/webssh/') this.terminalSocket.onopen = function()&#123; console.log('websocket is Connected...') &#125; this.terminalSocket.onclose = function()&#123; console.log('websocket is Closed...') &#125; this.terminalSocket.onerror = function()&#123; console.log('damn Websocket is broken!') &#125; this.term.attach(this.terminalSocket) // 绑定xterm到ws流中 &#125;, 当浏览器关闭时，也代表着客户端关闭，此时主动插入连接，交给vue的钩子函数来处理这个问题 1234beforeDestroy () &#123; this.terminalSocket.close() this.term.destroy()&#125; 后端实现 django这里使用dwebsocket模块进行ws的服务端编写与通信 首先确定路由，也是前端的ws连接地址 123＃urls.py ... path（'webssh /'，webssh） 定义函数，初始化SSH连接对象 1234567#views.py def _ssh(host,username,password,port=22): sh = paramiko.SSHClient() sh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) sh.connect(host, username=username, password=password) channle = sh.invoke_shell(term='xterm') return channle 由于在SSH通道中，服务端可能返回结果的方式并不与客户端发起的命令一唱一和，可能是一唱多和，类似类似top的命令，一次命令输入之后，服务端会返回N次结果，此时在django首先中采用多线程，专门处理命令结果的返回；以下是这个任务线程函数的定义 123456789101112def recv_ssh_msg(channle,ws): ''' channle: 建立好的SSH连接通道 这个函数会不停的接收ssh通道返回的命令 返回到前端的ws套接字里 ''' while not channle.exit_status_ready(): try: buf = channle.recv(1024) # 接收命令的执行结果 ws.send(buf) # 向Websocket通道返回 except: break 剩余的就是视图函数的调用和线程开启部分了！ 1234567891011121314151617181920@accept_websocketdef webssh(request): ''' 1: 接收前端(ws)的命令，发给后台(ssh) 2: 接收后台的返回结果，给到前端 ''' if request.is_websocket: channle = _ssh(host, username=username, password=password) ws = request.websocket t = threading.Thread(target=recv_ssh_msg,args=(channle,ws)) t.setDaemon(True) t.start() # 线程开启 while 1: cmd = ws.wait() # 阻塞接收前端发来的命令 if cmd: channle.send(cmd) # 由SSH通道转交给Linux环境 else: # 连接断开 跳出循环 break ws.close() # 释放对应套接字资源 channle.close() 效果展示 如下","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Websocket","slug":"Websocket","date":"2019-12-09T09:00:08.693Z","updated":"2019-12-09T11:26:53.607Z","comments":true,"path":"Websocket/","link":"","permalink":"https://cy-blogs.cn/Websocket/","excerpt":"Websocket WebSocket实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端可以主动向客户端发送数据。 传统的HTTP协议是无状态的，种客户端是主动方，服务端是被动方的；对于涉及实时信息的Web应用带来了很大的不便，如带有即时通信、实时数据、订阅推送等功能的应用。在之前有两种办法解决这个问题","text":"Websocket WebSocket实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端可以主动向客户端发送数据。 传统的HTTP协议是无状态的，种客户端是主动方，服务端是被动方的；对于涉及实时信息的Web应用带来了很大的不便，如带有即时通信、实时数据、订阅推送等功能的应用。在之前有两种办法解决这个问题 轮询是最原始的实现实时Web应用的解决方案。轮询技术要求客户端以设定的时间间隔周期性地向服务端发送请求，频繁地查询是否有新的数据改动。这种方法会导致过多不必要的请求，浪费流量和服务器资源。 Comet技术又可以分为长轮询和流技术；长轮询改进了上述的轮询技术，减小了无用的请求。它会为某些数据设定过期时间，当数据过期后才会向服务端发送请求；这种机制适合数据的改动不是特别频繁的情况。流技术通常是指客户端使用一个隐藏的窗口与服务端建立一个HTTP长连接，服务端会不断更新连接状态以保持HTTP长连接存活；这样的话，服务端就可以通过这条长连接主动将数据发送给客户端；流技术在大并发环境下，可能会考验到服务端的性能。 WebSocket真正实现了Web的实时通信，使B/S模式具备了C/S模式的实时通信能力 WebSocket的工作流程是这样的：浏览器通过JavaScript向服务端发出建立WebSocket连接的请求，在WebSocket连接建立成功后，客户端和服务端就可以通过 TCP连接传输数据。因为WebSocket连接本质上是TCP连接，不需要每次传输都带上重复的头部数据，所以它的数据传输量比轮询和Comet技术小了很多 Websocket在建立连接之前有一个Handshake（Opening Handshake）过程，在关闭连接前也有一个Handshake（Closing Handshake）过程，建立连接之后，双方即可双向通信 HTML的Websocket 初始化websocket 1var ws = new WebSocket(url, [protocol] ); url：指定连接的websocket protocol：可接受的子协议 响应事件 当ws套接字初始化成功之后，我们可以通过定义回调函数在某些事件触发时执行，以下是常见响应事件 当ws连接建立时触发 123ws.onopen = function()&#123; // 连接开启&#125; 当ws连接接收到数据时触发 123ws.onmessage = function(evt)&#123; // evt.data即是接收到的数据对象&#125; 当ws连接发生通信错误时触发 123ws.onerror = function()&#123; // 连接出错&#125; 当连接关闭时触发 123ws.onclose = function()&#123; // 连接关闭&#125; 初次之外，还可以通过一些方法函数进行数据的传输或连接的关闭 方法 通过ws连接发送数据 1ws.send(str) 关闭连接 1ws.close() 简单的示例12345678910111213141516171819var ws = new WebSocket('ws://127.0.0.1:3000')ws.onopen = function()&#123; console.log('连接建立')&#125;ws.onmessage = function(ev)&#123; console.log('server:',ev.data)&#125;ws.onerror = function()&#123; console.log('连接建立') ws.close()&#125;ws.onclose = function()&#123; console.log('连接关闭') ws.close()&#125; Django的Websocket dwebsocket是一个在django用来实现websocket服务端的三方模块，使用上手非常简单，安装方式如下 1pip install dwebsocket git地址 https://github.com/duanhongyi/dwebsocket 方法 在后台中，通过该三方模块可以让我们在django的视图中实现对于websocket的操作 首先是两个基本的装饰器，用来限定过滤websocket的连接 dwebsocket.accept_websocket 允许http与websocket连接 dwebsocket.require_websocke 只允许websocket连接 除去两种装饰器方法进行过滤判断，还可以通过在视图函数中的request进行websocket的判断 request.is_websocket 如果是个websocket请求返回True，如果是个普通的http请求返回False 可以用这个方法区分普通连接与websocket request.websocket 在一个websocket请求建立之后，这个请求将会有一个websocket属性，用来给客户端提供一个简单的api通讯，如果request.is_websocket()是False，这个属性将是None request.websocket.wait 接收客户端发来的一条消息；如果在收到消息或客户端关闭连接之前，它不会有任何返回，只会返回None request.websocket.read 如果从客户端接收到新消息，read函数返回这条消息；如果没有新消息，则返回None 这是一个替代wait的非阻塞读取数据的方法 request.websocket.count_messages() 返回消息队列数量 request.websocket.has_messages() 如果有新消息返回True，否则返回False request.websocket.send(message) 向客户端发送消息 requqest.websocket.__iter__ websocket迭代器 关于Django的Demo将会在下一章节结合paramiko以及xterm.js来进行一个webssh的实现","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Tinymce富文本编辑器","slug":"Tinymce富文本编辑器","date":"2019-12-09T08:53:20.976Z","updated":"2019-12-09T11:28:03.240Z","comments":true,"path":"Tinymce富文本编辑器/","link":"","permalink":"https://cy-blogs.cn/Tinymce富文本编辑器/","excerpt":"图文混排 在某些富文本编辑器中，我们可以支持文件与图片的同时编写，将文字与图片混合排列 在django中可以使用TimyMce富文本编辑器进行图文混排功能的实现","text":"图文混排 在某些富文本编辑器中，我们可以支持文件与图片的同时编写，将文字与图片混合排列 在django中可以使用TimyMce富文本编辑器进行图文混排功能的实现 TinyMce TinyMCE：是一个轻量级的基于浏览器的所见即所得编辑器，支持目前流行的各种浏览器，由JavaScript写成 功能配置灵活简单，两行代码就可以将编辑器嵌入网页中，并且支持AJAX，加载速度非常快 最重要的是，TinyMCE是一个根据LGPL license发布的自由软件，你可以把它用于商业应用。下图是此编辑器的界面 配置上传路径 首先配置整个项目的上传文件路径，为了区别与自身的static静态目录 这里的上传文件我们将另外保存至upload文件夹 12#settings.pyUPLOAD_ROOT = os.path.join(BASE_DIR,'upload') 配置模板页面 首先需要在使用到tinymce富文本编辑器的html页面下导入必备js文件 1234&lt;script src=\"&#123;% static 'js/jquery-1.10.2.min.js' %&#125;\" &gt;&lt;/script&gt;&lt;script src=\"&#123;% static 'js/tinymce_setup.js' %&#125;\"&gt;&lt;/script&gt;&lt;script src=\"&#123;% static 'tinymce/js/tinymce/tinymce.min.js' %&#125;\"&gt;&lt;/script&gt; 接下来，在模板页面中加入一个id为content的输入表单，这里我们以一个文章数据为例 首先是模型层文件定义 12345#models.py class Article(models.Model): title = models.CharField(max_length=100,verbose_name='标题') author = models.CharField(max_length=100,verbose_name='作者') content = models.TextField(verbose_name='内容') 这里的content内容要用到富文本编辑器 接着是模板页面的主要部分 12345678910&lt;form method=\"POST\" action='/' enctype=\"multipart/form-data\"&gt; &#123;% csrf_token %&#125; &lt;input type=\"text\" placeholder=\"文章标题\"&gt; &lt;br&gt; &lt;input type=\"text\" placeholder=\"文章作者\"&gt; &lt;br&gt; &lt;input id=\"rich_content\" name=\"content\" value=\" \"&gt; &lt;br&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt;&lt;/form&gt; 修改插件配置 这里搭配了一个tinymce_setup.js文件，用来控制富文本编辑器所使用的插件等 全文配置如下 123456789101112131415161718192021222324252627282930313233343536tinymce.init(&#123; // 选择id为content的标签作为编辑器 selector: '#rich_content', // 方向从左到右 directionality:'ltr', // 语言选择中文 language:'zh_CN', // 高度为400 宽度为一半 height:300, width: '50%', // 工具栏上面的补丁按钮 plugins: [ 'advlist autolink link image lists charmap print preview hr anchor pagebreak spellchecker', 'searchreplace wordcount visualblocks visualchars code fullscreen insertdatetime media nonbreaking', 'save table contextmenu directionality template paste textcolor', 'codesample imageupload', ], // 工具栏的补丁按钮 toolbar: 'insertfile undo redo | \\ styleselect | \\ bold italic | \\ alignleft aligncenter alignright alignjustify | \\ bullist numlist outdent indent | \\ link image | \\ print preview media fullpage | \\ forecolor backcolor emoticons |\\ codesample fontsizeselect fullscreen |\\ imageupload', // 字体大小 fontsize_formats: '10pt 12pt 14pt 18pt 24pt 36pt', // 按tab不换行 nonbreaking_force_tab: true, imageupload_url: \"/upload_img/\", // 上传后图片保存为绝对路径 relative_urls : false,&#125;); 注释已经很清晰 要注意的是imageupload_url配置用来确定当前图片上传所对应的视图路由 上传视图配置 接下来编写富文本编辑器的上传图片路由函数及对应的路由配置 路由映射tinymce_setup.js与中的imageupload_url配置路由相同 这里还要注意，由于此时tinymce的上传图片表单并不是和本身所容纳的form表单一起上传，所以并不会具备csrf_token值，需要我们将上传图片的函数额外进行装饰器装饰，取消csrf_token验证 1234567891011121314151617181920212223#views.pyfrom django.views.decorators.csrf import csrf_exemptdef md5(str_): import time m = hashlib.md5() m.update(str(time.time()).encode()) filename = m.hexdigest() return filename + '.' + str_.split('.')[-1]@csrf_exemptdef upload_img(request): if request.method == 'POST': img = request.FILES.get('file') if img: file_name_md5 = md5(img.name) with open(os.path.join(UPLOAD_ROOT,file_name_md5), 'wb') as fp: for buf in img.chunks(): fp.write(buf) # 迭代读取文件并写入到本地 response = &#123;&#125; response['path'] = '/upload/' + file_name_md5 response['error'] = False return HttpResponse(json.dumps(response)) 视图函数还是老样子去接收上传文件并保存即可 这里还使用了md5的方式进行文件名保存，避免重名文件上传互相覆盖 路由配置 12#urls.pypath('upload_img/',views.upload_img), 表单接收视图 以上的视图函数只能处理上传图片的内容接收 我们的模板页面中还有作者及标题两样表单内容会被POST提交到后台 并且要主要的是，富文本编辑器里除了图片的内容，还有文字等其他内容，这里也需要我们保存下来 这里还需要一个视图函数去接管处理 12345678910111213def index(request): if request.method == 'GET': return render(request, 'index.html') if request.method == 'POST': title = request.POST.get('title') author = request.POST.get('author') content = request.POST.get('content') models.Article.objects.create( title = title, author = author, content = content, ) return redirect('/show/') 表单路由 12#urls.pypath('',views.index), 这里上传之后，保存在后台的content数据是这个样子 1&lt;p&gt;&lt;img src=\"/upload/ec8f8c9a56ed32464a6727741fd58d8d.png\" /&gt;&lt;/p&gt;&lt;p&gt;今天&lt;em&gt;一切&lt;/em&gt;都是&lt;strong&gt;美丽&lt;/strong&gt;的，哈哈哈&lt;/p&gt; 图片访问路由 当有了上传图片的视图函数及所有内容的接收视图函数 这里还有一个特殊的问题，现在如果在富文本编辑器中选择上传图片，你会发现图片已经在选择时就已经存储到了后台upload文件夹下，这也是为什么我们的图片上传视图函数要单独编写，并且还需要取消csrf_token的验证的原因 除了这个问题你还会发现，在富文本编辑器中，上传的图片是看不到的，是一个坏掉的图片； 使用F12开发者工具你可以看到，这里的图片展示为一个img标签，而标签的src属性内容正是通过上传视图函数返回的response中的path值 想让这个path值在访问时，能获取到实际的图片效果，需要我们在路由文件中继续配置，配置专门的upload/xxxx.jpg的图片路由访问，让图片真正展示出来 123#urls.pyfrom django.views.static import servere_path('^upload/(?P&lt;path&gt;.*)/$',serve,&#123;'document_root':UPLOAD_ROOT&#125;), 上传后图片的访问路径是/upload/，那么这里的路由也是upload/，之后通过静态文件映射函数serve查找upload文件夹下的同路径同名图片资源 当有了这条路由配置之后，再次再富文本编辑器中加入图片，你就会发现图片出现啦 上传并展示 最后，我们将测试上传图片及文字 并且上传成功之后，重定向到show视图函数 这个视图函数用来提取当前最新的上传数据并返回到模板页面 12345#views.pydef show(request): if request.method == 'GET': article = models.Article.objects.all().last() return render(request,'show.html',locals()) 展示的模板页面 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;展示文章&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;% if article %&#125; &lt;h3&gt;&#123;&#123; article.title &#125;&#125;&lt;/h3&gt; &lt;h4&gt;&#123;&#123; article.author &#125;&#125;&lt;/h4&gt; &lt;div&gt;&#123;&#123; article.content|safe &#125;&#125;&lt;/div&gt; &#123;% endif %&#125;&lt;/body&gt;&lt;/html&gt; 其实本身富文本编辑器上传的文本内容就已经在一个p标签中，所以这里没有用段落标签 另外由于保存在数据库的文本为html格式，而后台传递来的模板变量django出于安全考虑会自动进行转义，直接观看到的效果不会html样式，只是一些普通字符串； 这里可以使用safe过滤器将内容认定为安全，展示为原始的html效果，其实还不错 总结 富文本编辑器其实就是将用户输入的内容变为html代码 这里的图文混排，只是在图片加入时，单独将图片上传保存，并且回调获取到上传的路径 之后只需要服务端后台配置好相关的上传图片访问路由配置即可","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"HayStack全文检索在Django中应用","slug":"HayStack全文检索在Django中应用","date":"2019-12-09T08:41:45.776Z","updated":"2019-12-09T11:26:38.345Z","comments":true,"path":"HayStack全文检索在Django中应用/","link":"","permalink":"https://cy-blogs.cn/HayStack全文检索在Django中应用/","excerpt":"全文检索官方文档 全文检索就是针对所有内容进行动态匹配搜索的概念 针对特定的关键词进行建立索引并精确匹配取出搜索结果，并且达到性能优化的目的 为啥要有全文检索","text":"全文检索官方文档 全文检索就是针对所有内容进行动态匹配搜索的概念 针对特定的关键词进行建立索引并精确匹配取出搜索结果，并且达到性能优化的目的 为啥要有全文检索 最常见的全文检索就是我们在数据库中进行的模糊查询 但是模糊查询是针对整体内容的一个动态匹配过程，在数据量较大的情况下匹配效率极低 常规项目中数据量一般都比较多并且内容繁杂，所以正常的项目搜索功能中很少会使用模糊查询进行操作 如果你开发的项目用户量较少并且项目数据较少，那么此时模糊查询可以是你值得考虑的选项 django使用啥进行全文检索 Python提供了各种模块进行全文检索，最常见的是haystack模块 该模块设计为支持whoosh、solr、Xapian、Elasticsearch四种全文检索引擎后端 使用haystack模块，不用更改代码，直接切换引擎，可以极大的减少代码量 haystack属于一种全文检索的框架 whoosh 纯Python编写的全文搜索引擎，是目前最快的python所编写的检索引擎，虽然性能比不上solr、Xapian、Elasticsearch等；但是无二进制包，程序不会莫名其妙的崩溃，对于小型的站点，whoosh已经足够使用 solr Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎 Lucene：不是一个完整的全文检索引擎，是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能 Xapian 12&gt; Xapian`是一个用`C++`编写的全文检索程序，他的作用类似于`Java`的`lucene&gt; Elasticsearch ElasticSearch是一个基于Lucene的搜索服务器它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口 Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。该引擎常设计用于云计算中；能够达到实时搜索，稳定，可靠，快速，安装使用方便 中文分词 whoosh作为一个全文搜索引擎模块 分词功能和检索功能已经非常强大，但是针对中文的处理还是比较欠缺 可以通过Jieba模块重写分词操作，支持whoosh对中文的强大操作 安装中文分词模块 1pip install jieba 除了jieba分词，现在还有很多付费的中文分词模块 中科院计算所NLPIR ansj分词器 哈工大的LTP 清华大学THULAC 斯坦福分词器 Hanlp分词器 结巴分词 KCWS分词器(字嵌入+Bi-LSTM+CRF) ZPar IKAnalyzer 安装 首先安装HayStack框架以及whoosh搜索引擎 12pip install django-haystackpip install whoosh settings配置 添加haystack应用到项目的settings文件下的app部分 12345INSTALLED_APPS = [ 'django.contrib.admin', ... 'haystack',] 添加搜索引擎，这里使用whoosh引擎 1234567HAYSTACK_CONNECTIONS = &#123; 'default': &#123; 'ENGINE': 'haystack.backends.whoosh_cn_backend.WhooshEngine', 'PATH': os.path.join(BASE_DIR, 'whoosh_index'), &#125;&#125;#这里使用django的信号机制，在数据表发生改动时自动更新whoosh的查询索引HAYSTACK_SIGNAL_PROCESSOR = 'haystack.signals.RealtimeSignalProcessor' 这里要注意的是，我们使用的引擎为whoosh_cn_backend 本身的whoosh引擎名为：whoosh_backend whoosh_cn_backend将在接下来我们对安装目录下的引擎文件复制修改得来 在项目的路由文件下配置查询的路由映射 12345from django.urls import include,re_pathurlpatterns = [ path('admin/', admin.site.urls), re_path('^search/',include('haystack.urls')),] 当查询条件被提交时，会跳转至search路由 并且查询条件会作为get请求时的连接参数传入，参数key值为q 创建索引文件 接下来，在需要被搜索的app下建立search_indexes.py文件，该文件名不许变更 1234567891011#app.models.pyclass User(models.Model): # 用户表 name = models.CharField( max_length=50, verbose_name='昵称' ) account = models.CharField(max_length=50,verbose_name='账号',unique=True) passwd = models.CharField(max_length=50,verbose_name='密码') def __str__(self): return self.name 1234567891011#app.search_indexes.pyfrom haystack import indexesfrom . import modelsclass UserIndex(indexes.SearchIndex, indexes.Indexable): text = indexes.CharField(document=True, use_template=True) def get_model(self): return models.User # 当前模型文件下需要被检索的模型类 def index_queryset(self, using=None): return self.get_model().objects.all() 该类为索引类，类名为模型类的名称+Index：比如模型类为People,则这里类名为PeopleIndex get_model函数用来获取当前索引类所关联的模型类，这里我们关联上面的User 类对象 text=indexes.CharField语句指定了将模型类中的哪些字段建立索引，而use_template=True说明后续我们将通过一个数据模板文件来指明需要检索的字段 12&gt; document=True&gt; 为什么要创建索引：索引就像是一本书的目录，可以为读者提供更快速的导航与查找 创建模板数据文件 创建数据模板文件 数据模板文件路径：templates/search/indexes/yourapp/note_text.txt 放在任何一个你的Django能搜索到的模板文件夹template下面均可，这个文件主要确定要检索的字段，为他们建立索引 文件名必须为要索引的类名_text.txt，比如这里我们检索的类名是User，那么对应的数据模板文件名为user_text.txt，文件名小写即可 1234#template.search.indexes.people.user_text.txt&#123;&#123; object.name &#125;&#125;&#123;&#123; object.account &#125;&#125;&#123;&#123; object.online_time &#125;&#125; 在数据模板文件中使用模板语法，写入需要建立索引的字段，这里我们将模型类中name、account以及online_time字段设置索引，当检索时会对这三个字段去做全文检索 接下来创建一个搜索结果展示页面 检索结果模板页面 创建检索结果展示页面 检索结果展示页面，需要在固定的目录路径下进行模板页面的编写 路径为：templates/search/ 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#123;% if query %&#125; &lt;h3&gt;搜索结果如下：&lt;/h3&gt; &#123;% for result in page.object_list %&#125; &#123;&#123; result.object.name &#125;&#125; &lt;br&gt; &#123;&#123; result.object.account &#125;&#125; &lt;br&gt; &#123;&#123; result.object.online_time &#125;&#125; &lt;br&gt; &#123;% empty %&#125; &lt;p&gt;没找到&lt;/p&gt; &#123;% endfor %&#125; &#123;% if page.has_previous or page.has_next %&#125; &lt;div&gt; &#123;% if page.has_previous %&#125; &lt;a href=\"?q=&#123;&#123; query &#125;&#125;&amp;amp;page=&#123;&#123; page.previous_page_number &#125;&#125;\"&gt; 上一页 &lt;/a&gt; &#123;% endif %&#125; &#123;% if page.has_next %&#125; &lt;a href=\"?q=&#123;&#123; query &#125;&#125;&amp;amp;page=&#123;&#123; page.next_page_number &#125;&#125;\"&gt; 下一页 &lt;/a&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% endif %&#125;&#123;% endif %&#125;&lt;/body&gt;&lt;/html&gt; 这个模板页面中已经自带了分页功能，可以按照需求修改 创建检索模板页面内容 还需要有一个表单，提交检索信息 1234&lt;form method='get' action=\"/search/\" &gt; &lt;input type=\"text\" name=\"q\"&gt; &lt;input type=\"submit\" value=\"查询\"&gt;&lt;/form&gt; 这部分检索的模板页面内容可以在你的项目中进行添加，查询方式为get，并且检索输入的表单框name属性必须为q 中文分词配置 接下来，需要创建有关中文检索的配置文件，这里的配置文件创建为全局 进入到python的安装目录下，比如我的目录为：C:\\Python37\\Lib\\site-packages\\haystack\\backends 在该路径下创建名为ChineseAnalyzer.py的中文分词文件 1234567891011121314151617181920import jiebafrom whoosh.analysis import Tokenizer, Tokenclass ChineseTokenizer(Tokenizer): def __call__(self, value, positions=False, chars=False, keeporiginal=False, removestops=True,start_pos=0, start_char=0, mode='', **kwargs): t = Token(positions, chars, removestops=removestops, mode=mode, **kwargs) seglist = jieba.cut(value, cut_all=True) for w in seglist: t.original = t.text = w t.boost = 1.0 if positions: t.pos = start_pos + value.find(w) if chars: t.startchar = start_char + value.find(w) t.endchar = start_char + value.find(w) + len(w) yield tdef ChineseAnalyzer(): return ChineseTokenizer() 在这个文件中，定义了一个ChineseAnalyzer的函数，这个函数将替代搜索引擎配置文件中的分词方式 复制引擎文件，修改分词方式为中文 同样在该文件夹下C:\\Python37\\Lib\\site-packages\\haystack\\backends，复制whoosh_backend.py文件，创建一个新的文件名为whoosh_cn_backend.py，这里复制出一份文件也是为了之后如果不需要使用中文分词，可以直接在settings配置文件中修改引擎为&#39;ENGINE&#39;:&#39;haystack.backends.whoosh_backend.WhooshEngine&#39;, 修改该引擎配置文件中的：analyzer=StemmingAnalyzer()变为analyzer=ChineseAnalyzer() 并且要记得在头部引入刚才所编写的中文分词文件 12#whoosh_cn_backend.pyfrom .ChineseAnalyzer import ChineseAnalyzer 初始化索引 最后，初始化索引数据 1python manage.py rebuild_index","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Admin","slug":"Django中的Admin组件","date":"2019-12-09T08:29:50.000Z","updated":"2019-12-09T11:26:35.571Z","comments":true,"path":"Django中的Admin组件/","link":"","permalink":"https://cy-blogs.cn/Django中的Admin组件/","excerpt":"Admin Django-admin界面是框架为我们提供的Web-APP的管理工具 在之前的练习中，我们已经多次使用它进行APP中表的DML语句操作 接下来，我们可以继续来学习，如何将Admin界面进行优化扩展，更加方便我们后台管理","text":"Admin Django-admin界面是框架为我们提供的Web-APP的管理工具 在之前的练习中，我们已经多次使用它进行APP中表的DML语句操作 接下来，我们可以继续来学习，如何将Admin界面进行优化扩展，更加方便我们后台管理 admin注册设置 在admin界面中，我们可以通过继承admin.ModelAdmin类进行自定义admin类的编写，用作控制展示后台所显示的数据，以及排序规则等等属性，基本语法像是下面这样 123456# models.pyclass User(models.Model): name = models.CharField(max_length=20) age = models.IntegerField() def __str__(self): return self.name 12345#admin.pyclass UserAdmin(admin.ModelAdmin): fields = ('name','age') # 控制admin界面模型类展示字段admin.site.register(User, UserAdmin) 常用字段 list_display：在admin控制台数据列表页面展示更多的字段 list_display_links：用来设置当前列表中由list_display所设置的字段哪些可以点击 fieldsets：将admin界面下的表单输入栏进行分块 1234567891011121314class UserAdmin(admin.ModelAdmin): fields = ('name','age') fieldsets = ( ('第一个区域'， &#123; 'fields': ('name',) &#125; ) ('第二个区域'， &#123; 'fields': ('age',) &#125; ) ) search_fields：在admin数据展示页，设置一个搜索框，设置的分段是可查找的属性 1search_fields =（'name'，） list_filter：以什么分解进行过滤，在admin页面上方展示 ordering：数据列表可以通过某些细分进行排序 利用现有用户系统 from django.contrib.auth.models import User 用户字段 username 必选。少于等于30个字符。用户名可以包含字母，数字，_， ，@，。+状语从句：-字符 first_name 任选。等于等于30个字符 last_name 可选。可以输入30个字符 email 任选。邮箱地址 password 必选。密码的哈希及元数据。（Django不保存原始密码）。原始密码可以无限长而且可以包含任意字符 is_staff 布尔值。指示用户是否可以访问Admin站点 is_active 布尔值。用户的账号是否激活。长使用这个标志为False来代替删除账号 is_superuser 布尔值。指定这个用户拥有所有的权限而不需要给他们分配明确的权限 last_login 用户最后一次登录的时间。如果这个用户没有登录过，这个细分将会是null 之前版本默认设置为的当前的datetime date_joined 帐户创建的时间。当账号创建时，替代设置为当前的datetime 用户实例方法 get_username() 获取到当前的用户的用户名属性 is_authenticated() 检查用户是否已通过认证 is_anonymous() 检查用户是否未通过认证 set_password(password) 设置保存用户的密码，和会负责密码的哈希加密工作 通常修改密码之后还需要调用save()方法进行数据更新 用户表方法 create_user(username, email=None, password=None, **extra_fields) django的用户创建需要使用User表管理器中的create_user函数进行 该函数可以创建并保存一个用户 create_superuser(username, email, password, **extra_fields) 与上一个创建用户函数功能相同，但是额外会设置用户的is_staff及is_superuser属性为True 创建一个admin后台超级用户 其他方法 authenticate(username,password) 验证是否为合法用户，如果用户存在合法则返回一个用户对象 logout() 清除当前浏览器下用户session login(request,user) 登录并保存当前用户session 接受参数为HttpRequest请求及一个User用户对象 参数user必须为使用authenticate验证过后的用户对象 用户登录 登陆所需表单类 12345678910111213141516171819#forms.pyfrom django import formsfrom django.contrib.auth.models import Userimport reclass LoginForm(forms.Form): username = forms.CharField(label=\"用户名\",required=True,) password = forms.CharField( widget=forms.PasswordInput(), label='密码', required=True, ) def clean_username(self): username = self.cleaned_data.get(\"username\").strip() try: User.objects.get(username=username) except User.DoesNotExist: raise forms.ValidationError(\"用户名 %s 不存在\" % username) else: return username 登录所需模板页面 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action='/login/' method=\"POST\"&gt; &#123;% csrf_token %&#125; &#123;&#123; errors &#125;&#125; &#123;% for field in form %&#125; &lt;label&gt; &#123;% if field.errors %&#125; &lt;ul&gt; &#123;% for error in field.errors%&#125; &lt;li&gt;&#123;&#123; error &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &#123;% endif %&#125; &lt;/label&gt; &lt;p&gt;&#123;&#123; field.label &#125;&#125;: &#123;&#123; field &#125;&#125;&lt;/p&gt; &#123;% endfor %&#125; &lt;input type=\"submit\" value=\"登录\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 登陆主要视图逻辑 12345678910111213141516#views.pyfrom django.contrib.auth import authenticate,logout as auth_logout,login as auth_logindef login(request): if request.method == 'GET': form = userForm() return render(request, \"login.html\",&#123;'form':form&#125;) form = userForm(request.POST) username = form.data['username'] password = form.data['password'] user = authenticate(username=username,password=password) # 验证当前账号密码是否匹配合法 if user and user.is_active: auth_login(request, user) return redirect('/') else: return render(request, \"login.html\",&#123;'form':form,'errors':'用户名或密码错误'&#125;) 在用户登录成功之后，将会重新进入主页，主页展示当前登录用户 登录用户可以直接在request.user属性中获取到，主页的模板内容如下 主页模板 123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;主页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 欢迎你: &#123;&#123; user &#125;&#125;&lt;/body&gt;&lt;/html&gt; 主页视图函数可以通过装饰器@login_required或判断is_authenticated状态来查看用户是否登录 只有登录用户可以访问该站点 使用当装饰器@login_required时，在需要settings下设置LOGIN_URL = &#39;/login/&#39; 引入属性设置为登录路由 首页视图函数 1234567from django.contrib.auth.decorators import login_required#@login_requireddef index(request): if request.user.is_authenticated(): return render(request, \"index.html\") else: return redirect('/login/') 注册功能 注册所需表单 123456789101112131415161718192021222324252627282930313233#forms.pyclass RegisterForm(forms.Form): username = forms.CharField(label=\"用户名\", max_length=30, required=True, error_messages=&#123;'max_length':'账号长度最长为30'&#125;, ) password = forms.CharField(label=\"密码\", min_length=6, max_length=30, widget=forms.PasswordInput(), required=True, error_messages=&#123;'min_length':'密码长度最短为6'&#125;, ) check_password = forms.CharField(label=\"重复密码\", min_length=6, max_length=30, widget=forms.PasswordInput(), required=True, error_messages=&#123;'min_length':'密码长度最短为6'&#125;, ) def clean_check_password(self): password = self.cleaned_data.get('password') check_password = self.cleaned_data.get('check_password') if password != check_password and password and check_password: raise ValidationError(\"重复输入密码错误\") def clean_username(self): username = self.cleaned_data.get('username') if username[:1] == '_': raise forms.ValidationError(\"用户名不能以下划线打头\") try: User.objects.get(username=username) except User.DoesNotExist: return username raise forms.ValidationError(\"用户名已存在\") 表单中，将对用户两次输入的密码进行校验和判断是否为空，而且分开下划线作为用户名的开头字符 注册主要视图函数逻辑 1234567891011121314#views.pydef register(request): if request.method == 'POST': form = RegisterForm(request.POST) if form.is_valid(): username = form.cleaned_data['username'] password = form.cleaned_data['password'] User.objects.create_user(username=username,password=password) user = authenticate(username=username,password=password) auth_login(request, user) return redirect('/') else : form = RegisterForm() return render(request, \"register.html\",&#123;'form':form&#125;) 通过表单验证，并获取到对应的用户账号密码，创建成功之后，验证并登录，并重定向到首页 主页模板页面 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;注册&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;% if request.user.is_authenticated %&#125; &lt;p&gt;您已登录:&lt;/p&gt; &#123;&#123; user &#125;&#125; &#123;% else %&#125; &lt;form action='/register/' method=\"POST\"&gt; &#123;% csrf_token %&#125; &#123;% for field in form %&#125; &lt;label&gt; &#123;% if field.errors %&#125; &lt;ul&gt; &#123;% for error in field.errors%&#125; &lt;li&gt;&#123;&#123; error &#125;&#125;&lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &#123;% endif %&#125; &lt;/label&gt; &lt;p&gt;&#123;&#123; field.label &#125;&#125;: &#123;&#123; field &#125;&#125;&lt;/p&gt; &#123;% endfor %&#125; &lt;input type=\"submit\" value=\"注册\"&gt; &lt;/form&gt; &#123;% endif %&#125;&lt;/body&gt;&lt;/html&gt; 当用户已经登录时，显示当前登录用户，反之则展示表单，以供用户填写 重载admin用户系统 django自带的admin模块下的用户系统主要负责用户帐户，组，权限和基于cookie的会话等业务 认证系统由以下部分组成： 用户：包含用户数据细分，是实现业务功能逻辑的基础 权限：控制用户进入否可以执行某项任务的二进制（是/否）标志。 组：一种为多个用户加上标签和权限的常用方式。 消息：一种为指定用户生成简单消息嵌入的方式 默认字段 username 必选项，小于等于30个字符；只能是字母数字（字母，数字和下划线） first_name 可选项，等于等于30个字符 last_name 可选项，等于等于30个字符 email 可选项。电子邮件地址 password 必选，密码（哈希值，元数据） Django不储存原始密码 原始密码可以是任意长度的，包含任何字符 密码由哈希类型，盐值和哈希值组成，用美元符合分隔 is_staff 布尔值，指明这个用户是否可以进入管理站点的权限 is_active 布尔值，指明这个用户帐户是否是活动的 我们建议把这个标记设置为False来代替删除用户帐户，这样就不会影响指向用户的外键 这个属性不控制用户是否可以登录。登录验证时不会核查is_active标志。 因此，如果在登录时需要检查is_active标志，需要你在自己的登录视图中实现 用于login()视图的AuthenticationForm会执行这个检查，判断用户是否是活跃账户 is_superuser 布尔值，规范用户拥有所有权限（包括显式赋予和非显式赋予的） last_login 预期情况下设置为用户最后一次登录的日期时间 date_joined 预期情况下设置为用户帐户创建的日期时间 默认方法 在项目中，我们将使用电子邮件作为用户的用户名，那么可以在自带用户表中写明 USERNAME_FIELD = &#39;email&#39; 该属性设置当前表的登陆细分 描述我们自定义用户模型上作的唯一标识符分割名称的字符串，分段必须是唯一的，在定义中设置unique=True REQUIRED_FIELDS = [&#39;username&#39;] 设置当前该基线为必填细分 is_authenticated() 判断用户是否已通过身份验证的方法，不意味任何权限，而且不检查用户的活动状态 get_username() 返回由USERNAME_FIELD制定的细分的值 get_full_name（） 返回first_name加上last_name 中间加上一个空格，由于我们重新设置了表分区，那么这个变量函数需要我们重新给定返回值 get_short_name() 一个短的且非正式用户的标识符，返回first_name 当你的项目重写该静态或直接去掉了first_name，所以我们必须重新给定这个函数的返回值 set_password() 将用户的密码设置为给定的字符串 has_perm(perm, obj=None) 用户是否具有某个权限，如果给定obj，则需要根据特定对象实例检查权限 has_module_perms(app_label) 如果用户有权访问给定应用中的模型，则返回True 这里我们这两个分区都设置为True，可以让用户访问任一APP is_staff()@property 如果用户允许访问管理网站，则返回True 这里我们返回is_admin的随机属性即可 关于细分属性，如果需要进行高度扩展 可以使用继承AbstractBaseUser这个类 这个类中只含有password， ，last_login以及is_active三个字段属性 重载管理器 由于已经覆盖了替代的admin用户表，现在需要将其对应的管理器函数进行编写 编写时主要关注一下两个父类函数的重写 123456create_user(username_field,password_filed=None,**other_fields) normalize_email()将邮件地址规范化的类方法 user.save(using=self._db)create_superuser(username, email, password) #用户创建，is_admin设置为True即可 user.save(using=self._db) 12345678910111213141516171819202122232425262728from django.contrib.auth.models import BaseUserManagerclass MyUserManager(BaseUserManager): def create_user(self, username, email, password=None): if not email : raise ValueError('Users must have an email address') if not username: raise ValueError('Users must have an username') #判断邮件和用户名是否具有 now = timezone.now() #获取当前django的时间 user = self.model( username=username, email=self.normalize_email(email), date_joined=now, last_login=now, ) user.set_password(password) user.save(using=self._db) return user def create_superuser(self, username, email, password): user = self.create_user(username, email, password=password, ) user.is_admin = True user.save(using=self._db) return user 重新定义新用户表的管理器之后，想要生效，还需要在对应的模型类表中覆盖objects属性 objects = MyUserManager() 重载表 下面是一个真实的重载自带用户表的模型类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677from django.contrib.auth.models import AbstractBaseUserclass Member(AbstractBaseUser): #AbstractBaseUser中只含有3个field: password, last_login和is_active. email = models.EmailField(verbose_name='邮箱',max_length=255,unique=True,) username = models.CharField(verbose_name=\"用户名\", max_length=16, unique=True) weibo_id = models.CharField(verbose_name=\"新浪微博\", max_length=30, blank=True) blog = models.CharField(verbose_name=\"个人网站\", max_length=200, blank=True) location = models.CharField(verbose_name=\"城市\", max_length=10, blank=True) profile = models.CharField(verbose_name=\"个人简介\", max_length=140, blank=True) avatar = models.CharField(verbose_name=\"头像\", max_length=128, blank=True) au = models.IntegerField(verbose_name=\"用户活跃度\", default=0) last_ip = models.IPAddressField(verbose_name=\"上次访问IP\", default=\"0.0.0.0\") email_verified = models.BooleanField(verbose_name=\"邮箱是否验证\", default=False) date_joined = models.DateTimeField(verbose_name=\"用户注册时间\", default=timezone.now) topic_num = models.IntegerField(verbose_name=\"帖子数\", default=0) comment_num = models.IntegerField(verbose_name=\"评论数\", default=0) is_active = models.BooleanField(default=True) is_admin = models.BooleanField(default=False) objects = MyUserManager() #objects就是我们之前一直使用的管理器 #管理器用来维护我们的增删改查 USERNAME_FIELD = 'email' REQUIRED_FIELDS = ['username'] def __str__(self): return self.username #标签中的数据实例 def is_email_verified(self): return self.email_verified #我们可以在模板中，通过实例出来的对象数据进行这个函数的调取，获取他是否验证过 def get_weibo(self): return self.weibo_id def get_username(self): return self.username #方法的圆括号在templates标签中必需省略！！ def get_email(self): return self.email #方法的圆括号在templates标签中必需省略！！ def get_full_name(self): # The user is identified by their email address return self.email #get_full_name本来是获取first_name和last_name的 #但是由于我们重新设置了表结构，那么这个函数必须自定义 #方法的圆括号在templates标签中必需省略！！ def get_short_name(self): # The user is identified by their email address return self.username def has_perm(self, perm, obj=None): \"Does the user have a specific permission?\" return True def has_module_perms(self, app_label): \"Does the user have permissions to view the app `app_label`?\" return True def calculate_au(self): \"\"\" 计算活跃度 公式：Topic * 5 + Comment * 1 \"\"\" self.au = self.topic_num * 5 + self.comment_num * 1 return self.au @property #类中函数可以直接做为属性使用 def is_staff(self): \"Is the user a member of staff?\" # Simplest possible answer: All admins are staff return self.is_admin 重载Admin表单 由于修改了默认的django表结构，此时在admin界面修改密码或添加用户数据已经不能再按照之前的表单系统啦 需要在app的admin.py中重写UserCreationForm和UserChangeForm 123456789101112131415161718192021222324252627282930313233# 用户创建表单from django import formsfrom django.contrib import adminfrom django.contrib.auth.admin import UserAdminfrom django.contrib.auth.forms import ReadOnlyPasswordHashFieldfrom people.models import Member, Followerclass UserCreationForm(forms.ModelForm): \"\"\"A form for creating new users. Includes all the required fields, plus a repeated password.\"\"\" password1 = forms.CharField(label='密码', widget=forms.PasswordInput) password2 = forms.CharField(label='确认密码', widget=forms.PasswordInput) class Meta: model = Member fields = ('email', 'username') def clean_password2(self): password1 = self.cleaned_data.get(\"password1\") password2 = self.cleaned_data.get(\"password2\") if password1 and password2 and password1 != password2: raise forms.ValidationError(\"两次输入验证失败\") return password2 #在form中的clean__field函数会在is_valid()函数验证时自动调用 def save(self, commit=True): user = super(UserCreationForm, self).save(commit=False) user.set_password(self.cleaned_data[\"password1\"]) #set_password将会采用django的加密算法将密码设置到对应的模型实例中 #在内存中创建的好的对象只有通过commit=True才被真正执行到数据库上 if commit: user.save() return user 123456789# 密码改变时的展示表单class UserChangeForm(forms.ModelForm): password = ReadOnlyPasswordHashField() class Meta: model = Member fields = ('email', 'password', 'username', 'is_active', 'is_admin',) def clean_password(self): return self.initial[\"password\"] #使用默认的save函数即可 1234567891011121314151617181920212223242526# 真正的用户admin界面管理方式class MyUserAdmin(UserAdmin): form = UserChangeForm add_form = UserCreationForm list_display = ('id', 'email', 'username', 'email_verified', 'last_login','is_active','is_admin','last_ip') list_display_links = ('id', 'email', 'username') list_filter = ('email', 'email_verified',) fieldsets = ( (None, &#123;'fields': ('username', 'email', 'date_joined', 'password','is_active','is_admin','avatar')&#125;), ('状态', &#123;'fields': ('email_verified', 'last_ip', 'au', 'topic_num', 'comment_num')&#125;), ('社交网络', &#123;'fields': ('weibo_id', 'blog')&#125;), ) add_fieldsets = ( (None, &#123; 'classes': ('wide',), #admin样式设置 #Fieldsets 使用 wide 样式将会有额外的水平空格. 'fields': ('email', 'username', 'password1', 'password2','is_active','is_admin')&#125; ), ) search_fields = ('id', 'email', 'username') ordering = ('id', 'email', 'email_verified') filter_horizontal = () #这个字段为了设置与groups关联的多选框admin.site.register(Member, MyUserAdmin)admin.site.register(Follower) 最终 还需要在settings.py文件下进行设置，覆盖最小的User模型 AUTH_USER_MODEL = &#39;people.Member&#39;","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Django邮件发送及华丽呼哨的邮件格式","slug":"Django邮件发送及华丽呼哨的邮件格式","date":"2019-12-09T08:19:22.320Z","updated":"2019-12-09T11:26:32.354Z","comments":true,"path":"Django邮件发送及华丽呼哨的邮件格式/","link":"","permalink":"https://cy-blogs.cn/Django邮件发送及华丽呼哨的邮件格式/","excerpt":"发送邮件 django中内置了许多方法可以使开发者方便的进行邮件发送 邮件配置 发送邮件，首先需要在项目的settings.py文件下配置邮件服务器连接等信息 123456EMAIL_USE_SSL = True # Secure Sockets Layer 安全套接层, 取决于邮件服务器是否开启加密协议EMAIL_HOST = 'smtp.qq.com' # 邮件服务器地址EMAIL_PORT = 465 # 邮件服务器端口 EMAIL_HOST_USER = 'account@qq.com' # 登陆邮件服务器的账号EMAIL_HOST_PASSWORD = 'password' # 登陆邮件服务器的密码DEFAULT_FROM_EMAIL = EMAIL_HOST_USER # 邮件的发送者","text":"发送邮件 django中内置了许多方法可以使开发者方便的进行邮件发送 邮件配置 发送邮件，首先需要在项目的settings.py文件下配置邮件服务器连接等信息 123456EMAIL_USE_SSL = True # Secure Sockets Layer 安全套接层, 取决于邮件服务器是否开启加密协议EMAIL_HOST = 'smtp.qq.com' # 邮件服务器地址EMAIL_PORT = 465 # 邮件服务器端口 EMAIL_HOST_USER = 'account@qq.com' # 登陆邮件服务器的账号EMAIL_HOST_PASSWORD = 'password' # 登陆邮件服务器的密码DEFAULT_FROM_EMAIL = EMAIL_HOST_USER # 邮件的发送者 注意：EMAIL_HOST_PASSWORD所设置的登陆邮件服务器的密码为邮件客户端后台所设置的第三方客户端登陆密码，这个值并非直接账号密码 如：QQ邮箱的该值密码在网页版QQ邮件客户端的设置-&gt;帐户-&gt;开启POP3/SMTP服务|IMAP/SMTP服务 发送文本邮件 发送普通邮件可以使用django.core.mail模块下的send_mail函数进行 send_mail(subject, message, from_email, recipient_list, fail_silently=False, html_message=None) 将邮件发送至recipient_list中的每一个收件人处 subject：发送邮件标题 message：发送邮件正文 from_email：发件人邮箱地址 recipient_list：一个字符串列表，每一个数据为接收者的邮箱地址 html_message：如果指定该值，则发送的内容类型为text/html为一个html邮件内容 发送普通邮件视图函数 1234567891011from django.core.mail import send_maildef send_email(request): subject = '邮件测试' message = '&lt;a href=\"http://www.python.org\"&gt;学习Python，我很快乐&lt;/a&gt;' send_mail( subject = subject, message = message, from_email = 'from@qq.com', recipient_list = ['recv@qq.com','recv1@qq.com'] ) return HttpResponse('Down') 发送HTML邮件 发送这里的邮件内容为一个HTML的a标签，但是真正接收者接到该邮件时，a标签并不会解释称为真正的a标签，只是一个普通的字符串，这是因为当前发送邮件的类型为text/plain，可以使用html_message参数进行HTML内容的发送 123456789101112from django.core.mail import send_maildef send_email(request): subject = '邮件测试' message = '&lt;a href=\"http://www.python.org\"&gt;学习Python，我很快乐&lt;/a&gt;' send_mail( subject = subject, message = '', # 该参数为必须参数，必须填写 html_message = message, from_email = 'from@qq.com', recipient_list =['recv@qq.com','recv1@qq.com'] ) return HttpResponse('Down') 发送html格式邮件还可以使用django.core.mail模块下的EmailMultiAlternatives类进行邮件体的构造，然后进行邮件发送 EmailMultiAlternatives(subject=&#39;&#39;, body=&#39;&#39;, from_email=None, to=None) subject：邮件标题 body：邮件内容 from_email：邮件发送者 to：邮件接收人列表 EmailMultiAlternatives.attach_alternative(content, mimetype) 向EmailMultiAlternatives实例中添加mimetype支持的邮件内容 content：添加的邮件内容 mimetype：添加内容的mime类型 EmailMultiAlternatives.send() 发送邮件 1234567891011121314from django.core.mail import EmailMultiAlternativesdef send_email(request): subject = '邮件测试' text_message = '学习Python，我很快乐' html_message = '&lt;a href=\"http://www.python.org\"&gt;学习Python，我很快乐&lt;/a&gt;' email = EmailMultiAlternatives( subject = subject, body = text_message, from_email = '1747266529@qq.com', to = ['recv@qq.com','recv1@qq.com'] ) email.attach_alternative(html_message,'text/html') # 添加HTML邮件部分 email.send() # 发送邮件 return HttpResponse('Down') 发送富文本邮件 经常需要我们在邮件中加入图片等静态资源 需要用到python中email.mime.image模块下的MIMEImage类进行图片内容的构造 这里发送邮件使用EmailMessage类，来自于django.core.mail模块下 并在使用对应该类实例的attach添加图片资源数据 最后使用实例的send函数发送邮件 EmailMessage(subject=&#39;&#39;, body=&#39;&#39;, from_email=None, to=None) ``subject`：邮件标题 body：邮件内容 from_email：邮件发送者 to：邮件接收人列表 12345678910111213141516171819202122232425262728293031323334from sendmailpro.settings import STATICFILES_DIRSimport osfrom email.mime.image import MIMEImagefrom django.core.mail import EmailMessagedef send_email(request): subject = '图片邮件测试' file_1 = os.path.join(STATICFILES_DIRS[0],'img/1.png') with open(file_1, 'rb') as fp: # 打开第一张图片 image_1 = MIMEImage(fp.read()) file_2 = os.path.join(STATICFILES_DIRS[0],'img/2.png') with open(file_2, 'rb') as fp: # 打开第二张图片 image_2 = MIMEImage(fp.read()) body = \"&lt;img src='cid:first_id'&gt;&lt;br&gt;&lt;img src='cid:sec_id'&gt;\" # 发送邮件主体内容 image_1.add_header('Content-ID','&lt;%s&gt;' % 'first_id') # 通过 CID 对称图片在邮件内容中的位置 image_2.add_header('Content-ID','&lt;%s&gt;' % 'sec_id') message = EmailMessage( # 构建发送的邮件主体 subject=subject, body=body, from_email='from@qq.com', to=['recv@qq.com','recv1@qq.com'] ) message.content_subtype = 'html' message.attach(image_1) # 添加两张图片 message.attach(image_2) message.send() # 发送邮件 return HttpResponse('Down') 发送附件邮件 发送附件，也可以使用django.core.mail模块下的EmailMessage类进行附件邮件体构造 通过EmailMessage实例的attach|attach_file两个函数在邮件主体中添加附件内容 attach_file添加邮件附件直接加入路径即可，但是attach添加附件内容需要提供附件内容 attach(filename=None, content=None, mimetype=None) 添加附件内容 filename：附件文件名称 content：附件内容 mimetype：附件的MIME类型 attach_file(path, mimetype=None) 直接通过路径添加附件 path：附件路径 mimetype：附件的MIME类型 123456789101112131415161718192021from sendmailpro.settings import STATICFILES_DIRSimport osfrom email.mime.image import MIMEImagefrom django.core.mail import EmailMessagedef send_email(request): subject = '附件邮件测试' email = EmailMessage( subject=subject, body='这是一封具有图片附件的邮件', from_email='from@qq.com', to=['recv@qq.com','recv1@qq.com'] ) file_1 = os.path.join(STATICFILES_DIRS[0],'img/1.png') image_1 = open(file_1,'rb').read() email.attach('1.png',image_1,'image/png') # 使用attach实例函数添加附件内容 file_2 = os.path.join(STATICFILES_DIRS[0],'img/2.png') email.attach_file(file_2,mimetype='image/png') # 使用attach_file实例函数添加附件路径 email.send() return HttpResponse('Down')","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Django缓存系统","slug":"Django缓存系统","date":"2019-12-09T08:16:28.960Z","updated":"2019-12-09T11:26:29.098Z","comments":true,"path":"Django缓存系统/","link":"","permalink":"https://cy-blogs.cn/Django缓存系统/","excerpt":"缓存 Django 是动态Web后台框架，需要实时生成用户访问的页面，进行多次的数据库操作，但是多次的数据库访问操作对于整个Web系统来说，会影响效率，尤其是当访问量增大时，数据库的压力也会越来越大。 相对于磁盘及内存操作，数据库的访问操作付出的成本要大的多","text":"缓存 Django 是动态Web后台框架，需要实时生成用户访问的页面，进行多次的数据库操作，但是多次的数据库访问操作对于整个Web系统来说，会影响效率，尤其是当访问量增大时，数据库的压力也会越来越大。 相对于磁盘及内存操作，数据库的访问操作付出的成本要大的多 浏览器第一次请求时，cache会缓存单个变量或整个网页等内容到硬盘或者内存中，同时设置response头部 当浏览器再次发起请求时，会与缓存中的过期时间相比较，如果缓存时间比较新，则会重新请求数据，并缓存起来然后返回response给客户端，如果缓存没有过期，则直接从缓存中提取数据，返回给response给客户端 Cache-Control HTTP协议头Cache-Control，Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires 在python中使用memcached需要我们额外安装memcached作为memcache客户端的支持 1pip3 install python-memcached -i https://pypi.tuna.tsinghua.edu.cn/simple Cache设置memcached 安装memcached 1234apt-get install memcached# debianyum install memcached # centos 配置文件：/etc/memcached.conf 配置文件中有两个可能需要修改的参数 12-m 64 #memcached所能使用的内存大小-l 127.0.0.1 #监听的IP地址 开启|关闭memcached服务 12systemctl start memcached # 开启systemctl stop memcached # 关闭 查看服务状态 1systemctl status memcached settings配置 使用memcached缓存，首先需要在项目的settings文件下进行配置 12345678CACHES = &#123; 'default': &#123; 'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache', # 指定缓存使用的引擎 'LOCATION':'172.16.19.26:11211', # 指定缓存服务器地址，常为本机地址 &#125;&#125; 视图缓存 可以只为某些视图函数进行缓存 使用django.views.decorators.cache下的装饰器cache_page进行视图函数装饰即可 模型类的表代码 12class People(models.Model): name = models.CharField(max_length=20,verbose_name='名字') 视图函数代码 1234567from django.views.decorators.cache import cache_page@cache_page(10) # 缓存10秒def index(request): print('视图函数被调用') ss = models.People.objects.all() return render(request, 'index.html', locals()) 模板页面代码 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;展示数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;% for s in ss %&#125; &lt;li&gt;&#123;&#123; s.name &#125;&#125; &lt;/li&gt; &#123;% endfor %&#125;&lt;/body&gt;&lt;/html&gt; 在第一次刷新浏览器之后， 立即在数据库中添加一个新的数据对象 接着继续刷新浏览器，前端页面将会读取缓存中的结果，而不会显示刚才添加的用户 除了在视图函数上使用装饰器进行缓存设置，还可以在路由匹配部分使用相同装饰器函数进行设置 全站缓存 将整站所有视图设置缓存，需要在配置文件的中间件设置首尾部分添加如下内容 12345678MIDDLEWARE = [ 'django.middleware.cache.UpdateCacheMiddleware', # 首部要添加的中间件 # 将response缓存起来 'django.middleware.security.SecurityMiddleware', ... 'django.middleware.cache.FetchFromCacheMiddleware',# 尾部要添加的中间件 # 将缓存的response取出来] 以及搭配设置当前全站缓存有效时间的全局变量 1CACHE_MIDDLEWARE_SECONDS = 10 # 每页页面缓存的秒数，默认为600 局部缓存 局部缓存主要为在模板页面，选择某个区域进行缓存，当用户再次访问相同页面时，如设置缓存未过期，则渲染时局部缓存不会重新生成 12345&#123;% load cache %&#125; 局部缓存首先需要加载cache标签 &#123;% cache sec key %&#125;&#123;% endcache %&#125; 以时间模板变量为例，做一个简单的测试，后台视图函数每次在访问时，返回当前时间 12import time now = time.strftime('%H:%M:%S', time.localtime()) 模板页面在使用时的代码 123456&#123;% load cache %&#125;&lt;p&gt;这里是未缓存的时间:&#123;&#123; now &#125;&#125;&lt;/p&gt;&#123;% cache 10 time %&#125;&lt;p&gt;这里是缓存的时间:&#123;&#123; now &#125;&#125;&lt;/p&gt;&#123;% endcache %&#125; 手动缓存 除了以上应用于各个业务中的缓存方式，还可以使用django所提供的cache接口进行缓存设置以及获取 设置缓存 1234from django.core.cache import cache#存储缓存数据cache.set('cache_key',data,60*15)#cache_key为存储在缓存中的唯一值，data为存储的数据，60*15为缓存有效时间 获取缓存 123#获取缓存数据cache.get('cache_key','获取不到的默认值')#cache_key为储存缓存数据的唯一值 避免key值重复导致更新缓存，可以使用cache.add函数，基本用法与set相同 123status = cache.add('add_key', 'New value')# 当指定key值的缓存存在，add方法不会尝试更新缓存# 返回值status为True时，代表存储成功，False代表存储失败 清除缓存，通过cache.delete方法，该方法接收一个缓存key值 1cache.delete('cache_key') 清空缓存，通过cache.clear方法，直接从缓存中清除所有 1cache.clear() 注意 memcached不允许使用超过250个字符或包含空格或控制字符的缓存键值 使用这样的键值将会导致异常","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Django的消息框架(message)与Django分页组件(paginator)","slug":"Django的消息框架(message)与Django分页组件(paginator)","date":"2019-12-09T08:11:25.363Z","updated":"2019-12-09T11:26:22.907Z","comments":true,"path":"Django的消息框架(message)与Django分页组件(paginator)/","link":"","permalink":"https://cy-blogs.cn/Django的消息框架(message)与Django分页组件(paginator)/","excerpt":"Messages消息框架 在网页应用中，你经常需要在处理完表单或其它类型的用户输入后。显示一个通知消息（也叫做flash message给用户 对于这个功能，Django提供基于Cookie 和会话的消息，无论是匿名用户还是认证的用户。 其消息框架允许你临时将消息存储在请求中，并在接下来的请求（通常就是下一个请求）中提取它们并显示。每个消息都带有一个特定level 标签，表示其优先级（例如info、warning 或error）","text":"Messages消息框架 在网页应用中，你经常需要在处理完表单或其它类型的用户输入后。显示一个通知消息（也叫做flash message给用户 对于这个功能，Django提供基于Cookie 和会话的消息，无论是匿名用户还是认证的用户。 其消息框架允许你临时将消息存储在请求中，并在接下来的请求（通常就是下一个请求）中提取它们并显示。每个消息都带有一个特定level 标签，表示其优先级（例如info、warning 或error） django-admin startproject 创建的默认settings.py 已经包含启用消息框架功能需要的所有的设置 INSTALLED_APPS 中的&#39;django.contrib.messages&#39;。 MIDDLEWARE_CLASSES 中的&#39;django.contrib.sessions.middleware.SessionMiddleware&#39; 和&#39;django.contrib.messages.middleware.MessageMiddleware&#39; 默认的后端存储 依赖[sessions] 所以MIDDLEWARE_CLASSES 中必须启用SessionMiddleware 并出现在MessageMiddleware 之前 TEMPLATES 设置中定义的DjangoTemplates 的&#39;context_processors&#39; 选项包含&#39;django.contrib.messages.context_processors.messages&#39; 消息级别 12&gt; from django.contrib import messages&gt; messages.debug messages.info messages.success messages.warning messages.error 使用消息框架 视图函数只需要创建messages消息对象即可 12messages.warning(request,'登陆失败，用户名或密码无效')return render(request,'login.html',locals()) 前端模板中判断是否含有messages消息，遍历取出即可 也可以结合bootstrap框架让提示消息变得更加美丽 1234567&#123;% if messages %&#125; &#123;% for message in messages %&#125; &lt;div class=\"alert alert-&#123;&#123; message.tags &#125;&#125; fade in\"&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &#123;% endfor %&#125;&#123;% endif %&#125; 注意：messages对象是一个数据集，并不是单独的一条消息，需要我们在使用时，必须通过for循环进行访问 Paginator分页组件 12&gt; from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger&gt; 1Paginator ：创建分页对象 分页对象内置属性 1234567891011121314all_ = models.objects.all()p = Paginator(all_, 10)# 分页all_数据，每页显示10条数据p.count# 总数据量p.num_pages() # 分页数p.page_range() # 列表形式返回当前可有的页数 [1,2,3]page_1 = p.page(1) # 选择第一页，返回第一页数据对象page_1.object_list# 返回第一页所有数据for var in page_1: print(var)ABC... 某一页内置属性12345678910111213141516page_1.number # 当前页的页码page_1.has_next() # 是否有下一页page_1.has_previous()# 是否有上一页page_1.has_other_pages()# 是否含有其他页page_1.next_page_number() # 下一页的页码page_1.previous_page_number()# 上一页的页码page_1.start_index() # 该页第一个数据的索引page_1.end_index()# 该页最后一个数据的索引 EmptyPage：取不到页面数据，抛出该异常 1234567all_ = models.objects.all()p = Paginator(all_, 10)try: list_ = p.page(page_num) except EmptyPage: #没有第page_num页 list_ = paginator.page(1) # 取不到该也数据，直接返回第一页数据 PageNotAnInteger：当页数是一个非整数类型时，抛出该异常 模板页面基本使用方式123456789&#123;% if topic_list.has_previous %&#125;&lt;!-- 当前页是否含有上一页 --&gt; &lt;a href=\"?page=&#123;&#123; list_.previous_page_number &#125;&#125;\"&gt;上一页&lt;/a&gt; &lt;!-- 连接传参形式传递上一页的页码ID --&gt;&#123;% endif %&#125;&#123;% if topic_list.has_next %&#125;&lt;!-- 当前页是否含有下一页 --&gt; &lt;a href=\"?page=&#123;&#123; list_.next_page_number &#125;&#125;\"&gt;下一页&lt;/a&gt;&lt;!-- 连接传参形式传递下一页的页码ID --&gt;&#123;% endif %&#125;","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Django的CBV类视图","slug":"Django的CBV类视图","date":"2019-12-09T08:07:02.109Z","updated":"2019-12-09T11:26:26.250Z","comments":true,"path":"Django的CBV类视图/","link":"","permalink":"https://cy-blogs.cn/Django的CBV类视图/","excerpt":"CBV CBV（class base views） 就是在视图里使用类处理请求 之前的代码中，我们的视图函数都是通过函数来进行request的响应以及response的返回，并且通常我们需要判断的请求方式get或是post都需要我们在代码中通过if进行条件判断，这样的视图功能编写就叫做FBV","text":"CBV CBV（class base views） 就是在视图里使用类处理请求 之前的代码中，我们的视图函数都是通过函数来进行request的响应以及response的返回，并且通常我们需要判断的请求方式get或是post都需要我们在代码中通过if进行条件判断，这样的视图功能编写就叫做FBV 但现在在django中还提供了一种方式叫做CBV，在类中编写视图功能， 并且将传统的get、post判断设置为了类中函数，这样当用户发起不同的请求，会自动进入到对应的类中函数上，像是下面这样 1234567891011from django.views import Viewclass ArticleView(View): def get(self,request): raise Http404 def post(self,request): if request.is_ajax(): id_ = request.POST.get('id_') result = models.Article.objects.get(id=id_).content data = result.replace('\\r\\n','&lt;br&gt;') return HttpResponse(json.dumps(data,ensure_ascii=False) ) raise Http404 通过将请求类型定义为函数，可以更加方便进行请求方式判断 用户访问时，会经由View基类中的as_view -&gt; dispatch进行判断，通过请求类型分发到不同对应请求的函数名下；也就是通过get方式访问，那么对应会调用到名为get的函数 此外，类中函数必须为小写， 对应路由此时设置为，需要使用试图类的as_view函数进行实例化 12#url.pypath('article/',ajaxviews.ArticleView.as_view()) 通过类视图可以方便我们进行请求条件的判断 并且可以在进行接口开发时，实现同一资源路由在使用不同请求访问时的功能解耦和 意思就是不用再把所有的功能都堆到一个视图函数里啦。多方便！ 并且，在Django-Restframework框架中，也将频繁使用CBV形式进行视图编写 类视图装饰器 在类视图中使用为函数视图准备的装饰器时，不能直接添加装饰器 需要使用method_decorator将其转换为适用于类视图方法的装饰器 12&gt; from django.utils.decorators import method_decorator&gt; 全部装饰 123456789101112131415from django.views import Viewfrom django.utils.decorators import method_decoratordef my_decorator(func): def nei(request): # dispatch函数有参数request print('这是装饰器在调用') return func(request) return nei@method_decorator(my_decorator, name='dispatch')# 为全部请求方法添加装饰器class DemoView(View): def get(self, request): print('get方法') return HttpResponse('ok') def post(self, request): print('post方法') return HttpResponse('ok') 为部分装饰，只需要通过method_decorator方法的name参数选择装饰的函数名即可 12345678@method_decorator(my_decorator, name='post')class DemoView(View): def get(self, request): print('get方法') return HttpResponse('ok') def post(self, request): print('post方法') return HttpResponse('ok') 为特定的多个类视图函数进行装饰，只需要在每个函数上使用method_decorator装饰器即可 123456789class DemoView(View): @method_decorator(my_decorator) # 为get方法添加了装饰器 def get(self, request): return HttpResponse('ok') @method_decorator(my_decorator) # 为post方法添加了装饰器 def post(self, request): return HttpResponse('ok') 类视图csrf_token装饰 当类视图需要允许跨站提交数据时，使用csrf_exempt装饰器装饰函数可以被跨域访问 但是使用上面的方法进行csrf_exempt是不行的，需要在类视图基类的dispatch函数上进行装饰 12345678910111213from django.views.decorators.csrf import csrf_exempt#@method_decorator(csrf_exempt,name='dispatch')# 直接加载类视图上也是可以修饰的class DemoView(View): @method_decorator(csrf_exempt) def dispatch(self, request, *args, **kwargs): return super(DemoView,self).dispatch(request, *args, **kwargs) def get(self, request): print('get方法') return HttpResponse('ok') def post(self, request): print('post方法') return HttpResponse('ok') csrf装饰只能在类视图的dispatch函数上才能被生效 除了在类视图的dispatch函数上进行装饰，在路由映射处使用csrf_exempt函数修饰路由规则也是可以的 123456#urls.pyfrom django.views.decorators.csrf import csrf_exempturlpatterns = [ ... path('',csrf_exempt(ajaxviews.DemoView.as_view()))]","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Django初识","slug":"Django初识","date":"2019-12-09T07:48:31.829Z","updated":"2019-12-20T00:56:47.828Z","comments":true,"path":"Django初识/","link":"","permalink":"https://cy-blogs.cn/Django初识/","excerpt":"开始玩耍Django Django是一个开放源代码的Web应用框架，由Python写成。采用了MVT的框架模式；最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件 框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的","text":"开始玩耍Django Django是一个开放源代码的Web应用框架，由Python写成。采用了MVT的框架模式；最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件 框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的 django安装 pip install django==2.0.4(版本号) pip install django默认安装最新版本 创建项目 12&gt; django-admin startproject myproject&gt; 开启开发服务器 cd myproject：进入项目目录 python manage.py runserver：开启服务 python manage.py runserver 7000：改变服务监听端口 python manage.py runserver 0:8000：改变服务监听IP:端口 项目文件夹1234manage.py：用来管理当前项目的一个命令行工具myproject/： 项目主文件夹myproject/__init__.py：空文件，用来指明当前的myproject为一个可导入的模块包myproject/settings.py：项目主要配置文件myproject/urls.py：项目主要路由配置文件myproject/wsgi.py：项目部署WSGI并发服务器时所需要的配置文件 Settings.py 该文件是整个项目的主控文件，其中相关配置选项如下 https://docs.djangoproject.com/zh-hans/2.0/ref/settings/ 123456789101112131415161718192021222324- BASE_DIR: 当前项目工作目录，用来在每一次开启项目时动态找到相关资源路径- SECRET_KEY: 加密的hash值以及保护某些签名数据的关键密钥- DEBUG: 调试模式- ALLOWED_HOSTS: 有哪些主机或域名可以访问当前django站点，如设置为*代表全部可访问。- INSTALL_APPS: django项目中所有使用的应用名称，自创建子应用也要加到这里，不然ORM数据库无法被识别到！- MIDDLEWARE: django中间件，用来在request或reponse过程中添加功能，比如确保安全性，传输保存Session等- SecurityMiddleware: xss脚本过滤，一些安全设置 - SessionMiddleware: session支持中间件，在每次用户访问django项目时，添加session对每一个浏览器- CommonMiddleware: 通用组件，比如为路由添加末尾斜杠- CsrfViewMiddleware: 防跨站请求伪造令牌，为客户端添加csrf_token密钥，在表单提交时需提交该值- AuthenticationMiddleware: admin用户组件，每个request对象都会被添加admin下的user属性- MessageMiddleware: 消息中间件 展示一些后台消息给前端- XFrameOptionsMiddleware: 防止欺骗点击攻击出现；自身页面被嵌入到他人页面中，点击欺骗- ROOT_URLCONF: 主路由配置文件，字符串填写url.py文件路径- TEMPLATES: 模板文件配置项- WSGI_APPLICATION: WSGI服务器配置项，找到当前django下的wsgi引入APP文件- DATABASES: 数据库配置项，默认使用SQLite3，一个本地文件数据库- AUTH_PASSWORD_VALIDATORS: 检查用户密码强度的验证程序列表，不过是针对admin界面下的用户，而非自定义- LANGUAGE_CODE: django所使用语言文件- TIME_ZONE: django所使用时区- USE_I18N: 国际化支持 18表示Internationalization这个单词首字母I和结尾字母N之间的字母有18个- USE_L10N: 是localization的缩写形式，意即在l和n之间有10个字母- USE_TZ:开启了Time Zone功能，则所有的存储和内部处理，包括print显示的时间将是是UTC时间格式- STATIC_URL: URL访问静态资源时的路径 来搞个Hello worlddjango创建子应用 项目和应用有啥区别？ 应用是一个专门做某件事的网络应用程序：比如博客系统，或者公共记录的数据库，或者简单的投票程序 项目则是一个网站使用的配置和应用的集合。项目可以包含很多个app应用，应用可以被很多个项目使用 python manage.py startapp myapp 创建子应用 app目录1234- admin.py: app在admin注册展示时需要的文件- views.py: app的功能视图函数文件- models.py: app需要使用数据库时的文件- urls.py: 当使用include路由分发时，每个app应该有他自己的子路由文件，这个是默认没有创建好的 视图函数 打开app下的views.py文件 Web访问起始就是通过一个URL连接地址访问到服务器上的一个函数 在views.py中我们通过编写函数的形式，接收用户请求的request并返回一个response 12345# 每一个视图函数都需要有一个必须参数 request,用来接收用户访问时的请求内容from django.http import HttpResponsedef index(request): return HttpResponse(\"&lt;h1&gt;Hello world&lt;/h1&gt;\") HttpResponse函数用来向用户返回一个字符串 路由配置 创建好了一个可以在请求时返回H1标签的视图函数，但是现在通过浏览器还是访问不到 需要我们为这个app下的函数进行路由配置 第一种简单的路由配置，直接在主控路由文件下，找到这个视图函数 12345678910#myproject/urls.pyfrom django.contrib import adminfrom django.urls import pathfrom myapp import viewsurlpatterns = [ path('admin/', admin.site.urls), #admin控制界面路由 path('',views.index) #path函数第一个参数为访问地址，空字符串代表：当用户直接访问首页时 #第二个参数代表访问该地址时对应的视图函数，我们引入了app下的views中的index视图函数 ] 接下来访问127.0.0.1:8000，那么你会看到一个非常大的Hello world 以上将视图函数的查找直接写到主控路由并不是最好的办法 我们的项目通常会有非常多的路由配置项，如果都堆到这个文件中肯定是非常乱的，难以维护 我们可以在对应app下创建一个子路由控制文件，并在其中设置视图的路由配置 1234#myapp/urls.pyfrom django.urls import pathfrom . import viewsurlpatterns = [ path(\"\",views.index)] 现在虽然配置了app下的路由文件，但是访问时，是看不到对应视图的结果 这是因为默认的url查找动作将会从主控路由文件开始，我们还需要在主控路由文件下进行路由分发设置 让主控路由可以找到子app下的路由映射文件 123456789#myproject/urls.pyfrom django.contrib import adminfrom django.urls import path,includefrom myapp import viewsurlpatterns = [ path('admin/', admin.site.urls), #path('',views.index) path('',include(\"myapp.urls\")), # 函数 include() 允许引用其它 URLconfs ] 接下来再次尝试，在浏览器中访问主机域名；如果可以看到的话，恭喜你，效果已经很棒了！ 路由查找流程 查找主控路由文件下的urlpatterns全局变量，这是一个序列数据类型，其中每一个元素都是对应的一个路由匹配规则 如果在规则中查找到符合匹配规则的，则执行其中的对应执行函数 如果对应的不是一个执行函数，而是一个include路由包含，那么截断与此项匹配的URL的部分，并将剩余的路由字符串发送到include所包含的子路由文件中以供进一步处理 如果没有匹配到的任何结果，django默认抛出Page not found (404) 注意：Django的路由不考虑HTTP请求方式，仅根据URL进行路由，即，只要URL相同，无论POST、GET等哪种请求方式都指向同一个操作函数 path path函数用来处理一个路由对应的视图映射 path(route, view, name) route： 匹配规则，是一个字符串 view：对应的视图函数 name：未来我们会用到他，用来为匹配规则命名，这样方便日后修改路由而不影响全局下的路由使用 re_path re_path是path函数的加强版 可以在re_path函数的第一个位置的字符串参数，是一个标准Python正则表达式，其余参数与path相同 注意：匹配模式的最开头不需要添加/，因为默认情况下，每个url都带一个最前面的/，既然大家都有的部分，就不用浪费时间特别写一个了，所以一定要注意在写路由映射关系时，记得加末尾的/ 模板页面 返回一个字符串这肯定是不行的，太low了，也不好看，现在来返回一个正式的HTML页面 并在HTML页面中加入模板变量，由视图函数动态传递值； 配置django中模板页面的保存路径，在项目目录下的settings.py文件中 12345678910111213141516#myproject/settings.pyTEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR,'template')], # 就是这一行 设置静态模板路径 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 创建template目录并在其中创建index.html文件 1234567&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;hi&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 在HTML页面中，我们并没有明确指出H1标签的内容；通过一个``来等待接收视图函数传来的数据，在HTML页面中这样的变量也叫做模板变量，双大括号为使用语法 接下来修改之前的视图函数，由视图函数传递变量给到HTML页面 12345678#myapp/views.pyfrom django.shortcuts import renderdef index(request): #return HttpResponse(\"&lt;h1&gt;Hello world&lt;/h1&gt;\") content = &#123; \"message\":\"你好，世界\" #此处的key值message对应页面中我们写的&#123;&#123; message &#125;&#125; &#125; return render(request,'index.html',content) render render函数用来返回一个模板页面，并将一个字典组合成的模板变量传递到模板页面上，完成页面的渲染 render(request, template_name, context=None) 返回一个HTTP响应 request： 固定接收request请求 template_name： 为一个可以找到的模板页面 context： 模板页面所需模板变量 模板变量 在django中的HTML页面，不光可以编写原本的标签等内容，还可以像Vue一样在页面中使用双大括号，来提前定义一些模板变量，之后动态的渲染到HTML模板页面中 模板变量可以由后台视图函数构建一个字典数据类型传递， 字典的key是模板变量名，value值该模板变量对应的数据 当然，模板变量的内容远不止此，还会再后面继续为大家叙述 静态文件 虽然有了模板页面，可以来展示一些标签的效果，但是整个HTML还是感觉很丑陋 我们还要继续引入一些类似css、img这样的静态资源，来装饰我们的页面 在django中模板页面的静态资源使用，不能像之前写HTML代码直接引入 需要我们首先在项目中创建目录保存对应的静态资源，该目录名常为static 在settings中配置静态文件保存目录，添加如下内容 12STATICFILES_DIRS = ( os.path.join(BASE_DIR, 'static'),)# STATICFILES_DIRS 该配置项用来告诉django在查找静态资源时，应该访问哪个目录 在项目中创建static目录，static目录下创建专门保存图片的img目录，在里面存一张图片1.jpg 1#此时的目录结构myproject/ myproject/ myapp/ template/ static/ img/ 1.jpg 有了图片，接下来在模板页面中去引入并使用它，打开index.html进行修 123456789&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &#123;% load staticfiles %&#125;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;hi&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt; &lt;img src='&#123;% static \"img/1.jpg\" %&#125;' alt=\"图片\"&gt; &lt;/body&gt;&lt;/html&gt; 12345&gt; 这里用到了一个特殊语法：&#123;% tag %&#125; 这个叫静态标签，静态标签不同于模板变量，静态标签经常用来加载数据，或创建逻辑，比如之后我们要学到的&#123;% if %&#125;，使用静态标签可以方便我们在模板页面上实现某些只有在后台代码中才可以实现的逻辑功能&gt; 在页面中要引入静态资源：图片，`CSS`，`JS`文件在引入时都需要通过&#123;% static “path” %&#125;来进行引入&gt;&gt; 最后，需要使用静态标签`static`前使用&#123;% load staticfiles %&#125;标签进行静态资源路径的加载 模型数据库 有了以上内容的修饰，现在感觉还是缺少一些什么，我们在视图函数中为前端页面返回的是一个提前定义好的变量，这显然在真正开发中是很少出现的，我们的数据大都来自于数据库中，那么现在需要我们在项目中加入数据库，并且在视图函数中通过对数据库的访问来拿到数据 创建数据库，这里使用项目自带的SQLite3数据库，默认已经是配置好的，接下来需要我们进入到app下的models.py文件中，编写一个类，这个类就对应数据库中的一张表 123456789#myapp/models.pyfrom django.db import models# Create your models here.class Weather(models.Model): weather = models.CharField(max_length=100,verbose_name=\"天气\") class Meta: verbose_name_plural = \"天气\" # 设置当前表名的一个可读的性更好的名字 def __str__(self): return self.weather 在这里我们使用到了django的orm映射关系用来创建数据库表，继承自django的models.Model类， 一个类用来表示一张表，类中的一个属性代表一个字段， 这里我们定义了一个类型为CharField，长度为100的字段，用来存储天气 12&gt; models.CharField(max_length=100,verbose_name=\"天气\")&gt; 下面的class Meta是模型类的元类，用来设置当前表的一些属性； 这里我们使用verbose_name_plural属性设置当前表在admin后台查看时的名字 在这里我们还定义了一个属于实例的函数__str__，用来描述当前数据在返回时的默认展示结果，为weather字段的值 12&gt; django`在创建模型类对应的数据表时，默认使用 `应用名`加`下划线`加`模型类名`作为表的名字；比如当前`Weather`表名为：`myapp_Weather&gt; orm映射关系，是django与数据库之间的一个桥梁，可以使开发者不再关注如何去编写SQL语句，直接通过一套ORM所提供的API接口即可方便对各种数据库进行交互 当某个子应用APP涉及到了数据库的使用时，要记得在settings文件中进行配置 12345678910#myproject/settings.pyINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'myapp',] 接下来通过manage.py命令行管理工具提供的两条，创建我们所需要的数据 注意：默认django本身就已经需要一些数据的创建，所以我们在初次执行以下两条命令时可能会看到很多数据表和字段的创建，不要惊讶，这是正常的 python manage.py migrate：根据数据库迁移文件生成对应SQL语句并执行 初次执行是为了先把默认django需要的数据库创建出来 python manage.py makemigrations：创建数据库迁移文件 这次执行是为了创建APP中Weather模型类的迁移文件 12&gt; python manage.py migrate&gt; 将新添加的模型类迁移文件生成对应SQL，实际创建出对应的Weather表 如果提示结果正常，那么代表相应的数据表已经创建好了，接下来就需要我们去到django为我们提供的admin（数据库管理界面）来进行相关表的操作了！ admin控制台 admin控制台是django为我们提供的一个非常便捷的用来管理数据库的界面 在主控路由文件下，其实你已经看到了它对应的路由设置：path(&#39;admin/&#39;, admin.site.urls), 进入admin界面，初次访问连接：127.0.0.1/admin，会提示我们输入账号密码，这是因为django的admin界面是需要一个超级管理员来登陆访问的，所以还需要我们创建对应的admin界面下的超级用户 创建admin超级用户，使用manage.py命令行工具执行如下命令 12python manage.py createsuperuserUsername (leave blank to use 'lienze'): rootEmail address:Password:Password (again):This password is too short. It must contain at least 8 characters.This password is too common.This password is entirely numeric.Password:Password (again):This password is too common.This password is entirely numeric.Password:Password (again):Superuser created successfully. 以上是我们创建超级用户的过程，非常坎坷； 可以看到，在输入太短（不满足8位），或是只包含数字的简单密码，超级用户的创建都是被拒绝的 所以我们把用户账号创建为root，而密码创建为a1234567， 接下来开启测试服务器，并通过创建好的超级用户登陆访问，如果幸运的话，你已经可以看到后台的admin界面啦 admin界面已经展示出了默认django所使用的两张表，用户表和组表，用来保存当前管理后台的用户以及对应权限分组，可以点入用户表查看其中我们刚创建的root。 admin注册表 问题还是有的，虽然admin界面已经可以登入，但是为什么看不到刚才创建的Weather表呢 这是因为默认的表创建之后，还需要通过对应app下的admin.py文件进行admin后台注册，只有注册在这个文件中的模型类对应的表才可以在admin界面所看到 在app下的admin.py文件中进行模型类的注册 12345#myapp/admin.pyfrom django.contrib import adminfrom myapp import modelsadmin.site.register(models.Weather)#使用register函数接收模型类作为参数即可完成注册 注册成功之后，在服务器，通过浏览器访问admin界面，就可以看到创建好的Weather表了 鼠标点击进去之后，就可以看到对应的表数据界面；右上角提供了可以添加功能的选项，试试给这个表来一些数据吧，这里我们添加了三条数据 1阴天，晴天，打雷了 视图操作模型 最终我们希望可以在视图函数中通过orm接口来访问到表中的数据，那么来打开视图文件吧：views.py 123456789#myapp/views.pyfrom django.shortcuts import renderfrom myapp import modelsdef index(request): weathers = models.Weather.objects.all() content = &#123; \"weathers\":weathers, &#125; return render(request, 'index.html', content) 光返回是不行的，虽然我们绑定到了模板版变量的字典中，但是还得修改一下对应的要渲染的HTML页面哦： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &#123;% load staticfiles %&#125; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;hi&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &#123;% for weather in weathers %&#125; &lt;p&gt;&#123;&#123; weather &#125;&#125;&lt;/p&gt; &#123;% empty %&#125; &lt;p&gt;没有任何天气&lt;/p&gt; &#123;% endfor %&#125; &lt;/body&gt;&lt;/html&gt; 12345&gt; 模板标签&#123;% for xxx in xxxs %&#125;可以用来在模板页面出迭代访问取出每一个数据&gt;&gt; 具体对于不同序列数据的访问我们会在后面详细为大家介绍&gt;&gt; &#123;% empty %&#125;标签用来判断当循环访问数据为空时要做的事情，最后循环标签要有&#123;% endfor %&#125;标签进行结束；因为`HTML`中并没有像`Python`缩进这样的方式来控制代码块。 总结 至此，我们的HELLO WORLD项目已经涵盖了django框架中的大部分常用的组件； 路由、视图、模板、静态、模型，admin 那么其中每一部分都还有很多内容等着我们去了解，在接下来的章节中我们会继续详细给大家介绍！","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Django-Views-视图层","slug":"Django-Views-视图层","date":"2019-12-09T07:43:24.816Z","updated":"2019-12-09T11:26:17.262Z","comments":true,"path":"Django-Views-视图层/","link":"","permalink":"https://cy-blogs.cn/Django-Views-视图层/","excerpt":"视图层 视图函数一般用来接收一个Web请求HttpRequest，之后返回一个Web响应HttpResponse HttpRequest 一个视图函数用来响应用户的Request请求，每个视图函数默认的第一个位置参数request用来接收用户发起请求的HttpRequest信息。 视图函数的返回值，为一个HttpResponse值，包括我们要返回给用户的HTML页面或者字符串等等，以及对应的头部字段信息","text":"视图层 视图函数一般用来接收一个Web请求HttpRequest，之后返回一个Web响应HttpResponse HttpRequest 一个视图函数用来响应用户的Request请求，每个视图函数默认的第一个位置参数request用来接收用户发起请求的HttpRequest信息。 视图函数的返回值，为一个HttpResponse值，包括我们要返回给用户的HTML页面或者字符串等等，以及对应的头部字段信息 123from django.http import HttpResponsedef index(request): return HttpResponse('Hello world') 常见请求方式 POST和GET是HTTP协议定义的与服务器交互的方法。 GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。另外，还有PUT和DELETE方法 get 常用来从指定地址请求数据； 如果需要在请求时提交某些数据，则以路由形式传递参数，查询Query字符串如下格式所示： 1https://www.baidu.com/?key=abc&amp;pos=shanxi get请求可被浏览器缓存，保存在历史记录中 get不应在使用敏感数据时使用，明文包路在请求地址中 get有长度限制 post 向指定的资源提交要被处理的数据 使用POST，提交的数据保存在HTTP协议中的消息主体部分 post请求不会被浏览器缓存 post提交数据长度无限制 post比get更加安全 request 如果说urls.py是Django中前端页面和后台程序桥梁，那么request就是桥上负责运输的小汽车，可以说后端接收到的来至前端的信息几乎全部来自于requests中 request.method 获取当前用户请求方式， 请求方式字符串为纯大写：&#39;GET&#39;、&#39;POST&#39; 如用户以get方式发起请求，对应代码中获取到的结果以及在判断时像是这样 123def index(request): if request.method == 'GET': … request.GET 当用户通过get方式请求站点，并在路由中提供了查询参数，可以通过该属性获取到对应提交的值 123456789def index(request): print(request.GET) # &lt;QueryDict: &#123;'name': ['jack'], 'id': ['1']&#125;&gt; print(type(request.GET)) # &lt;class 'django.http.request.QueryDict'&gt; name_ = request.GET.get('name') id_ = request.GET.get('id') content = '%s:%s' % (name_,id_) return HttpResponse(content) 12&gt; request.GET`是一个类似字典的数据类型：`QueryDict&gt; 其中也支持类似对字典的get或直接dict.[key]键值访问方式，当然使用get方式进行对应key获取会更好，因为get在访问不到时不会报错 如果定义了如上所示的视图函数，那么在访问连接时，我们可以通过路由传参： 1http://127.0.0.1:8000/?name=jack&amp;id=1 这里对应页面会显示的结果： 1jack:1 注意：使用GET方法在连接中进行参数提交，后台接收到的数据类型均是字符串 request.POST 获取用户以post形式提交的数据并保存在后台，为类字典数据，这里和request.GET是一个东西； 在网页中，一般我们通过html的表单进行数据的提交，POST方式可以提交空数据 因为涉及到了表单页面，所以我们先来弄一个HTML页面 12345678910&lt;body&gt; &lt;div&gt;这是一个关于POST的测试&lt;/div&gt; &lt;form action=\"/\" method=\"POST\"&gt; &#123;% csrf_token %&#125; 账号:&lt;input type=\"text\" name=\"account\"&gt; &lt;br&gt; 密码:&lt;input type=\"password\" name=\"passwd\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;/body&gt; 在模板页面中，一旦涉及到了表单提交，那么一定要注意在表单区域添加csrf_token标签进行防跨站伪造令牌的加载，否则表单数据的将被认为是无效的。 在接下来的视图函数中会使用到input标签中的name属性； name值属性维护了post的数据传入到后台时的标示，会与表单的数据组合成类字典格式 如name属性为account的输入框中输入了test，那么后台数据接收到的值类似：{&#39;account&#39;:&#39;test&#39;} 写一个视图函数用来捕获当前表单使用POST形式提交的数据： 123456789def index(request): if request.method=\"POST\": print(request.POST) print(type(request.POST)) account = request.POST.get(\"account\") passwd = request.POST.get(\"passwd\") content = \"%s:%s\" % (account,passwd) return HttpResponse(content) return render(request,\"index.html\") #在使用get形式请求时，返回表单页面 如果在表单页面中账号填写为test，密码为123456；在视图函数中捕捉到的结果为： 1&lt;QueryDict: &#123;'csrfmiddlewaretoken': ['EmyGwsVcrXI2LDkYLS9qflkUH4N7bM1nfTQxr3fsOsZlI4vJFwci7TargtYRAGl2'], 'account': ['test'], 'passwd': ['123456']&#125;&gt; 表单多值提交 在request.POST中需要注意，某些情况下，使用POST提交数据的表单数据可能是多个值，类似复选框CheckBox，直接使用request.POST.get()进行获取是有一些问题的，比如修改模板页面如下所示 1234567&lt;form action=\"/\" method=\"POST\"&gt; &#123;% csrf_token %&#125; &lt;input type=\"checkbox\" name=\"taste\" value=\"eat\"&gt;吃 &lt;input type=\"checkbox\" name=\"taste\" value=\"sleep\"&gt;睡 &lt;input type=\"checkbox\" name=\"taste\" value=\"play\"&gt;耍 &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 这是一个name值为taste的兴趣爱好采集的多选框，value值将会作为选中时，提交到后台的值，比如现在我们全选这些表单数据，那么后台接收到的值是这样的 1&lt;QueryDict: &#123;'csrfmiddlewaretoken': ['nuaLzxc2E0artYKUZiefMPv5iHTX5gLFY1sCu8wi1vrKqpVFTWh7EnlCR64Hua5k'], 'taste': ['eat', 'sleep', 'play']&#125;&gt; 但是问题接踵而至，我们发现使用get函数获取不到对应全选的整个结果，而是只拿到了选中的最后一项 request.POST.get(key, default=None) 返回对应key值的数据中的最后一个数据单独返回；key值不存在，取default 要想真正拿出所有的结果，应该使用getlist函数 request.POST.getlist(key, default=None) 将对应key值的所有数据以一个列表形式返回；key值不存在，取default request.META request.MATE获取的是一个标准的python字典。它包含了所有的HTTP请求信息 比如用户IP地址和用户Agent（通常是浏览器的名称和版本号）。 注意，Header信息的完整列表取决于用户所发送的Header信息和服务器端设置的Header信息 CONTENT_LENGTH：请求的正文的长度，字符串类型 CONTENT_TYPE：请求的正文的MIME 类型 HTTP_ACCEPT：响应可接收的Content-Type HTTP_ACCEPT_ENCODING：响应可接收的编码 HTTP_ACCEPT_LANGUAGE：响应可接收的语言 HTTP_HOST：客服端发送的HTTP Host头部 HTTP_REFERER：请求前的连接地址 HTTP_USER_AGENT：客户端的user-agent字符串 QUERY_STRING：单个字符串形式的查询字符串（未解析过的形式） REMOTE_ADDR：客户端的IP 地址 REMOTE_HOST：客户端的主机名 REMOTE_USER：服务器认证后的用户 REQUEST_METHOD：一个字符串，例如GET 或POST SERVER_NAME：服务器的主机名 SE0RVER_PORT：服务器的端口，字符串类型 request.FILES 接收用户上传文件及相关信息。同样类似于request.POST，提取到的数据为一个类字典的数据类型，包含所有文件上传的信息 f = request.FILES.get(&#39;upload_file&#39;) file_data = f.read()：读取整个上传文件的内容，适合小文件上传 yiled = f.chunks()：返回一个类似生成器（）的数据，每一次读取按块返回文件，可以通过for迭代访问其中数据；适合上传大文件到服务器。 f.multiple_chunks()：返回文件大小，当文件大小大于2.5M时，返回True，反之返回False，可以通过该函数来选择是否使用chunks方法或read直接存储。 如果想要修改这个文件判定的默认值，可以通过：FILE_UPLOAD_MAX_MEMORY_SIZE在settings文件下进行设置 f.content_type：上传文件时头部中的Content-Type字段值，参考MIME类型 f.name：上传文件名字 f.charset：上传文件编码 f.size： 上传文件大小，字节为单位：byte 创建好静态资源目录，并在下面创建一个img文件夹，保存我们即将上传的图片； 完成上传文件的HTML表单页面 123456&lt;form action=\"/\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &#123;% csrf_token %&#125; &lt;input type=\"file\" name=\"upload_file\" /&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; &lt;img src=\"&#123;% static 'img/1.jpg' %&#125;\" alt=\"这是一张图片\"&gt;&lt;!-- 这里使用的是即将要上传的文件名字，只做文件是否上传成功的简单测试 --&gt; 注意：上传文件的页面表单，一定要记得设置属性enctype=&quot;multipart/form-data&quot; 视图函数如下编写，接收上传图片，并保存在静态目录下刚才创建好的img目录中 12345678910111213def index(request): if request.method == \"POST\": f = request.FILES.get(\"upload_files\") path = os.path.join(settings.STATICFILES_DIRS[0],'img/'+f.name) # 上传文件本地保存路径 with open(path,'wb') as fp: if f.multiple_chunks: #判断到上传文件为大于2.5MB的大文件 for buf in f.chunks(): #迭代写入文件 fp.write(buf) else: fp.write(f.read()) return HttpResponse(\"Success!\") return render(request, 'index.html') 测试上传一个名为1.jpg的图片，如果成功上传，那么后台static目录下会出现该图片，并且模板页面也可以展示对应图片效果 HTTPResponse 一个视图的返回值经常是为了向用户返回一个HttpResponse响应， 有如下常用的可以返回HttpResponse的函数 response HttpResponse(content=b&#39;&#39;) 返回一个字符串内容 from django.http import HttpResponse render(request,template_name,context=None,content_type=None,status=None) 返回一个可渲染HTML页面，状态码为200 from django.shortcuts import render request：固定参数，响应的request请求，来自于参数部分接收的HttpRequest template_name：返回的模板页面路径 context：模板页面渲染所需的数据，默认为字典格式 content_type：生成之后的结果使用的MIME类型 status：响应的状态码，默认为200 redirect(to, permanent=False) 一个重定向，浏览器通过该状态码自动跳转到一个新的路由地址，默认返回响应状态码302 from django.shortcuts import redirect to：可以是一个django项目中视图函数的路由映射，也可以是一个reverse的反向路由解析 permanent：如果设置为True，将返回301状态码，代表永久重定向 1302：临时重定向，旧地址资源临时不能用了，搜索引擎只会暂时抓取新地址的内容而保存旧的地址。301：永久重定向，旧地址资源已经不复存在，搜索引擎不光会抓取新地址的内容，还会替换旧地址为新地址 视图错误处理 为了方便我们开发，django提供了一个异常叫做Http404异常，我们可以在视图函数的代码中按照需求进行抛出，抛出之后django项目会自动捕获该异常，并会展示默认的404页面 1234from django.http import Http404def index(request): if request.GET.get(\"id\") == \"1\": raise Http404 在settings中的debug配置项为false时，访问http://127.0.0.1:8000/?id=1，可以看到django为我们提供的错误页面； 除了django默认提供的，我们还可以可以在模板目录下定义全局404.html进行错误页面的定制 1&lt;h1&gt; 抱歉，找不到你要的东西&lt;/h1&gt; 自定义错误处理视图 除去404错误的自定义，django还提供了覆盖默认错误行为处理的办法； 有些时候，django自动的错误处理可能不能满足我们的需求，那么我们可以重新定义一些新的视图函数， 来覆盖掉django所提供的错误处理视图函数，最后在urls.py路由配置文件下通过定义全局变量来重新设置默认的错误处理视图函数 1234567891011handler404：覆盖page_not_found()视图。handler500：覆盖server_error()视图。handler403：覆盖permission_denied()视图。handler400：覆盖bad_request()视图from django.contrib import adminfrom django.urls import path,includeurlpatterns = [ path('admin/', admin.site.urls), path('', include(\"viewapp.urls\")),]handler404 = \"viewapp.views.error_404\"# APP.模块.视图函数handler500 = \"viewapp.views.error_500\" 相关定义好的错误处理视图函数 123456def error_404(request): return HttpResponse(\"这是404错误\")def error_403(request): return HttpResponse(\"这是403错误\")def error_500(request): return HttpResponse(\"这是500错误\")","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Django-Urls-路由层","slug":"Django-Urls-路由层","date":"2019-12-09T05:56:43.065Z","updated":"2019-12-09T11:26:14.411Z","comments":true,"path":"Django-Urls-路由层/","link":"","permalink":"https://cy-blogs.cn/Django-Urls-路由层/","excerpt":"路由层 路由是Web服务的入口，就好像办事大厅有各个服务窗口一样 Django奉行DRY主义，提倡使用简洁、优雅的URL： 可以不用.html、.php或.cgi之类后缀 尽量不要单独使用无序随机数字这样无意义的东西 让你随心所欲设计你的URL，不受框架束缚","text":"路由层 路由是Web服务的入口，就好像办事大厅有各个服务窗口一样 Django奉行DRY主义，提倡使用简洁、优雅的URL： 可以不用.html、.php或.cgi之类后缀 尽量不要单独使用无序随机数字这样无意义的东西 让你随心所欲设计你的URL，不受框架束缚 路由urlpatterns urlpatterns是路由文件中的一个全局变量，用来存放路由及视图函数的映射关系 用户发起的请求URL都会首先进入主控制目录下的这个urls.py文件中进行查找匹配 首先找到urls.py下的urlpatterns全局变量，这是一个路由规则实例的列表数据。 按照先后定义顺序，进行路由匹配。 找到第一个匹配项时停止匹配，执行匹配到的视图函数。 遍历完全，未发现匹配，django进行异常处理 其中urlpatterns中的每一个路由映射规则可以由path或re_path进行构造 注意：Django的路由不考虑HTTP请求方式，仅根据URL进行路由；即，只要URL相同，无论POST、GET等哪种请求方式都指向同一个操作函数 path path(regex, view, kwargs=None, name=None) regex：一个匹配对应url地址的规则字符串。 view：路由对应的视图函数，并且会自动封装HttpRequest作为第一个参数给这个视图函 kwargs：视图函数的关键字参数。 name：该路由的全局命名，可以让我们方便的在django项目中任意部分显示的使用，相当于为url取变量名，接下来全局使用该命名值即可；当对应url路由改变之后，结合路由反向解析使用的地方不需要更改路由 此外，django还提供了一个兼容老版本url路由配置函数的re_path函数；re_path：第一个参数部分为一个正则匹配规则，其他与path同 静态路由 静态路由用来映射对应视图函数，以下是一个简单的例子 123456from django.http import HttpResponsedef index(request): return HttpResponse('Hello Worlds!')from django.urls import path,re_pathfrom urlapp import viewsurlpatterns = [ path('',views.index), re_path(r\"^\",views.index),] 路由传参 有的时候，我们的路由设置不能一直维持一个一成不变的状态； 比如遇到一些内容翻页的场景，那么我们的连接可能是：xx.com/airticle_list/1/、xx.com/airticle_list/2/ 那么这样的路由其实对应的都应该是一个视图函数，用以展示页面内容，那么如何设计这样的路由，就要涉及到动态路由及路由传参 123def index(request,x,y): content = \"x:%s\\ny:%s\" % (x,y) return HttpResponse(content) 定义如上函数，将会接收连接中的后两部份path值作为参数，分别依次给到x和y 1234567from django.urls import path,re_pathfrom urlapp import viewsurlpatterns = [ path('&lt;int:x&gt;/&lt;str:y&gt;/',views.index), #指明类型 path(\"&lt;x&gt;/&lt;y&gt;/\",views.index) #不指明类型 re_path(r\"^(?P&lt;x&gt;\\d+)/(?P&lt;y&gt;[a-zA-Z]+)/$\"), # (?P&lt;name&gt;pattern) 正则分组 re_path(r\"^(\\d+)/([a-zA-Z]+)/$\"),] 路由通过尖括号进行分组匹配，使用int以及str内置转换器将连接对应部分的值进行转换；并将匹配到的结果传递到视图函数对应的参数位置上； 访问：http://127.0.0.1:8000/1/abc/ 其中1将作为x的参数值，abc将作为y的参数 但如果访问连接是：http://127.0.0.1:8000/abc/abc/，这会匹配到第二个路由，第二个路由没有对传递参数的类型进行限定 内置Path转换器： 1str：匹配除了路径分隔符（`/`）之外的非空字符串，这是默认的形式int：匹配正整数，包含0slug：匹配字母、数字以及横杠、下划线组成的字符串uuid：匹配格式化的uuid，如 075194d3-6885-417e-a8a8-6c931e272f00path：匹配任何非空字符串，包含了路径分隔符 自定义转换器 除了以上django所提供的path转换器，如果还觉得无法实现我们想要的功能，我们可以通过编写一个类进行自定义path转换器 定义转换器类，类名随意 定义类中必须属性 regex：一个字符串形式的正则表达式，也是对应的路由规则 to_python(self, value)：用于将匹配到的路由字符串转换为Python中的数据类型，并传递给视图函数，如果转换失败，必须抛出ValueError，路由映射视图函数时使用 to_url(self, value)：将Python数据类型转换为一段url的方法，to_python方法的反向操作，反向解析时使用 通过django.urls模块中的register_converter函数进行注册 12函数第一个参数为转换器类函数第二个参数为转换器别名 以下定义一个路由参数只能是三位字符的路由规则 12345678910111213#先将转换器类定义class ThreeChar: regex = \"[a-zA-Z]&#123;3&#125;\" def to_python(self,value): print(\"to_python\") return str(value) def to_url(self,value): # 当通过反向路由解析时，将会调用该函数 print('to_url') return str(value)[:3] #此处切片操作是为了当反向路由解析传参字符串长于3时，可以将其截断，符合转换器正则规则#注册转换器 from django.urls import register_converterregister_converter(ThreeChar,'tc')urlpatterns = [ path('&lt;tc:x&gt;/&lt;tc:y&gt;/',views.index)]#127.0.0.1:8000/aaa/bbb/ 接下里，通过路由进行访问该视图映射时，一定是三个字符所组成的路由才可以，否则是访问不到的 123456#urls.pyapp_name = \"app\"path('&lt;tc:x&gt;/&lt;tc:y&gt;/', views.index, name=\"threechr\")#views.pyreturn redirect(reverse(\"app:threechr\",args=('aaaa','bbbb')))#此时会调用three路由规则中的tc转换器中的to_url反向合成路由，并切片只取参数前三位 路由分发 我们的路由编写都是在项目主要目录下的urls.py文件中，但是如果app有很多的话，这么多路由都写到一起，明显是一件很不方便管理的事情 其实在之前的练习中，我们使用的方式均是路由分发，每个子app都拥有自己独立的urls.py路由映射文件，而主控路由文件里只需要使用include函数导入子app下路由文件即可，这就是路由分发 123456from django.contrib import adminfrom django.urls import path,includeurlpatterns = [ path('admin/', admin.site.urls), path('',include(\"urlapp.urls\")) # 使用include 实现路由分发，找到子app下的路由文件 ] 路由分发为我们带来的好处有很多，可以让我们在多个app的项目中更加方便有效的管理每一个路由 并且也可以让我们的用户在访问时看到浏览器中的URL地址更加赏心悦目 路由反向解析 到了这里，思考一下，之前我们已经设置过了很多路由； 但是现在会出现一个问题，比如我们把其中某个路由规则进行了修改，把aaa换成了aba，那么现在我们需要回到每一个使用到这个路由的地方进行同步修改，这显然非常麻烦的，如果修改的路由更多，这甚至是一个灾难 django也为我们提供了一个解决办法，通过为路由映射使用name参数，来为每一个路由映射设置一个独立唯一的变量名 12345path('left/&lt;str:x&gt;/',views.left, name=\"left\"),path('right/&lt;int:x&gt;/',views.right, name=\"right\"),# 通过正则命名分组方式re_path(r'^left/([a-zA-Z]+)/$',views.left,name=\"left\"),re_path(r'^right/(?P&lt;x&gt;\\d+)/$',views.right, name=\"right\") 两个视图函数对应如下： 12345678def left(request,x): # x: str content = &#123; 'message':x, &#125; return render(request, \"left.html\", content)def right(request,x): # x: int content = &#123; 'message':x, &#125; return render(request, \"right.html\",content) 两个HTML页面 1234567&lt;p&gt;我是左页面&lt;/p&gt;&lt;p&gt;路由参数: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;a href=\"&#123;% url 'right' 123 %&#125;\"&gt;右页面&lt;/a&gt;&lt;!-- ------另一个页面------ --&gt;&lt;p&gt;我是右页面&lt;/p&gt;&lt;p&gt;路由参数: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;a href=\"&#123;% url 'left' 'abc' %&#125;\"&gt;右页面&lt;/a&gt; 1&gt; 在模板页面中，对于已命名路由可以通过&#123;% url “name” “arg” %&#125;模板标签进行反向解析 参数以空格隔开，在标签后传入 视图函数反向解析 12def index(request): return redirect(reverse(\"left\",args=('aaa',) )) 在视图函数中需要使用到路由命名时，进行反向解析需要我们通过django.shortcuts模块下的reverse函数 reverse(viewname,args=None,kwargs=None) 1参数介绍viewname：视图函数、命名路由映射、或视图函数路径的字符串args：元组形式路由传参。kwargs：字典形式路由传参 命名空间 如果想在多个app下使用相同的name路由命名，那么我们可以通过路由分发过程中的include函数来指定不同app所属的命名空间 ​123456from django.contrib import adminfrom django.urls import path,includeurlpatterns = [ path('admin/', admin.site.urls), path('app1/',include((\"app1.urls\",'app1'))), #直接传递一个元祖，元祖第一个值为分发路由地址，第二个值为命名空间 path('app2/',include((\"app2.urls\",'app2')))] 当为每个app的路由分发映射设置了命名空间，接下来在模板页面以及视图函数对路由的反向解析将是如下所示的样子，路由解析前加冒号指明命名空间 123def index(request): return redirect(reverse(\"app1:left\"))&lt;a href=\"&#123;% url 'app2:left' %&#125;\"&gt;app2:left&lt;/a&gt; 应用命名空间：app_name 使用app_name指明命名空间，在子app的urls.py文件下配置全局变量app_name，这个值是唯一的 在这个路由文件中定义的其他映射关系，将具有命名空间app1 1app_name = \"app1\" # 这个值应该是唯一的urlpatterns = [ ...] 实例命名空间：namespace 当有多个子app同时引入同一个子路由映射文件，比如这样 12345from django.contrib import adminfrom django.urls import path,includeurlpatterns = [ path('admin/', admin.site.urls), path('app1/',include(\"app1.urls\")), path('app2/',include(\"app1.urls\"))] 这就会出现一个问题，不同的路由访问在做路由反向解析时，会造成混淆， 此时需要给每一个路由分发的规则设置namespace属性，为实例进行命名空间 123from django.contrib import adminfrom django.urls import path,includeurlpatterns = [ path('admin/', admin.site.urls), path('app1/',include(\"app1.urls\",namespace=\"app1\")), path('app2/',include(\"app1.urls\",namespace=\"app2\"))] 这样做的好处，可以在不同路由导向同一app下时，为他们的不同命名空间； 虽然看起来到最后执行的视图函数功能是一样的，但可以分清楚究竟是哪个路由引起视图函数在工作 接下来视图及模板页面中使用namespace的值 12345678910111213141516&lt;p&gt; 我是左页面&lt;/p&gt;&lt;p&gt; 路由参数: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;a href=\"&#123;% url 'app1:right' 123 %&#125;\"&gt;app1的右页面&lt;/a&gt;&lt;p&gt;我是右页面&lt;/p&gt;&lt;p&gt;路由参数: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;a href=\"&#123;% url 'app1:left' 'abc' %&#125;\"&gt;app1的左页面&lt;/a&gt;&lt;!-- ----------------------------------------- --&gt;&lt;p&gt;我是左页面&lt;/p&gt;&lt;p&gt;路由参数: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;a href=\"&#123;% url 'app2:right' 123 %&#125;\"&gt;app2的右页面&lt;/a&gt;&lt;p&gt;我是右页面&lt;/p&gt;&lt;p&gt;路由参数: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;a href=\"&#123;% url 'app2:left' 'abc' %&#125;\"&gt;app2的左页面&lt;/a&gt;","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Django-Models-模型层","slug":"Django-Models-模型层","date":"2019-12-03T08:05:23.931Z","updated":"2019-12-09T11:26:11.153Z","comments":true,"path":"Django-Models-模型层/","link":"","permalink":"https://cy-blogs.cn/Django-Models-模型层/","excerpt":"模型层 该层开发的首要任务就是定义模型类以及属性 每个模型都可以被映射为数据库中的一个数据表，而类属性被映射为为数据字段 配置Mysql数据库 在确保mysql数据库可以连接使用的情况下； 首先在数据库中创建专为django使用的库django_data","text":"模型层 该层开发的首要任务就是定义模型类以及属性 每个模型都可以被映射为数据库中的一个数据表，而类属性被映射为为数据字段 配置Mysql数据库 在确保mysql数据库可以连接使用的情况下； 首先在数据库中创建专为django使用的库django_data 1create database django_data; 配置django的settings.py文件中的DATABASES属性如下 12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', # 数据库引擎 'NAME': \"django_data\", # 使用的库名 \"USER\": \"root\", # 用户名 \"PASSWORD\": \"123456\", # 数据库密码 \"HOST\": \"localhost\", # 数据库主机地址 \"PORT\": \"3306\" &#125;&#125; 由于使用django的Python版本为3+； 此时对于mysql的支持已经变为pymysql，而对于django加载数据库引擎时还需要使用2版本的mysqldb名称 现在先需要我们安装pymysql之后在项目中重申mysql引擎 首先安装pymysql 1pip install pymysql -i https://pypi.tuna.tsinghua.edu.cn/simple 项目主目录下的__init__文件中添加如下内容 12import pymysqlpymysql.install_as_MySQLdb() 现在整个项目的数据库使用已经切换到了mysql 模型层字段 在模型层类中的字段即是数据库中表的字段，表的字段设计非常重要 每一个字段都是Field基类的一个实例（Field类用来建立字段与数据库之间的映射） 模型字段定义不能以下划线结尾 django会根据在模型类中定义的字段属性来确定以下几点工作 数据库中使用的数据类型 模型类对应的表单类渲染时使用的表单类型及HTML部件 必填字段等最低限度的验证要求检查，包括admin界面下自动生成的表单 BooleanField BooleanField(**options)：True/False字段，默认值为None 表单类型：CheckboxInput，`` CharField CharField(max_length=None)：字符串字段 含有一个必须参数：max_length设置最大的字符数长度限制； 表单类型：TextInput，`` DateField DateField(auto_now=False, auto_now_add=False,**options)：以 datetime.date实例表示的日期 含有两个可选参数：auto_now、auto_now_add auto_now：该值为True时，每次在保存数据对象时，自动设置该字段为当前时间，也可以理解为自动更新最后一次修改时间 auto_now_add：该值为True时，该字段设置在第一次数据对象创建时，可以记录当前字段创建的时间值 注意：避免矛盾，auto_now，auto_now_add，default不能同时出现，一个字段属性只能有其中一条设置，当设置了auto_now，或auto_now_add时，也会让该字段默认具有blank=True（字段可以为空）属性 表单类型：TextInput，`` DatetimeField DatetimeField(auto_now=False, auto_now_add=False,**options)：以datetime.datetime实例表示的日期和时间 和DateField具有相同的字段属性 DecimalField DecimalField(max_digits=None,decimal_places=None, **options)：以Decimal实例标示的十进制浮点数类型 含有两个可选参数：max_digits、decimal_places max_digits：位数总数，包括小数点后的位数，必须大于decimal_places参数 decimal_places：小数点后的数字数量，精度 表单类型：TextInput，`` EmailField EmailField(max_length=254, **option)：CharField子类，表示Email字段，并会检查是否为合法邮箱地址 默认参数：max_length，表示邮箱地址长度，默认为254 表单类型：TextInput，`` FloatField FloatField(**options)：使用float实例来表示的浮点数 表单类型：TextInput，`` IntegerField 12&gt; IntegerField(**options)`：一个整数，范围由`-2147483648`到`2147483647&gt; GenericIPAddressField GenericIPAddressField(protocol=both, unpack_ipv4=False, **options)：一个IPV4或IPV6地址的字符串 默认参数：protocol、unpack_ipv4 protocol：IP协议，ipv4或ipv6，默认both为全选 unpack_ipv4：解析IP地址，只有当协议为both时才可以使用 表单类型：TextInput，`` SlugField SlugField(max_length=50, **option)：只包含字母、数字、下划线的字符串，常用来表示连接中的path部分或者一些其他短标题类型数据 TextField TextField(**options)：大文本字段 表单类型：Textarea，... URLField URLField(max_length=200, **options)：CharField的子类，存储URL的字段 表单类型：TextInput，`` 字段属性 以上所介绍的字段，均支持以下属性 null 如果该值为True，Django将在数据库中将控制存储为NULL 字符串字段CharField与TextField要避免使用null，因为空值字符串将存储空字符串（””）,而不是null值。 对于字符串类型的数据字段，大多数情况下，django使用空字符串代表空值 blank 如果该值为True，则在验证时该字段值可以为空； null为数据库存储层面可以为空，而blank为表单验证层面可以填写空值 choices 一个二元组的列表或元组； 元组中第一个值为真正在数据库中存储的值，第二个值为该选项的描述 该值一旦被设定，表单样式会显示选择框，而不是标准的文本框，选择框内的选项为choices中的元组 1234567class TestTable(models.Model): CHAR_CHOICE = [ ('H',\"非常苦难\"), ('M',\"中等难度\"), ('S',\"非常简单\"), ] choicechar = modesl.CharField(max_length=1,choices=CHAR_CHOICE) choices字段也支持分类的写法 1234567891011CHAR_CHOICE = [ ('A', ( ('H',\"Hard\"), ) ), ('B', ( ('M',\"Medium\"), ) ), … ] 分类的名称作为元组中的第一个值， 元组的第二个值为该分类下的一个新的二元组序列数据 db_column 数据库中用来表示该字段的名称，如果未指定，那么Django将会使用Field名作为字段名 db_index 当该值为True时，为该字段创建索引 default 该字段默认值，可以是一个值或是一个回调函数 当是一个函数对象时，在创建新对象时，函数调用 editable 如果设置该值为False，那么这个字段将不允许被编辑 不会出现在admin后台界面下，以及其他ModelForm表单中，同时也会跳过模型验证 primary_key 设置该值为True时，该字段成为模型的主键字段，一个模型类同时只能有一个主键 如果一个表中不存在任意一个设置好的主键字段，django会自动设置一个自增的AutoField字段来充当主键，该值可以用pk，id方式获取。主键的设置还意味着，null=False，unique=True unique 如果该值为True，代表这个数据在当前的表中有唯一值 这个字段还会在模型层验证存储的数据是否唯一 unique的设置也意味着当前字段具备索引的创建 ManyToManyField、OneToOneField与FileField字段不可以使用该属性 verbose_name 对于字段的一个可读性更高的名称 如果没有设置该值，django将字段名中的下换线转换成空格，作为当前字段的数据库中名称 模型元属性 在模型类的Meta类中，可以提供一系列的元选项，可以方便对该模型类进行属性设置或约束等 12345class TestTable(models.Model): … class Meta: ordering = [Fields] … abstract 代表当前模型类为抽象基类，不会创建真正的数据表，只是为了其他模型类继承使用 1abstract = True app_label 当模型类被定义在了其他app下，这个属性用来描述当前表属于哪个app应用 1app_label = \"MyApp\" db_table 当前模型类所对应的表名，未设置时，django默认将表名与app名由下划线组成，作为表名 需要注意这个表名为真实在数据库中所使用的，所以该元选项的使用应在数据表创建之前 如果在表已经存在的情况下去修改，会导致数据库内表与模型类表名不一致而查找不到报错 ordering 当前表中的数据存储时的排序规则，这是一个字段名的字符串，可以是一个列表或元组； 每一个字符串前可以使用”-“来倒序排序，使用”?“随机排序 ordering排序规则的添加，也会增加数据库的开销 12ordering = ['-birthday', 'age']#先按照birthday倒序排序，再按照age字段进行排序。 unique_together 用来设置表中的不重复字段组合 格式为一个元组，元组中的每个数据都是一个元组，用来描述不重复的组合字段 如果只处理单一字段组合，可以是一个一维的元组 联合约束 1unique_together = (('name','phone'),) verbose_name 一般设置该表展示时所用的名称，名称被自动处理为复数，字符串后加一个”s” verbose_name_plural 与verbose_name功能相同，但是不会自动在字符串后加”s“以表复数 设置表的复数名称 模型操作 在进行模型操作的学习之前，可以先创建一个测试的数据库模型类，如下所示 123class Person(models.Model): name = models.CharField(max_length=10,verbose_name=\"姓名\") age = models.IntegerField(verbose_name=\"年龄\") 创建对象 django自带了一个数据库测试的shell工具 这是一个非常方便可以让我们对django代码进行测试的环境 可以直接通过python manage.py shell命令行管理工具来打开 实例save创建数据 通过模型类的关键词参数实例化一个对象来进行数据的创建 123&gt;&gt;&gt; from app.models import Person&gt;&gt;&gt; p1 = Person(name='张三',age=15)&gt;&gt;&gt; p1.save() 以上的代码，在为字段赋予值之后，通过实例的save函数进行该数据的保存 在数据库底层执行了SQL语句中的insert操作，并且，在我们显示调用save之前，django不会访问数据库，实例数据只存在于内存中 注意：save函数没有返回值 create方法创建数据1&gt;&gt;&gt; P1 = Person.objects.create(name='李四',age=20) 这条语句创建一条数据，并且返回一个数据在内存中的实例P1 之后可以通过这个实例字段P1对数据库中该条数据进行修改或删除操作 create 方法一步到位，save方式可以慢悠悠的赋予字段值，最后赋予结束再save 查找对象 接下来，我们将通过模型类中的管理器进行数据的查询； 管理器（Manager）是每一个模型类所具有的，默认名为objects 模型类通过模型类调用orm数据接口，其实就是在对数据表进行操作。 注意，具体的某一条数据无法访问这个管理器 all() 获取一个表中的所有数据，返回QuerySet数据对象 1all_person = Person.objects.all() filter(**kwargs) 返回一个包含数据对象的集合，满足参数中所给的条件 12res = Person.objects.all().filter(age__lt=16)res = Person.objects.filter(age__lt=16) 我们在查询过程中，除了直接使用字段属性进行验证 还可以在字段名之后使用双下化线来标明更加详细的字段筛选条件（在下一节会有详细的字段筛选条件介绍），也叫做链式过滤 这也是为什么表单类字段不可以以下换线结尾的原因 exclude(**kwargs) 返回一个包含数据对象的集合，数据为不满足参数中所给的条件 filter()查询会始终返回一个结果集，哪怕只有一个数据。 但是有些时候，我们对于一些在数据表中的唯一数据进行查询时，可以使用更加合适的get方法 注意：创建结果集的过程不涉及任何数据库的操作，查询工作是惰性的，在上面的查询方式中，查询代码不会实际访问数据库，只有查询集在真正使用时，django才会访问数据库 get(**kwargs) 获取唯一单条数据 get获取数据只会返回一条匹配的结果，获取的数据只能在数据库中有一条 如果返回多个结果，会引发MultipleObjectsReturned异常 如果没有任何匹配到的结果也会引发DoesNotExist异常 1Person.objects.get(pk=1) order_by(*field) 默认情况下，数据表使用模型类中的Meta中指定的ordering选项进行排序 现在也可以通过使用order_by函数进行查询结果的排序 1Person.objects.order_by('age') 1Person.objects.all().order_by('-age') count() 返回数据库中对应字段的个数，并且该函数永远不会引发异常 1models.Person.objects.filter(age=20).count()Person.objects.count() 使用count函数时，还需要对数据表进行迭代访问 所以有时使用已生产好的结果集，通过len函数获取长度，这种方式效率会更高 count方法的调用会导致额外的数据库查询 values(*fields) 返回一个查询集结果，但是迭代访问时返回的是字典，而不是数据实例对象 1models.Person.objects.all().values()models.Person.objects.values() 链式过滤条件 exact 如果在查询过程中，没有提供查询类型（没有双下划线），那么查询类型就会被默认指定为exact，这是一种严格查找的方式，用来在数据库中查找和查询时的关键词参数完全一致的内容 12&gt;&gt;&gt; Person.objects.filter(account='root')&gt;&gt;&gt; Person.objects.filter(account__exact='root') iexact 忽略大小写的匹配 12&gt;&gt;&gt; Person.objects.filter(account__iexact='root')#匹配到的结果可能是Root，ROot，ROOt，ROOT startswith、endswith 分别匹配开头和结尾，区分大小写 12&gt;&gt;&gt; Person.objects.filter(passwd__startswith='admin')#匹配以admin开头的数据 istartswith、iendswith 分别匹配开头和结尾，忽略大小写 1&gt;&gt;&gt; Person.objects.filter(passwd__istartswith='admin')匹配以不区分大小写的字符串admin为开头的数据 gte 大于或等于 1&gt;&gt;&gt; Person.objects.filter(reg_data__gte=datetime.date.today) lte 小于或等于 1&gt;&gt;&gt; Person.objects.filter(reg_data__lte=datetime.date.today) 修改对象 获取到对应的数据实例之后，通过.的方式访问数据实例中的属性，进行数据的字段修改 1p = models.Person.objects.get(pk=1)p.age = 21p.save() 对过滤出的结果链式调用update()函数，这样的修改，类似批量修改，update函数会返回成功修改的个数 1models.Person.objects.filter(age__gt=100).update(age=25)# 将所有年纪小于100的人的年纪改为20 删除对象 对于普通的单表数据删除，获取到数据实例对象后调用内置的delete()函数即可 1models.Person.objects.get(pk=1).delete() 需要注意的是，删除一条数据之后，默认占有的主键ID值并不会被下一个新插入的值所占用 比如 1，2，3，4；删除掉3之后，剩下：1，2，4；下一个值存储时，id是5，3不会被复用 字段关系 字段关系是django维护表关系的方式；其中主要有一对一，多对一以及多对多， 现在的一对一及多对一关系中需要设置on_delete属性用来描述当关联数据被删除时的操作，有如下一些 models.CASCADE：删除关联数据,与之关联也删除 models.PROTECT：删除关联数据,引发错误ProtectedError models.SET_NULL：与之关联的值设置为null（前提FK字段需要设置为可空） models.SET_DEFAULT： 删除关联数据,与之关联的值设置为默认值（前提FK字段需要设置默认值） models.DO_NOTHING：删除关联数据,什么也不做 一对一关系 模型类使用OneToOneField用来定义一对一关系； 比如当你拥有一个老师表时，紧接着你还需要一个教授表，那么教授表可能拥有老师表的一系列属性，那么你还不想把老师表中的字段直接复制到教授表那么可以通过OnToOneField来实现教授表继承老师表。 其实，在使用模型类继承时，也隐含有一个一对一关系 OneToOneField(to, on_delete, parent_link=False, options) 12345678class Teacher(models.Model): name = models.CharField(max_length=50) age = models.CharField(max_length=50) def __str__(self): return self.nameclass Professor(models.Model): teacher = models.OneToOneField(Teacher,primary_key=True,on_delete=models.CASCADE) big_project = models.CharField(max_length=50) def __str__(self): return self.teacher.name 在manage.py shell下进行数据库操作 1234567&gt;&gt;&gt; t1 = Teacher.objects.create(name='Jack',age='22')&gt;&gt;&gt; t2 = Teacher.objects.create(name='Bob',age='17')&gt;&gt;&gt; p1 = Professor.objects.create(teacher=t1,big_project='雾霾净化术')&gt;&gt;&gt; p1.teacher&lt;Teacher: Jack&gt;&gt;&gt;&gt; p1.teacher = t2&gt;&gt;&gt; p1.save()&gt;&gt;&gt; p1.teacher&lt;Teacher: Bob&gt; 在上面的测试中，看似已经将p1对应的教授变成了Bob； 但是在数据库中之前t1老师所对应的教授信息还存在，此时的赋值操作并不会覆盖掉教授他之前的教授数据，只是重新创建了一条。 正确的做法应该是将某一条数据的一对一关系通过delete关系先删除之后再重新赋予 多对一关系 Django使用django.db.models.ForeignKey定义多对一关系。 ForeignKey需要一个位置参数：与该模型关联的类 生活中的多对一关系：班主任，班级关系。一个班主任可以带很多班级，但是每个班级只能有一个班主任 12345678910111213class Headmaster(models.Model): name = models.CharField(max_length=50) def __str__(self): return self.nameclass Class(models.Model): class_name = models.CharField(max_length=50) teacher = models.ForeignKey(Headmaster,null=True,on_delete=models.SET_NULL) def __str__(self): return self.class_name&gt;&gt;&gt; H1 = Headmaster(name='渔夫')&gt;&gt;&gt; H1.save()&gt;&gt;&gt; H1&lt;Headmaster: 渔夫&gt;&gt;&gt;&gt; H2 = Headmaster(name='农夫')&gt;&gt;&gt; H2.save()&gt;&gt;&gt; Headmaster.objects.all()[&lt;Headmaster: 渔夫&gt;, &lt;Headmaster: 农夫&gt;] 以上创建了两条老师数据 由于我们设置外键关联可以为空null=True,所以此时在班级表创建时，可以直接保存，不需要提供老师数据 12345678&gt;&gt;&gt; C1 = Class(class_name='一班')&gt;&gt;&gt; C2 = Class(class_name='二班')#如果外键设置不为空时，保存会引发以下错误# IntegrityError: NOT NULL constraint failed: bbs_class.teacher_id&gt;&gt;&gt; C1.teacher = H1&gt;&gt;&gt; C2.teacher = H2&gt;&gt;&gt; C1.save()&gt;&gt;&gt; C2.save() 将老师分配个班级之后，由于班级表关联了老师字段，我们可以通过班级找到对应老师 虽然老师表中没有关联班级字段，但是也可以通过老师找到他所带的班级，这种查询方式也叫作关联查询 通过模型类名称后追加一个’_set’，来实现反向查询 1&gt;&gt;&gt; H1.class_set.all()&lt;QuerySet [&lt;Class: 一班&gt;]&gt; 由于我们这是一个多对一的关系，也就说明我们的老师可以对应多个班级 我们可以继续给H1老师分配新的班级 1234&gt;&gt;&gt; C3 = Class(class_name='三班')&gt;&gt;&gt; C3.teacher = H1&gt;&gt;&gt; C3.save()&gt;&gt;&gt; H1.class_set.all()[&lt;Class: 一班&gt;, &lt;Class: 三班&gt;] 一个班级只能对应一个老师，外键是唯一的，那么你在继续给C1班级分配一个新的老师时，会覆盖之前的老师信息，并不会保存一个新的老师 123456&gt;&gt;&gt; H3 = Headmaster(name='伙夫')&gt;&gt;&gt; H3.save()&gt;&gt;&gt; C1.teacher&lt;Headmaster: 渔夫&gt;&gt;&gt;&gt; C1.teacher=H3&gt;&gt;&gt; C1.save()&gt;&gt;&gt; C1.teacher&lt;Headmaster: 伙夫&gt; 把这个班级的老师删除，由于设置了外键字段可以为null，此时班级的老师选项为null 12345678910&gt;&gt;&gt; t1 = Headmaster.objects.all().first()&gt;&gt;&gt; t1&gt;&gt;&gt; c1 = Class.objects.all().first()&lt;Headmaster: 渔夫&gt;&gt;&gt;&gt; c1&lt;Class: 一班&gt;&gt;&gt;&gt; c1.teacher&lt;Headmaster: 渔夫&gt;&gt;&gt;&gt; t1.delete()(1, &#123;'modelsapp.Headmaster': 1&#125;)&gt;&gt;&gt; c1 = Class.objects.all().first()&gt;&gt;&gt; c1&lt;Class: 一班&gt;&gt;&gt;&gt; c1.teacher&gt;&gt;&gt; #这里什么都没有，因为此时C1的老师已经是个None了 要记得删除之后要重新获取一次数据，否则查看到的结果中还是之前获取到的有老师的班级数据 多对多关系 多对多关系在模型中使用ManyToManyField字段定义 多对多关系可以是具有关联，也可以是没有关联，所以不需要明确指定on_delete属性 生活中，多对多关系：一个音乐家可以隶属于多个乐队，一个乐队可以有多个音乐家 12345678class Artist(models.Model): artist_name = models.CharField(max_length=50) def __str__(self): return self.artist_nameclass Band(models.Model): band_name = models.CharField(max_length=50) artist = models.ManyToManyField(Artist) def __str__(self): return self.band_name 创建音乐家以及乐队 12345&gt;&gt;&gt; from bbs.models import Artist,Band&gt;&gt;&gt; A1 = Artist.objects.create(artist_name='Jack')&gt;&gt;&gt; A2 = Artist.objects.create(artist_name='Bob')&gt;&gt;&gt; B1 = Band.objects.create(band_name='FiveMonthDay')&gt;&gt;&gt; B2 = Band.objects.create(band_name='SHE') 创建出两个乐队之后对其进行音乐家的添加 多对多字段添加时，可以使用add函数进行多值增加 12&gt;&gt;&gt; B1.artist.add(A1,A2)&gt;&gt;&gt; B2.artist.add(A2) B1乐队含有A1,A2两名成员 B2乐队含有A1成员 12&gt;&gt;&gt; B1.artist.all()[&lt;Artist: Bob&gt;, &lt;Artist: Jack&gt;]&gt;&gt;&gt; B2.artist.all() [&lt;Artist: Jack&gt;] 可以在音乐家表中查找某个乐家属于哪些乐队 12345&gt;&gt;&gt; Band.objects.filter(artist=A1) # 这里使用的是我们模型类来进行查找。[&lt;Band: SHE&gt;, &lt;Band: FiveMonthDay&gt;] # A1乐家属于，SHE以及FiveMonthDay&gt;&gt;&gt; Band.objects.filter(artist=A2)[&lt;Band: SHE&gt;] 也可以查找这音乐家在哪个乐队 1234&gt;&gt;&gt; A1.band_set.all() # 直接通过具体数据对象进行查找[&lt;Band: SHE&gt;, &lt;Band: FiveMonthDay&gt;]&gt;&gt;&gt; A2.band_set.all()[&lt;Band: SHE&gt;] 多对多关联字段的删除，要使用remove来进行关系的断开 而不是直接使用delete，remove只会断开数据之间的联系，但是不会将数据删除 现在在B1乐队中删除A1乐家 12&gt;&gt;&gt; B1.artist.remove(A1)&gt;&gt;&gt; B1.artist.all()&lt;QuerySet [&lt;Artist: Bob&gt;]&gt; 关联表的查询 如果想要查询的字段在关联表，则使用表名小写__字段来进行跨表查询操作 创建一个多对一关系的父子表，一个父亲可能有多个儿子 123456789class Father(models.Model): name = models.CharField(max_length=30) age = models.CharField(max_length=30) def __str__(self): return self.nameclass Son(models.Model): father = models.ForeignKey(Father,on_delete=models.CASCADE) name = models.CharField(max_length=30) def __str__(self): return self.name 创建数据 12345&gt;&gt;&gt; f1 = Father.objects.create(name='Jack',age='30')&gt;&gt;&gt; s1 = Son.objects.create(name='Json',father=f1)&gt;&gt;&gt; s2 = Son.objects.create(name='Json2',father=f1)&gt;&gt;&gt; f2 = Father.objects.create(name='Bob',age='40')&gt;&gt;&gt; s3 = Son.objects.create(name='Json3',father=f2) 查询所有父亲名字是jack的孩子 1&gt;&gt;&gt; Son.objects.filter(father__name__exact='Jack')[&lt;Son: Json&gt;, &lt;Son: Json2&gt;] 查询所有儿子名开头为J的父亲 1&gt;&gt;&gt; Father.objects.filter(son__name__startswith='J')[&lt;Father: Jack&gt;, &lt;Father: Jack&gt;, &lt;Father: Bob&gt;] 获取到某一个父亲的所有孩子，通过某一条数据的小写表名_set反向查询 1&gt;&gt;&gt; f1.son_set.all()&gt;&gt;&gt; [&lt;Son: Json&gt;, &lt;Son: Json2&gt;] 数据的反向查询 默认的，当有某一条数据获取到之后，我们可以通过模型类名称加上一个 _set，来实现反向查询 现在设计两个表为军队和士兵表，并且士兵多对一关联军队 12345678class Aramy(models.Model): name = models.CharField(max_length=30) def __str__(self): return self.nameclass Soldier(models.Model): aramy = models.ForeignKey(Aramy,on_delete=models.CASCADE) name = models.CharField(max_length=30) def __str__(self): return self.name 创建一些数据 1&gt;&gt;&gt; a1 = Aramy(name='一军')&gt;&gt;&gt; a1.save()&gt;&gt;&gt; s1 = Soldier(name='张三',aramy=a1)&gt;&gt;&gt; s1.save()&gt;&gt;&gt; s2 = Soldier(name='李四',aramy=a1)&gt;&gt;&gt; s2.save() 通过soldier_set我们就可以关联到对应的士兵表 并且对应返回结果可以执行我们常用的filter，exclude等查询操作 12&gt;&gt;&gt; a1.soldier_set.all()[&lt;Soldier: 张三&gt;, &lt;Soldier: 李四&gt;]&gt;&gt;&gt; a1.soldier_set.filter(name='张三')[&lt;Soldier: 张三&gt;] 也可以通过定义关联字段中的related_name值，来实现自定义的反向查询名字 且related_name的值必须唯一 1234567class Aramy(models.Model): name = models.CharField(max_length=30) def __str__(self): return self.nameclass Soldier(models.Model): aramy = models.ForeignKey(Aramy,on_delete=models.CASCADE,related_name='soldier') name = models.CharField(max_length=30) def __str__(self): return self.name 接下来通过某条数据反向查询 123&gt;&gt;&gt; a1 = Aramy.objects.all()[0]&gt;&gt;&gt; s1 = Soldier.objects.get(name='张三')&gt;&gt;&gt; a1.soldier.all()[&lt;Soldier: 张三&gt;, &lt;Soldier: 李四&gt;] 注意：related_name一定是一个唯一的值，否则反向查找时会出现二异性错误 也可以将related_name初始化为+，来取消反向查询","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Cookie和Session","slug":"Cookie和Session","date":"2019-10-26T03:24:15.603Z","updated":"2019-12-09T11:25:59.925Z","comments":true,"path":"Cookie和Session/","link":"","permalink":"https://cy-blogs.cn/Cookie和Session/","excerpt":"Cookie和Session Cookie及Session一直以来都是Web开发中非常关键的一环，因为HTTP协议本身为无状态，每一次请求之间没有任何状态信息保持，往往我们的Web服务无法在客户端访问过程中得知用户的一些状态信息，比如是否登录等等；那么这里通过引入Cookie或者Seesion来解决这个问题。","text":"Cookie和Session Cookie及Session一直以来都是Web开发中非常关键的一环，因为HTTP协议本身为无状态，每一次请求之间没有任何状态信息保持，往往我们的Web服务无法在客户端访问过程中得知用户的一些状态信息，比如是否登录等等；那么这里通过引入Cookie或者Seesion来解决这个问题。 当客户端访问时，服务端会为客户端生成一个Cookie键值对数据，通过Response响应给到客户端。当下一次客户端继续访问相同的服务端时，浏览器客户端就会将这个Cookie值连带发送到服务端。 Cookie值存储在浏览器下，一般在你的浏览器安装目录的Cookie目录下，我们也可以通过F12或者各种浏览器的开发者工具来获取到 因为cookie是保存在浏览器中的一个纯明文字符串，所以一般来说服务端在生成cookie值时不建议存储敏感信息比如密码 Cookie 在django的代码中，我们可以使用一些提供Response响应的类，如：HttpResponse，redirect等实例的内置set_cookie函数来进行django项目中的Cookie设置 set_cookie(key, value=&#39;&#39;, max_age=None, expires=None, path=&#39;/&#39;,domain=None, secure=False, httponly=False) key：Cookie的key值，未来通过该key值获取到对应设置好的Cookie。 value=&#39;&#39;：对应Cookie的key值的value，比如：set_cookie(key=&#39;value&#39;,value=&#39;shuai&#39;) max_age=None：Cookie生效的时间，单位为秒，如果Cookie值只持续在客户端浏览器的会话时长，那么这个值应该为None。存在该值时，expires会被计算得到。 expires=None：Cookie具体过期日期，是一个datetime.datetime对象，如果该值存在，那么max_age也会被计算得到 1234567 import datetime current_time = datetime.datetime.now()# 当前时间 expires_time = current_time + datetime.timedelta(seconds=10) # 向后推延十秒 set_cookie('key','value',expires=expires_time) #设置Cookie及对应超时时间 path=&#39;/&#39;：指定哪些url可以访问到Cookie，默认/为所有。 domain=None：当我们需要设置的为一个跨域的Cookie值，那么可以使用该参数，比如：domain=&#39;.test.com&#39;，那么这个Cookie值可以被www.test.com、bbs.test.com等主域名相同的域所读取，否则Cookie只被设置的它的域所读取。为None时，代表当前域名下全局生效。 secure=False：https加密传输设置，当使用https协议时，需要设置该值，同样的，如果设置该值为True，如果不是https连接情况下，不会发送该Cookie值。 httponly=False：HTTPOnly是包含在HTTP响应头部中Set-Cookie中的一个标记。为一个bool值，当设置为True时，代表阻止客户端的Javascript访问Cookie。这是一种降低客户端脚本访问受保护的Cookie数据风险的有效的办法 设置COOKIE 简单的实现一下COOKIE的设置 12345from django.shortcuts import render,HttpResponse# Create your views here.def set_cookie(request): # 在HTTPResponse部分设置COOKIE值 cookie_reponse = HttpResponse('这是一个关于cookie的测试') cookie_reponse.set_cookie('test','hello cookie') return cookie_reponse 以上视图函数返回一个HttpResponse对象，并在该对象中集成COOKIE值的设定，设置key值为test，value值为hello cookie 获取COOKIE 再来简单的实现一下COOKIE的获取 1234def get_cookie(request): # 获取cookie值，从request属性中的COOKIE属性中 cookie_data = request.COOKIES.get('test') return HttpResponse('Cookie值为:%s' % cookie_data) Cookie值存储在，request中的COOKIES属性中 并且该属性获取到的结果与字典类似，直接通过内置函数get获取即可 删除COOKIE 这里通过该视图函数路由进行COOKIE的删除 1234def delete_cookie(request): response = HttpResponseRedirect('/check_cookie/') response.delete_cookie('test') return response delete_cookie(key, path=&#39;/&#39;, domain=None) 在Cookie中删除指定的key及对应的value，如果key值不存在，也不会引发任何异常。 由于Cookie的工作方式，path和domain应该与set_cookie时使用的值相同，否则Cookie值将不会被删除 通过response相应类的delete_cookie方法，本来应该在会话结束之后才消失的Cookie值，现在已经被直接删除掉。后台中通过Request中的Cookie字典获取到值也为None 不要忘记字典的get，获取不到结果时，返回None 但是，现在还有一个问题，我们在用户浏览器存储的Cookei值为明文，具有极大的安全隐患，django也提供了加密的Cookie值存储及获取方式 防止篡改COOKIE 通过set_signed_cookie函数进行持有签名的COOKIE值设置，避免用户在客户端进行修改 要记得，这个函数并不是对COOKIE值进行加密 HttpResonse.set_signed_cookie(key, value, salt=&#39;&#39;, max_age=None, expires=None, path=&#39;/&#39;, domain=None, secure=None, httponly=True) 为cookie值添加签名，其余参数与set_cookie相同 Request.get_signed_cookie(key, salt=&#39;&#39;, max_age=None) 从用户请求中获取通过salt盐值加了签名的Cookie值。 这里的salt要与之前存储时使用的salt值相同才可以解析出正确结果。 还要注意的是，如果对应的key值不存在，则会引发KeyError异常，所以要记得异常捕获来确定是否含有Cookie值 12345678def check_salt_cookie(request): try: salt_cookie = request.get_signed_cookie(key='salt_cookie',salt='nice') except KeyError: #获取不到该key值的Cookie response = HttpResponse('正在设置一个salt Cookie值') response.set_signed_cookie(key='salt_cookie',salt='nice',value='salt_cookie') return response else: #获取到了对应key值，展示到新的HttpResonse中 return HttpResponse('获取到的salt Cookie值:%s' % salt_cookie) 第一次访问的时候，还没有加Cookie值，所以我们在获取的时候会抛出KeyError异常 此时捕获异常，并且设置Cookie即可； 再次刷新的时候，因为这里已经给出了Cookie值，则不会引发异常，会在页面中展示获取到的加盐Cookie Session 虽然说有了Cookie之后，我们把一些信息保存在客户端浏览器中，可以保持用户在访问站点时的状态，但是也存在一定的安全隐患，Cookie值被曝露，Cookie值被他人篡改，等等。我们将换一种更健全的方式，也就是接下来要说的Session。 Session在网络中，又称会话控制，简称会话。用以存储用户访问站点时所需的信息及配置属性。当用户在我们的Web服务中跳转时，存储在Session中的数据不会丢失，可以一直在整个会话过程中存活。 在django中，默认的Session存储在数据库中session表里。默认有效期为两个星期。 session创建流程 客户端访问服务端，服务端为每一个客户端返回一个唯一的sessionid，比如xxx。 客户端需要保持某些状态，比如维持登陆。那么服务端会构造一个{sessionid: xxx }类似这样的字典数据加到Cookie中发送给用户。注意此时，只是一个随机字符串，返回给客户端的内容并不会像之前一样包含实际数据。 服务端在后台把返回给客户端的xxx字符串作为key值，对应需要保存的服务端数据为一个新的字典，存储在服务器上，例如：{xxx : {id:1}} 之后的一些客户端数据获取，都是通过获取客户端向服务端发起的HttpRequest请求中里Cookie中的sessionid之后，再用该sessionid从服务端的Session数据中调取该客户端存储的Session数据 注意：补充说明，默认存储在数据库的Session数据，是通过base64 编码的，我们可以通过Python的base64模块下的b64decode()解码得到原始数据 整个过程结束之后：客户端浏览器存储的其实也只是一个识别会话的随机字符串（xxx） 而服务器中是通过这个随机的字符串（xxx:value）进行真正的存储 Session的使用必须在Settings配置下 12345678INSTALLED_APPS = (... 'django.contrib.sessions', ...)MIDDLEWARE_CLASSES = ( 'django.contrib.sessions.middleware.SessionMiddleware', ...) 当settings.py中SessionMiddleware激活后 在视图函数的参数request接收到的客户端发来的HttpResquest请求对象中都会含有一个session属性 这个属性和之前所讨论的Cookie类似，是一个类字典对象，首先支持如下常用字典内置属性 获取Session session_data = request.session.get(Key) session_data = request.session[Key] 在Session中获取对应值，get方法获取时，如不存在该Key值，不会引发异常，返回None 而第二种直接通过字典获取，如Key值不存在，引发KeyErro 删除Session del request.seesion[Key] 删除对应session，Key值不存在时，引发KeyError request.session.clear() 清空Session中的所有数据。这里客户端还会保留sessionid 只不过在服务端sessionid对应的数据没有了。 request.session.flush() 直接删除当前客户端的的Seesion数据。这里不光服务端sessionid对应的数据没有了，客户端的sessionid也会被删除 设置有效期 request.session.set_expiry(value)： 设置Session的有效时间。 value：有效时间。 为整数时：将在value为秒单位之后过期 为0时：将在用户关闭浏览器之后过期。 为None时：使用全局过期的设置，默认为两个星期，14天。 为datetime时：在这个指定时间后过期。 request.session.get_expiry_age() 返回距离过期还剩下的秒数。 request.session.clear_expired() 清除过期的Session会话。 编写一个简单的视图函数来玩耍Session吧 12345678910111213141516from django.shortcuts import render,HttpResponseimport datetimedef set_session(request): if request.session.get('test_id'): session_data = request.session.get('test_id') # 用户拿到的的session随机字符串 session_key = request.session.session_key # 获取客户端浏览器中的SessionID值 session_expire = request.session.get_expiry_age() now = datetime.datetime.now() expire_time = now + datetime.timedelta(seconds=session_expire) response = '&lt;div&gt;SessionID : %s&lt;/div&gt;' % session_key + \\ '&lt;div&gt;Session : %s&lt;/div&gt;' % session_data + \\ '&lt;div&gt;ExpireTime : %s&lt;/div&gt;' % expire_time return HttpResponse(response) else: request.session['test_id'] = 'TEST' request.session.set_expiry(None) return HttpResponse('已设置好Session') 用户在第一次访问时，会走else分支，此时还没有任何服务端的Session及客户端的Cookie值设定 那么我们会通过request.session[Key]的方式来设置一个Session值，值为TEST 当用户第二次访问时将展示出所设置好的Session值及在客户端浏览器中存储的sessionid 在编写一个删除Session的视图函数吧 123456def delete_session(request): if request.session.get('test_id'): del request.session['test_id'] return HttpResponse('Session被删了') else: return HttpResponse('目前没有任何需要删除的session') 这里温柔的使用del request.session[Key]的方式来进行Session的删除 如果存在对应test_id的Session值则删除，反之返回一个字符串 Session删除总结 使用的是del的针对性删除方式，这样不会将整个客户端的session删除掉 使用request.session.clear()，只是清空了服务端Session中的数据，但是客户端的Cookie中还会保存sessionid，只不过这个值对应的字符串所对应的用户数据是一个空 使用request.session.flush()，那么客户端Cookie中保存的sessionid首先会被删除，其次服务端通过sessionid值保存的用户数据也会被全部删除。","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Django-Forms-表单层","slug":"Django-Forms-表单层","date":"2019-10-26T03:22:58.227Z","updated":"2019-12-09T11:26:06.013Z","comments":true,"path":"Django-Forms-表单层/","link":"","permalink":"https://cy-blogs.cn/Django-Forms-表单层/","excerpt":"Forms django提供了一整套健全的机制来帮助我们自动创建对应HTML中的表单，类似序列化器 开发者可以方便的使用已经设定好的一系列字段进行表单的设计 可以在某个app下面新建一个forms.py文件，在这个文件编写django自带表单类的编写 比如像下面这样","text":"Forms django提供了一整套健全的机制来帮助我们自动创建对应HTML中的表单，类似序列化器 开发者可以方便的使用已经设定好的一系列字段进行表单的设计 可以在某个app下面新建一个forms.py文件，在这个文件编写django自带表单类的编写 比如像下面这样 123from django import formsclass TestForm(forms.Form): name = forms.CharField(label='名字:',max_length=100) 在这个表单类中，设置了一个CharField字段，并且具有label标签值为name 此外在``标签处还会设置maxlength=100的属性 django在接收到这样表单内的数据时，还将验证数据的长度 实例化该类，然后打印出来查看效果 12345678&lt;tr&gt; &lt;th&gt; &lt;label for=\"id_name\"&gt;名字:&lt;/label&gt; &lt;/th&gt; &lt;td&gt; &lt;input type=\"text\" name=\"name\" maxlength=\"100\" required id=\"id_name\" /&gt; &lt;/td&gt;&lt;/tr&gt; 在渲染后的结果中不包含提交的按钮，以及外层的form标签，还需要我们自己手动在模板页面中进行添加 form表单实例的使用也非常简单，直接在模板页面处将表单实例以模板变量形式传递赋值即可 1234# views.pydef index(request): form = forms.TestForm() return render(request,'index.html',locals()) 123456&lt;!-- index.html --&gt;&lt;form action=\"/\" method=\"POST\"&gt; &#123;% csrf_token %&#125; &#123;&#123; form &#125;&#125; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; is_valid 每一个form类的实例都具有一个is_valid()方法，验证表单内的字段是否合法，并将表单中合法的的数据将放到表单中的cleaned_data属性中 如果全部数据都没有问题，那么该函数将会返回True，返回的合法数据。结果是一个字典的数据类型 123456789101112form = TestFrom()if form.is_valid(): data = form.cleaned_datadef post_test(request): if request.method == \"POST\": form = TestForm(request.POST) if form.is_valid(): name = form.cleaned_data.get('name') return HttpResponse('OK') else: form = TestForm() return render(request, \"xxx.html\",&#123;\"form\":form&#125;) 在视图函数中，当用户以post形式提交数据，此时将post数据与表单类进行关联 使用post数据做为类实例化的参数，这种操作也叫作绑定数据到表单 如果用户在表单中填写张三并提交，那么绑定数据之后的表单实例像是这样 12&lt;label for=\"id_name\"&gt;名字:&lt;/label&gt;&lt;input id=\"id_name\" maxlength=\"100\" name=\"name\" type=\"text\" value=\"张三\" /&gt; input标签中的value值为用户post所提交的数据 如果绑定数据的表单实例经过is_valid函数校验并通过，那么正确的数据将存储在cleaned_data中，cleaned_data中的数据同时也是处理好的Python数据类型，比如这里为一个字典数据类型 接下来在视图函数中可以直接通过字典的操作方式来获取到用户在对应表单标签中所填写的数据 表单字段类型 所有表单字段Field的子类均带有默认参数require BooleanField 控件：CheckboxInput 复选框：`` 空值：False 12&gt; Python`：`True\\False&gt; 错误键：required CharField 控件：TextInput 文本输入：`` 空值：空字符串 12&gt; Python`：`str&gt; 错误键：max_length、min_length、required ChoiceField 控件：Select 选择框：... 空值：空字符串 Python：Unicode str 必选参数：choices，该参数为一个二元组组成的可迭代对象，二元组中的第一个值为获取到的数据，第二个值为表单中展示的内容。 错误键：required、invalid_choice 123class TestForm(forms.Form): choices = ( ('0','男'), ('1','女'), ) gender = forms.ChoiceField(choices=choices) DateField 控件：DateInput 日期以普通的文本框输入：`` 空值：None Python：datetime.date 验证是否为一个指定日期格式的字符串 错误键：required、invalid 可选参数：input_formats，一个时间格式化字符串，用来将表单中的数据转换为datetime.date对象 可选参数格式参考如下： 1'%Y-%m-%d', # '2006-10-25''%m/%d/%Y', # '10/25/2006''%m/%d/%y' # '10/25/06' DateTimeField 控件：DateTimeInput 日期/时间以普通的文本框输入：&lt;input type=’text’ …&gt; 空值：None Python：datetime.datetime 验证是否为一个指定日期格式的字符串 可选参数：input_formats，一个时间格式化字符串，用来将表单中的数据转换为datetime.datetime对象 错误键：required、invalid DecimalField 控件：当Field.localize 是False 时为NumberInput，否则为TextInput NumberInput文本输入：`` TextInput文本输入：`` 空值：None Python：decimal 验证给定值是否为一个十进制数字 可选参数：max_value、min_value控制大小值范围 max_digits：值允许的最大位数（小数点之前和之后的数字总共的位数，前导的零将被删除） decimal_places：允许的最大小数位 错误键：required，invalid， max_value， min_value， max_digits， max_decimal_places max_whole_digits EmailField 控件：文本输入：`` 空值：空字符串 Python：Unicode str 使用正则验证给定的值是否为一个合法的邮件地址 可选参数：max_length与min_length，限定邮件地址字符串大小长度。 错误键：required、invalid FileField 控件：ClearableFileInput 文件上传输入：`` 空值：None Python：UploadedFile 验证非空的文件数据绑定到表单 使用该字段时，在使用表单实例获取上传文件数据时，表单标签中需要具备enctype=&quot;multipart/form-data&quot;属性，此外还需要绑定文件数据在表单上 1form = TestForm(request.POST,request.FILES) FloatField 控件：当Field.localize是False 时为NumberInput，否则为TextInput NumberInput文本输入：`` TextInput文本输入：`` 空值：None Python：Float 验证给出的值是一个浮点数，对比float函数 可选参数：max_value、min_value限定大小值范围 错误键：required， invalid， max_value，min_value ImageField 控件：ClearableFileInput 文件上传输入：`` 空值：None Python：UploadedFile 验证文件数据并且检验是否是一个可以被pillow所解释的图像 使用该字段，需要安装pillow模块。 错误键：required，invalid，missing，empty，invalid_image IntergerField 控件：当Field.localize 是False时为NumberInput，否则为TextInput NumberInput文本输入：`` TextInput文本输入：`` 空值：None Python：int 验证给定的值是否是一个整数 可选参数：max_value、min_value限定大小值范围 错误键：required，invalid，max_value，min_value GenericIPAddressField 控件：TextInput 文本输入：`` 空值：空字符串 Python：Unicode str 可选参数 protocol：默认值为both，可选IPv4或IPv6。 错误键：required，invalid MultipleChoiceField 控件：SelectMultiple ... 空值：一个空列表 Python：list 验证表单中的值是否存在于选择列表中，对比ChoiceField，该字段支持多选 必选参数：choices，与ChoiceField类似，接收一个二元组可迭代对象 错误键：required，invalid_choice，invalid_list RegexField 控件：TextInput 文本输入：`` 空值：空字符串 Python：Unicode str 验证表单中值与某个正则表达式匹配 必选参数：regex，字符串或编译的正则表达式 可选参数：max_length、min_length 错误键：required，invalid SlugField 控件：TextInput 文本输入：`` 空值：空字符串 Python：Unicode对象 验证给定的值为字母、数字、下划线及连字符组成 错误键：required，invalid URLField 控件：TextInput 文本输入：`` 空值：空字符串 Python：Unicode对象 验证给定值是一个有效的URL 可选参数：max_length、min_length 错误键：required，invalid TimeField 控件：TextInput 文本输入：`` 空值：None Python：datetime.time 验证给定值是否为一个给定格式的时间字符串 可选参数：input_formats，控制表单输入的格式 表单属性 required： 表单字段为必填值，当传递数据为一个空值，不管是空字符串还是None 在表单验证时，将引发ValidationError异常，这个异常将会在表单上展示错误信息 label 指定当前字段的label标签值，字段默认Label为字段名所有下换线转换为空格 且一个字母大写生成 label_suffix 修改label提示字符串的追加符号，默认表单类实例化过程会自动在label属性后加: initial 字段的初始值。不能将初始值直接作为参数传入，会造成直接验证表单数据而报错。 1form = forms.TestForm(initial=&#123;'name':'Bob'&#125;) widget 表单字段渲染时使用的Widget类，如果不想使用默认的表单类型，通过该参数指明所需表单控件 可以使用类似的表单类型，在下面会有详细的介绍。 help_text 指定字段的描述文本，该文本一般会紧挨着字段显示 表单控件：widget 默认django会为每一个表单字段设置默认的HTML控件 控件用来渲染HTML中输入元素与提取提交的原始数据 如果你希望使用一个不同的控件Widget，可以为字段设置widget参数 1234from django import formsclass CommentForm(forms.Form): comment = forms.CharField(widget=forms.Textarea) #修改CharField默认控件TextInput为Textarea 此外，我们还可以为字段的Widget设置额外的属性 比如一些之后在HTML渲染时候将会使用到的标签class值等等 只需要在widget参数部分使用attrs形参指定即可，该参数设置这个字段控件的对应HTML属性 1name = forms.CharField( max_length=5, widget=forms.TextInput(attrs=&#123;'class':'green'&#125;)) 还可以使用日期控件覆盖默认日期控件 12YEARS = ('2016', '2017', '2018')MONTHS = &#123; 1:'一月', 2:'二月', 3:'三月', 4:'四月',5:'五月', 6:'六月', 7:'七月', 8:'八月',9:'九月', 10:'十月', 11:'十一月', 12:'十二月'&#125;birth_year = forms.DateField(widget=froms.SelectDateWidget(years=YEARS,months=MONTHS)) 文本输入控件 TextInput 文本输入：`` NumberInput 文本输入：`` EmailInput 文本输入：`` URLInput 文本输入：`` PasswordInput 密码输入：`` HiddenInput 隐藏输入：`` DateInput 日期以普通的文本框输入：`` 可选参数：format，时间的字符串格式 DateTimeInput 日期/时间以普通的文本框输入：`` 可选参数：format，时间的字符串格式 TimeInput 时间以普通的文本框输入：`` 可选参数：format，时间的字符串格式 Textarea 文本区域：... 选择和复选框 CheckboxInput 复选框：`` 可选参数：check_test 这个参数接收一个函数对象，函数对象的参数为当前CheckboxInput的值，函数对象如果返回True，该控件在字段渲染时自动勾上。 1comment = forms.CharField(widget=forms.CheckboxInput(check_test=lambda *arg: True)) Select 单选框：... 可选参数：choices，与字段设置相同，但是会被字段设置所覆盖。 NullBooleanSelect 单选框：选项为Unknown、Yes和No，Unknown也代表False。 SelectMultiple 多选框：... RadioSelect 单选框，与select类似，但是会将选择渲染为一个单选按钮列表 CheckboxSelectMultiple 多选框：与SelectMultiple类似，但是会渲染为一个复选框列表/ 复合控件 SelectDateWidget 封装了三个Widget，分别用于年、月、日 可选参数：可以来指定日期表单的选择 years：一个列表或元组的序列数据类型，用来确定年的选择。 months：一个字典数据类型，字典的key值为月份数字，从1开始，value值为在表单中渲染展示的字符串，比如 1MONTHS = &#123; 1:'一月', 2:'二月', 3:'三月', 4:'四月', 5:'五月', 6:'六月', 7:'七月', 8:'八月', 9:'九月', 10:'十月', 11:'十一月', 12:'十二月'&#125; 表单API 表单类的实例，只有两种，一种是绑定了数据的，一种是未绑定的。都可以渲染成为html Form.is_valid() 对于绑定了数据的表单，进行验证并返回一个数据是否合法的布尔值 并在所有数据有效时将数据放入cleaned_data中 Form.is_bound() 区分绑定表单和未绑定表单，当表单类绑定数据时，返回True Form.errors 当验证发生错误时的错误信息的字典，字典key值为字段名称，value为报错信息列表，可能有多个报错 表单的数据将会在调用is_valid时或访问errors属性时验证 并且验证过程只会调用一次，不论访问errors和调用is_valid多少次 12345678class TestForm(forms.Form): name = forms.CharField(max_length=5,) email = forms.EmailField(required=True) def clean_name(self): cleaned_data = super(TestForm,self).clean() if self.cleaned_data.get('name') == '小红': raise forms.ValidationError(\"不允许小红\") return cleaned_data 12&gt;&gt;&gt; f = forms.TestForm(&#123;'name':'小红','emali':'123'&#125;)&gt;&gt;&gt; a.errors&#123;'name': ['不允许小红'], 'email': ['This field is required.']&#125; Form.errors.as_data 返回报错信息的字典，映射字段报错信息到一个ValidationError实例 1&gt;&gt;&gt; f.errors.as_data()&#123; 'name': [ValidationError(['不允许小红'])], 'email': [ValidationError(['This field is required.'])]&#125; Form.errors.as_json(escape_html=False) 以json格式返回错误信息 12&gt;&gt;&gt; a.errors.as_json()'&#123; \"name\": [&#123;\"message\": \"\\\\u4e0d\\\\u5141\\\\u8bb8\\\\u5c0f\\\\u7ea2\", \"code\": \"\"&#125;], \"email\": [&#123;\"message\": \"This field is required.\", \"code\": \"required\"&#125;]&#125;' Form.initial 声明当前表单类的默认数据，参数为一个字典数据类型 key对应需要填充默认数据的表单字段，value值为实际数据 1class TestForm(forms.Form): name = forms.CharField(max_length=5,initial='Jack',) 12&gt;&gt;&gt; f = TestForm(initial=&#123;'name':'Bob'&#125;)&gt;&gt;&gt; print(f)&lt;tr&gt;&lt;th&gt;&lt;label for=\"id_name\"&gt;Name:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input id=\"id_name\" maxlength=\"5\" name=\"name\" type=\"text\" value=\"Bob\" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt; Form.has_changed() 检查表单当前的数据是否与默认值不同 12&gt;&gt;&gt; f = TestForm(data=&#123;'name':'Jack'&#125;,initial=&#123;'name':'Bob'&#125;)&gt;&gt;&gt; f.has_changed()True Form.cleaned_data 在对绑定数据的表单实例进行is_valid验证之后，如果数据无误 那么返回的数据将保存在cleaned_data中 如果有部分数据没有经过验证，那么cleaned_data中也会保留合法的字段 并且，在cleaned_data属性中获取到的数据，只包含表单类中含有的字段 1234class TestForm(forms.Form): name = forms.CharField(max_length=5,) email = forms.EmailField(required=True) active = forms.BooleanField() 123456789&gt;&gt;&gt; data = &#123;... 'name':'Jack', ... 'email':'111',... 'active':True,... &#125;&gt;&gt;&gt;&gt;&gt;&gt; f = TestForm(data=data)&gt;&gt;&gt; f.is_valid()False&gt;&gt;&gt; f.cleaned_data&#123; 'name':'Jack', 'active': True&#125; Form.as_p() 将表单渲染为一系列的``标签，每个标签内含一个字段porm.as_ul()` 渲染表单为一系列的标签，并且不包含标签，可以自行指定``的HTML属性 1&gt;&gt;&gt; print(f.as_ul())&lt;li&gt;&lt;label for=\"id_name\"&gt;Name:&lt;/label&gt; &lt;input id=\"id_name\" maxlength=\"5\" name=\"name\" type=\"text\" /&gt;&lt;/li&gt; Form.as_table() 渲染表单为`标签 1&gt;&gt;&gt; print(f.as_table())&lt;tr&gt;&lt;th&gt;&lt;label for=\"id_name\"&gt;Name:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input id=\"id_name\" maxlength=\"5\" name=\"name\" type=\"text\" /&gt;&lt;/td&gt;&lt;/tr&gt; 配置表单元素的HTML id值与默认自带的label标签 通过表单类进行渲染时，默认会包含以下属性 表单元素的HTML id属性 辅助的label标签 有些时候，想要设置自定义HTML id值或者取消label标签，可以使用如下内置函数 Form.auto_id=True 修改对应渲染表单属性 当auto_id值为False时，表单类的渲染将不会包含``以及id属性 12&gt;&gt;&gt; f = TestForm(auto_id=False)&gt;&gt;&gt; print(f)&lt;tr&gt;&lt;th&gt;Name:&lt;/th&gt;&lt;td&gt;&lt;input maxlength=\"5\" name=\"name\" type=\"text\" /&gt;&lt;/td&gt;&lt;/tr&gt; 模板中表单实例属性 模板页面接收到的form表单实例支持循环遍历访问 1&#123;% for field in form %&#125; &#123;&#123; field &#125;&#125;&#123;% endfor %&#125; 其中for迭代访问之后的每一个表单字段又支持如下操作 ``：字段的label，例如Email address。 ``：包含在HTML 标签中的字段值。 ``：这个字段的ID值。 ``：字段的值 ``：该字段的标签中name属性使用的值。 ``：该字段的帮助文档。 ``：字段的验证错误信息，字段标签会在 ``：如果该字段为隐藏字段，返回True。反之返回False。 ``：获取当前字段实例，可以用该属性来访问字段实例的属性 1&#123;&#123; field.field.max_length &#125;&#125; 与模型类关联的表单 除了以上我们自定义表单类来进行表单的初始化 django还提供了另外一种表单类的创建方法，可以通过与模型关联来构建表单 这种办法可以更加省时省力，直接使用模型类中已经定义好的字段来进行表单字段的生成 123456class TestTable(modes.Model): name = models.CharField(max_length=10) class TestTableForm(forms.ModelForm): class Meta: model = TestTable fields = ['name'] 生成的表单实例将具备模型类中的字段，表单生成的字段顺序也与模型类中的定义顺序相同 fields属性用来显示的设置所有需要在表单中处理的字段 也可以直接为该字段设置fields = &#39;__all__&#39;来使用所有模型类中的字段作为未来的表单字段 注意 ： 如果模型类中字段定义了blank=True，那么对应关联的表单类中字段会默认具有require=False的属性 模型类中字段的verbose_name属性对应关联表单类字段的Label属性 如果模型类字段中设置了choices值，那么对应关联表单字段的widget将会设置为select 当然，除了根据关联模型类来创建表单类，还可以在关联表单类中选择性的覆盖某些字段的设置 比如使用表单类Meta元类中的widgets属性可以以字典形式设置对应字段的控件 12345678class TestTableForm(forms.ModelForm): name = forms.URLField() class Meta: model = TestTable fields = ['name'] widgets = &#123; 'name':forms.Textarea(attrs=&#123;'class':'green'&#125;) &#125; 除此之外，还可以指定labels、help_texts和error_messages等信息 123456789101112131415class TestTableForm(forms.ModelForm): name = forms.URLField() class Meta: model = TestTable fields = ['name'] labels = &#123; 'name':'您的名字' &#125; help_texts = &#123; 'name':'请输入您的名字' &#125; error_messages = &#123; 'name':&#123; 'required':'你必须填写这个名字', 'max_length':'你的名字太长了' &#125; &#125; 与模型关联的表单验证 表单的验证在我们调用is_valid函数时执行，也可以通过访问errors属性或调用full_clean函数 验证的出错会引发ValidationError异常，该异常会向表单传达一个错误信息 验证的步骤主要分为两步，表单验证，如果关联了模型，则还会进行模型验证 表单字段的验证分为以下过程 字段to_python，这个方法将字段的值根据字段的类型转换为Python中的数据类型，如果不能转换则引发ValidationError异常 字段的clean函数，该函数用来运行对应的验证器，根据顺序执行to_python，validate特异性验证，以及run_validators（用于将错误信息汇总）验证，如果有任何验证过程引发了ValidationError异常，验证都将停止。其余通过验证的字段数据插入到表单的cleaned_data字典中 表单中的字段clean函数，这个验证用于完成特定属性，与表单字段类型无关；比如我们经常需要验证用户输入的字段值不能为小红，那么可以编写字段的clean函数，函数命名为clean_，fileds_name为字段名 123456class TestTableForm(forms.ModelForm): def clean_name(self): name = self.cleaned_data.get('name') if name == '小红': raise forms.ValidationError('不允许小红') return name 表单的clean函数，这个方法进行表单中多个字段值的联合验证，验证之后的数据返回为cleaned_data，可以通过重写该函数来提供的额外验证方法，并且为了维持clean方法的验证行为，在代码中，表单类需要调用父类的clean方法 123456def clean(self): cleaned_data = super(TestTableForm,self).clean() name = cleaned_data.get('name') if '1' in name: cleaned_data['name'] = name.replace('1','一') return cleaned_data 最后总结的来说： 一个表单在验证时，首先验证每一个字段，接着调用字段的clean_fields函数，最后使用表单类的clean函数进行验证 如果表单与模型关联，那么现在还有第二步验证，模型的验证 模型的验证为如下过程 验证关联模型的字段及相关属性：Model.clean_fields(exclud=None)，该方法将验证模型的所有字段属性，如果有字段验证错误，引发ValidationError异常 验证模型的完整性：Model.clean(exclude=None)，可以对模型做整体的检验，如果想要自己验证模型中通过属性校验的数据，可以在模型类中重新定义这个函数 123456from django.core.exceptions import ValidationErrorclass TestTable(models.Model): name = models.CharField(max_length=10,verbose_name='名字',unique=True) def clean(self): if '$' in self.name: raise ValidationError('无法使用$符号') 验证模型的唯一性：Model.validate_unique(exclude=None)，如果模型中所有唯一约束性，比如使用类似unique属性，会校验表单中的值是否唯一 并且，除了通过绑定模型的表单实例is_valid函数可以来进行以上的验证过程，如果想自己控制验证 可以直接使用模型的full_clean(exclude=None,validate_unique=True)方法进行以上三个步骤的验证 与模型关联的表单保存 与模型关联的表单，在校验成功之后，表单实例可以直接通过save函数来进行表单数据的保存数据库 12345def form_test(request): if request.method == \"POST\": form = TestTableForm(request.POST,request.FILES) if form.is_valid(): form.save() return HttpResponse('OK:%s' % value) 该函数也支持在模型类中进行重写，但是要切记使用父类的save方法，确保数据可以正确存储到数据库中 12345def save(self, *args, **kwargs): if self.name == 'abc': return False#不做存储 else: super(TestTable,self).save(*args, **kwargs)","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]},{"title":"Ajax及Axios异步请求，接口数据序列化处理","slug":"Ajax及Axios异步请求接口数据序列化处理","date":"2019-10-26T03:21:46.194Z","updated":"2019-12-09T11:25:53.566Z","comments":true,"path":"Ajax及Axios异步请求接口数据序列化处理/","link":"","permalink":"https://cy-blogs.cn/Ajax及Axios异步请求接口数据序列化处理/","excerpt":"Ajax ajax可以使当前浏览器不需要整个重新加载，只是局部刷新，给用户的体验良好，也因为只是刷新局部页面，相对而言效率更高一些 同步交互：客户端发出一个请求后，需要等待服务器相应结束后，才可以发起第二个请求 异步交互：客户端发出一个请求后，无需等待该次服务器的相应，即可发起第二个请求","text":"Ajax ajax可以使当前浏览器不需要整个重新加载，只是局部刷新，给用户的体验良好，也因为只是刷新局部页面，相对而言效率更高一些 同步交互：客户端发出一个请求后，需要等待服务器相应结束后，才可以发起第二个请求 异步交互：客户端发出一个请求后，无需等待该次服务器的相应，即可发起第二个请求 json数据类型 数据在键值对中 数据由逗号分隔 花括号存储数据 方括号保存数组 1[ &#123; \"name\":\"Bill\", \"age\":1 &#125;, &#123; \"name\":\"George\", \"age\":2 &#125;, &#123; \"name\":\"Thomas\", \"age\": 3 &#125;]; jQuery-Ajax 使用ajax进行django后台数据的异步获取，django只是提供的数据，并不承担前端页面的渲染工程 这里使用jQuery所提供的ajax方法进行异步通信 首先测试数据库中模型类定义如下： 1234567class Article(models.Model): title = models.CharField(max_length=50,verbose_name=\"标题\") author = models.CharField(max_length=20,verbose_name=\"作者\") date = models.DateField(auto_now_add=True,verbose_name=\"发表日期\") content = models.TextField(verbose_name=\"文章内容\") def __str__(self): return self.title 测试数据可由用户自行添加，非常简单 编写主页视图函数，返回所有数据库中内容 123def index(request): articles = models.Article.objects.all() return render(request,'ajax/index.html',locals()) 此处的index.html页面不光承担所有数据的渲染工作 还将负责未来ajax异步请求，获取对应文章的详细内容 index.html页面代码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;style&gt; label&#123; border: 5px outset gray; width: 150px; margin-top: 10px; &#125;&lt;/style&gt;&lt;head&gt; &#123;% load staticfiles %&#125; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Ajax测试&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"&#123;% static 'js/jquery-1.10.2.min.js' %&#125;\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"&#123;% static 'js/jquery.cookie.js' %&#125;\"&gt;&lt;/script&gt; &lt;!-- 该js文件用来引入jquery所提供的获取cookie值的库 为了提取对应csrf_token--&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是一个ajax的请求测试&lt;/h1&gt; &#123;% for article in articles %&#125; &lt;label class=\"&#123;&#123; article.id &#125;&#125;\"&gt; &#123;&#123; article.author &#125;&#125;:&#123;&#123; article.title &#125;&#125; &lt;/label&gt; &#123;% endfor %&#125; &lt;p class=\"content\"&gt; &lt;/p&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function () &#123; $(\"label\").click(function () &#123; $.ajax(&#123; url: '/article/', // 请求地址，对应Django某个路由映射 type: 'POST', // 请求方式 post data: &#123; 'csrfmiddlewaretoken': $.cookie('csrftoken'), // 提交数据需有当前csrf_token 防跨站请求伪造令牌 'id_': $(this).attr('class'), // 获取当前的id值 传递到视图后台 &#125;, success: function (result) &#123; var data = JSON.parse(result) // 解析获得实际字符串 $('.content').html(data) // 将内容以html形式显示到对应的p标签上 &#125; &#125;) &#125;) &#125;)&lt;/script&gt; 有了前端页面，并且ajax的请求地址为/article/，那么就需要我们定义一个视图函数返回对应的json数据，并且设置路由为/article/ 1234567891011121314151617181920#urls.pypath('ajax/',ajaxviews.index),# 首页路由path('article/',ajaxviews.article)# ajax请求路由#views.pydef article(request):if request.is_ajax():# 判断是否为ajax请求if request.method == \"POST\":# 为ajax的post方式请求 id_ = request.POST.get('id_') if id_: try: content = models.Article.objects.get(id=id_).content.replace('\\r\\n','&lt;br&gt;') # 这里还将获取到的文章字符串内容中的换行替换为HTML的换行标签 except models.Article.DoesNotExist: raise Http404 else: data = json.dumps(content,ensure_ascii=False,cls=JsonEncoder) # 返回get对应取到的实际属性 return HttpResponse(data) raise Http404 这里要注意的是，后端返回的数据得是序列化之后的才可以被前端js所解析，直接返回一个django model数据实例是不行的。所以需要我们视图函数对需要返回的数据进行序列化操作 对于数据的序列化操作主要有以下两种 json序列化 普通Python数据直接使用json模块进行序列化 12content = models.Article.objects.get(id=id_).content.replace('\\r\\n','&lt;br&gt;')#这里将文章内容对应返回，之所以有replace函数，是因为文章数据是通过admin后台复制添加，需要将其中的\\r\\n换行转换为HTML可以解析的&lt;br&gt;标识符data = json.dumps(content,ensure_ascii=False)# 第二个参数是因为序列化时对中文默认使用的ascii编码，此时需要将该值设置为False，这样前端接收到时才是一个正常中文结果return HttpResponse(data) 但如果要序列化的数据中包含时间类型date 或datetime时，这种办法就会报错啦 12&gt; TypeError: Object of type date is not JSON serializable&gt; 12345678910111213class JsonEncoder(json.JSONEncoder): # 自定义json处理器 def default(self, obj): if isinstance(obj, datetime): # 如果判断到类型为datetime格式 return obj.strftime('%Y-%m-%d %H:%M:%S') # 处理为字符串类型的 (年-月-日 时:分:秒) elif isinstance(obj, date): # 如果判断到json处理数据为date类型 return obj.strftime('%Y-%m-%d') else: return json.JSONEncoder.default(self,obj) # 其他数据类型按照默认的序列化方式处理即可 使用cls指定序列化方式，即可轻松解决特殊格式没有办法被json序列化的问题 1234content = models.Article.objects.get(id=id_).datadata = json.dumps(content,ensure_ascii=False,cls=JsonEncoder)# 通过json.dumps的cls参数指明所使用的自定义序列化类return HttpResponse(data) 对应前端接收展示 12var data = JSON.parse(result) // 普通json传输方式$('.content').html(data) 如果返回的数据并不是一个单独的数据属性，那么也可以通过json进行处理，以一个数据列表的形式返回 12345content = models.Article.objects.filter(id=id_).values()# ----------------------------------------------# content = models.Article.objects.all().values()# ----------------------------------------------data = json.dumps(list(content),ensure_ascii=False,cls=JsonEncoder)return HttpResponse(data) 对应前端接收展示 12345678910111213&lt;div class=\"content\"&gt; &lt;!-- 这里用到的不是之前的p标签 而是一个div容器 --&gt;&lt;/div&gt;success: function (result) &#123; var data = JSON.parse(result)[0]['content'] $('.content').html(data.replace(/\\r\\n/g,\"&lt;br&gt;\"))&#125;// ---------------------------------------------// 如果需要展示的是所有的结果，可以通过js的for循环success: function (result) &#123; var data = JSON.parse(result) var tag = '' for (var i = 0, len = data.length; i &lt; len; i++) &#123; tag += '&lt;p&gt;' + data[i]['content'].replace(/\\r\\n/g, \"&lt;br&gt;\") + '&lt;/p&gt;' tag += '&lt;hr&gt;' &#125; $('.content').html(tag)&#125; // ---------------------------------------------- Vue-Axios 除去jQuery所提供的异步通信ajax方法 在Vue中也提供了ajax的异步通信方法，叫做Axios Axios会自动转换json数据 简单的来编写一个视图函数 get：返回当前页面 post：返回一条json数据 12345678910111213141516171819202122232425window.onload = function () &#123; new Vue(&#123; el: '#content', // Vue接管的区域 data: &#123; message: '这个是表单内容', &#125;, methods: &#123; getajax() &#123; axios.get('/get_ajax/', &#123; params: &#123; // 这部分为get方式进行传参时使用的 id: 123 &#125; &#125;).then(function (response) &#123; console.log(response) // 打印输出get方式进行ajax请求时获取到的数据 &#125;).catch(function (error) &#123; console.log(error) // 当get方式ajax请求报错时，会进入该函数 &#125;) &#125; &#125;, &#125;)&#125; 对应的HTML页面 12345&lt;body&gt; &lt;div id=\"content\"&gt; &lt;button @click='getajax'&gt;点我发送ajax的get请求&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; 后台视图函数 1234if request.method == 'GET': message = request.GET.get('message') print(message) return render(request,'axios/index.html') 当使用的是post形式获取服务端数据时，首先要注意，axios默认的提交post 数据不是普通的form-data 12&gt; axios`的`post`使用的是`request payload`方式，参数格式是`application/json;charset=UTF-8&gt; 而我们之前的表单提交数据的类型都是application/x-www-form-urlencoded，所以直接再django后台通过request.POST.get是获取不到任何数据的 解决办法，需要我们在axios提交数据时，指明提交时的头部信息 12345678910111213141516171819202122232425window.onload = function () &#123; new Vue(&#123; el: '#content', // Vue接管的区域 data: &#123; message: '这个是表单内容', &#125;, methods: &#123; getajax() &#123; axios(&#123; method: 'post', url: '/get_ajax/', data: &#123; message:this.message, name: '张三' &#125;, headers: &#123; 'Content-Type':'application/x-www-form-urlencoded', &#125;, &#125;).then((response) =&gt; &#123; console.log(response.data) this.message = response.data &#125;) &#125; &#125;, &#125;)&#125; 虽然通过添加头部信息，可以让axios发送的数据被django后台所接收到，但是此时的数据还是有问题的 获取到的POST提交的数据被django打包成了一个QueryDict中的key值，value为空数组 导致后台按照平时的解析方式是获取不到的 解决办法也很简单，把QueryDict单独处理为一个字典 123456if request.method == 'POST': data = eval(list(request.POST.keys())[0]) # 将获取到的数据转换为字典 message = data.get('message') data = json.dumps(message + '我被服务端后台修改过') return HttpResponse(data) 接下来，当用户点击按钮时，post提交表单数据，给到django后台，后台追加字符串并返回，返回的数据被then回调函数所接收到，重新赋值给绑定的表单变量中 第二种办法，在前端vue提交数据时， serializer序列化 serializer是由django所提供的一个专门用来处理django数据对象(django model)变为序列化数据的框架 并且Django的序列化不支持单个对象，比如像objects.get获取到的数据，或是Python中的 str等数据类型 该序列化框架所提供的功能类位于django.core.serializers 12345678#views.py from django.core import serializerscontent = models.Article.objects.filter(id=id_)data = serializers.serialize('json',content,ensure_ascii=False)return HttpResponse(data)var data = JSON.parse(result)[0]['fields']['content']// 序列化传输方式$('.content').html(data.replace(/\\r\\n/g,\"&lt;br&gt;\"))console.log(data) 总结：通过管理器的get方法获取到的是一个独立的结果，并不是一个QuerySet数据对象，也不是一个普通Python数据类型；只能对数据其中的某条属性进行json格式的处理或是将其变为列表等序列数据类型之后再进行序列化处理 serializer反序列化 序列化：serializers.serialize 反序列化：serializers.deserialize 1234567from django.core import serializerscontent = models.Article.objects.filter(id=id_) # QuerySetdata = serializers.serialize('json',content,ensure_ascii=False) # strcontent = serializers.deserialize(\"json\", data)return HttpResponse(data) Ajax跨域 浏览器有一个很重要的概念：同源策略(Same-Origin Policy) 所谓同源是指，域名，协议，端口相同 不同源的客户端脚本javascript、ActionScript在没明确授权的情况下，不能读写对方的资源 同源：请求资源的地址与请求的发起方都属于同一域名下 JSONP JSONP是JSON with padding（填充式JSON 或参数式 JSON）的简写 JSONP实现跨域请求的原理简单的说，就是动态创建标签，然后利用的src不受同源策略约束来跨域获取数据。 JSONP由两部分组成：回调函数和数据 回调函数是当响应到来时应该在页面中调用的函数；回调函数的名字一般是在请求中指定的，而数据就是传入回调函数中的参数 注意：JSONP方式解决AJAX跨域，必须使用get方式，并且该方式常在一些数据量级比较小的情况下，因为需要服务端后台构建回调函数带参数的字符串，像是下面这样 123456def index(request): name = request.GET.get('name') + '哈哈哈哈哈' callback = request.GET.get('callback') data = '%s(\"%s\")' % (callback,name) # 这里以前端生成的回调函数名作为函数名，待返回数据作为参数返回 return HttpResponse(data) 前端代码：点击按钮传送表单的值到后台，并由后台处理后追加内容返回，返回的结果展示再p标签处 1&lt;input type='text' id='ajax_data'&gt;&lt;button&gt; 按钮&lt;/button&gt;&lt;p id=\"content\"&gt;&lt;/p&gt; Ajax代码，获取当前表单数据，并使用get方式传递到服务端 12345678910111213141516171819$(document).ready(function () &#123; $(\"button\").click(function () &#123; $.ajax(&#123; url: 'http://127.0.0.1:8000/axios/', // 请求地址，对应Django某个路由映射 type: 'get', // 请求方式 post dataType: \"jsonp\", // 指定服务端返回的数据为jsonp格式 data: &#123; 'name': $('#ajax_data').val(), &#125;, success: function (result) &#123; console.log(result) $('#content').html(result) &#125; &#125;) &#125;)&#125;) ajax发起请求，并指定服务端返回数据类型为jsonp格式 服务端构建函数包含参数的字符串，为jsonp请求发起时，给定的回调参数名，参数为要返回的数据 客户端先会调用回调函数，然后会调用 1success 回调函数可以接收处理服务端返回的数据 success回调函数是成功返回数据后必定会调用的函数 CORS 跨域资源共享CORS(Cross-Origin Resource Sharing)是一种机制，它使用额外的HTTP头来告诉浏览器，让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源 当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求 注意：不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了 实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信 这里需要我们将后端视图函数在接收到请求时，返回结果指明头部信息 123456789101112class Cors(View): def post(self,request): #判断是否为ajax请求 name = request.POST.get('name') response = HttpResponse(json.dumps('OK')) response[\"Access-Control-Allow-Origin\"] = \"http://127.0.0.1:5500\" # 允许可以跨域请求的站点 response[\"Access-Control-Allow-Methods\"] = \"POST, GET, OPTIONS\" # 允许可以跨域访问的请求方式 response[\"Access-Control-Allow-Headers\"] = \"*\" # 允许可以跨域请求时的头部字段 return response 前端页面的ajax代码正常提交数据即可 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.10.2.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"text\" id='name'&gt; &lt;button id='button'&gt;提交&lt;/button&gt;&lt;/body&gt; &lt;script&gt; $('#button').click(function ()&#123; $.ajax(&#123; url: 'http://127.0.0.1:8000/', type: 'post', data: &#123; name: $('#name').val() &#125;, success: function(result)&#123; console.log(result) &#125; &#125;) &#125;) &lt;/script&gt;&lt;/html&gt; django-cors-headers 除了以上手动构建返回结果的头部信息用来解决跨域问题 在django中还可以通过一个先成可以自动添加CORS-Header的中间件，只需要在settings.py中做一些简单的配置即可 要想使用该中间件需要安装django的三方插件 1pip install django-cors-headers 安装完成之后，在django的settings文件中加载app 1# settings.pyINSTALLED_APPS = [ ... 'django.contrib.staticfiles', 'corsheaders',] 接下来在中间件配置部分加载该插件所提供的中间件 1# settings.pyMIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'corsheaders.middleware.CorsMiddleware', # 顺序需要在common组件之前 'django.middleware.common.CommonMiddleware', #'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',] 继续配置允许跨站请求的白名单设置等属性 123# settings.pyCORS_ORIGIN_ALLOW_ALL = False # 是否允许其他所有站点发起跨站请求CORS_ORIGIN_WHITELIST = ( 'http://127.0.0.1:5500',) # 跨站请求白名单CORS_ALLOW_METHODS = ( 'POST',) # 允许跨站访问的请求方式CORS_ALLOW_HEADERS = ( '*',) # 允许跨站请求头中的字段类型 注：其中某些设置的默认值为如下所示 1234567891011121314151617default_headers = ( 'accept', 'accept-encoding', 'authorization', 'content-type', 'dnt', 'origin', 'user-agent', 'x-csrftoken', 'x-requested-with',)default_methods = ( 'DELETE', 'GET', 'OPTIONS', 'PATCH', 'POST', 'PUT',)","categories":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://cy-blogs.cn/tags/Django/"}]}]}
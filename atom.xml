<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>哼着自己旳小调调</title>
  
  <subtitle>Happy hum their own small tune</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cy-blogs.cn/"/>
  <updated>2019-12-20T03:22:12.655Z</updated>
  <id>https://cy-blogs.cn/</id>
  
  <author>
    <name>哼着自己旳小调调</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis 心跳检测</title>
    <link href="https://cy-blogs.cn/redis%E7%9A%84%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B/"/>
    <id>https://cy-blogs.cn/redis的心跳检测/</id>
    <published>2019-12-20T03:23:07.031Z</published>
    <updated>2019-12-20T03:22:12.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-心跳检测"><a href="#Redis-心跳检测" class="headerlink" title="Redis 心跳检测"></a>Redis 心跳检测</h1><blockquote><p>在命令传播阶段，<strong>从服务器默认以每秒一次的频率</strong>，向主服务器发送命令：</p><p>*<em>REPLCONF ACK *</em> //replication_offset是从服务器当前的复制偏移量。</p><p>心跳检测的作用：检测主服务器的网络连接状态；辅助实现min-slaves选项；检测命令丢失。</p><p>检测主从服务器的网络连接状态</p><p>通过向主服务器发送INFO replication命令，可以列出从服务器列表，可以看出从最后一次向主发送命令距离现在过了多少秒。</p><p><img src="https://img-blog.csdn.net/20170829110005938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemxmcHJvZ3JhbQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p>lag的值应该在0或1之间跳动，如果超过1则说明主从之间的连接有故障。</p><p>辅助实现min-slaves选项</p><p>Redis可以通过配置<strong>防止主服务器在不安全的情况下执行写命令</strong>；</p><p>min-slaves-to-write 3</p><p>min-slaves-max-lag 10</p><p>上面的配置表示：从服务器的数量少于3个，或者三个从服务器的延迟（lag）值都大于或等于10秒时，主服务器将拒绝执行写命令。这里的延迟值就是上面INFOreplication命令的lag值。</p><p>检测命令丢失</p><p>如果因为网络故障，主服务器传播给从服务器的<strong>写命令在半路丢失</strong>，那么当从服务器向主服务器发送REPLCONF ACK命令时，主服务器将发觉从服务器当前的<strong>复制偏移量</strong>少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器。</p><p>主服务器向从服务器<strong>补发缺失数据</strong>这一操作的原理和部分重同步操作的原理非常相似，它们的区别在于：补发缺失数据操作在主从服务器没有断线的情况下执行，而部分重同步操作则在主从服务器断线并重连之后执行。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis-心跳检测&quot;&gt;&lt;a href=&quot;#Redis-心跳检测&quot; class=&quot;headerlink&quot; title=&quot;Redis 心跳检测&quot;&gt;&lt;/a&gt;Redis 心跳检测&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在命令传播阶段，&lt;strong&gt;从服务器默认以每秒
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://cy-blogs.cn/categories/Redis/"/>
    
    
      <category term="Redis 心跳检测" scheme="https://cy-blogs.cn/tags/Redis-%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis 哨兵机制</title>
    <link href="https://cy-blogs.cn/Redis%E7%9A%84%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/"/>
    <id>https://cy-blogs.cn/Redis的哨兵机制/</id>
    <published>2019-12-20T03:23:07.006Z</published>
    <updated>2019-12-20T03:21:50.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-哨兵机制"><a href="#Redis-哨兵机制" class="headerlink" title="Redis 哨兵机制"></a>Redis 哨兵机制</h1><h3 id="什么是哨兵机制？"><a href="#什么是哨兵机制？" class="headerlink" title="什么是哨兵机制？"></a>什么是哨兵机制？</h3><ul><li><p>Redis 的哨兵（sentinel）系统用于管理多个 Redis 服务器，<strong>哨兵是redis集群架构中非常重要的一个组件</strong>，该系统执行以下三个任务：</p><ul><li><strong>监控（Monitoring）</strong>：哨兵（sentinel）会不断地检查你的 Master 和Slave 是否运作正常。</li><li><strong>提醒（Notification）</strong>：当别监控的某个 Redis 出现问题时，哨兵（sentinel）可以通过 API 向管理员或者其他应用程序发送通知。</li><li><strong>自动故障迁移（Automatic failover）</strong>：当一个Master 不能正常工作时，哨兵（sentinel）会开始一次自动故障迁移操作，它会将失效 Master 的其中一个 Slave 升级为新的 Master，并让失效 Master 的其他 Slave 改为复制新的 Master；当客户端视图连接失败的 Master时，集群也会向客户端返回新 Master 的地址，使得集群可以使用 Master 代替失效 Master。</li></ul></li><li><p><strong>哨兵（sentinel）是一个分布式系统，作为一个哨兵集群去运行的，相互协同工作，你可以在一个架构中运行多个哨兵（sentinel）进程</strong></p><blockquote><p>​        (1)故障转移时，判断一个master node宕机了，需要大部分哨兵都同意才行，涉及到分布式选举问题。<br>​         (2)及时部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身就是单点，那么就不靠谱。        </p><p>​        这些进程使用留言协议（gossipprotocols）来接收关于Master 是否下线的信息，并使用投票协议 （agreementprotocols）来决定是否执行自动故障迁移，以及选择哪个 Slave 作为新的 Master。</p><p>​        每个哨兵（sentinel）会向其它哨兵（sentinel）、master、slave<strong>定时</strong>发送消息，以确认对方是否 <strong>“活“ **着，如果发现对方在指定时间（可配置）内未响应，则暂时认为对方已挂（所谓的</strong>”主观认为冗机“**Subjective Down,简称sdown)）</p><p>​        若<strong>“哨兵群”</strong>中的多数据sentinel，都报告某一 master 没响应，系统才认为该 master <strong>“彻底死亡”</strong>(即:客观上的真正down机,Objective Down,简称odown),通过一定的vote算法,从剩下的slave节点中,选一台提升为master,然后自动修改相关配置。</p><p>​         虽然<strong>哨兵(sentinel) *<em>释出为一个单独的可执行文件 *</em>redis-sentinel **,但实际上它只是一个运行在特殊模式下的 Redis 服务器，你可以在启动一个普通 Redis 服务器时通过给定</strong> –sentinel** 选项来启动<strong>哨兵(sentinel)</strong>。</p></blockquote><p>​         哨兵(sentinel) 的一些设计思路和zookeeper非常类似</p><p><img src="https://img-blog.csdn.net/20171004163652928?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXN3S25pZ2h0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="哨兵"></p></li></ul><a id="more"></a><h3 id="哨兵的核心知识"><a href="#哨兵的核心知识" class="headerlink" title="哨兵的核心知识"></a>哨兵的核心知识</h3><hr><ul><li><p>哨兵至少需要3个实例，来保证自己的健壮性。</p></li><li><p>哨兵+redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用性</p></li><li><p>对于哨兵+redis主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充分的测试和演练。</p></li></ul><h3 id="redis哨兵主备切换的数据丢失问题"><a href="#redis哨兵主备切换的数据丢失问题" class="headerlink" title="redis哨兵主备切换的数据丢失问题"></a>redis哨兵主备切换的数据丢失问题</h3><hr><p>两种丢失情况：</p><ul><li><p>异步复制导致的数据丢失</p><blockquote><p>​        因为master-&gt;slave的复制是异步的，所 以可能有部分数据还没复制到slave，master就宕机了，这些数据就丢失了。</p></blockquote></li><li><p>脑裂导致的数据丢失</p><blockquote><p>​        脑裂，也就是说，某个master所在机器 突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着<br> ​        这个时候，集群中就会出现两个master。<br> ​        此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续写向旧master数据可能就会丢失。<br> ​        因此master在恢复的时候，会被作为一个slave挂到新的master上，自己的数据会被清空，从新的master复制数据</p></blockquote></li></ul><h3 id="解决异步复制和脑裂导致的数据丢失"><a href="#解决异步复制和脑裂导致的数据丢失" class="headerlink" title="解决异步复制和脑裂导致的数据丢失"></a>解决异步复制和脑裂导致的数据丢失</h3><hr><p>min-slaves-to-write 1<br> min-slaves-max-lag 10<br> 要求至少有1个slave，数据复制和同步的延迟不能超过10秒<br> 如果说一旦所有slave，数据复制和同步的延迟都超过了10秒钟，那么这个时候，master就不会再接收任何请求了。<br> （1）减少异步复制的数据丢失<br> 有了min-slaves-max-lag这个配置，就可以确保说，一旦slave复制数据和ack延时太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求，这样可以把master宕机时由于部分数据未同步到slave导致的数据丢失降低的可控范围内<br> （2）减少脑裂的数据丢失<br> 如果一个master出现了脑裂，跟其他slave丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的slave发送数据，而且slave超过10秒没有给自己ack消息，那么就直接拒绝客户端的写请求<br> 这样脑裂后的旧master就不会接受client的新数据，也就避免了数据丢失<br> 上面的配置就确保了，如果跟任何一个slave丢了连接，在10秒后发现没有slave给自己ack，那么就拒绝新的写请求<br> 因此在脑裂场景下，最多就丢失10秒的数据</p><p><img src="https://upload-images.jianshu.io/upload_images/16098303-42c2105c21bdce39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>集群脑裂导致的数据丢失问题.png</p><p><img src="https://upload-images.jianshu.io/upload_images/16098303-8536b356a0b50aa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>脑裂导致数据丢失的问题如何降低损失.png</p><p><img src="https://upload-images.jianshu.io/upload_images/16098303-a9e5b4bd87a20f7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>异步复制导致的数据丢失问题.png</p><p><img src="https://upload-images.jianshu.io/upload_images/16098303-d31754d7d5f73a8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><h3 id="哨兵模式的配置修改"><a href="#哨兵模式的配置修改" class="headerlink" title="哨兵模式的配置修改"></a>哨兵模式的配置修改</h3><hr><ul><li>实现步骤<ul><li>拷贝到etc目录<ul><li><strong>cp sentinel.conf /usr/local/redis/etc</strong></li></ul></li><li>修改sentinel.conf配置文件<ul><li><strong>sentinel monitor mymast 192.168.110.133 6379 1</strong> #主节点 名称 IP 端口号 选举次数</li><li>#配置主服务器的密码(如没设置密码，可以省略)<br>  <strong>sentinel auth-pass mymaster 123456</strong> </li></ul></li><li>修改心跳检测 5000毫秒<ul><li><strong>sentinel down-after-milliseconds mymaster 5000</strong></li></ul></li><li>做多多少合格节点<ul><li><strong>sentinel parallel-syncs mymaster 2</strong></li></ul></li><li>启动哨兵模式<ul><li><strong>./redis-server /usr/local/redis/etc/sentinel.conf –sentinel &amp;</strong></li></ul></li></ul></li></ul><blockquote><p>注意：</p><p>1.当启动哨兵模式之后，如果你的master服务器宕机之后，哨兵自动会在从redis服务器里面 投票选举一个master主服务器出来；这个主服务器也可以进行<strong>读写</strong>操作！</p><p>2.如果之前宕机的主服务器已经修好，可以正式运行了。那么这个服务器只能进行<strong>读</strong>的操作，会自动跟随由哨兵选举出来的新服务器！</p><p>3.大家可以进入./redis-cli，输入<strong>info，</strong>查看你的状态信息；</p></blockquote><p><img src="https://img-blog.csdn.net/20171004170405127?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXN3S25pZ2h0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><h3 id="哨兵-Sentinel-总结"><a href="#哨兵-Sentinel-总结" class="headerlink" title="哨兵(Sentinel)总结"></a>哨兵(Sentinel)总结</h3><blockquote><p>1、<strong>Sentinel</strong>的作用：</p><p>A、Master 状态监测</p><p>B、如果Master 异常，则会进行Master-slave 转换，将其中一个Slave作为Master，将之前的Master作为Slave </p><p>C、Master-Slave切换后，master_redis.conf、slave_redis.conf和sentinel.conf的内容都会发生改变，即master_redis.conf中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换 </p><p>2、<strong>Sentinel</strong>的工作方式<strong>:</strong></p><p>1)：每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令。</p><p>2)：如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。 </p><p>3)：如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。 </p><p>4)：当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 。</p><p>5)：在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 。</p><p>6)：当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 。</p><p>7)：若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。 </p><p>若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</p><p>最后，如果大家看不太懂，推荐大家看两个博客，就明白了！</p><p>1.<a href="http://blog.csdn.net/zbw18297786698/article/details/52891695" target="_blank" rel="noopener">http://blog.csdn.net/zbw18297786698/article/details/52891695</a><br>2.<a href="http://blog.csdn.net/candy_rainbow/article/details/52842402" target="_blank" rel="noopener">http://blog.csdn.net/candy_rainbow/article/details/52842402</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-哨兵机制&quot;&gt;&lt;a href=&quot;#Redis-哨兵机制&quot; class=&quot;headerlink&quot; title=&quot;Redis 哨兵机制&quot;&gt;&lt;/a&gt;Redis 哨兵机制&lt;/h1&gt;&lt;h3 id=&quot;什么是哨兵机制？&quot;&gt;&lt;a href=&quot;#什么是哨兵机制？&quot; class=&quot;headerlink&quot; title=&quot;什么是哨兵机制？&quot;&gt;&lt;/a&gt;什么是哨兵机制？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Redis 的哨兵（sentinel）系统用于管理多个 Redis 服务器，&lt;strong&gt;哨兵是redis集群架构中非常重要的一个组件&lt;/strong&gt;，该系统执行以下三个任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;监控（Monitoring）&lt;/strong&gt;：哨兵（sentinel）会不断地检查你的 Master 和Slave 是否运作正常。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提醒（Notification）&lt;/strong&gt;：当别监控的某个 Redis 出现问题时，哨兵（sentinel）可以通过 API 向管理员或者其他应用程序发送通知。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动故障迁移（Automatic failover）&lt;/strong&gt;：当一个Master 不能正常工作时，哨兵（sentinel）会开始一次自动故障迁移操作，它会将失效 Master 的其中一个 Slave 升级为新的 Master，并让失效 Master 的其他 Slave 改为复制新的 Master；当客户端视图连接失败的 Master时，集群也会向客户端返回新 Master 的地址，使得集群可以使用 Master 代替失效 Master。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;哨兵（sentinel）是一个分布式系统，作为一个哨兵集群去运行的，相互协同工作，你可以在一个架构中运行多个哨兵（sentinel）进程&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;​        (1)故障转移时，判断一个master node宕机了，需要大部分哨兵都同意才行，涉及到分布式选举问题。&lt;br&gt;​         (2)及时部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身就是单点，那么就不靠谱。        &lt;/p&gt;
&lt;p&gt;​        这些进程使用留言协议（gossipprotocols）来接收关于Master 是否下线的信息，并使用投票协议 （agreementprotocols）来决定是否执行自动故障迁移，以及选择哪个 Slave 作为新的 Master。&lt;/p&gt;
&lt;p&gt;​        每个哨兵（sentinel）会向其它哨兵（sentinel）、master、slave&lt;strong&gt;定时&lt;/strong&gt;发送消息，以确认对方是否 &lt;strong&gt;“活“ **着，如果发现对方在指定时间（可配置）内未响应，则暂时认为对方已挂（所谓的&lt;/strong&gt;”主观认为冗机“**Subjective Down,简称sdown)）&lt;/p&gt;
&lt;p&gt;​        若&lt;strong&gt;“哨兵群”&lt;/strong&gt;中的多数据sentinel，都报告某一 master 没响应，系统才认为该 master &lt;strong&gt;“彻底死亡”&lt;/strong&gt;(即:客观上的真正down机,Objective Down,简称odown),通过一定的vote算法,从剩下的slave节点中,选一台提升为master,然后自动修改相关配置。&lt;/p&gt;
&lt;p&gt;​         虽然&lt;strong&gt;哨兵(sentinel) *&lt;em&gt;释出为一个单独的可执行文件 *&lt;/em&gt;redis-sentinel **,但实际上它只是一个运行在特殊模式下的 Redis 服务器，你可以在启动一个普通 Redis 服务器时通过给定&lt;/strong&gt; –sentinel** 选项来启动&lt;strong&gt;哨兵(sentinel)&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​         哨兵(sentinel) 的一些设计思路和zookeeper非常类似&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20171004163652928?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveXN3S25pZ2h0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;哨兵&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://cy-blogs.cn/categories/Redis/"/>
    
    
      <category term="Redis 哨兵机制" scheme="https://cy-blogs.cn/tags/Redis-%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Redis 主从复制</title>
    <link href="https://cy-blogs.cn/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>https://cy-blogs.cn/Redis主从复制/</id>
    <published>2019-12-20T00:52:31.992Z</published>
    <updated>2019-12-20T01:59:27.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h1><ul><li><p>参考链接：</p><ul><li><p><a href="https://www.cnblogs.com/leeSmall/p/8398401.html" target="_blank" rel="noopener">Redis主从复制和哨兵 参考1</a></p><p><a href="https://www.cnblogs.com/chenhuabin/p/10048854.html" target="_blank" rel="noopener">Redis主从复制和哨兵 参考2</a></p><p><a href="https://www.cnblogs.com/lxx666/articles/10693844.html" target="_blank" rel="noopener">Redis主从架构和主从从架构集群搭建详细步骤</a></p><p><a href="https://www.cnblogs.com/wade-luffy/p/9639986.html" target="_blank" rel="noopener">Redis主从复制原理</a></p><p><a href="http://doc.redisfans.com/topic/replication.html" target="_blank" rel="noopener">Redis复制官方文档翻译</a></p></li></ul></li></ul><a id="more"></a><blockquote><p> ​        Redis 的定位是一个高可用的数据服务器，可是实际生产环境下，单机的 <code>redis</code> 服务器是无法满足真正意义上的高可用性的，</p><p>​        第一，单机的 <code>redis</code> 服务器很容易发生单点故障，即使 <code>redis</code> 提供了各种持久化的方法来避免数据的丢失，但是物理机上的故障（硬板损坏等）还是无法完全避免的。</p><p>​        第二，如果单台机器的性能进行纵向扩展，无论是<code>CPU</code>，内存还是磁盘容量都很容易达到瓶颈，无法满足实际需求。</p><p>​        针对这些问题，Redis提供了<strong>复制（replication）</strong>的功能，通过 “主从（一主多从）” 和 （集群（多住多从））的方式对 redis的服务进行水平扩展，用多台 redis 服务器共同构建一个高可用的 redis 服务系统。</p></blockquote><hr><p><img src="https://image-static.segmentfault.com/169/623/16962389-5c72b52170799_articlex" alt="图片描述">            </p><blockquote><p>​        主从复制，是指将一台<code>Redis</code>服务器的数据，复制到其它的 <code>Redis</code>服务器。前者称为主节点（master/leader），后者称为从节点（slave/follower）；数据的复制是单向的，只能由主节点到从节点。</p></blockquote><blockquote><p> ​            默认情况下，每台 <code>Redis</code>服务器都是主节点；且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。</p></blockquote><h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><hr><ul><li><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li><strong>负载均衡</strong> ：在主从复制的基础上，配合读写分离，可以由主节点提供服务，由从节点提供读服务（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</li><li><strong>读写分离</strong>：可以用于实现读写分离，主库写，从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量。</li><li><strong>高可用基石</strong> ：主从复制还是哨兵和肌群能够实施的基础，因此说主从复制是 Redis高可用的基础。</li></ul><h3 id="主从括扑结构"><a href="#主从括扑结构" class="headerlink" title="主从括扑结构"></a>主从括扑结构</h3><hr><ul><li><p><strong>一主一从</strong>：用于节点故障转移从节点，当主节点的 写 命令并发高且需要持久化，可以值在从节点开启AOF （主节点不需要），这样保证了数据的安全性，也避免持久化对主节点的影响。</p><p> <img src="https://images2017.cnblogs.com/blog/1227483/201802/1227483-20180201102310015-486760227.png" alt="img"></p></li><li><p><strong>一主多从</strong> ：针对 <code>读</code>较多的场景， <code>读</code>由多个从节点来分担，但节点越多，主节点同步到多节点的次数也越多，影响带宽，也加重主节点的稳定</p><p>​     <img src="https://images2017.cnblogs.com/blog/1227483/201802/1227483-20180201103217750-831662244.png" alt="img"></p></li><li><p><strong>树状主从</strong>  ：一主多从的缺点（住节点推送次数多压力大）可用些方案解决，主节点只推送一次数据到从节点B，再由从节点B推送到C，减轻主节点推送的压力。</p></li></ul><p>  <img src="https://images2017.cnblogs.com/blog/1227483/201802/1227483-20180201103511703-1604168118.png" alt="img"></p><h3 id="Redis-主从复制启用"><a href="#Redis-主从复制启用" class="headerlink" title="Redis 主从复制启用"></a>Redis 主从复制启用</h3><hr><ul><li><p>主从复制的开启，完全是在从节点发起的；不需要我们在主节点做任何事情。</p></li><li><p>从节点开启主从复制，有三种方式：</p><blockquote><ol><li><p>配置文件：在从服务器的配置文件中加入：slaveof <masterip><masterpory></masterpory></masterip></p></li><li><p>启动命令： redis-server 启动命令后加入 –slaveof <masterip><masterport></masterport></masterip></p></li><li><p>客户端命令：Reids 服务器启动后，直接通过客户端执行命令： slaveof <masterip> <masterport> ,则该Redis实例成为从节点。</masterport></masterip></p><p>通过 info  relication  命令可以看到复制的一些信息</p></li></ol></blockquote></li><li><p>断开主从复制</p><blockquote><p>​        通过 slaveof <masterip> <masterport> 命令建立主从复制关系以后，可以通过slaveof no one断开。</masterport></masterip></p><p>​        从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化。</p></blockquote></li></ul><h3 id="Redis-主从复制原理"><a href="#Redis-主从复制原理" class="headerlink" title="Redis 主从复制原理"></a>Redis 主从复制原理</h3><hr><p>主从复制过程大体可以分为3个阶段：<strong>连接建立阶段（即准备阶段）</strong>、<strong>数据同步阶段</strong>、<strong>命令传播阶段</strong>：</p><p>在从节点执行 slaveof 命令后，复制过程便开始运作，下图大概可以看到,</p><p>从图中可以看出复制过程大致分为 6 个过程</p><p><img src="https://image-static.segmentfault.com/129/061/1290613498-5c72b64944189_articlex" alt="图片描述"></p><h4 id="从服务器故障后处理"><a href="#从服务器故障后处理" class="headerlink" title="从服务器故障后处理"></a><strong>从服务器故障后处理</strong></h4><blockquote><pre><code>当从服务器崩溃之后，重启之后进行初始化，会自动的同步主服务器的数据。在 redis的2.8版本之后，redis 采用了 **增量复制** 的方式优化了从服务器的初始化同步数据的过程。</code></pre></blockquote><h4 id="主服务器故障后处"><a href="#主服务器故障后处" class="headerlink" title="主服务器故障后处"></a><strong>主服务器故障后处</strong></h4><blockquote><pre><code>当主服务器崩溃之后，首先需要手动的选择一个从服务器升级为主服务器（需要手动调整所有相关的服务器），然后启动之前已经崩溃的主服务器做为从服务回到系统中。可以看到，redis 在主服务器崩溃之后需要繁琐的人工预来恢复服务，特别是在主数据库进制了持久化之后，上述步骤不能错乱，否则会导致主数据库重启后恢复了错误数据，进而导致从数据库也同步错误数据这一灾难性后果。为此，redis 提供了哨兵机制，用于自动化的监控和维持分布式 redis 系统的良好运转。    </code></pre></blockquote><h3 id="连接建立阶段"><a href="#连接建立阶段" class="headerlink" title="连接建立阶段"></a>连接建立阶段</h3><h4 id="step1：保存主节点信息"><a href="#step1：保存主节点信息" class="headerlink" title="step1：保存主节点信息"></a>step1：保存主节点信息</h4><p>​    从节点服务器内部维护了两个字段，即<strong>masterhost</strong>和<strong>masterport</strong>字段，用于存储主节点的<strong>ip</strong>和<strong>port</strong>信息。</p><p>​    <strong>slaveof是异步命令，从节点完成主节点ip和port的保存后，向发送slaveof命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。</strong></p><h4 id="step2：建立socket连接"><a href="#step2：建立socket连接" class="headerlink" title="step2：建立socket连接"></a>step2：建立socket连接</h4><p>​    <strong>从节点每秒1次调用复制定时函数replicationCron()</strong>，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。</p><p><strong>如果连接成功：</strong></p><p>​    <strong>从节点：</strong>为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。</p><p>​    <strong>主节点：</strong>接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。</p><h4 id="step3：发送ping命令"><a href="#step3：发送ping命令" class="headerlink" title="step3：发送ping命令"></a>step3：发送ping命令</h4><p>​    从节点成为主节点的客户端之后，发送ping命令进行首次请求，<strong>目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求。</strong></p><p><strong>从节点发送ping命令后，可能出现3种情况：</strong></p><ol><li><p>返回ping：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。</p></li><li><p>超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。</p></li><li><p>返回ping以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。</p></li></ol><h4 id="step4：身份验证"><a href="#step4：身份验证" class="headerlink" title="step4：身份验证"></a>step4：身份验证</h4><p>如果从节点中设置了<strong>masterauth</strong>选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。</p><p>从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。</p><p>如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。</p><h4 id="step5：发送从节点端口信息"><a href="#step5：发送从节点端口信息" class="headerlink" title="step5：发送从节点端口信息"></a>step5：发送从节点端口信息</h4><p>身份验证之后，从节点会向主节点发送其监听的端口号，主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；<strong>该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。</strong></p><h3 id="数据同步阶段"><a href="#数据同步阶段" class="headerlink" title="数据同步阶段"></a>数据同步阶段</h3><p>主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。</p><p>具体执行的方式是：从节点向主节点发送<strong>psync命令</strong>，开始同步。</p><p>数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为<strong>全量复制和部分复制</strong>。</p><blockquote><p>在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端。原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。</p></blockquote><h3 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h3><p>​    数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。</p><p>​    在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。</p><p><strong>PS：</strong></p><p>​    <strong>延迟与不一致：</strong>命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关。</p><p>​    <strong>repl-disable-tcp-nodelay no：</strong>该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY；默认no，即不禁止TCP_NODELAY。当设置为yes时，TCP会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no。</p><h3 id="【数据同步阶段】全量复制和部分复制"><a href="#【数据同步阶段】全量复制和部分复制" class="headerlink" title="【数据同步阶段】全量复制和部分复制"></a>【数据同步阶段】全量复制和部分复制</h3><p>在Redis2.8以前，从节点向主节点发送sync命令请求同步数据，此时的同步方式是全量复制；</p><p>在Redis2.8以后，从节点可以发送psync命令请求同步数据，此时根据主从节点当前状态的不同，同步方式可能是全量复制或部分复制。</p><ol><li>全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。</li><li>部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。</li></ol><h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p><strong>Redis通过psync命令进行全量复制的过程如下：</strong></p><ol><li><p>从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行全量复制；</p></li><li><p>主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令。</p></li><li><p>主节点的bgsave执行完成后，将RDB文件发送给从节点；从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态。</p></li><li><p>主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态。</p></li><li><p>如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态。</p></li></ol><p><strong>通过全量复制的过程可以看出，全量复制是非常重型的操作：</strong></p><ol><li><p>主节点通过<strong>bgsave</strong>命令<strong>fork</strong>子进程进行<strong>RDB</strong>持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的；</p></li><li><p>主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗。</p></li><li><p>从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗。</p></li></ol><h4 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h4><p>​    由于全量复制在主节点数据量较大时效率太低，因此Redis2.8开始提供部分复制，用于处理网络中断时的数据同步。</p><p>​    部分复制的实现，依赖于三个重要的概念：复制偏移量，复制积压缓冲区，服务器运行ID</p><h5 id="offset-复制偏移量"><a href="#offset-复制偏移量" class="headerlink" title="offset 复制偏移量"></a>offset 复制偏移量</h5><p>​        在主从复制的Master(主节点)和Slave(从节点)双方都会各自维持一个offset，代表的是<strong>主节点向从节点传递的字节数</strong>；Master成功发送N个字节的命令后会将Master的offset加上N，Slave在接收到N个字节命令后同样会将Slave的offset增加N。Master和Slave如果状态是一致的那么它的的offset也应该是一致的。</p><p>​        offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。</p><h5 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h5><p>  复制积压缓冲区是由<strong>Master(主节点)维护的一个固定长度的FIFO队列(先进先出)</strong>，默认大小1MB；当主节点开始有从节点时创建，它的作用是缓存已经传播出去的命令。当Master进行命令传播时，不仅将命令发送给所有Slave，还会将命令写入到复制积压缓冲区里面。注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。</p><p>​        除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。</p><p>​        由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。</p><p><strong>从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制：</strong></p><ul><li><strong>如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；</strong></li><li><strong>如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。</strong></li></ul><h5 id="runid-服务器运行ID"><a href="#runid-服务器运行ID" class="headerlink" title="runid 服务器运行ID"></a>runid 服务器运行ID</h5><p>​        每个Redis服务器(无论主从)在启动时都会自动生成一个表明自己身份的随机ID(每次启动都不一样)，由40个随机的十六进制字符组成。在PSYNC中发送的这个ID是指之前连接的Master的ID，如果没保存这个ID，PSYNC命令会使用<strong>”PSYNC ? -1”</strong> 这种形式发送给Master，表示需要全量复制。</p><p>​        每个Redis节点，在启动时都会自动生成一个随机ID，由40个随机的十六进制字符组成；</p><p>runid用来唯一识别一个Redis节点。<strong>通过info Server命令，可以查看节点的runid。</strong></p><p>​        主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；</p><p><strong>主节点根据runid判断能否进行部分复制：</strong></p><ul><li><p>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</p></li><li><p>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</p></li></ul><h3 id="PSYNC命令"><a href="#PSYNC命令" class="headerlink" title="PSYNC命令"></a>PSYNC命令</h3><p>  Redis在2.8版本提供了PSYNC命令来带代替SYNC命令，为Redis主从复制提供了部分复制的能力。</p><h4 id="PSYNC命令格式"><a href="#PSYNC命令格式" class="headerlink" title="PSYNC命令格式"></a>PSYNC命令格式</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PSYNC &lt;runid&gt; &lt;offset&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> runid:主服务器ID</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> offset:从服务器最后接收命令的偏移量</span></span><br></pre></td></tr></table></figure><p>  <strong>PSYNC执行过程中比较重要的概念有3个：runid、offset（复制偏移量）以及复制积压缓冲区。</strong></p><h4 id="psync命令的执行"><a href="#psync命令的执行" class="headerlink" title="psync命令的执行"></a>psync命令的执行</h4><p><img src="C:%5CUsers%5Casus%5CDesktop%5C990532-20180913134017449-1623896661.png" alt="990532-20180913134017449-1623896661"></p><ol><li><p>首先从节点根据当前状态，决定如何调用psync命令：</p><ul><li>如果从节点之前未执行过<strong>slaveof</strong>或最近执行了<strong>slaveof no one</strong>，则从节点发送命令为<strong>psync ? -1</strong>，向主节点请求全量复制；</li><li>如果从节点之前执行了<strong>slaveof</strong>，则发送命令为 <strong>psync <runid> <offset> **，其中</offset></runid></strong>runid<strong>为上次复制的主节点的</strong>runid<strong>，</strong>offset**为上次复制截止时从节点保存的复制偏移量。</li></ul></li><li><p>主节点根据收到的psync命令，及当前服务器状态，决定执行全量复制还是部分复制：</p><ul><li>如果主节点版本低于Redis2.8，则返回-ERR回复，此时从节点重新发送sync命令执行全量复制；</li><li>如果主节点版本够新，且runid与从节点发送的runid相同，且从节点发送的offset之后的数据在复制积压缓冲区中都存在，则回复+CONTINUE，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可；</li><li>如果主节点版本够新，但是runid与从节点发送的runid不同，或从节点发送的offset之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，则回复<strong>+FULLRESYNC <runid> <offset></offset></runid></strong>，表示要进行全量复制，其中runid表示主节点当前的runid，offset表示主节点当前的offset，从节点保存这两个值，以备使用。</li></ul></li></ol><h3 id="【命令传播阶段】心跳机制"><a href="#【命令传播阶段】心跳机制" class="headerlink" title="【命令传播阶段】心跳机制"></a>【命令传播阶段】心跳机制</h3><p>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。心跳机制对于主从复制的超时判断、数据安全等有作用。</p><h4 id="主-gt-从：PING"><a href="#主-gt-从：PING" class="headerlink" title="主-&gt;从：PING"></a>主-&gt;从：PING</h4><p>每隔指定的时间，<strong>主节点会向从节点发送PING命令</strong>，这个PING命令的作用，主要是为了让从节点进行超时判断。</p><p>PING发送的频率由 repl-ping-slave-period 参数控制，单位是秒，默认值是10s。</p><h4 id="从-gt-主：REPLCONF-ACK"><a href="#从-gt-主：REPLCONF-ACK" class="headerlink" title="从-&gt;主：REPLCONF ACK"></a>从-&gt;主：REPLCONF ACK</h4><p>在命令传播阶段，<strong>从节点会向主节点发送REPLCONF ACK命令，</strong>频率是每秒1次；</p><p><strong>命令格式为：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLCONF ACK &#123;offset&#125;# offset指从节点保存的复制偏移量。</span><br></pre></td></tr></table></figure><p><strong>REPLCONF ACK命令的作用包括：</strong></p><ol><li><p><strong>实时监测主从节点网络状态：</strong>该命令会被主节点用于复制超时的判断。此外，在主节点中使用info Replication，可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1。</p></li><li><p><strong>检测命令丢失：</strong>从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会推送缺失的数据（这里也会利用复制积压缓冲区）。</p></li></ol><ul><li><strong>注意：offset和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的。</strong></li></ul><ol start="3"><li><strong>辅助保证从节点的数量和延迟：</strong>Redis主节点中使用min-slaves-to-write和min-slaves-max-lag参数，来保证主节点在不安全的情况下不会执行写命令；所谓不安全，是指从节点数量太少，或延迟过高。例如min-slaves-to-write和min-slaves-max-lag分别是3和10，含义是如果从节点数量小于3个，或所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。而这里从节点延迟值的获取，就是通过主节点接收到REPLCONF ACK命令的时间来判断的，即前面所说的info Replication中的lag值。</li></ol><p>　　</p><h2 id="开启主从复制"><a href="#开启主从复制" class="headerlink" title="开启主从复制"></a>开启主从复制</h2><p>从节点开启主从复制，有3种方式：</p><ul><li>配置文件：在从服务器的配置文件中加入：<strong>slaveof <masterip> <masterport></masterport></masterip></strong></li><li>启动命令：redis-server启动命令后加入： <strong>–slaveof <masterip> <masterport></masterport></masterip></strong></li><li>客户端命令：Redis服务器启动后，直接通过客户端执行命令：<strong>slaveof <masterip> <masterport></masterport></masterip></strong>，则该Redis实例成为从节点。</li></ul><h3 id="修改配置文件方法："><a href="#修改配置文件方法：" class="headerlink" title="修改配置文件方法："></a>修改配置文件方法：</h3><h4 id="1-配置从服务配置文件redis-conf"><a href="#1-配置从服务配置文件redis-conf" class="headerlink" title="1. 配置从服务配置文件redis.conf"></a>1. 配置从服务配置文件redis.conf</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slaveof 192.168.1.9 6379    #添加属于某台主机的从 服务</span><br><span class="line">masterauth 123456       #从服务连接主服的密码（访问主服务器的密码）</span><br><span class="line">slave-read-only yes     #从服务只读，不可在命令行写入数据</span><br><span class="line"></span><br><span class="line">5.0.4以后：</span><br><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">replica-read-only yes</span><br></pre></td></tr></table></figure><h4 id="2-重新启动从服务即实现主从连接"><a href="#2-重新启动从服务即实现主从连接" class="headerlink" title="2. 重新启动从服务即实现主从连接"></a>2. 重新启动从服务即实现主从连接</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. ./bin/redis-cli# 启动redis客户端</span><br><span class="line">2. 输入 info replication # 查看与复制相关的状态，了解主从节点的当前状态</span><br></pre></td></tr></table></figure><p><strong>输入info replication 后显示的内容：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:slave      # 表示此台服务器是主是从</span><br><span class="line">master_host:39.107.38.62     # 主服务器ip</span><br><span class="line">master_port:6379        # 主服务器端口号</span><br><span class="line">master_link_status:up       # 与主服务器是否连接成功 up为成功 down失败</span><br><span class="line">master_last_io_seconds_ago:9</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:808</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:ea5230cc485f9c6f372b2c89a65613fb075aff8b</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:808</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:15</span><br><span class="line">repl_backlog_histlen:794</span><br></pre></td></tr></table></figure><h4 id="遇到的报错："><a href="#遇到的报错：" class="headerlink" title="遇到的报错："></a>遇到的报错：</h4><h5 id="1-Error-condition-on-socket-for-SYNC-Connection-refused"><a href="#1-Error-condition-on-socket-for-SYNC-Connection-refused" class="headerlink" title="1. Error condition on socket for SYNC: Connection refused"></a>1. Error condition on socket for SYNC: Connection refused</h5><p>  <strong>出现原因</strong>：</p><p>  ​    redis主服务器绑定了127.0.0.1，跨服务器IP的访问就会失败，只能本机才能访问，外部请求会被过滤。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">1. 主服务器绑定ip: bind 39.107.38.62</span><br><span class="line">3. bind 0.0.0.0</span><br><span class="line">2. 注释bind  # 会报下面的错↓</span><br></pre></td></tr></table></figure><h5 id="2-‘-DENIED-Redis-is-running-in-protected-mode-because-protected-mode-is-enabled-no-bind-address-was-specified-no-authentication-password-is-requested-to-clients-In-this-mode-connections-are-only-accepted-from-the-loopback-interface-If-you-want-to-connec"><a href="#2-‘-DENIED-Redis-is-running-in-protected-mode-because-protected-mode-is-enabled-no-bind-address-was-specified-no-authentication-password-is-requested-to-clients-In-this-mode-connections-are-only-accepted-from-the-loopback-interface-If-you-want-to-connec" class="headerlink" title="2. ‘-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connec"></a>2. ‘-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connec</h5><p>   <strong>出现原因</strong>：</p><p>   ​    处于保护模式，只能本地链接。没有绑定ip 没有设置验证密码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">1. 主服务器绑定ip： bind 39.107.38.62</span><br><span class="line">2. 设置主服务器访问密码：requirepass 12345</span><br></pre></td></tr></table></figure><h5 id="3-error-READONLY-You-can’t-write-against-a-read-only-replica"><a href="#3-error-READONLY-You-can’t-write-against-a-read-only-replica" class="headerlink" title="3. (error) READONLY You can’t write against a read only replica."></a>3. (error) READONLY You can’t write against a read only replica.</h5><p>​    <strong>出现原因</strong>：</p><p>​        从库只可读不可写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">1. 设置slave-read-only no # 代表不限于只读</span><br></pre></td></tr></table></figure><h2 id="断开主从复制"><a href="#断开主从复制" class="headerlink" title="断开主从复制"></a>断开主从复制</h2><p>​    通过<strong>slaveof <masterip> <masterport></masterport></masterip></strong>命令建立主从复制关系以后，可以通过slaveof no one断开。</p><p>从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化。</p><hr><h4 id="Redis-哨兵"><a href="#Redis-哨兵" class="headerlink" title="Redis 哨兵"></a>Redis 哨兵</h4><hr><ul><li><p>哨兵的介绍</p><blockquote><p>​        redis 的设计者为了让 redis 能够在主从模式下实现故障恢复的自动化，为此提供了 redis 的哨兵功能。哨兵是一个独立于数据服务器的进程，用于监控 redis 数据服务器的状态，当主从模式下最关键的主服务器出现故障时，能够被哨兵自动的察觉。同时哨兵会在剩余的从服务器中“<strong>选择</strong>”出新的主服务器，达到自动化恢复系统的目的。</p></blockquote></li><li><p>哨兵的使用</p><blockquote><p>​        redis 提供了<strong>redis-setine</strong> 脚本用于部署哨兵，启动时通过指定的哨兵配置文件来对哨兵的行为进行灵活的控制。哨兵的配置文件中至少需要包含被哨兵监控的主服务器<strong>IP</strong>、<strong>端口</strong>、投票决定数目，当然可以配置诸如 <strong>down-after-milliseconds</strong> （发送<strong>ping</strong>命令的时间间隔，用于监听）等选项。</p><p>​        <strong>sentinel monitor</strong> *”master_name” “IP” “PORT”***</p><p>​        <strong>down-after-milliseconds</strong> *”milliseconds”*　(“milliseconds”大于1000时，默认为1000)</p></blockquote></li><li><p><strong>哨兵的工作方式</strong></p><blockquote><p>​        哨兵启动时会与主服务器建立连接，并且间接的获得所属从服务器信息，完成哨兵的初始化。哨兵初始化完成之后，会周期性的和主从服务器、其他哨兵节点（通过消息频道的订阅）进行通信。</p><p>​        哨兵每10秒会向所有服务器发送一次<strong>INFO</strong>命令，获得相关 redis 服务器的当前状态以便决定是否需要故障恢复。</p><p>​        当一个哨兵在<strong>down-after-milliseconds</strong>规定时间内未收到主服务器的响应，则当前哨兵<strong>“主观”</strong>认为主服务器下线，同时和监视当前系统的其它哨兵进行投票决定，当超过当前哨兵配置中投票决定的数目时，则当前哨兵<strong>“客观”</strong>认为主服务器下线，哨兵集群会选举出领导哨兵来进行主从服务器集群主从状态的切换(使用Raft算法)。</p></blockquote></li></ul><h3 id="redis主从复制总结"><a href="#redis主从复制总结" class="headerlink" title="redis主从复制总结"></a>redis主从复制总结</h3><hr><ul><li><h4 id="乐观复制策略"><a href="#乐观复制策略" class="headerlink" title="乐观复制策略"></a>乐观复制策略</h4><blockquote><p>​        redis的主从复制采用的是乐观复制的策略，在一定的时间内允许主从服务器的数据不完全一致，但是保持主从数据库数据的最终一致性(按照<strong>CAP定理</strong>,放弃了<strong>C</strong>(强一致性))。</p><p>　　这意味着redis主从服务器之间的数据复制操作时异步的，主服务器不等待从服务器返回复制的结果，可以立即处理新的写入命令。这一策略使得主服务器的性能在复制时不会受到太大影响，但是从服务器会出现短时间内数据不一致的情况。redis允许用户配置主库的<strong>min-slaves-to-write</strong>(代表至少N台从服务器完成复制，才允许主服务器写入)和<strong>min-slaves-max-lag</strong>(允许从服务器断开连接的时间)这两个配置项来控制分区中数据不一致的影响。</p></blockquote></li><li><h4 id="和集群的区别"><a href="#和集群的区别" class="headerlink" title="和集群的区别"></a>和集群的区别</h4><blockquote><p>redis的主从复制特性为redis带来了很高的读取可用性，但是对于海量数据的持久化存储是力不从心的。因为主从复制结构下，任意的节点都保存了100%的存储数据，所以能够存储的数据规模还是受限于单例服务器存储容量的大小。</p><p>　　为此，在单主多从结构的基础上，redis还提供了集群特性。通过将存储数据合理的分片存储在不同的redis节点上，通过集群水平扩容之后的redis集群拥有了极高的读写可用性和分区容错性。理解redis的主从复制原理是理解更为复杂的集群特性的基础。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-主从复制&quot;&gt;&lt;a href=&quot;#Redis-主从复制&quot; class=&quot;headerlink&quot; title=&quot;Redis 主从复制&quot;&gt;&lt;/a&gt;Redis 主从复制&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;参考链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/leeSmall/p/8398401.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis主从复制和哨兵 参考1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chenhuabin/p/10048854.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis主从复制和哨兵 参考2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/lxx666/articles/10693844.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis主从架构和主从从架构集群搭建详细步骤&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/wade-luffy/p/9639986.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis主从复制原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://doc.redisfans.com/topic/replication.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis复制官方文档翻译&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://cy-blogs.cn/categories/Redis/"/>
    
    
      <category term="Redis 主从复制" scheme="https://cy-blogs.cn/tags/Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Docker 存储</title>
    <link href="https://cy-blogs.cn/docker%E5%AD%98%E5%82%A8/"/>
    <id>https://cy-blogs.cn/docker存储/</id>
    <published>2019-12-16T03:17:54.956Z</published>
    <updated>2019-12-17T11:03:08.457Z</updated>
    
    <content type="html"><![CDATA[<p>#Docker 存储</p><h3 id="Docek-镜像层的镜像分层结构"><a href="#Docek-镜像层的镜像分层结构" class="headerlink" title="Docek 镜像层的镜像分层结构"></a>Docek 镜像层的镜像分层结构</h3><ul><li>docker的镜像分层结构，如下所示：</li></ul><p><img src="https://docs.docker.com/storage/storagedriver/images/container-layers.jpg" alt="基于Ubuntu映像的容器层"></p><ul><li><p>docker镜像中引入层layer概念，镜像的制作过程中的每一步都会生产一个新的镜像层</p></li><li><p>容器读写层的工作原理</p><blockquote><p>我们刚刚在说镜像的分层特性的时候说到镜像是只读的。而事实上当我们使用镜像启动一个容器的时候，我们其实是可以在容器里随意读写的，从结果上看，似乎与镜像的只读特性相悖。</p><p>我们继续看上面的图，其实可以看到在镜像的最上层，还有一个读写层。而这个读写层，即在容器启动时为当前容器单独挂载。每一个容器在运行时，都会基于当前镜像在其最上层挂载一个读写层。而用户针对容器的所有操作都在读写层中完成。一旦容器销毁，这个读写层也随之销毁。</p><blockquote><p>知识点： 容器=镜像+读写层</p></blockquote><p>而我们针对这个读写层的操作，主要基于两种方式：写时复制和用时分配。</p></blockquote></li></ul><a id="more"></a><hr><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p><img src="https://docs.docker.com/storage/storagedriver/images/sharing-layers.jpg" alt="容器共享相同的图像"></p><ul><li><p>容器由最上面一个可写的容器层和若干个只读的镜像层组成，容器的数据就存在这些层中。这种分层结构最大的特点是Copy-on-Write。</p><ol><li><p>新数据会直接存放在最上面的容器层</p></li><li><p>修改现有数据会从镜像层复制文件到容器中，再在容器层修改并保存，镜像层的数据不会发生改变</p></li><li><p>若多个层中有命名相同的文件，用户只能看到最上面一层的文件</p></li></ol></li></ul><ul><li>分层结构使镜像和容器的创建、共享以及分发变得非常高效，而这些都要归功于 Docerk stoage driver。<strong>正是 storage driver 实现了多层数据的堆叠并为用户提供一个单一的合并之后的统一视图</strong>。</li></ul><hr><h3 id="Docker-为容器提供了两种存放数据的资源："><a href="#Docker-为容器提供了两种存放数据的资源：" class="headerlink" title="Docker 为容器提供了两种存放数据的资源："></a>Docker 为容器提供了两种存放数据的资源：</h3><ul><li>由storage driver（存储驱动） 管理的镜像层和容器层<ul><li>用来放一些无状态的数据<ul><li><strong>对于某些容器，直接将数据放在由</strong> storage driver <strong>维护的层中是很好的选择，比如那些无状态的应用。无状态意味着容器没有需要持久化的数据，随时可以从镜像直接创建。即存在与否依赖镜像的存在。</strong></li></ul></li></ul></li><li>Data Volume。（数据卷）<ul><li>用来放一些有状态的数据，例如数据库<ul><li><strong>本质上是</strong> Docker Host （主机）<strong>文件系统中的目录或文件，能够直接被 ** mount （挂载）</strong>到容器的文件系统中**。</li></ul></li></ul></li></ul><h4 id="关于docker镜像的三问"><a href="#关于docker镜像的三问" class="headerlink" title="关于docker镜像的三问"></a>关于docker镜像的三问</h4><ul><li>基于镜像A创建镜像B时是否会拷贝A镜像中的所有文件：<code>是不会的</code></li><li>基于镜像创建容器时是否会拷贝镜像中的所有文件至文件层：<code>不会的</code></li><li>容器与镜像在结构上有什么区别：<code>没有区别容器会比镜像多了一个</code> <code>merged</code>文件</li></ul><blockquote><p>在讲原理前，先讲下写时复制和写时分配</p></blockquote><h4 id="写时复制（CoW）"><a href="#写时复制（CoW）" class="headerlink" title="写时复制（CoW）"></a>写时复制（CoW）</h4><blockquote><p>所有驱动都用到的技术——写时复制（CoW）。CoW就是copy-on-write，表示只在需要写时才去复制，这个是针对已有文件的修改场景比如基于一个image启动多个Container，如果为每个Container都去分配一个image一样的文件系统，那么将会占用大量的磁盘空间。而CoW技术可以让所有的容器共享image的文件系统，所有数据都从image中读取，只有当要对文件进行写操作时，才从image里把要写的文件复制到自己的文件系统进行修改。所以无论多少个容器共享同一个image，所作的写操作都是从image中复制到自己的文件系统中的复制本上进行，并不会修改image的源文件，且多个容器操作同一个文件，会在每个容器的文件系统里生成一个复本，每个容器修改的都是自己的复本，相互隔离的，相互不影响。使用CoW可以有效的提高磁盘的利用率。</p></blockquote><h4 id="用时分配（allocate-on-demand）"><a href="#用时分配（allocate-on-demand）" class="headerlink" title="用时分配（allocate-on-demand）"></a>用时分配（allocate-on-demand）</h4><blockquote><p>而用时分配是用在原本没有这个文件的场景，只有在要新写入一个文件时才分配空间，这样可以提高存储资源的利用率。比如启动一个容器，并不会为这个容器预分配一些磁盘空间，而是当有新文件写入时，才按需分配新空间。</p></blockquote><h4 id="Docker存储驱动的作用"><a href="#Docker存储驱动的作用" class="headerlink" title="Docker存储驱动的作用"></a>Docker存储驱动的作用</h4><blockquote><p>将这些分层的镜像文件堆叠起来，并且提供统一的视图.使container的文件系统看上去和我们普通的文件系统没什么区别。<br>当创建一个新的容器的时候,实际上是在镜像的分层上新添加了一层container layer（容器层）.之后所有对容器产生的修改,实际都只影响这一层。</p><p>注意</p><p>容器层：读写层(可写层)<br>镜像层：只读层</p></blockquote><blockquote><p> Docker 支持多种 storage driver，有 AUFS 、Device Mapper 、Btrfs 、OverlayFS 、VFS 和ZFS。它们都能实现分层的架构，同时又有各自的特性。对于Docker 用户来说，具体选择使用哪个 storage driver 是一个难题，因为：</p></blockquote><p>​            没有哪个driver 能够适应所有的场景。</p><p>​            driver 本身在快速发展和迭代。</p><blockquote><p>优先使用 Linux 发行版默认的 storage driver。Docker 安装时会根据当前系统的配置选择默认的 driver。默认 driver 具有最好的稳定性，因为默认 driver 在发行版上经过了严格的测试。</p></blockquote><blockquote><p>运行<code>docker info</code>可以查看可查看当前系统使用的<code>Storage driver</code>。</p><blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; [root@izbp1dg6m4eebtcm77n0smz ~]# docker info</span><br><span class="line">&gt; &gt; Client:</span><br><span class="line">&gt; &gt; <span class="builtin-name">Debug</span> Mode: <span class="literal">false</span></span><br><span class="line">&gt; &gt; </span><br><span class="line">&gt; &gt; Server:</span><br><span class="line">&gt; &gt; Containers: 6</span><br><span class="line">&gt; &gt; Running: 4</span><br><span class="line">&gt; &gt; Paused: 0</span><br><span class="line">&gt; &gt; Stopped: 2</span><br><span class="line">&gt; &gt; Images: 4</span><br><span class="line">&gt; &gt;<span class="built_in"> Server </span>Version: 19.03.5</span><br><span class="line">&gt; &gt; Storage Driver: overlay2</span><br><span class="line">&gt; &gt; Backing Filesystem: extfs</span><br><span class="line">&gt; &gt; Supports d_type: <span class="literal">true</span></span><br><span class="line">&gt; &gt; Native Overlay Diff: <span class="literal">false</span></span><br><span class="line">&gt; &gt;<span class="built_in"> Logging </span>Driver: json-file</span><br><span class="line">&gt; &gt; Cgroup Driver: cgroupfs</span><br><span class="line">&gt; &gt;</span><br></pre></td></tr></table></figure></blockquote></blockquote><blockquote></blockquote><hr><blockquote><p>Ubuntu 用的 <code>AUFS</code>，底层文件系统是 <code>extfs</code>，各层数据存放在 <code>/var/lib/docker/aufs</code>。<br>centos默认的<code>driver</code>用的是<code>overlay2</code>，底层的文件系统是xfs,各层数据存放在<code>/var/lib/docker</code></p></blockquote><blockquote><p>而写时分配是用在原本没有这个文件的场景，只有在要新写入一个文件时才分配空间，这样可以提高存储资源的利用率。</p><p>比如启动一个容器，并不是为这个容器预分配一些磁盘空间，而是当有新文件写入时，才按需分配新空间。</p></blockquote><ul><li>docker提供了多种的存储驱动来实现不同的方式存储镜像</li></ul><h5 id="Docker五种存储驱动原理及应用场景和性能测试对比"><a href="#Docker五种存储驱动原理及应用场景和性能测试对比" class="headerlink" title="Docker五种存储驱动原理及应用场景和性能测试对比"></a>Docker五种存储驱动原理及应用场景和性能测试对比</h5><blockquote><p><code>Docker</code> 最开始采用AUFS作为文件系统，也得益于AUFS分层的概念，实现了多个Container可以共享同一个image。但由于<code>AUFS</code> 为并入 <code>Linux</code>内核，且只支持 <code>Ubuntu</code>，考虑到兼容的问题，在 <code>Docker 0.7</code> 版本中引入了存储驱动，就如Docker官网上说的，没有单一的驱动适应所有的应用场景，要根据不同的场景选择合适的存储驱动，才能有效的提高Docker 的性能。如何选择适合的存储驱动，要先了解存储驱动原理才能更好的判断。</p></blockquote><blockquote><p>接下来我们说说这些分层的镜像是如何在磁盘中存储的。</p></blockquote><ul><li><p><code>docker</code> 提供了多种存储驱动来实现不同的方式存储镜像</p><ul><li><p>下列出了 <code>Docker</code> 中支持的存储驱动程序：</p><table><thead><tr><th align="center">技术</th><th align="center">存储驱动成名称</th></tr></thead><tbody><tr><td align="center"><code>OverlayFS</code></td><td align="center"><code>overlay</code> 或  <code>overlay2</code></td></tr><tr><td align="center"><code>AUFS</code></td><td align="center"><code>aufs</code></td></tr><tr><td align="center"><code>Btrfs</code></td><td align="center"><code>btrfs</code></td></tr><tr><td align="center"><code>Device Mapper</code></td><td align="center"><code>devicemapper</code></td></tr><tr><td align="center"><code>VFS</code></td><td align="center"><code>vfs</code></td></tr><tr><td align="center"><code>ZFS</code></td><td align="center"><code>zfs</code></td></tr></tbody></table></li></ul></li></ul><h5 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h5><blockquote><p>AUFS（AnotherUnionFS）是一种 Union FS ，是文件级的存储驱动。AUFS 是一个能透明覆盖一个或多个县有文件系统的层状文件系统，把多层合并成文件系统的单层表示。简单来说就是支持将不同目录挂载到同一个虚拟文件系统下的文件系统。这种文件可以一层一层地叠加修改文件。无论低下有多少层都是只读的，只有最上层的文件系统是可写的。当需要修改文件时，AUFS创建该文件的一个副本，使用CoW将文件从只读层复制到可写层进行修改，结果保存在可写层。在Docker中，低下的只读层就是image，可写层就是Container。结构如下图所示：</p></blockquote><p>  <a href="http://dockone.io/uploads/article/20190702/87af417e9f80a3eb8ae9716ae07b3dc1.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/87af417e9f80a3eb8ae9716ae07b3dc1.jpg" alt="1.jpg"></a></p><blockquote><p><strong>历史</strong>：aufs驱动老早就在Docker中存在了！其实，他在使用<code>graphdriver</code>这个名字之前久存在了。如果你查看项目在那（即首次使用graphdriver名称）提交之前的历史，之前项目中当时只有一个aufs的实现。下边devicemapper部分会讲到更多关于graphdriver这个名称诞生的历史。</p><p><strong>实现</strong>：Aufs最初代表的意思“另一个联合文件系统（another union filesystem）”，试图对当时已经存在的UnionFS实现进行重写。正如你期望的那样，它是一个传统意义的上层覆盖，通过利用aufs称作为“分支（branch）”的特性，让堆叠的目录合并成一个堆叠内容单一挂载点视图。此驱动会将父级信息组合一个有序列表，并把它作为挂载参数，然后把重活移交给aufs来把这些分层组装成一个联合视图。更多的细节信息可以在aufs的<a href="http://aufs.sourceforge.net/aufs3/man.html" target="_blank" rel="noopener">帮助文档</a>上看到。</p><p><strong>优点</strong>：这可能是历史最久且测试最完善的graphdriver后端了。它拥有不错的性能，也比较稳定，适用于广泛的场景。尽管它只在Ubuntu或者Debian的内核上才可以启用（下边有说明），但是这两个发行版和Docker一起使用的场景已经非常多，这让它在广阔的环境中得到了验证。同时，通过让不同的容器从同一个分层里面加载相同的库（因为他们在磁盘上是相同的inode）达到了共享内存页的效果。</p><p><strong>缺点</strong>：Aufs从来没有被上游Linux内核社区接受。多年来Ubuntu和Debian都需要往内核集成一个历史久远的补丁包，且原作者已经放弃了让它被内核采纳的努力。可能与IPV4和IPv6的辩论有些类似，人们担心某一天内核更新后会出现难以整合aufs的补丁的情况，从而导致aufs没得玩。但是就如IPv6，替换aufs势在必行的决心讲了一年又一年。除此之外，它面临着很多其他比较棘手的问题。其中一个最麻烦的、也是比较有历史的问题（尽管某种程度上这是一个安全的特性），是关于在高层更改向上拷贝的文件的权限的，这个问题困扰了不少用户。最终在2015年早期的时候通过编号为<a href="http://dockone.io/docker/docker#11799" target="_blank" rel="noopener">#11799</a>的PR使用aufs的<code>dirperm1</code>特性修复了。自然，这需要内核中有具有<code>dirperm1</code>能力aufs，然而这在今天任何较新版本的Ubuntu或者Debian上都已经不成问题了。</p><p><strong>总结</strong>：如果你在使用Ubtuntu或者Debian，那默认的graphdriver就是aufs，它能满足你绝大多数需求。有人期望有一天它能被overlay的实现取代，但是考虑到overlay文件系统的诸多问题，以及在上游内核中的成熟程度等挑战，这尚未实现。最后，aufs中没有配额的支持。</p></blockquote><h5 id="Overlay"><a href="#Overlay" class="headerlink" title="Overlay"></a>Overlay</h5><blockquote><p>Overlay 是Linux内核3.18后支持的，也是一种Union FS，和AUFS的多层不同的是Overlay只有两层：一个upper文件系统和一个lower文件系统，分别代表Docekr的镜像层和容器层。当需要修改一个文件时，使用CoW将文件从只读的lower复制到可写的upper进行修改，结果也保存在upper层。在Docekr中，底下的只读层就是image，可写层就是Container。目前最新的OverlayFS为Overlay2。结构图如下所示：</p></blockquote><p>  <a href="http://dockone.io/uploads/article/20190702/c12e244abea02f7ed1eb42f0ccdbcf1d.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/c12e244abea02f7ed1eb42f0ccdbcf1d.jpg" alt="2.jpg"></a></p><blockquote><p><strong>历史</strong>：<strong>2014年8月</strong>，Red Hat的 Alex Larsson在编号为<a href="https://github.com/docker/docker/commit/453552c8384929d8ae04dcf1c6954435c0111da0" target="_blank" rel="noopener">453552c8384929d8ae04dcf1c6954435c0111da0</a>的代码提交中添加了针对OverlayFS（最初的上游内核的名称）的graphdriver。</p><p><strong>实现</strong>：Overlay是一个联合文件系统，它的概念较之aufs的分支模型更为简单。Overlay通过三个概念来实现它的文件系统：一个“下层目录（lower-dir）”，一个“上层目录（upper-dir）”，和一个做为文件系统合并视图的“合并（merged）”目录。受限于只有一个“下层目录”，需要额外的工作来让“下层目录”递归嵌套（下层目录自己又是另外一个overlay的联合），或者按照Docker的实现，将所有位于下层的内容都硬链接到“下层目录”中。正是这种可能潜在的inode爆炸式增长（因为有大量的分层和硬连接）阻碍了很多人采用Overlay。Overlay2通过利用更高内核（4.0以及以上的版本）中提供了的更优雅处理多个位于下层分层的机制解决了这个问题。</p><p><strong>优点</strong>：Overlay作为一个合并进主线Linux内核的一个有完整支持的联合文件系统有望成为人们的焦点。与aufs类似，通过使用磁盘上相同的共享库，它也能让分散的容器实现内存共享。Overlay同时有很多的上游Linux内核基于现代的应用场景，如Docker，被持续开发（参看overlay2）。</p><p><strong>缺点</strong>：硬链接的实现方式已经引发了 <a href="http://dockone.io/docker/docker#10613" target="_blank" rel="noopener">inode耗尽</a>的问题，这阻碍了它的大规模采用。inode耗尽并不是唯一的问题，还有其他一些与用户命名空间、SELinux支持有关的问题，且整体的成熟状况不足也阻碍着overlay直接取代aufs成为Docker默认的graphdriver。随着很多问题的解决，特别是在最新的内核发新版中，overlay的可用度越来越高了。如今出现的Overlay2修复了inode耗尽的问题，应该是从Docker 1.12版本之后的焦点，成为overlay驱动的后续开发对象。出于向后兼容的原因，<code>overlay</code>驱动将会继续留在Docker引擎中继续支持现有的用户。</p><p><strong>总结</strong>：考虑到aufs没有足够多的发行版的支持，能有一个上游集成的联合文件系统且拥有Linux内核文件系统社区的支持，overlay驱动的加入是一个重大进步。Overlay在过去的18-24个月已经成熟了很多，并且随着overlay2的出现，它之前一些麻烦的问题已经解决了。希望overlay（或者更具可能性的overlay2）会成为未来默认的graphdriver。为了overlay最好的体验，上游内核社区在4.4.x的内核系列里面修复了很多overlay实现中存在的问题；选择该系列中更新的版本可以获得overlay更好的性能和稳定性。</p></blockquote><h5 id="Overlay2"><a href="#Overlay2" class="headerlink" title="Overlay2"></a>Overlay2</h5><blockquote><p><strong>历史</strong>：<a href="https://github.com/dmcgowan" target="_blank" rel="noopener">Derek McGowan</a>在编号为<a href="https://github.com/docker/docker/pull/22126" target="_blank" rel="noopener">#22126</a>的PR中添加了overlay2的graphdriver，在<strong>2016年6月</strong>被合并进Docker 1.12版本，正如该PR的标题注明的，要取代之前overlay的主要原因是它能“支持多个下层目录”，能解决原先驱动中inode耗尽的问题。</p><p><strong>实现</strong>：在上面的overlay部分已经讲述了Linux内核中的Overlay的框架。上面链接的PR中改进了原有的设计，基于Linux内核4.0和以后版本中overlay的特性，可以允许有多个下层的目录。</p><p><strong>优点</strong>：overlay2解决了一些因为最初驱动的设计而引发的inode耗尽和一些其他问题。Overlay2继续保留overlay已有的优点，包括在同一个引擎的多个容器间从同一个分层中加载内库从而达到内存共享。</p><p><strong>缺点</strong>：现在可能唯一能挑出overlay2的问题是代码库还比较年轻。很多早期的问题已经在早期测试过程中发现并被及时解决了。但是Docker 1.12是第一个提供overlay2的发行版本，随着使用量的增长，相信可能还会发现其他问题。</p><p><strong>总结</strong>：将Linux内核中的一个现代的、广受支持的联合文件系统，和一个和Docker中一个性能优秀的graphdriver结合起来，这应该是Docker引擎未来打造默认的graphdriver最好的道路，只有这样才能获得各种Linux发行版广泛的支持。</p></blockquote><h5 id="Device-mapper"><a href="#Device-mapper" class="headerlink" title="Device mapper"></a>Device mapper</h5><blockquote><p>Device mapper 是Linux 内核 2.6.9 后支持的，提供的一种从逻辑设备到物理设备的映射框架机制，在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略。前面讲的 AUFS 和 OverlayFS 都是文件级存储，而 Device mapper 是块级存储，所有的操作都是直接对块进行操作，而不是文件。Device mapper 驱动会先在块设备上创建一个资源池，然后在资源池上创建一个带有文件系统的基本设备，所有镜像都是这个基本设备的快照，而容器则是镜像的快照。所以在容器里看到文件系统是资源池上基本设备的文件系统的快照，并不有为容器分配空间。当要写入一个新文件时，在容器的镜像内为其分配新的块并写入数据，这个用时分配。当要修改已有文件时，再使用 CoW 为容器快照分配块空间，将要修改的数据复制在容器快照中新的块里在进行修改。Device mapper 驱动默认会创建一个 100 G 的文件包含镜像和容器。每个容器被限制在 10G 大小的卷内，可以自己设置调整。结构如下图所示：</p></blockquote><p>  <a href="http://dockone.io/uploads/article/20190702/0ef920a30190955999076f524229f321.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/0ef920a30190955999076f524229f321.jpg" alt="3.jpg"></a></p><blockquote><p> <strong>历史</strong>：Devicemapper很早就以Ｃ代码的包装器面貌存在了，用来和libdevmapper进行交互； 是2013的９月Alex Larsson在编号为<a href="https://github.com/docker/docker/commit/739af0a17f6a5a9956bbc9fd1e81e4d40bff8167" target="_blank" rel="noopener"> 739af0a17f6a5a9956bbc9fd1e81e4d40bff8167</a>的代码提交中添加的。几个月后的重构了才诞生了我们现在所知道的“graphdriver”这个词；Solomon Hykes在2013年10月份早期代码合并的注释中说：将devmapper和aufs整合进通用的“graphdriver”框架。</p><p>  <strong>实现</strong>：devicemapper这个graphdriver利用了Linux中devicemapper代码中众多特性之一，“轻配置（thin provisioning）”，或者简称为“thinp”。<em>（译注：根据Wikipedia，“thin provisioning是利用虚拟化技术，让人觉得有比实际可用更多的物理资源。如果系统的资源足够，能同时满足所有的虚拟化的资源，那就不能叫做thin-provisioned。”）</em> 这与之前提到的联合文件系统不同，因为devicemapper是基于块设备的。这些“轻配置（thin-provisioned）”的块设备带来的是如联合文件系统所提供的一样轻量的行为，但是最重要的一点是，他们不是基于文件的（而是基于块设备的）。正如你能推测的，这让计算分层之间的差别变得不再容易，也丧失了通过在容器间使用同样的库片段而共享内存的能力。</p><p>  <strong>优点</strong>：Devicemapper在过去的年间也被一些人感到不屑，但是它提供的一个非常重要的能力让红帽系（Fedora,RHEL，Project Atomic）也有了一个graphdriver。因为它是基于块设备而不是基于文件的，它有一些内置的能力如配额支持，而这在其他的实现中是不容易达到的。</p><p>  <strong>缺点</strong>：使用devicemapper没有办法达到开箱立即唾手可得很好的性能。你必须遵循<a href="https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/#/configure-direct-lvm-mode-for-production" target="_blank" rel="noopener">安装和配置指示</a>才能得到性能还可以的配置。并且最重要的是，在任何需要用Docke引擎来做点正事的地方，都不要使用“虚拟设备（loopback）”模式（对于运行有devicemapper且负载高的系统，如延迟删除（ deferred removal）这样的特性绝对有必要的，这能减少引擎看起来好似夯住了一样的悲剧。）。它的一些特性依赖libdevmaper特定的版本，并且需要比较高级的技能来验证系统上所有的设置。同时，如果Docker Engine的二进制是静态编译的话，devicemapper会完全无法工作，因为它需要<a href="http://dockone.io/docker/docker#11412" target="_blank" rel="noopener">udev sync</a>的支持，而这不能被静态编译进引擎中。</p><p>  <strong>总结</strong>：对于红帽类发行版本来说，devicemapper已经成为“可以直接用”的选择，并且在过去几年间里得到了红帽团队的大力支持和改进。它质量上有优点也有缺点，如果安装/配置过程中没有特别格外注意的话，可能导致和其他选项比较起来性能低下、质量不高。鉴于overlay和overlay2受到了Fedora和RHEL最新的内核的支持，并且拥有SELinux的支持，除非在Red Hat场景中有某种必须使用devicemapper的需求，我想随着用户的成熟他们会转向overlay的怀抱。</p></blockquote><h5 id="Btrfs"><a href="#Btrfs" class="headerlink" title="Btrfs"></a>Btrfs</h5><blockquote><p>Btrfs 被称为下一代写时复制文件系统，并入Linux内核，也是文件级存储，但可以向 Device mapper 一直操作底层设备。 Btrfs 把文件系统的一部分配置为一个完整的子文件系统，称为 subvolume。那么采用 subvolume ，一个大的文件系统可以被划分为很多个子文件系统，这些子文件系统共享底层的设备空间，在需要磁盘空间使用时便从底层设备中分配，类似应用程序调用 malloc（）分配内存一样。为了灵活利用设备空间， Btrfs 将磁盘空间划分为多个 chunk。每个 chunk 可以使用不同的磁盘空间分配策略。比如某些 chunk 只存放 metadata ，某些chunk 只存放数据。这种模型有很多优点，比如 Btrfs 支持动态添加设备。用户在系统中添加新的磁盘之后，可以使用 Btrfs 的命令将该设备添加到文件系统中。Btrfs 把一个大的文件系统当成一个资源池，配置成多个完整的子文件系统，还可以往资源池里加新的子文件系统，而基础镜像则是子文件系统的快照，每个子镜像和容器都有自己的快照，这些快照都是 subvolume 的快照。</p></blockquote><p>   <a href="http://dockone.io/uploads/article/20190702/99ab3acda52806a948625219d9e96a0b.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/99ab3acda52806a948625219d9e96a0b.jpg" alt="4.jpg"></a></p><blockquote><p>当写入一个新文件时，为在容器的快照里为其分配一个新的数据块，文件写在这个空间里，这个叫做分配。而当要修改已有文件时，使用 CoW 复制分配一个新的原始数据和快照，在这个新分配的空间变更数据，变结束再跟新相关的数据结构指向新子文件系统和快照，原来的原始数据和快照没有指针指向，被覆盖。</p></blockquote><blockquote><p><strong>历史</strong>：<strong>2013年12月</strong>较晚的时候，Red Hat公司的Alex Larsson在编号为<a href="https://github.com/docker/docker/commit/e51af36a85126aca6bf6da5291eaf960fd82aa56" target="_blank" rel="noopener">e51af36a85126aca6bf6da5291eaf960fd82aa56</a>的提交中，让使用btrfs作为管理<code>/var/lib/docker</code>的文件系统成为可能。</p><p><strong>实现</strong>：Btrfs的原生特性中，有两个是“子卷（subvolumes）”和“快照（snapshots）”。<em>（译注：根据Wikipedia，“子卷在btrfs中不是一个块设备，也不应该被当做是一个块设备。相反，子卷可以被想象成POSIX文件的命名空间。这个命名空间可以通过顶层的子卷来访问到，也可以独立地被挂载。快照在Btrfs中实际上是一个子卷，通过使用Btrfs的写时复制来和其他的子卷共享数据，对快照的更改不会影响原先的子卷。” ）</em> graphdriver实现中主要结合了这两个能力，从而提供了堆叠和类似写时复制的特性。当然，graphdriver的根（默认情况下是：<code>/var/lib/docker</code>）需要是一个被btrfs文件系统格式化的磁盘。</p><p><strong>优点</strong>：Btrfs几年前发布的时候（2007-2009时代），它被视作一个未来的Linux文件系统并<a href="https://lwn.net/Articles/342892/" target="_blank" rel="noopener">受到了大量的关注</a>。如今在上游Linux内核中，该文件系统已经比较健壮，并受到良好的支持，是众多可选的文件系统之一。</p><p><strong>缺点</strong>：但是Btrfs并没有成为Linux发行版的主流选择，所以你不大可能已经有一个btrfs格式化的磁盘。因为这种在Linux发行版中采用不足的原因，它并没有受到类似其他graphdriver一样的关注和采用。</p><p><strong>总结</strong>：如果你正在使用btrfs，那很显然的这个graphdriver应该迎合了你的需求。在过去几年有过很多Bug，并且有一段时间缺乏对SELinux的支持，但是这已经<a href="http://dockone.io/docker/docker#16452" target="_blank" rel="noopener">被修复</a>了。同时，对btrfs配额的支持也直接加进了docker守护进程中，这是<a href="https://github.com/zhuguihua" target="_blank" rel="noopener">Zhu Guihua</a>在编号为<a href="http://dockone.io/docker/docker#19651" target="_blank" rel="noopener">#19651</a>的PR中添加的，这个特性包含在了Docker 1.12版本中。</p></blockquote><h5 id="ZFS"><a href="#ZFS" class="headerlink" title="ZFS"></a>ZFS</h5><blockquote><p>ZFS 文件系统是一个革命性的全新的文件系统，它从根本上改变了文件系统的管理方式， ZFS 完全抛弃了 “ 卷管理 ” ，不再创建虚拟的卷，而是把所有设备集中到一个存储池中进行管理，用 “ 存储池 ”  的概念来管理物理存储空间。过去，文件系统都是构建在物理设备之上的，为了管理这些物理设备，并为数据提供冗余，“ 卷管理 ” 的概念提供了一个单设备的映射。而 ZFS 创建在虚拟的，被称为 “ zpools ” 的存储池之上。每个存储池由若干虚拟设备（ virtual devices ，vdevs ）组成。这些虚拟设备可以是原始磁盘，也节能是一个RAID1 镜像设备，或是非标准 RAID 等级的多磁盘组。  于是 zpool 上的文件系统可以使用这些虚拟设备的总存储容量。</p></blockquote><p>  <a href="http://dockone.io/uploads/article/20190702/d6daba2b7adfe96daca62f9ed90bf0c4.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/d6daba2b7adfe96daca62f9ed90bf0c4.jpg" alt="5.jpg"></a></p><blockquote><p>下面看一下Docker 里ZFS的使用。首先从 zpool里分配一个ZFS 文件系统给镜像的基础层，而其他镜像层则是这个 ZFS 文件系统快照的克隆，快照是只读的，而克隆是可写的，当容器启动时则在镜像的顶层生成一个可写层。如下图所示：</p></blockquote><p>  <a href="http://dockone.io/uploads/article/20190702/34cc4c9ea6c96b6f83dabb961ed8950e.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/34cc4c9ea6c96b6f83dabb961ed8950e.jpg" alt="6.jpg"></a></p><blockquote><p>d当要写一个新文件时，使用按需分配，一个新的数据块从 zpool 里生成新的数据写入这个块，而这个新空间存于容器（ ZFS 的克隆 ）里。</p><p>当要修改一个已存在的文件时，使用写时复制，分配一个新空间并把原始数据复制到新空间完成修改。</p></blockquote><blockquote><p><strong>历史</strong>：ZFS的graphdriver是由Arthur Gautier和Jörg Thalheim一起在<a href="http://dockone.io/docker/docker#9411" target="_blank" rel="noopener">#9411</a>的PR中实现的，在<strong>2014年的5月</strong>被合并进了Docker引擎里面，并且从Docker 1.7版本开始用户可以使用。该实现依赖Go的一个三方包<a href="https://github.com/mistifyio/go-zfs" target="_blank" rel="noopener">go-zfs</a>进行相关zfs命令的交互。</p><p><strong>实现</strong>：与btrfs和devicemapper类似，要使用zfs驱动必需要有一个ZFS格式化的块设备挂载到graphdriver路径（默认是/var/lib/docker）。同时也需要安装好zfs工具（在绝大多数的发行版上是一个名为zfs-utils的包）供zfs Go库调用来执行相关操作。ZFS有能力创建快照（与btrfs类似），然后以快照的克隆作为分享层的途径（在ZFS的实现中成了一个快照）。因为ZFS不是一个基于文件的实现，aufs和overlay中所拥有的内存共享能力在ZFS是没有的。</p><p><strong>优点</strong>：ZFS正在受到越来越多的欢迎，在Ubuntu 16.04中，在Ubuntu的LXC/LXD中已经被使用。最初由Sun创建，ZFS已经存在很长的时间了，并且在Solaris和很多BSD的衍生版中使用，并且它的Linux移植版实现看起来也比较稳定，对于容器文件系统的场景也有足够合理性能。<code>ZFS</code>graphdriver也很及时的在Dockr 1.12中通过PR <a href="http://dockone.io/docker/docker#21946" target="_blank" rel="noopener">#21946</a>添加了配额的支持，这让它在配额支持方面和btrfs、devicemapper站在了同一起跑线上。</p><p><strong>缺点</strong>：除了没有基于文件（inode）的共享达到内库共享之外，很难说ZFS和其它同样基于块设备的实现相比有什么缺点。通过比较，ZFS看起来欢迎程度越来越高。对于那些完全支持或者正在使用ZFS的Linux发行版或者UNIX衍生版而言，zfs graphdriver可以是一个非常好的选择。</p><p><strong>总结</strong>：ZFS的支持为Docker引擎中稳定的graphdriver加了分。对于那些ZFS的使用者，或者那些ZFS扮演了更要角色的发行版来说，Docker能直接支持该文件系统，对这些社区来说是一个好消息。对于那些默认文件系统是ext4和xfs的发行版，默认采用overlay驱动的用户来说，时间会告诉我们他们是否会对zfs驱动产生更多的兴趣。</p></blockquote><h4 id="存储驱动的对比及适应场景"><a href="#存储驱动的对比及适应场景" class="headerlink" title="存储驱动的对比及适应场景"></a>存储驱动的对比及适应场景</h4><table><thead><tr><th><strong>存储驱动</strong></th><th><strong>特点</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td>AUFS</td><td>联合文件系统、未并入内核主线、文件级存储</td><td>作为docker的第一个存储驱动，已经有很长的历史，比较稳定，且在大量的生产中实践过，有较强的社区支持</td><td>有多层，在做写时复制操作时，如果文件比较大且存在比较低的层，可能会慢一些</td><td>大并发但少IO的场景</td></tr><tr><td>overlayFS</td><td>联合文件系统、并入内核主线、文件级存储</td><td>只有两层</td><td>不管修改的内容大小都会复制整个文件，对大文件进行修改显示要比小文件消耗更多的时间</td><td>大并发但少IO的场景</td></tr><tr><td>Devicemapper</td><td>并入内核主线、块级存储</td><td>块级无论是大文件还是小文件都只复制需要修改的块，并不是整个文件</td><td>不支持共享存储，当有多个容器读同一个文件时，需要生成多个复本，在很多容器启停的情况下可能会导致磁盘溢出</td><td>适合io密集的场景</td></tr><tr><td>Btrfs</td><td>并入linux内核、文件级存储</td><td>可以像devicemapper一样直接操作底层设备，支持动态添加设备</td><td>不支持共享存储，当有多个容器读同一个文件时，需要生成多个复本</td><td>不适合在高密度容器的paas平台上使用</td></tr><tr><td>ZFS</td><td>把所有设备集中到一个存储池中来进行管理</td><td>支持多个容器共享一个缓存块，适合内存大的环境</td><td>COW使用碎片化问题更加严重，文件在硬盘上的物理地址会变的不再连续，顺序读会变的性能比较差</td><td>适合paas和高密度的场景</td></tr></tbody></table><p><a href="http://dockone.io/uploads/article/20190702/747be895d53add6ea9ddf868f95ff8ec.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/747be895d53add6ea9ddf868f95ff8ec.jpg" alt="7.jpg"></a></p><h5 id="AUFS-VS-Overlay"><a href="#AUFS-VS-Overlay" class="headerlink" title="AUFS VS  Overlay"></a>AUFS VS  Overlay</h5><blockquote><p>AUFS和Overlay都是联合文件系统，但AUFS有多层，而Overlay只有两层，所以在做写时复制操作时，如果文件比较大且存在比较低的层，则AUSF可能会慢一些。而且Overlay并入了linux kernel mainline，AUFS没有，所以可能会比AUFS快。但Overlay还太年轻，要谨慎在生产使用。而AUFS做为docker的第一个存储驱动，已经有很长的历史，比较的稳定，且在大量的生产中实践过，有较强的社区支持。目前开源的DC/OS指定使用Overlay。</p></blockquote><h5 id="Overlay-VS-Device-mapper"><a href="#Overlay-VS-Device-mapper" class="headerlink" title="Overlay VS Device mapper"></a>Overlay VS Device mapper</h5><blockquote><p>Overlay是文件级存储，Device mapper是块级存储，当文件特别大而修改的内容很小，Overlay不管修改的内容大小都会复制整个文件，对大文件进行修改显示要比小文件要消耗更多的时间，而块级无论是大文件还是小文件都只复制需要修改的块，并不是整个文件，在这种场景下，显然device mapper要快一些。因为块级的是直接访问逻辑盘，适合IO密集的场景。而对于程序内部复杂，大并发但少IO的场景，Overlay的性能相对要强一些。</p></blockquote><h5 id="Device-mapper-VS-Btrfs-Driver-VS-ZFS"><a href="#Device-mapper-VS-Btrfs-Driver-VS-ZFS" class="headerlink" title="Device mapper VS Btrfs Driver VS ZFS"></a>Device mapper VS Btrfs Driver VS ZFS</h5><blockquote><p>Device mapper和Btrfs都是直接对块操作，都不支持共享存储，表示当有多个容器读同一个文件时，需要生活多个复本，所以这种存储驱动不适合在高密度容器的PaaS平台上使用。而且在很多容器启停的情况下可能会导致磁盘溢出，造成主机不能工作。Device mapper不建议在生产使用。Btrfs在docker build可以很高效。<br>ZFS最初是为拥有大量内存的Salaris服务器设计的，所在在使用时对内存会有影响，适合内存大的环境。ZFS的COW使碎片化问题更加严重，对于顺序写生成的大文件，如果以后随机的对其中的一部分进行了更改，那么这个文件在硬盘上的物理地址就变得不再连续，未来的顺序读会变得性能比较差。ZFS支持多个容器共享一个缓存块，适合PaaS和高密度的用户场景。</p></blockquote><h4 id="IO性能对比"><a href="#IO性能对比" class="headerlink" title="IO性能对比"></a>IO性能对比</h4><blockquote><p>测试工具：IOzone（是一个文件系统的benchmark工具，可以测试不同的操作系统中文件系统的读写性能）<br>测试场景：从4K到1G文件的顺序和随机IO性能<br>测试方法：基于不同的存储驱动启动容器，在容器内安装IOzone，执行命令：</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./iozone -<span class="selector-tag">a</span> -n <span class="number">4</span>k -g <span class="number">1</span>g -<span class="selector-tag">i</span> <span class="number">0</span> -<span class="selector-tag">i</span> <span class="number">1</span> -<span class="selector-tag">i</span> <span class="number">2</span> -f /root/test<span class="selector-class">.rar</span> -Rb ./iozone.xls</span><br></pre></td></tr></table></figure><h5 id="测试项的定义和解释"><a href="#测试项的定义和解释" class="headerlink" title="测试项的定义和解释"></a>测试项的定义和解释</h5><blockquote><p>Write：测试向一个新文件写入的性能。<br>Re-write：测试向一个已存在的文件写入的性能。<br>Read：测试读一个已存在的文件的性能。<br>Re-Read：测试读一个最近读过的文件的性能。<br>Random Read：测试读一个文件中的随机偏移量的性能。<br>Random Write：测试写一个文件中的随机偏移量的性能。</p></blockquote><h5 id="测试数据对比"><a href="#测试数据对比" class="headerlink" title="测试数据对比"></a>测试数据对比</h5><blockquote><p>Write：</p><p><a href="http://dockone.io/uploads/article/20190702/f592fe0e47c24441541b3970f6775674.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/f592fe0e47c24441541b3970f6775674.jpg" alt="8.jpg"></a></p><p>Re-write:</p><p><a href="http://dockone.io/uploads/article/20190702/778f51a47542033e0ded1b1b1d0edd63.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/778f51a47542033e0ded1b1b1d0edd63.jpg" alt="9.jpg"></a></p><p>Read：</p><p><a href="http://dockone.io/uploads/article/20190702/3028c70ce9a0abcfa673459b199612a3.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/3028c70ce9a0abcfa673459b199612a3.jpg" alt="10.jpg"></a></p><p>Re-Read：</p><p><a href="http://dockone.io/uploads/article/20190702/fb9fe60305c941fbfbc564cb2351e588.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/fb9fe60305c941fbfbc564cb2351e588.jpg" alt="11.jpg"></a></p><p>Random Read：</p><p><a href="http://dockone.io/uploads/article/20190702/ef273f23ee51927344a224ef3798e75a.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/ef273f23ee51927344a224ef3798e75a.jpg" alt="12.jpg"></a></p><p>Random Write：</p><p><a href="http://dockone.io/uploads/article/20190702/3a07e8a8a9b4de99602d02dc849b771b.jpg" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20190702/3a07e8a8a9b4de99602d02dc849b771b.jpg" alt="13.jpg"></a></p></blockquote><ul><li>通过以上的性能数据可以看到：<ul><li>AUFS在读的方面性能相比Overlay要差一些，但在写的方面性能比Overlay要好。</li><li>device mapper在512M以上文件的读写性能都非常的差，但在512M以下的文件读写性能都比较好。</li><li>btrfs在512M以上的文件读写性能都非常好，但在512M以下的文件读写性能相比其他的存储驱动都比较差。</li><li>ZFS整体的读写性能相比其他的存储驱动都要差一些。 简单的测试了一些数据，对测试出来的数据原理还需要进一步的解析。</li></ul></li></ul><blockquote><p><code>Docker</code> 提供了可插拔的存储驱动程序架构。它使我们能够灵活地 <code>插入</code> <code>Docker</code>中的存储驱动程序。他完全基于<code>Linux</code>文件系统 。</p></blockquote><blockquote><p>要实现这一功能，我们必须 在<code>docker</code> 守护进程的开始时就设置驱动程序。 <code>Docker</code> 守护程序只能运行一个存储驱动程序，并且该守护程序实例创建的所有容器使用相同的存储驱动程序。</p></blockquote><ul><li><p>当前存储驱动</p><ul><li>查看守护程序使用哪个存储驱动程序，可以使用一下命令。</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="meta">info</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到上面的命令显示了守护进程使用的存储驱动程序。备份文件系统 <code>extfs</code> 。 <code>extfs</code> 表示覆盖存储驱动程序在文件系统的顶部运行。</p><p>后备文件系统实质用于在 <code>/var/lib/docker</code> 录下创建 <code>Docker</code> 主机的本地存储区域的文件系统。</p></blockquote><ul><li><p>下表包含必须与主机备份文件系统相匹配的存储驱动程序。</p><table><thead><tr><th align="center">存储驱动</th><th align="center">常用</th><th align="center">已禁用</th></tr></thead><tbody><tr><td align="center">overlay</td><td align="center">ext4xfs</td><td align="center">btrfs  aufs  overlayzfs  eCryptfs</td></tr><tr><td align="center">overlay2</td><td align="center">ext4xfs</td><td align="center">btrfs  aufs  overlayzfs  eCryptfs</td></tr><tr><td align="center">aufs</td><td align="center">ext4xfs</td><td align="center">btrfs  aufs  eCryptfs</td></tr><tr><td align="center">aufs</td><td align="center">btrfsonly</td><td align="center">N/A</td></tr><tr><td align="center">devicemapper</td><td align="center">Direct-lvm</td><td align="center">N/A</td></tr><tr><td align="center">vfs</td><td align="center">debugging only</td><td align="center">N/A</td></tr><tr><td align="center"></td><td align="center"></td><td align="center">N/A</td></tr></tbody></table></li></ul><blockquote><p>注意 ：- “已禁用/Disabled on” 表示某些存储驱动程序无法在某些后台文件系统上运行</p></blockquote></li></ul><h4 id="设置存储驱动程序"><a href="#设置存储驱动程序" class="headerlink" title="设置存储驱动程序"></a>设置存储驱动程序</h4><blockquote><p>可以通过 <code>dockersd</code>命令按指定名称来设置存储驱动程序。以下命令启动守护程序并设置新的驱动程序。</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dockerd <span class="attribute">--storage-driver</span>=devicemapper</span><br></pre></td></tr></table></figure><blockquote><p>稍后，可以通过 <code>docker info</code> 命令检查 <code>docker</code> 服务驱动程序</p></blockquote><hr><p><strong>对于某些容器，直接将数据放在由</strong> storage driver <strong>维护的层中是很好的选择，比如那些无状态的应用。无状态意味着容器没有需要持久化的数据，随时可以从镜像直接创建。即存在与否依赖镜像的存在。</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如一些工具箱，启动是为了执行命令，不需要保存数据供以后使用，使用完直接退出，容器删除时存在容器层的工作数据也一起删除，这没问题，下次启动新容器即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但对于另一类应用这种方式就不合适了，它们有持久化数据的需求，容器启动时需要加载已有的数据，容器销毁时希望保留产生的新数据，也就是说，这类容器是有状态的，例如数据库。</span></span><br><span class="line">这就要用到docker 的另一个存储机制：data <span class="keyword">volume</span><span class="bash"></span></span><br></pre></td></tr></table></figure><h3 id="Data-Volume（数据卷）"><a href="#Data-Volume（数据卷）" class="headerlink" title="Data Volume（数据卷）"></a>Data Volume（数据卷）</h3><hr><blockquote><p>对于有些容器，我们可能会持久化数据的需求，也就是容器启动时需要加载已有的数据，容器销毁时希望保留产生的数据，也就是说这类容器是有状态的。</p><p>这就需要用到 <code>Docker</code> 的 <code>Data Volume</code> 存储机制。<code>Data Volume</code>本质上是 <code>Docker host</code>文件系统中的目录或文件，能够直接被 <code>mount</code> 到容器的文件系统。</p><p>在具体的使用上，<code>Docekr</code> 提供了两种类型的Volume：bind mount 和docker managed volume。</p></blockquote><h5 id="附：bind-mount-与-docker-managed-volume-的区别"><a href="#附：bind-mount-与-docker-managed-volume-的区别" class="headerlink" title="附：bind mount 与 docker managed volume 的区别"></a>附：bind mount 与 docker managed volume 的区别</h5><ul><li>这两种 <strong>data volume</strong> 实际上都是使用 <strong>host</strong> 文件系统的中的某个路径作为 <strong>mount</strong> 源。它们不同之处在于：</li></ul><table><thead><tr><th><strong>不同点</strong></th><th><strong>bind mount</strong></th><th><strong>docker managed volume</strong></th></tr></thead><tbody><tr><td><strong>volume 位置</strong></td><td>可任意指定</td><td><strong>/var/lib/docker/volumes/…</strong></td></tr><tr><td><strong>对已有mount point 影响</strong></td><td>隐藏并替换为 <strong>volume</strong></td><td>原有数据复制到 <strong>volume</strong></td></tr><tr><td><strong>是否支持单个文件</strong></td><td>支持</td><td>不支持，只能是目录</td></tr><tr><td><strong>权限控制</strong></td><td>可设置为只读，默认为读写权限</td><td>无控制，均为读写权限</td></tr><tr><td><strong>移植性</strong></td><td>移植性弱，与 <strong>host path</strong> 绑定</td><td>移植性强，无需指定 <strong>host</strong> 目录</td></tr></tbody></table><h5 id="什么是数据卷"><a href="#什么是数据卷" class="headerlink" title="什么是数据卷"></a>什么是数据卷</h5><ul><li><p>Data Volume 数据卷 ：是可以存放在一个或多个容器内的 <strong>特定的目录</strong>，提供独立于容器之外的<strong>持久化存储</strong>；是经过<strong>特殊设计的目录</strong>，可以绕过联合文件系统（UFS），为一个或多个容器提供访问；</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Docker</span> Contrainer</span><br><span class="line">面向对象中的对象</span><br><span class="line"></span><br><span class="line">对象一旦被销毁，数据就不存在了</span><br><span class="line"></span><br><span class="line">容器一旦被销毁，则容器内的数据将一并被删除</span><br><span class="line"></span><br><span class="line">服务器中的图案也会一并销毁</span><br><span class="line"></span><br><span class="line">容器中的数据不是持久化状态的</span><br></pre></td></tr></table></figure><blockquote><p>不使用 <code>volume</code>的时候，对容器进行的改动是不会被保存的，使用 <code>volume</code>可以实现持久化存储；比如运行一个数据的操作，数据库的一个容器，数据库的数据应该被持久化存储的，<code>volume</code>就可以实现这个，并且 <code>volume</code>可以提供容器与容器之间的共享数据；</p></blockquote></li></ul><h5 id="Docker-的理念之一："><a href="#Docker-的理念之一：" class="headerlink" title="Docker 的理念之一："></a>Docker 的理念之一：</h5><blockquote><p>就是将其应用于其运行的环境打包，因此，通过<code>Docker</code> 容器的生存周期，都是与容器中运行的程序相一致的，而我们对数据的要求通常是持久化的；另一方面，<code>docker</code>容器之间也需要有一个 <strong>共享数据的渠道</strong> ，而这些需求就催生出了<code>docker</code>数据卷的产生；</p></blockquote><h5 id="数据卷的设计的目的："><a href="#数据卷的设计的目的：" class="headerlink" title="数据卷的设计的目的："></a>数据卷的设计的目的：</h5><blockquote><p>在于 <strong>数据的永久化</strong> ，它完全独立于容器的生存周期，因此，<code>Docekr</code>不会在容器删除时删除其挂载的数据卷，也不会存在类似垃圾收集机制，对容器引用的数据卷进行处理了；</p></blockquote><h5 id="数据卷特点："><a href="#数据卷特点：" class="headerlink" title="数据卷特点："></a>数据卷特点：</h5><ul><li><ol><li><code>Docker</code>数据卷是独立于<code>Docker</code>的存在，它存在于<code>Docker host</code>（宿主机）中，因此，它与容器的生存周期是分离的；</li><li><code>Docker</code>数据卷本质上是存在于<code>Docker</code>宿主机的本地文件系统中；</li><li><code>Docker</code> 数据卷可以是目录也可以是文件；（不是块设备）</li><li><code>Docker</code> 容器可以利用数据卷的技术与容器宿主机进行数据共享；</li><li>同一个目录或者文件，可以支持多个容器进行访问，这样其实实现了容器的数据共享和交换；</li><li>数据卷是在容器启动是进行初始化的，那么如果容器使用的镜像包含了的数据也会在容器启动时拷贝到容器的数据卷中；</li><li><code>数据卷可以在容器之间共享和重用</code>；</li><li><code>数据卷的修改会立马生效</code>；容器可以对数据卷里的内容直接修改；容器对数据卷进行的修改是及时的，所有的修改都会直接体现在数据卷中；</li><li><code>数据卷的更新不会影响镜像</code>；因为文件不会写到镜像中去，数据卷是独立于联合文件系统的，而镜像本身基于联合文件系统，so镜像与数据卷之间不会有相互影响的情况；</li><li><code>数据卷会一直存在，即使挂载数据卷的容器已经删除</code>因为数据均本质上是宿主机上的一个目录，同时为了提供数据的永久化，它的生存周期与容器是完全隔离的；</li></ol><p><img src="https://img-blog.csdnimg.cn/20190617160156293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTQ2ODkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><blockquote><p>Docker 容器中的数据操作经过了UFS 的，UFS 会在宿主机中写一次文件，这个文件在宿主机上是临时的，这时候就出现了重复写的情况，会影响系统的性能；此外，删除容器的时候，就没有人能够通过UFS 在访问到宿主机中的文件了；</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190617160937555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTQ2ODkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>容器卷可以绕过 UFS 直接操作主机上的文件，当容器删除的时候，宿主机上的文件还在，就在指定的目录下，在重新创建容器的时候们可以指定容器继续读取宿主机上的文件；</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190617161045446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTQ2ODkx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h5><blockquote><p>包含数据卷挂载的容器在容器关闭时，如果修改了宿主机下的数据卷会，容器里面会产生改变吗？ </p></blockquote><ul><li><strong>bind mount 数据卷</strong></li></ul><blockquote><p>使用docker run –name nginx-test -p 8080:80 -d -v ~/myvolume:/usr/share/nginx/html nginx  创建一个bind mount 数据卷 是宿主机的存储位置必须是绝对路径。目录不存在则会生成</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下两种情况创建的数据卷如果浏览器访问宿主机的ip:8080 会出现报错，因为这是创建的时候清空了容器数据卷下index.html</span></span><br><span class="line"><span class="comment"># 创建的宿主机和容器的数据卷都有读写的权限</span></span><br><span class="line">$ docker run <span class="params">--name</span> nginx-test -p 8080<span class="function">:80</span> -d -v ~<span class="string">/myvolume</span>:<span class="string">/usr/share/nginx/html</span> nginx</span><br><span class="line"><span class="comment"># 这样执行后的文件宿主机的~/myvolume 文件如果不存在直接创建，容器的文件路径不存在也会直接创建，如果/usr/share/nginx/html文件存在里面内容会清空</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给容器里面的数据卷加权限</span></span><br><span class="line">$ docker run <span class="params">--name</span> nginx-test -p 8080<span class="function">:80</span> -d -v ~<span class="string">/myvolume</span>:<span class="string">/usr/share/nginx/html</span><span class="function">:ro</span> nginx</span><br><span class="line"><span class="comment"># 如果执行这个 :/usr/share/nginx/html:ro这个地方加的是 :ro 是设置的只有读取权限</span></span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行dockers inspect 容器名称或容器（ID） 是将容器的配置文件已json字符串的形式返回</span></span><br><span class="line"><span class="string">"Binds"</span>: [</span><br><span class="line">                <span class="string">"/root/myvolume:/usr/share/nginx/html"</span>   <span class="comment"># 宿主机数据卷位置: 容器的目录位置</span></span><br><span class="line">            ],</span><br><span class="line"></span><br><span class="line"><span class="string">"Mounts"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Type"</span>: <span class="string">"bind"</span>,</span><br><span class="line">                <span class="string">"Source"</span>: <span class="string">"/root/myvolume"</span>,   <span class="comment"># 是宿主机数据卷的存储位置</span></span><br><span class="line">                <span class="string">"Destination"</span>: <span class="string">"/usr/share/nginx/html"</span>,</span><br><span class="line">                <span class="string">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="string">"RW"</span>: <span class="literal">true</span>,   <span class="comment"># 权限 true是可以读写 fales 是只读</span></span><br><span class="line">                <span class="string">"Propagation"</span>: <span class="string">"rprivate"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 在宿主机的数据卷下执行:</span></span><br><span class="line">vim index.html </span><br><span class="line"><span class="meta"># 在文件里写入hello ， 你在访问的时候就可以在页面上看到你写入得数据了</span></span><br></pre></td></tr></table></figure><blockquote><p>执行 docker exec -it 容器名称（容器ID） bahs进入到容器里面，每个容器都会包含一个迷你版的linux系统</p><p>执行 cd /usr/share/nginx/html  </p><p>执行 ls</p><p>你会看到容器目录里会有我们刚才创建好的文件</p><p>index.html</p><p>执行 cat index.html  可以看到里面我们加入的数据</p><p>如果是挂载数据卷的时候加 <code>:ro</code> 容器内修改文件，发现会提示该文件是只读的  </p></blockquote><hr><ul><li><strong>docker managed volume 数据卷</strong><ul><li>创建出来的两个都是有读写权限的</li></ul></li></ul><blockquote><p>使用docker run –name nginx-test2 -p 8080:80 -d -v /usr/share/nginx/html nginx 创建一个<strong>docker managed volume 数据卷</strong> </p><p>这种命令创建是不用指定宿主机数据卷存储位置的默认在 /var/lib/docker/volumes/ 下的文件名是经过<code>sha256</code> 摘要过的</p></blockquote><ul><li>查看宿主机创建出来的数据卷</li></ul><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd  /var/<span class="class"><span class="keyword">lib</span>/<span class="title">docker</span>/<span class="title">volumes</span>/</span></span><br><span class="line">$ ls </span><br><span class="line"><span class="number">8</span>d668720aaeccee44b5fb554571912a6a257eb3a28cecf334203805a0c9b6fd3  <span class="comment">#这是自己创建出来的数据卷</span></span><br><span class="line"><span class="comment"># 执行 cd _data 进入这这个文件夹里面</span></span><br><span class="line">$ ls</span><br><span class="line"><span class="number">50</span>x.html  index.html   <span class="comment"># 这两个文件是把容器里文件给拷贝了出来</span></span><br></pre></td></tr></table></figure><blockquote><p>可以在宿主机或者容器里面都可以对文件进行读写操作</p></blockquote><h5 id="挂载多个目录实现数据卷的"><a href="#挂载多个目录实现数据卷的" class="headerlink" title="挂载多个目录实现数据卷的"></a>挂载多个目录实现数据卷的</h5><ul><li>就是执行多个 <code>-v</code> 就可以</li></ul><h5 id="容器间的数据共享"><a href="#容器间的数据共享" class="headerlink" title="容器间的数据共享"></a>容器间的数据共享</h5><ul><li>数据卷容器挂载了一个本地文件系统的目录，其它容器通过挂载这个数据卷容器来实现容器间的数据的共享；</li></ul><p><img src="https://img-blog.csdn.net/20180524134945342?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTQ2ODkx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h5 id="容器间挂载"><a href="#容器间挂载" class="headerlink" title="容器间挂载"></a>容器间挂载</h5><blockquote><p>创建数据卷，只要在<code>docker run</code>命令后面跟上<code>-v</code>参数即可创建一个数据卷，当然也可以跟多个<code>-v</code>参数来创建多个数据卷，当创建好带有数据卷的容器后，就可以在其他容器中通过<code>--volumes-from</code>参数来挂载该数据卷了，而不管该容器是否运行。</p></blockquote><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">docker</span> <span class="comment">run</span> <span class="literal">-</span><span class="comment">tid</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">rm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">volumes</span><span class="literal">-</span><span class="comment">from</span> <span class="comment">nginx</span><span class="literal">-</span><span class="comment">test</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">name</span> <span class="comment">nginx</span><span class="literal">-</span><span class="comment">test3</span> <span class="comment">nginx</span></span><br></pre></td></tr></table></figure><blockquote><p>-i  : 以交互模式运行容器，通常与 -t 同时使用；</p><p>-t  : 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p><p>-d : 后台运行容器，并返回容器ID；</p></blockquote><ul><li>再创建一个nginx-test4，挂载nginx-test3中从nginx-test挂载的数据卷，当然也可以直接挂载初识的nginx-test容器的数据卷</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>即使删除了初始的数据卷容器 nginx-test，或者是删除了其他容器，但只要是有容器在使用该数据卷，那么它里面的数据就不会丢失</span><br><span class="line"><span class="bullet">* </span>命令中的rm表示当容器退出即停止的时候，会自动删除该容器</span><br></pre></td></tr></table></figure><hr><h5 id="备份数据卷"><a href="#备份数据卷" class="headerlink" title="备份数据卷"></a>备份数据卷</h5><ul><li>创建一个容器container1，包含两个数据卷/usr/share/nginx/html1和/usr/share/nginx/html2（这两个目录是在容器里的数据卷路径）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -tid -v /usr/share/nginx/html1 -v /usr/share/nginx/html2 --name container1 -p 8080:80 nginx</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建容器container1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it container1 bash   <span class="comment">#进入创建好的容器里面</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> html1/  <span class="comment"># 进入到html1数据卷中</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> html1 &gt;&gt; 1.text <span class="comment"># 向 1.text 文件中追加数据，文件不存在则会创建文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> html2/  <span class="comment"># 进入到html2数据卷中</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> html2 &gt;&gt; 2.text <span class="comment"># 向 2.text 文件中追加数据，文件不存在则会创建文件</span></span></span><br></pre></td></tr></table></figure><ul><li>接下来进行数据卷的备份操作</li></ul><blockquote><p>使用  - -volumes-from 来创建一个加载 container1 容器卷的容器，并从宿主机挂载当前所在目录到容器的 /backup 目录，容器内会 tar 压缩 /var/colume1 目录下的文件到 /backup/backup1.tar，因为宿主机当前目录已经映射到 /backup 目录了，因此会在宿主机当前目录也存在该压缩包。备份完毕后 -rm 自动删除该创建的容器。</p></blockquote><ul><li>备份container1容器中的/usr/share/nginx/html1数据卷数据</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 备份container1容器中的/usr/share/nginx/html1数据卷数据</span></span><br><span class="line"><span class="comment"># -tid 这个参数加不加都可以</span></span><br><span class="line"><span class="comment"># --rm 加上，备份后就会自动删除这个容器，如果不加这个 --rm 参数，name备份后的容器就会保留，docker ps -a就会查看到）</span></span><br><span class="line"><span class="comment"># $(pwd) </span></span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]<span class="comment"># docker run -tid --rm --volumes-from container1 -v $(pwd):/backup nginx tar cvf /backup/backup1.tar /usr/share/nginx/html1</span></span><br><span class="line">b3663a3bdd302a38036d6a156471cd448c8e5b9333a20f9480b3c61cbd9270df</span><br><span class="line"></span><br><span class="line">[root@iz2zefaujekcdpmfw1qs4az ~]<span class="comment"># ls</span></span><br><span class="line">backup1.tar</span><br></pre></td></tr></table></figure><blockquote><ul><li>–volumes-from [containerName]：这个命令来指定需要备份的容器的名字；（数据卷容器的名字）</li><li>-v $(pwd):/backup:权限：使用-v命令来指定希望备份文件存放的位置；本地存放目录：容器存放目录：读写权限；（默认权限是读写）</li><li>tar cvf /backup/backup.tar [container data volume]：tar表示执行备份的操作是：压缩文件的命令；</li><li>/backup/backup.tar是文件存放的地址， [container data volume]指定需要备份的目录；</li><li>tar cvf 压缩；tar xvf解压缩；</li></ul></blockquote><ul><li>备份container1容器中的/usr/share/nginx/html2数据卷数据</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 备份container1容器中的/usr/share/nginx/html2数据卷数据</span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# pwd</span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# docker run -tid --rm --volumes-<span class="keyword">from</span> container1 -v $(pwd):/backup nginx tar cvf /backup/backup2.tar /usr/share/nginx/html2</span><br><span class="line"><span class="number">001129</span>bc393d5d0ed4665d053d4ca7972584cf2bd56980064be182ec758138cd</span><br><span class="line"></span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# ll</span><br><span class="line">total <span class="number">22464</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root    <span class="number">10240</span> Dec <span class="number">16</span> <span class="number">18</span>:<span class="number">52</span> backup1.tar  # 文件<span class="number">1</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root    <span class="number">10240</span> Dec <span class="number">16</span> <span class="number">19</span>:<span class="number">05</span> backup2.tar  # 文件<span class="number">2</span></span><br><span class="line">drwxr-xr-x <span class="number">2</span> root root     <span class="number">4096</span> Dec <span class="number">16</span> <span class="number">16</span>:<span class="number">45</span> myvolume</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">22973527</span> Mar <span class="number">26</span>  <span class="number">2019</span> Python<span class="number">-3.7</span><span class="number">.3</span>.tgz</span><br></pre></td></tr></table></figure><ul><li>备份container1 容器中的 /usr/share/nginx/html1 和 /usr/share/nginx/html2 数据卷数据</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#  备份container1 容器中的 /usr/share/nginx/html2 和 /usr/share/nginx/html2 数据卷数据</span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# pwd</span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# docker run -tid --rm --volumes-<span class="keyword">from</span> container1 -v $(pwd):/backup nginx tar cvf /backup/backup.tar /usr/share/nginx/html1</span><br><span class="line">/usr/share/nginx/html2</span><br><span class="line"><span class="number">441</span>df929e123cbe51564ca3d6bf3f06a5ea415298a34bb9871f1ed2b68a60102</span><br><span class="line"></span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# ll</span><br><span class="line">total <span class="number">22476</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root    <span class="number">10240</span> Dec <span class="number">16</span> <span class="number">18</span>:<span class="number">52</span> backup1.tar</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root    <span class="number">10240</span> Dec <span class="number">16</span> <span class="number">19</span>:<span class="number">05</span> backup2.tar</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root    <span class="number">10240</span> Dec <span class="number">16</span> <span class="number">19</span>:<span class="number">09</span> backup.tar</span><br><span class="line">drwxr-xr-x <span class="number">2</span> root root     <span class="number">4096</span> Dec <span class="number">16</span> <span class="number">16</span>:<span class="number">45</span> myvolume</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">22973527</span> Mar <span class="number">26</span>  <span class="number">2019</span> Python<span class="number">-3.7</span><span class="number">.3</span>.tgz</span><br></pre></td></tr></table></figure><h5 id="恢复数据给同一个容器"><a href="#恢复数据给同一个容器" class="headerlink" title="恢复数据给同一个容器"></a>恢复数据给同一个容器</h5><blockquote><p>之前的数据卷是从 container1 中备份的，现在模拟 container1 数据卷丢失，然后直接用之前备份的 backup.tar 进行恢复</p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了测试恢复，先删除容器里原先的数据（注意：数据卷目录不能删除，只能删除其中的数据）</span></span><br><span class="line">[root<span class="variable">@iz2zefaujekcdpmfw1qs4az</span> ~]<span class="comment"># docker exec -it container1 bash </span></span><br><span class="line"><span class="comment">#进入到创建的容器里</span></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/</span><span class="comment"># ls</span></span><br><span class="line">bin  boot  devetc  home  liblib64  media  mnt  optproc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/</span><span class="comment"># cd /usr/share/nginx  </span></span><br><span class="line"><span class="comment">#进入到容器里面的数据卷所在的目录</span></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx</span><span class="comment"># ls</span></span><br><span class="line">html  html1  html2  </span><br><span class="line"></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx</span><span class="comment"># cd html1</span></span><br><span class="line"><span class="comment"># 进入到 html1 数据卷目录</span></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx/html1</span><span class="comment"># ls</span></span><br><span class="line"><span class="number">1</span>.text</span><br><span class="line"></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx/html1</span><span class="comment"># rm -rf 1.text </span></span><br><span class="line"><span class="comment"># 删除 1.text 文件</span></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx/html1</span><span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx</span><span class="comment"># cd html2</span></span><br><span class="line"><span class="comment"># 进入到 html2 的数据卷目录</span></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx/html2</span><span class="comment"># ls</span></span><br><span class="line"><span class="number">2</span>.text</span><br><span class="line"></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx/html2</span><span class="comment"># rm -rf 2.text </span></span><br><span class="line"><span class="comment"># 删除 2.text 文件</span></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx/html2</span><span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行数据卷恢复，恢复数据卷中的所有数据</span></span><br><span class="line">注意-C后面的路径，表示将数据恢复到容器里的路径直接使用压缩包中文件的各个路径。比如压缩包中的结果如下：</span><br><span class="line">tar -xvf backup.tar   <span class="comment">#解压压缩文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据1</span></span><br><span class="line">usr/share/nginx/html1/<span class="number">1</span>.text</span><br><span class="line">--usr</span><br><span class="line">--share</span><br><span class="line">--nginx</span><br><span class="line">--html1</span><br><span class="line">--<span class="number">1</span>.text</span><br><span class="line"><span class="comment"># 数据2</span></span><br><span class="line">usr/share/nginx/html2/<span class="number">2</span>.text</span><br><span class="line">--usr</span><br><span class="line">--share</span><br><span class="line">--nginx</span><br><span class="line">--html2</span><br><span class="line">--<span class="number">2</span>.text</span><br><span class="line"><span class="comment"># 直接将文件解压到 /usr/share/nginx/html1 和 /usr/share/nginx/html2 目录</span></span><br><span class="line">[root<span class="variable">@iz2zefaujekcdpmfw1qs4az</span> ~]<span class="comment"># docker run --rm --volumes-from container1 -v $(pwd):/backup nginx tar xvf /backup/backup.tar -C /</span></span><br><span class="line">usr/share/nginx/html1/</span><br><span class="line">usr/share/nginx/html1/<span class="number">1</span>.text</span><br><span class="line">usr/share/nginx/html2/</span><br><span class="line">usr/share/nginx/html2/<span class="number">2</span>.text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接进入容器查看</span></span><br><span class="line">[root<span class="variable">@iz2zefaujekcdpmfw1qs4az</span> ~]<span class="comment"># docker exec -it container1 bash</span></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/</span><span class="comment"># cd /usr/share/nginx/ </span></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx</span><span class="comment"># ls</span></span><br><span class="line">html  html1  html2</span><br><span class="line"><span class="comment"># 查看数据是否存在</span></span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx</span><span class="comment"># ls html1</span></span><br><span class="line"><span class="number">1</span>.text</span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx</span><span class="comment"># ls html2</span></span><br><span class="line"><span class="number">2</span>.text</span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx</span><span class="comment"># cat html1/1.text </span></span><br><span class="line">html1</span><br><span class="line">root<span class="variable">@6869560e6ff5</span><span class="symbol">:/usr/share/nginx</span><span class="comment"># cat html2/2.text </span></span><br><span class="line">html2</span><br></pre></td></tr></table></figure><ul><li><h5 id="如果你备份的数据里面有，不是设置的数据卷里面的数据，使用这个命令是恢复不了的（恢复的是设置的数据卷里面的数据）"><a href="#如果你备份的数据里面有，不是设置的数据卷里面的数据，使用这个命令是恢复不了的（恢复的是设置的数据卷里面的数据）" class="headerlink" title="!  如果你备份的数据里面有，不是设置的数据卷里面的数据，使用这个命令是恢复不了的（恢复的是设置的数据卷里面的数据）"></a><strong>!</strong>  如果你备份的数据里面有，不是设置的数据卷里面的数据，使用这个命令是恢复不了的（恢复的是设置的数据卷里面的数据）</h5></li><li><h5 id="你可以创一个新的容器多一个，你数据卷挂载你备份数据时候，备份的文件的路径就可以解决了"><a href="#你可以创一个新的容器多一个，你数据卷挂载你备份数据时候，备份的文件的路径就可以解决了" class="headerlink" title="你可以创一个新的容器多一个，你数据卷挂载你备份数据时候，备份的文件的路径就可以解决了"></a>你可以创一个新的容器多一个，你数据卷挂载你备份数据时候，备份的文件的路径就可以解决了</h5></li></ul><h5 id="恢复数据给新的容器"><a href="#恢复数据给新的容器" class="headerlink" title="恢复数据给新的容器"></a>恢复数据给新的容器</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 新建一个容器container2</span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# docker run -tid -v /usr/share/nginx/html1 -v /usr/share/nginx/html2 --name container2 nginx</span><br><span class="line"><span class="number">89</span>abb55858fb1e3dddc07c2066d05614349aaf78ba446a1ea12f1241b98e4896</span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line"><span class="number">89</span>abb55858fb        nginx               <span class="string">"/bin/bash"</span>         <span class="number">9</span> seconds ago       Up <span class="number">8</span> seconds        <span class="number">80</span>/tcp              container2</span><br><span class="line"><span class="number">6869560e6f</span>f5        nginx               <span class="string">"/bin/bash"</span>         <span class="number">2</span> hours ago         Up <span class="number">2</span> hours          <span class="number">80</span>/tcp              container1</span><br><span class="line"></span><br><span class="line"># 开始恢复数据</span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# pwd</span><br><span class="line">/root</span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# ll</span><br><span class="line">total <span class="number">22476</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root    <span class="number">10240</span> Dec <span class="number">16</span> <span class="number">18</span>:<span class="number">52</span> backup1.tar</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root    <span class="number">10240</span> Dec <span class="number">16</span> <span class="number">19</span>:<span class="number">05</span> backup2.tar</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root    <span class="number">10240</span> Dec <span class="number">16</span> <span class="number">19</span>:<span class="number">09</span> backup.tar</span><br><span class="line">drwxr-xr-x <span class="number">2</span> root root     <span class="number">4096</span> Dec <span class="number">16</span> <span class="number">16</span>:<span class="number">45</span> myvolume</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">22973527</span> Mar <span class="number">26</span>  <span class="number">2019</span> Python<span class="number">-3.7</span><span class="number">.3</span>.tgz</span><br><span class="line"></span><br><span class="line"># 恢复数据</span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# docker run --rm --volumes-<span class="keyword">from</span> container2 -v $(pwd):/backup nginx tar xvf /backup/backup.tar -C /</span><br><span class="line">usr/share/nginx/html1/</span><br><span class="line">usr/share/nginx/html1/<span class="number">1.</span>text</span><br><span class="line">usr/share/nginx/html2/</span><br><span class="line">usr/share/nginx/html2/<span class="number">2.</span>text</span><br><span class="line"></span><br><span class="line"># 查看确实已经恢复了</span><br><span class="line">[<span class="symbol">root@</span>iz2zefaujekcdpmfw1qs4az ~]# docker exec -it container2 bash</span><br><span class="line"><span class="symbol">root@</span><span class="number">89</span>abb55858fb:/# ls /usr/share/nginx/</span><br><span class="line">html  html1  html2</span><br><span class="line"><span class="symbol">root@</span><span class="number">89</span>abb55858fb:/# ls /usr/share/nginx/html1</span><br><span class="line"><span class="number">1.</span>text</span><br><span class="line"><span class="symbol">root@</span><span class="number">89</span>abb55858fb:/# ls /usr/share/nginx/html2</span><br><span class="line"><span class="number">2.</span>text</span><br><span class="line"><span class="symbol">root@</span><span class="number">89</span>abb55858fb:/# cat /usr/share/nginx/html1/<span class="number">1.</span>text </span><br><span class="line">html1</span><br><span class="line"><span class="symbol">root@</span><span class="number">89</span>abb55858fb:/# cat /usr/share/nginx/html2/<span class="number">2.</span>text </span><br><span class="line">html2</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li><p>–volumes-from [containerName]：这个命令来指定需要备份的容器的名字；（数据卷容器的名字）</p></li><li><p>-v $(pwd):/backup:权限：使用-v命令来指定希望备份文件存放的位置；本地存放目录：容器存放目录：读写权限；（默认权限是读写）</p></li><li><p>tar cvf /backup/backup.tar [container data volume]：tar表示执行备份的操作是：压缩文件的命令；</p></li><li><p>/backup/backup.tar是文件存放的地址， [container data volume]指定需要备份的目录；</p></li><li><p>tar cvf 压缩；tar xvf解压缩；</p></li><li><p>新容器创建时挂载的数据卷路径最好和之前备份的数据卷路径一致</p></li><li><p>新容器创建时，如果挂载的数据卷只是备份卷的一部分，那么恢复的时候也只是恢复一部分数据。</p></li><li><p>比如新建容器挂载数据卷为 <code>-v /usr/share/nginx/html1</code> ,那么使用 <code>backup.tar</code> 恢复时，只会恢复 <code>/usr/share/nginx/html1</code> 的数据， <code>/usr/share/nginx/html2</code> 的数据是不会恢复的</p></li><li><p>比如新容器创建时挂载的数据卷目录和备份的数据卷目录不一致，那么数据恢复不了，除非修改 - C 后面的路径，比如新建容器时指定数据卷目录为 <code>/usr/share/nginx/html</code> ，恢复时也是用 <code>-C /usr/share/nginx/html</code>，则是可以成功恢复的</p></li></ul></blockquote><h5 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">volume</span><span class="bash"> ls     列出所有的数据卷</span></span><br><span class="line">docker <span class="keyword">volume</span><span class="bash"> ls --filter dangling=<span class="literal">true</span>     过滤不在使用的数据卷</span></span><br><span class="line">docker <span class="keyword">volume</span><span class="bash"> rm [volume name]     删除一个数据卷，容器正在使用的数据卷不能删除，绑定挂载的数据卷无法删除</span></span><br></pre></td></tr></table></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm <span class="keyword">my</span>-volio  删除数据卷 <span class="keyword">my</span>-volio</span><br></pre></td></tr></table></figure><blockquote><p>数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。</p></blockquote><ul><li>无主的数据卷可能会占据很多空间，要清理请使用以下命令</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">volume</span><span class="bash"> prune</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#Docker 存储&lt;/p&gt;&lt;h3 id=&quot;Docek-镜像层的镜像分层结构&quot;&gt;&lt;a href=&quot;#Docek-镜像层的镜像分层结构&quot; class=&quot;headerlink&quot; title=&quot;Docek 镜像层的镜像分层结构&quot;&gt;&lt;/a&gt;Docek 镜像层的镜像分层结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;docker的镜像分层结构，如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://docs.docker.com/storage/storagedriver/images/container-layers.jpg&quot; alt=&quot;基于Ubuntu映像的容器层&quot;&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;docker镜像中引入层layer概念，镜像的制作过程中的每一步都会生产一个新的镜像层&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;容器读写层的工作原理&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们刚刚在说镜像的分层特性的时候说到镜像是只读的。而事实上当我们使用镜像启动一个容器的时候，我们其实是可以在容器里随意读写的，从结果上看，似乎与镜像的只读特性相悖。&lt;/p&gt;
&lt;p&gt;我们继续看上面的图，其实可以看到在镜像的最上层，还有一个读写层。而这个读写层，即在容器启动时为当前容器单独挂载。每一个容器在运行时，都会基于当前镜像在其最上层挂载一个读写层。而用户针对容器的所有操作都在读写层中完成。一旦容器销毁，这个读写层也随之销毁。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;知识点： 容器=镜像+读写层&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而我们针对这个读写层的操作，主要基于两种方式：写时复制和用时分配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://cy-blogs.cn/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://cy-blogs.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Linux用户组及权限管理</title>
    <link href="https://cy-blogs.cn/Linux%E7%94%A8%E6%88%B7%E7%BB%84%E5%8F%8A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>https://cy-blogs.cn/Linux用户组及权限管理/</id>
    <published>2019-12-11T05:10:16.031Z</published>
    <updated>2019-12-11T04:56:36.622Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h3><hr><blockquote><p><code>Linux</code> 是哟个多用户的操作系统，引入用户，可以更加方便管理 <code>Linux</code> 服务器</p><p>系统默认需要以一个用户的身份登入，而且在系统上启动进程也需要以一个用户身份器运行，用户可以限制某些进程对特定资源的权限控制</p></blockquote><a id="more"></a><h3 id="Linux用户及组"><a href="#Linux用户及组" class="headerlink" title="Linux用户及组"></a>Linux用户及组</h3><hr><blockquote><p><code>Linux</code> 操作系统对多用户的管理，是非常繁琐的，所以用组的概念来管理用户就变到的简单，每个用户可以在一个独立的组，每个组也可以有零个用户或者多个用户。</p><p><code>Linux</code> 系统用户是根据用户 <code>ID</code> 来识别的，默认 <code>ID</code> 长度为 <code>32</code> 位，默认 <code>ID</code> 编号从 <code>0</code> 开始，但是为了和老式系统兼容，用户 <code>ID</code>限制在 <code>60000</code>一下， <code>Linux</code> 用户总共分为三种，分别如下：</p></blockquote><ul><li>超级用户： <code>root</code>， <code>ID</code> 为0</li><li>系统用户：<code>ID</code> 从1 到499</li><li>普通用户：<code>ID</code>为500以上</li></ul><blockquote><p><code>Linux</code> 系统中的每个文件或者文件夹，都有一个所属用户及所属组</p><p>使用 <code>ID</code> 命令可以显示当前用户的信息，使用 <code>passwd</code> 命令可以修改当前用户密码。 <code>Linux</code>操作系统用户的特点如下</p></blockquote><ul><li>每个用户拥有一个 <code>UserID</code>，操作系统实际读取的是 <code>UID</code>，而非用户名；</li><li>每个用户属于一个主组；属于一个或多个附属组，一个用户最多有 <code>31</code>个附属组；</li><li>每个组用有一个 <code>GroupID</code>;</li><li>每个进程以一个用户身份进行，该用户可以对进程拥有资源控制权限；</li><li>每个可登录用户拥有一个指定的 <code>Shell</code>环境</li></ul><h4 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h4><hr><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">useradd</span> usertest <span class="comment"># 创建用户usertest</span></span><br></pre></td></tr></table></figure><blockquote><p>创建新用户，可以使用命令<code>useradd</code>，执行命令即可创建新用户</p><p>同时会创建一个同名的组，默认该用户属于该用户组</p></blockquote><blockquote><p>创建用户，会根据如下步骤进行操作</p></blockquote><ul><li>在<code>/etc/passwd</code>文件中添加用户信息</li><li>如使用<code>passwd</code>命令创建密码，密码会被加密保存在<code>/etc/shdaow</code>中</li><li>为用户创建家目录：<code>/home/usertest</code>，创建目录操作应操作系统而异</li><li>将<code>/etc/skel</code>中的<code>.bash</code>开头的文件复制至用户家目录</li><li>创建与用户名相同的组，该用户默认属于这个同名组，组信息保存在<code>/etc/group</code>配置文件中</li></ul><blockquote><p>其他命令可选参数如下所示</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-d <span class="comment"># 指定新用户的主目录-G # 指定新用户的组列表-s # 新用户所使用的shell环境</span></span><br><span class="line">useradd usertest -s <span class="regexp">/bin/</span>bash -d <span class="regexp">/home/u</span>sertest<span class="comment"># 创建新用户usertest，指定shell环境为bash，主目录在/home/usertest</span></span><br></pre></td></tr></table></figure><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><hr><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel # 保留用户的家目录userdel –r usertest # 删除用户及用户家目录，用户login系统无法删除userdel –rf usertest # 强制删除用户及该用户家目录，不论是否login系统</span><br></pre></td></tr></table></figure><blockquote><p>当一个用户创建之后，我们可以通过<code>usermod</code>命令来修改用户及组的属性</p></blockquote><ul><li><code>linux</code>下命令选项</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">选项：  -c, --comment 注释            GECOS 字段的新值  -d, --home HOME_DIR           用户的新主目录  -e, --expiredate EXPIRE_DATE  设定帐户过期的日期为 EXPIRE_DATE  -f, --inactive INACTIVE       过期 INACTIVE 天数后，设定密码为失效状态  -g, --gid<span class="built_in"> GROUP </span>              强制使用<span class="built_in"> GROUP </span>为新主组  -G, --groups GROUPS           新的附加组列表 GROUPS  -a, --append<span class="built_in"> GROUP </span>           将用户追加至上边 -G 中提到的附加组中，                                并不从其它组中删除此用户  -h, --help                    显示此帮助信息并推出  -l, --login LOGIN             新的登录名称  -L, --lock                    锁定用户帐号  -m, --move-home               将家目录内容移至新位置 (仅于 -d 一起使用)  -o, --non-unique              允许使用重复的(非唯一的) UID  -p, --password PASSWORD       将加密过的密码 (PASSWORD) 设为新密码  -R, --root CHROOT_DIR         chroot 到的目录  -s, --shell SHELL             该用户帐号的新登录 shell  -u, --uid UID                 用户帐号的新 UID  -U, --unlock                  解锁用户帐号  -Z, --selinux-user  SEUSER       用户账户的新 SELinux 用户映射</span><br><span class="line">groups username# 查看用户所属组</span><br></pre></td></tr></table></figure><h4 id="修改用户所属组"><a href="#修改用户所属组" class="headerlink" title="修改用户所属组"></a>修改用户所属组</h4><hr><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usermod usertest -G old_normal# 将用户usertest修改加入old_normal组中</span><br><span class="line">usermod usertest -a -G other_normal# 将用户追加至other_normal组中，且不影响原有组状态</span><br><span class="line">cat /etc<span class="built_in">/group </span>| grep usertest # 可以查看到usertest用户当前所属组的情况</span><br></pre></td></tr></table></figure><h4 id="修改用户家目录及启动shell"><a href="#修改用户家目录及启动shell" class="headerlink" title="修改用户家目录及启动shell"></a>修改用户家目录及启动shell</h4><hr><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod usertest -d /home<span class="built_in">/user </span>-s /bin/sh</span><br></pre></td></tr></table></figure><h4 id="修改用户名"><a href="#修改用户名" class="headerlink" title="修改用户名"></a>修改用户名</h4><hr><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -l <span class="keyword">new</span> <span class="keyword">old</span># 将<span class="keyword">old</span>用户名变为<span class="keyword">new</span></span><br></pre></td></tr></table></figure><h4 id="锁定-解锁用户"><a href="#锁定-解锁用户" class="headerlink" title="锁定/解锁用户"></a>锁定/解锁用户</h4><hr><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -L usertest;# 锁定usertest用户usermod -U usertest;# 解锁usertest用户</span><br></pre></td></tr></table></figure><h3 id="Linux组管理"><a href="#Linux组管理" class="headerlink" title="Linux组管理"></a>Linux组管理</h3><hr><blockquote><p>所有的<code>Linux</code>或者<code>Windows</code>系统都有组的概念，通过组可以更加方便的管理用户</p><p>组的概念应用于各行行业，例如企业会使用部门、职能或地理区域的分类方式来管理成员，映射在<code>Linux</code>系统，同样可以创建用户，并用组的概念对其管理</p><p>Linux组有如下特点</p></blockquote><ul><li>每个组有一个组<code>ID</code></li><li>组信息保存在<code>/etc/group</code>中</li><li>每个用户至少拥有一个主组，同时还可以拥有<code>31</code>个附属组</li></ul><h4 id="创建新组"><a href="#创建新组" class="headerlink" title="创建新组"></a>创建新组</h4><hr><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd <span class="keyword">normal</span> <span class="comment"># 创建normal组</span></span><br><span class="line">groupadd -g <span class="number">1000</span> <span class="keyword">normal</span> <span class="comment"># 创建ID为1000的分组</span></span><br></pre></td></tr></table></figure><h4 id="其他组属性"><a href="#其他组属性" class="headerlink" title="其他组属性"></a>其他组属性</h4><hr><blockquote><p>常见参数</p></blockquote><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-r # 系统账户-f # 如果指定的组已经存在，则退出-g # 指定当前组id-n --new --old # 修改组名</span><br><span class="line">groupmod -n old_normal normal# 修改normal组名为old_normal</span><br><span class="line">groupmod -g <span class="number">1001</span> old_normal# 修改old_normal组id为<span class="number">1001</span></span><br></pre></td></tr></table></figure><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><blockquote><p>设置好了用户和组，那么接下来就可以对其进行权限控制</p><p>由于linux下处处皆文件，所谓权限也就是对文件的<strong>读</strong>、<strong>写</strong>、<strong>执行</strong>，至少这三种</p><p>当操作系统下某个进程在运行时，进程的权限，也相当于这个进程的运行用户身份权限</p></blockquote><table><thead><tr><th align="left">权限</th><th align="left">文件</th><th align="left">目录</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">读取文件</td><td align="left">列出目录</td></tr><tr><td align="left">w</td><td align="left">修改文件</td><td align="left">修改目录内文件</td></tr><tr><td align="left">x</td><td align="left">执行文件</td><td align="left">进入目录</td></tr></tbody></table><ul><li>权限分组</li></ul><blockquote><p>默认的linux的权限分为三种角色</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; user`、`group`、`other</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>每个文件将基于<strong>UGO</strong>三种权限进行设置</p><p>一般一个文件创建之后，谁创建该文件，默认成为该文件的所有者</p></blockquote><h3 id="用户及组权限"><a href="#用户及组权限" class="headerlink" title="用户及组权限"></a>用户及组权限</h3><hr><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -ahl# 查看文件所有者</span><br><span class="line">chmod g+rwx <span class="meta">file</span># 给<span class="meta">file</span>文件增加rwx权限chmod g-<span class="meta">x</span> <span class="meta">file</span># 给<span class="meta">file</span>文件减少<span class="meta">x</span>权限</span><br></pre></td></tr></table></figure><h3 id="用户及组修改"><a href="#用户及组修改" class="headerlink" title="用户及组修改"></a>用户及组修改</h3><hr><blockquote><p>修改某个文件或目录所属<strong>用户</strong>或<strong>组</strong></p></blockquote><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R root <span class="keyword">file</span># 修改<span class="keyword">file</span>文件所属用户为root</span><br><span class="line">chown -R :root <span class="keyword">file</span># 修改<span class="keyword">file</span>文件所属用户为rootchgrp -R root <span class="keyword">file</span># 修改<span class="keyword">file</span>文件所属组为root</span><br></pre></td></tr></table></figure><h3 id="二进制权限"><a href="#二进制权限" class="headerlink" title="二进制权限"></a>二进制权限</h3><hr><blockquote><p>linux下具备权限设置为1，反之为0，那么一个权限按照二进制位数来计算，如下所示</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--x: <span class="number">001</span> <span class="number">1</span>-wx: <span class="number">011</span> <span class="number">3</span>rwx: <span class="number">111</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><blockquote><p>很清晰，对应的权限位置所代表的数字分别是：<strong>r=4</strong>，<strong>w=2</strong>，<strong>x=1</strong></p></blockquote><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 775 <span class="meta">file</span># 修改<span class="meta">file</span>文件权限为 rwxrwxr-<span class="meta">x</span></span><br></pre></td></tr></table></figure><h3 id="权限掩码"><a href="#权限掩码" class="headerlink" title="权限掩码"></a>权限掩码</h3><hr><blockquote><p>神奇的事情需要我们考虑，每次创建文件，默认都会具备一定的权限，而这个权限是如何分配而来的呢？</p><p>是通过一个叫做权限掩码的东西来维护的，这个码可以通过<strong>umask</strong>命令看到</p><p>默认系统的掩码是<strong>022</strong></p></blockquote><ul><li>文件权限由默认权限减去掩码</li></ul><blockquote><p>文件默认权限：666<br>那么创建一个文件真实的权限是：666-022=644</p></blockquote><blockquote><p>目录的默认权限：777</p><p>一个目录的真实权限是：777-022=755</p></blockquote><ul><li>设置默认掩码</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask -S <span class="number">011</span></span><br></pre></td></tr></table></figure><h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><hr><table><thead><tr><th align="left">权限</th><th align="left">对文件的影响</th><th align="left">对目录的影响</th></tr></thead><tbody><tr><td align="left"><strong>suid</strong></td><td align="left">以文件的所属用户身份执行，而非执行文件的用户</td><td align="left">无</td></tr><tr><td align="left"><strong>sgid</strong></td><td align="left">以文件所属组身份去执行</td><td align="left">在该目录中创建任意新文件的所属组与该目录的所属组相同</td></tr><tr><td align="left"><strong>sticky</strong></td><td align="left">无</td><td align="left">对目录拥有写入权限的用户仅可以删除其拥有的文件，无法删除其他用户所拥有的文件</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;用户和组&quot;&gt;&lt;a href=&quot;#用户和组&quot; class=&quot;headerlink&quot; title=&quot;用户和组&quot;&gt;&lt;/a&gt;用户和组&lt;/h3&gt;&lt;hr&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt; 是哟个多用户的操作系统，引入用户，可以更加方便管理 &lt;code&gt;Linux&lt;/code&gt; 服务器&lt;/p&gt;
&lt;p&gt;系统默认需要以一个用户的身份登入，而且在系统上启动进程也需要以一个用户身份器运行，用户可以限制某些进程对特定资源的权限控制&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://cy-blogs.cn/categories/Linux/"/>
    
    
      <category term="Linux用户组及权限管理" scheme="https://cy-blogs.cn/tags/Linux%E7%94%A8%E6%88%B7%E7%BB%84%E5%8F%8A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://cy-blogs.cn/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://cy-blogs.cn/linux常用命令/</id>
    <published>2019-12-11T05:10:16.027Z</published>
    <updated>2019-12-11T03:56:22.829Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><hr><blockquote><p>随着IT产业的不断发展，<code>linux</code> 操作系统应用领域越来越广泛，尤其是近年来 <code>linux</code>在服务器领域飞速的发展，主要得益于 <code>linux</code>操作系统具备的如下优点</p></blockquote><a id="more"></a><ul><li>开源免费</li><li>系统迭代更新</li><li>系统性能稳定</li><li>安全性高</li><li>多任务/多用户</li><li>耗资源小，无需图形化界面</li><li>内核小</li><li>应用领域广泛</li><li>使用及入门容易</li></ul><h3 id="操作系统分类介绍"><a href="#操作系统分类介绍" class="headerlink" title="操作系统分类介绍"></a>操作系统分类介绍</h3><hr><blockquote><p>学习 <code>Linux</code> 操作系统，需要悬着不同的发行版本</p><p><code>Linux</code> 操作系统是一个大类别， <code>Linux</code> 操作系统主流发型版本包括： <code>Red Hat Linux</code> 、 <code>CentOS</code> , <code>Ubuntu</code> , <code>SUSE Linux</code>  , <code>Fedore Linux</code> 等，具体发行版本区别如下</p></blockquote><ul><li><code>Red Hat Linux</code></li></ul><blockquote><p> <code>Red Hat Linux</code>  是最早的 <code>Linux</code> 发行版本之一</p><p>同时也是最著名的 <code>Linux</code> 版本， <code>Red Hat Linux</code> 已经创造了自己的品牌，也是读者经常听到的 ’‘ 红帽操作系统’‘</p><p><code>Red Hat 1994</code> 年创立，目前公司全世界有 <code>3000</code> 多人，一直致力于开放的源代码体系，向用户提供一套完整的服务，这使得它特别适合在公共网络中使用</p><p>这个版本的 <code>Liunx</code> 也使用最新的内核，还拥有大多数人都需要使用的主要软件包</p></blockquote><ul><li><code>Centos</code></li></ul><blockquote><p>社区企业版操作系统（<code>Community Enterprise Operating System</code>，<code>CentOS</code>）是<code>Linux</code>发行版之一，它是来自于<code>Red Hat Enterprise Linux</code>依照开放源代码所编译而成。由于出自同样的源代码，因此有些要求高度稳定性的服务器以<code>CentOS</code>替代商业版的<code>Red Hat Enterprise Linux</code>使用。</p><p><code>CentOS</code>于<code>Red Hat Linux</code>不同之处在于<code>CentOS</code>并不包含封闭的源代码软件，可以开源免费使用，得到运维人员、企业、程序员的青睐，<code>CentOS</code>发行版操作系统是目前企业使用最多的系统之一</p><p><code>2016年12月12日</code>，<code>CentOS</code>基于<code>Red Hat Enterprise Linux的CentOS Linux 7 (1611)</code>系统正式对外发布</p></blockquote><ul><li><code>Ubuntu</code></li></ul><blockquote><p><code>Ubuntu</code>是一个以桌面应用为主的<code>Linux</code>操作系统，其名称来自非洲南部祖鲁语或豪萨语的“<code>ubuntu</code>”一词（译为吾帮托或乌班图），意思是“人性”、“我的存在是因为大家的存在”，是非洲传统的一种价值观</p><p><code>Ubuntu</code>基于<code>Debian</code>发行版和<code>GNOME</code>桌面环境，<code>Ubuntu</code>发行版操作系统的目标在于为一般用户提供一个最新的、同时稳定的以开放自由软件构建而成的操作系统，目前<code>Ubuntu</code>具有庞大的社区力量，用户可以方便地从社区获得帮助</p></blockquote><ul><li><code>SUSE Linux</code></li></ul><blockquote><p><code>SUSE</code>(发音 /ˈsuːsə/)，<code>SUSE Linux</code>出自德国，<code>SuSE Linux AG</code>公司发行维护的<code>Linux</code>发行版，是属于此公司的注册商标<code>2003年11月4日</code>，<code>Novell</code>表示将会对<code>SUSE</code>提出收购。收购的工作于<code>2004年1月</code>完成。</p><p><code>Novell</code>也向大家保证<code>SUSE</code>的开发工作仍会继续下去，<code>Novell</code>更把公司内全线电脑的系统换成<code>SUSE LINUX</code>，并同时表示将会把<code>SUSE</code>特有而优秀的系统管理程序 - <code>YaST2</code>以<code>GPL</code>授权释出</p></blockquote><ul><li><code>Fedora Linux</code></li></ul><blockquote><p><code>Fedora</code>是一个知名的<code>Linux</code>发行版，是一款由全球社区爱好者构建的面向日常应用的快速、稳定、强大的操作系统。</p><p>它允许任何人自由地使用、修改和重发布，无论现在还是将来。它由一个强大的社群开发。</p><p>这个社群的成员以自己的不懈努力，提供并维护自由、开放源码的软件和开放的标准。<code>Fedora</code>约每六个月会发布新版本</p></blockquote><h3 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h3><hr><p><code>cd</code> </p><blockquote><p>目录切换</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">..</span>   <span class="comment">#上一层目录</span></span><br><span class="line"><span class="keyword">cd</span>   <span class="comment"># 家目录</span></span><br><span class="line"><span class="keyword">cd</span> ~  <span class="comment"># 家目录</span></span><br><span class="line"><span class="keyword">cd</span> / <span class="comment"># 根目录</span></span><br></pre></td></tr></table></figure><p><code>ls</code></p><blockquote><p>浏览目录下的文件或文件夹</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> -a <span class="comment"># 列举所有文件或目录，包含.开头的隐藏文件</span></span><br><span class="line"><span class="keyword">ls</span> -l <span class="comment"># 详细信息列举文件或目录</span></span><br><span class="line"><span class="keyword">ls</span> -i <span class="comment"># 列出每个文件的Inode号</span></span><br><span class="line"><span class="keyword">ls</span> -t <span class="comment"># 根据修改时间列出文件</span></span><br></pre></td></tr></table></figure><p><code>pwd</code></p><blockquote><p>显示当前所处目录</p></blockquote><p><code>mkdir</code></p><blockquote><p>创建目录</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="keyword">a</span> <span class="comment"># 创建a目录</span></span><br><span class="line">mkdir -p <span class="keyword">a</span>/b/c <span class="comment"># 递归创建目录</span></span><br></pre></td></tr></table></figure><p><code>rm</code></p><blockquote><p>删除文件或目录</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm <span class="keyword">a</span> <span class="comment"># 删除a文件</span></span><br><span class="line">rm -r <span class="keyword">a</span> <span class="comment"># 删除a 目录</span></span><br><span class="line">rm -rf <span class="keyword">a</span> <span class="comment"># 强制删除a 文件，不提示确认</span></span><br></pre></td></tr></table></figure><p><code>cp</code></p><blockquote><p>拷贝或备份文件</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="regexp">/root/</span><span class="number">1</span>.py <span class="regexp">/hoom/</span><span class="number">1</span>.py  <span class="comment"># 拷贝文件至新目录下</span></span><br></pre></td></tr></table></figure><p><code>mv</code></p><blockquote><p>重命名或移动文件或目录</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv <span class="regexp">/root/</span><span class="number">1</span>.py <span class="regexp">/hoome/</span><span class="number">1</span>.py.bak <span class="comment"># 移动文件并重命名</span></span><br></pre></td></tr></table></figure><p><code>touch</code></p><blockquote><p>创建普通文件</p></blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">touch</span> <span class="number">1.</span>py # 创建<span class="number">1.</span>py文件</span><br></pre></td></tr></table></figure><p><code>cat</code></p><blockquote><p>查看文件内容</p></blockquote><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="meta-keyword">/etc/</span>redis/redis.conf <span class="meta"># 查看redis.conf文件</span></span><br><span class="line">car -n <span class="meta"># 对输出所有进行编号</span></span><br><span class="line">car -b <span class="meta"># 对输出非空进行编号</span></span><br></pre></td></tr></table></figure><p><code>head</code></p><blockquote><p>查看文件头部内容，通常为十行</p></blockquote><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">head -3 /etc/memcached.conf <span class="comment"># 查看前三行</span></span><br><span class="line">head -n<span class="number"> 100 </span><span class="comment"># 查看前100行</span></span><br><span class="line">head -c<span class="number"> 3 </span><span class="comment"># 查看前三字节</span></span><br></pre></td></tr></table></figure><p><code>tail</code></p><blockquote><p>查看文件头部内容，通常为十行</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail -n <span class="number">3</span> <span class="number">1.</span>txt # 查看后<span class="number">3</span>行</span><br><span class="line">tail -f # 阻塞并即时输出文件变化后追加的数据</span><br></pre></td></tr></table></figure><p><code>chmod</code></p><blockquote><p>修改文件或目录权限</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">775</span> <span class="number">1.</span>py # 赋予文件<span class="number">775</span>权限 rwx rwx r-w</span><br></pre></td></tr></table></figure><p><code>chown</code></p><blockquote><p>修改文件或目录所属组及所属用户</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R root.root <span class="regexp">/tmp/</span>test.txt <span class="comment"># 文件所属用户及所属组均为root</span></span><br></pre></td></tr></table></figure><p><code>df</code></p><blockquote><p>磁盘信息查询</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">df</span> -h <span class="comment"># 查询磁盘使用量</span></span><br><span class="line">df -i <span class="comment"># 分区Inode使用量</span></span><br></pre></td></tr></table></figure><p><code>du</code></p><blockquote><p>查看文件大小</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h <span class="number">1.</span>txt # 查看<span class="number">1.</span>txt文件大小</span><br></pre></td></tr></table></figure><p><code>echo</code></p><blockquote><p>打印或输出内容</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'hello'</span> <span class="comment"># 输出hello</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'hello'</span> &gt; 1.md <span class="comment"># 以hello内容覆盖1.md</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'hello'</span> &gt;&gt; 1.md <span class="comment"># 以hello追加至1.md文件中</span></span><br></pre></td></tr></table></figure><p><code>tar</code></p><blockquote><p>解压或压缩文件</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -<span class="keyword">jxvf </span> <span class="comment"># 解压bz2属性的压缩包</span></span><br><span class="line">tar -zxvf  <span class="comment"># 解压gz属性的压缩包</span></span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tar</span> -czcf <span class="comment"># 使用gzip格式压缩文件</span></span><br><span class="line">tar -cjvf <span class="comment"># 使用bzip2格式压缩文件</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Linux&quot;&gt;&lt;a href=&quot;#Linux&quot; class=&quot;headerlink&quot; title=&quot;Linux&quot;&gt;&lt;/a&gt;Linux&lt;/h3&gt;&lt;hr&gt;&lt;blockquote&gt;
&lt;p&gt;随着IT产业的不断发展，&lt;code&gt;linux&lt;/code&gt; 操作系统应用领域越来越广泛，尤其是近年来 &lt;code&gt;linux&lt;/code&gt;在服务器领域飞速的发展，主要得益于 &lt;code&gt;linux&lt;/code&gt;操作系统具备的如下优点&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://cy-blogs.cn/categories/Linux/"/>
    
    
      <category term="Linux常用命令" scheme="https://cy-blogs.cn/tags/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Ansible-PlayBook</title>
    <link href="https://cy-blogs.cn/Ansible-PlayBook/"/>
    <id>https://cy-blogs.cn/Ansible-PlayBook/</id>
    <published>2019-12-11T05:10:16.013Z</published>
    <updated>2019-12-11T05:03:39.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ansible-playbook"><a href="#ansible-playbook" class="headerlink" title="ansible-playbook"></a>ansible-playbook</h2><blockquote><p>在之前的<code>ansible</code>使用中，我们都是通过命令行的形式实现对应远程主机的响应管理</p><p>但这样的工作方式功能上来说还是有一定的局限性，并且维护并不方便，引入<code>playbook</code>可以更加方便我们对于功能的编写维护，并且具有良好的灵活性</p><p><code>playbook</code>也可以理解为命令行功能的一个合集脚本，用来编写更加复杂的业务</p></blockquote><a id="more"></a><h3 id="yaml语法"><a href="#yaml语法" class="headerlink" title="yaml语法"></a>yaml语法</h3><blockquote><p><code>Yaml</code>为通用数据串行化格式语法，简洁而强大</p><p><code>ansible</code>中的配置文件就采用了<code>Yaml</code>格式语法存在，以下就是对<code>Yaml</code>语法的介绍</p></blockquote><ul><li><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yaml</span></span><br></pre></td></tr></table></figure><p>基本语法规则如下</p><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进的空格数目不唯一，只要相同层级元素左侧对齐即可</li><li><code>#</code>号表示注释</li></ul></li><li><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">yaml</span></span><br></pre></td></tr></table></figure><p>语法支持的数据结构有三种：</p><ul><li>键值对：相当于<code>hash</code>表映射关系，字典</li><li>序列：相当于数组或列表</li><li>纯量（标量）：单独的值，无法继续拆分，比如字符串、整数、浮点数、<code>Null</code>、布尔值（<code>true</code>、<code>false</code>）</li></ul></li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li>字符串定义时，默认可以不使用引号标注</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str_1: abc</span><br><span class="line">&#123;'str_1': 'abc',&#125; <span class="meta"># 对应Python中数据类型</span></span><br></pre></td></tr></table></figure><ul><li>如字符串中出现特殊字符或包含空格，需要使用引号标注</li></ul><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str_2: <span class="symbol">'abc</span>: bbb'</span><br><span class="line">&#123;<span class="symbol">'str_2'</span>: <span class="symbol">'abc</span>: bbb'&#125; # 对应<span class="type">Python</span>中数据类型</span><br></pre></td></tr></table></figure><ul><li>双引号不会对字符串中特殊字符进行转义</li></ul><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str_3: <span class="symbol">'abc</span>: \n bbb'</span><br><span class="line">str_4: <span class="string">"abc: \n bbb"</span></span><br><span class="line">&#123;<span class="symbol">'abc</span>: \\n bbb', <span class="symbol">'str_4'</span>: <span class="symbol">'abc</span>: \n bbb'&#125; # 对应<span class="type">Python</span>中数据类型</span><br></pre></td></tr></table></figure><ul><li>单引号字符串还有引号，需要使用两个单引号进行转义</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str_5: 'a''b'</span><br><span class="line">&#123;'str_5': <span class="string">"a'b"</span>&#125; <span class="meta"># 对应Python中数据类型</span></span><br></pre></td></tr></table></figure><ul><li>当字符串需要换行时，从第二行开始的下面几行，需要有对齐缩进，换行会被解释为空格，其余缩进前空格会忽略</li></ul><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str_6: <span class="symbol">'abc</span></span><br><span class="line">    aaa</span><br><span class="line">    bbb</span><br><span class="line">    ccc'</span><br><span class="line">&#123;<span class="symbol">'str_6'</span>: <span class="symbol">'abc</span> aaa bbb ccc'&#125; # 对应<span class="type">Python</span>中数据类型</span><br></pre></td></tr></table></figure><ul><li>多行字符串可以使用 <code>|</code>保留换行符形成段落，或使用<code>&gt;</code>将换行符替换为空格</li></ul><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">str_7: &gt;  bbb  aaastr_8: |  bbb  aaa&#123;<span class="symbol">'str_7'</span>: <span class="symbol">'bbb</span> aaa\n', <span class="symbol">'str_8'</span>: <span class="symbol">'bbb</span>\naaa\n'&#125; # str_7: &gt;</span><br><span class="line">  bbb</span><br><span class="line">  aaa</span><br><span class="line"></span><br><span class="line">str_8: |</span><br><span class="line">  bbb</span><br><span class="line">  aaa</span><br><span class="line">&#123;<span class="symbol">'str_7'</span>: <span class="symbol">'bbb</span> aaa\n', <span class="symbol">'str_8'</span>: <span class="symbol">'bbb</span>\naaa\n'&#125; # 对应<span class="type">Python</span>中数据类型</span><br><span class="line">对应<span class="type">Python</span>中数据类型</span><br></pre></td></tr></table></figure><ul><li><code>+</code>表示保留字符串末位的换行，<code>-</code>表示删除字符串末位的换行</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str_9: <span class="string">|+</span></span><br><span class="line">  aaabbb</span><br><span class="line"></span><br><span class="line">str_10: <span class="string">|-</span></span><br><span class="line">  aaabbb</span><br><span class="line">'str_9': 'aaabbb\n', 'str_10': 'aaabbb'&#125; <span class="meta"># 对应Python中数据类型</span></span><br></pre></td></tr></table></figure><h4 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h4><ul><li>Yaml中的键值对数据通过冒号定义，冒号后的数据与冒号之间存在一个空格</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dict_1: adict_2: &#123; <span class="number">1</span> : <span class="keyword">a</span> &#125;dict_3: dict_1: <span class="keyword">a</span></span><br><span class="line">dict_2: &#123; <span class="number">1</span> : <span class="keyword">a</span> &#125;</span><br><span class="line">dict_3:</span><br><span class="line">  <span class="variable">a:</span> <span class="number">1</span></span><br><span class="line">  <span class="variable">b:</span> <span class="number">2</span></span><br><span class="line">&#123;<span class="string">'dict_1'</span>: <span class="string">'a'</span>, <span class="string">'dict_2'</span>: &#123;<span class="number">1</span>: <span class="string">'a'</span>&#125;, <span class="string">'dict_3'</span>: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;&#125; # 对应Python中数据类型</span><br><span class="line"> <span class="variable">a:</span> <span class="number">1</span>  <span class="variable">b:</span> <span class="number">2</span>&#123;<span class="string">'dict_1'</span>: <span class="string">'a'</span>, <span class="string">'dict_2'</span>: &#123;<span class="number">1</span>: <span class="string">'a'</span>&#125;, <span class="string">'dict_3'</span>: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;&#125; # 对应Python中数据类型</span><br></pre></td></tr></table></figure><h4 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- list_1</span><br><span class="line">- list_2</span><br><span class="line">-</span><br><span class="line"> - a_1</span><br><span class="line"> - a_2</span><br><span class="line">[<span class="string">'list_1'</span>, <span class="string">'list_2'</span>, [<span class="string">'a_1'</span>, <span class="string">'a_2'</span>]] # 对应<span class="symbol">Python</span>中数据类型</span><br><span class="line">- list_1- list_2- - a_1 - a_2[<span class="string">'list_1'</span>, <span class="string">'list_2'</span>, [<span class="string">'a_1'</span>, <span class="string">'a_2'</span>]] # 对应<span class="symbol">Python</span>中数据类型</span><br></pre></td></tr></table></figure><h4 id="数据嵌套使用"><a href="#数据嵌套使用" class="headerlink" title="数据嵌套使用"></a>数据嵌套使用</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- test_1:</span><br><span class="line">  - a</span><br><span class="line">  - b</span><br><span class="line">- test_2:</span><br><span class="line">    var_1: <span class="literal">true</span></span><br><span class="line">    var_2: <span class="number">0.2</span></span><br><span class="line">[&#123;<span class="string">'test_1'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>]&#125;, &#123;<span class="string">'test_2'</span>: &#123;<span class="string">'var_1'</span>: <span class="literal">True</span>, <span class="string">'var_2'</span>: <span class="number">0.2</span>&#125;&#125;] <span class="meta"># 对应Python中数据类型</span></span><br></pre></td></tr></table></figure><h3 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h3><ul><li><code>playbook</code>的编写使用<code>yaml</code>语法规则，先来看一下最简单的<code>playbook</code></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: all</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Yum Install Apache</span><br><span class="line">    yum: <span class="attribute">name</span>=httpd <span class="attribute">state</span>=installed</span><br><span class="line">    - name: Start Apache Server</span><br><span class="line">    service: <span class="attribute">name</span>=httpd <span class="attribute">state</span>=started</span><br></pre></td></tr></table></figure><blockquote><p>第一行：<code>---</code>指明<code>Ymal</code>将文件解释为正确的文档的要求，<code>Yaml</code>允许可以有多个文档同时出现在一个文件里，每个文档之间由<code>---</code>进行分割，目前我们的<code>playbook</code>中只需要有一个文档即可</p><p>第二行：<code>hosts</code>指明当前<code>playbook</code>将要操作的目标主机有哪些，这里我们选择全部</p><p>第三行：<code>remote_user</code>指明当前操作所使用的远程主机用户</p><p>第四行：<code>tasks</code>为任务列表，<code>playbook</code>将按照从上到下的定义顺序执行其中的模块对应的操作，<code>name</code>属性为一个字符串用以标示当前任务的介绍，第一个任务将使用<code>yum</code>模块安装<code>apache</code>服务，第二个任务使用<code>ansible</code>模块<code>service</code>，使<code>httpd</code>服务启动</p></blockquote><ul><li>执行<code>playbook</code>使用<code>ansible-playbook</code></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook <span class="regexp">/etc/</span>ansible<span class="regexp">/playbook.yml</span></span><br></pre></td></tr></table></figure><h3 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h3><blockquote><p>当遇到较为复杂的情况时，单独的<code>playbook</code>可能无法应对业务需求，那么可能需要编写多个<code>playbook</code></p><p>这时，如果在<code>playbook</code>中的<code>handlers</code>或<code>tasks</code>可能在多个<code>playbook</code>中重复使用，就可以通过<code>ansible</code>所提供的<code>include</code>功能，将复用的部分单独写成一个文件，在需要的地方<code>include</code>包含进来即可</p></blockquote><ul><li>比如有这样的一个功能是需要多次复用的，这个文件叫做<code>tasks.yaml</code></li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--- </span><br><span class="line">- name: Yum Install Nginx</span><br><span class="line">yum: name=nginx <span class="keyword">state</span>=installed</span><br></pre></td></tr></table></figure><ul><li>那么在一个主要<code>playbook</code>文件中可以这样引入</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span>  </span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">    - include:</span> <span class="string">tasks.yml</span></span><br></pre></td></tr></table></figure><ul><li>执行该<code>playbook</code></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook <span class="regexp">/etc/</span>ansible<span class="regexp">/playbook.yml</span></span><br></pre></td></tr></table></figure><ul><li><code>include</code>包含的其他<code>playbook</code>支持模板变量，可以通过定义<code>vars</code>变量覆盖，或者像这样</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Yum</span> <span class="string">Install</span> <span class="string">Nginx</span> </span><br><span class="line"><span class="attr">yum:</span> <span class="string">name=&#123;&#123;</span> <span class="string">server_name</span> <span class="string">&#125;&#125;</span> <span class="string">state=installed</span></span><br></pre></td></tr></table></figure><ul><li><code>playbook</code>文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">all</span> </span><br><span class="line"><span class="attr">tasks:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">include:</span> <span class="string">tasks.yml</span> <span class="string">server_name=nginx</span></span><br></pre></td></tr></table></figure><ul><li>此外在<code>1.4</code>及以上版本中，还支持字典、列表形式的参数传递</li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--- </span><br><span class="line">-name: Yum Install Nginx  </span><br><span class="line">yum: name=&#123;&#123; server_name &#125;&#125; <span class="keyword">state</span>=installed</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">---</span> </span><br><span class="line"><span class="selector-tag">-hosts</span>: <span class="selector-tag">all</span> </span><br><span class="line"><span class="selector-tag">tasks</span>:  </span><br><span class="line"><span class="selector-tag">-</span> &#123; <span class="attribute">include</span>: tasks.yml, server_name: nginx &#125;</span><br></pre></td></tr></table></figure><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><blockquote><p>除去通过<code>include</code>功能将不同的任务分别写入不同的文件，然后按需<code>include</code>包含进来，在<code>ansible</code>中还有一种标准规范叫做<code>role</code>角色</p><p>通过不同级别的层级目录和文件来对变量、任务、配置模板等进行拆分管理，提高扩展性和可维护性</p></blockquote><ul><li>一般来说，一个<code>role</code>角色定义目录结构如下</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">role_name/<span class="comment"># 角色名目录，playbook调用时需要</span></span><br><span class="line">    <span class="built_in">file</span>/<span class="comment"># 存放copy或script等模块调用文件</span></span><br><span class="line">    tasks/<span class="comment"># 存放各种task任务，需要包含一个main.yml</span></span><br><span class="line">    handlers/<span class="comment"># 存放各种handlers任务，需要包含一个main.yml</span></span><br><span class="line">    vars/<span class="comment"># 存放定义好的变量，需要包含一个main.yml</span></span><br><span class="line">    templates/<span class="comment"># 存放需要使用到的配置模板</span></span><br><span class="line">    meta/<span class="comment"># 当前角色的特殊设定及其依赖，需要包含一个main.yml</span></span><br></pre></td></tr></table></figure><ul><li>角色目录存放的路径可以在<code>ansible</code>的配置文件中定义</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="regexp">/etc/</span>ansible<span class="regexp">/ansible.cfgroles_path = /</span>etc<span class="regexp">/ansible/</span>roles</span><br></pre></td></tr></table></figure><ul><li>示例目录结构</li></ul><p><a href="https://lienze.tech/blog/images/1562121857022.png" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/1562121857022.png" alt="1562121857022"></a></p><ul><li>任务<code>tasks</code>目录下<code>main</code>文件内容</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tasks/main.yml- <span class="type">name</span>: Install Apache <span class="keyword">Server</span>  yum: <span class="type">name</span>=httpd state=installed- <span class="type">name</span>: <span class="keyword">Write</span> Apache Config  <span class="keyword">template</span>: src=httpd.j2 dest=/etc/httpd/conf/httpd.conf  <span class="keyword">notify</span>: <span class="keyword">Restart</span> Apache <span class="keyword">Server</span></span><br></pre></td></tr></table></figure><ul><li><code>handlers</code>目录下<code>main</code>文件内容</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># handlers/main.yml- <span class="type">name</span>: <span class="keyword">Restart</span> Apache <span class="keyword">Server</span>  service: <span class="type">name</span>=httpd state=restarted</span><br></pre></td></tr></table></figure><ul><li><code>templates</code>下配置模板</li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># templates/httpd.j2#上面内容太多省略，只保留模板变量部分Listen &#123;&#123; listen_port &#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>变量<code>vars</code>目录下<code>main</code>文件</li></ul><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># vars/main.ymllisten_port: 8000</span></span><br></pre></td></tr></table></figure><ul><li>调用<code>role</code>的<code>playbook</code>文件内容</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="string">hosts:</span> all  <span class="string">remote_user:</span> root  <span class="string">roles:</span> - apache</span><br></pre></td></tr></table></figure><ul><li>在执行角色<code>role</code>此处为<code>apache</code>任务时，会将文件夹下的<code>main.yml</code>文件自动导入合并，执行结果如下</li></ul><p><a href="https://lienze.tech/blog/images/1562122149050.png" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/1562122149050.png" alt="1562122149050"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ansible-playbook&quot;&gt;&lt;a href=&quot;#ansible-playbook&quot; class=&quot;headerlink&quot; title=&quot;ansible-playbook&quot;&gt;&lt;/a&gt;ansible-playbook&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在之前的&lt;code&gt;ansible&lt;/code&gt;使用中，我们都是通过命令行的形式实现对应远程主机的响应管理&lt;/p&gt;
&lt;p&gt;但这样的工作方式功能上来说还是有一定的局限性，并且维护并不方便，引入&lt;code&gt;playbook&lt;/code&gt;可以更加方便我们对于功能的编写维护，并且具有良好的灵活性&lt;/p&gt;
&lt;p&gt;&lt;code&gt;playbook&lt;/code&gt;也可以理解为命令行功能的一个合集脚本，用来编写更加复杂的业务&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://cy-blogs.cn/categories/Linux/"/>
    
    
      <category term="Linux,Ansible-PlayBook" scheme="https://cy-blogs.cn/tags/Linux-Ansible-PlayBook/"/>
    
  </entry>
  
  <entry>
    <title>Paramiko</title>
    <link href="https://cy-blogs.cn/Paramiko/"/>
    <id>https://cy-blogs.cn/Paramiko/</id>
    <published>2019-12-11T05:10:16.009Z</published>
    <updated>2019-12-11T05:09:54.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Paramiko"><a href="#Paramiko" class="headerlink" title="Paramiko"></a>Paramiko</h2><blockquote><p><code>Paramiko</code>是<code>SSHv2</code>协议的<code>Python</code>实现，提供客户端和服务器功能</p><p><code>Paramiko</code>本身是一个围绕<code>SSH</code>网络概念的纯<code>Python</code>接口</p><p>利用<code>paramiko</code>我们可以通过<code>Python</code>方便的进行<code>ssh</code>操作</p></blockquote><a id="more"></a><p>+++</p><blockquote><p>paramiko<code>包含两个核心组件：</code>SSHClient<code>和</code>SFTPClient</p></blockquote><h3 id="SSHClient"><a href="#SSHClient" class="headerlink" title="SSHClient"></a>SSHClient</h3><p>+++</p><blockquote><p><code>SSHClient</code>的作用类似于<code>Linux</code>的<code>ssh</code>命令，是对<code>SSH</code>会话的封装</p><p>该类封装了传输<code>Transport</code>，通道<code>Channel</code>及<code>SFTPClient</code>建立的方法<code>open_sftp</code>，通常用于执行远程命令</p></blockquote><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><ul><li><code>class paramiko.client.SSHClient</code></li></ul><blockquote><p>创建<code>SSH</code>客户端实例</p></blockquote><ul><li><code>SSHClient.connect(hostname, port=22, username=None, password=None, pkey=None, key_filename=None, timeout=None, allow_agent=True, look_for_keys=True, compress=False..)</code></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数解释</span></span><br><span class="line">- hostname：连接的目标主机</span><br><span class="line">- <span class="attribute">port</span>=SSH_PORT：指定端口</span><br><span class="line">- <span class="attribute">username</span>=None：验证的用户名</span><br><span class="line">- <span class="attribute">password</span>=None：验证的用户密码</span><br><span class="line">- <span class="attribute">pkey</span>=None：私钥方式用于身份验证</span><br><span class="line">- <span class="attribute">key_filename</span>=None：一个文件名或文件列表，指定私钥文件</span><br><span class="line">- <span class="attribute">timeout</span>=None：可选的tcp连接超时时间</span><br><span class="line">- <span class="attribute">allow_agent</span>=<span class="literal">True</span>：是否允许连接到ssh代理，默认为True 允许</span><br><span class="line">- <span class="attribute">look_for_keys</span>=<span class="literal">True</span>：是否在~/.ssh中搜索私钥文件，默认为True 允许</span><br><span class="line">- <span class="attribute">compress</span>=<span class="literal">False</span>：是否打开压缩</span><br></pre></td></tr></table></figure><blockquote><p>通过验证连接远程服务端</p></blockquote><hr><ul><li><code>SSHClient.exec_command(command, bufsize=-1, timeout=None, get_pty=False, environment=None)</code></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 参数解释</span></span><br><span class="line"><span class="bullet">- </span>command：要执行的命令</span><br><span class="line"><span class="bullet">- </span>bufsize：与Python中文件对象的同名函数解释相同，缓冲区大小</span><br><span class="line"><span class="bullet">- </span>timeout：设置命令的超时相应事件</span><br><span class="line"><span class="bullet">- </span>get_pty：从服务器请求一个伪终端（默认为假）</span><br><span class="line"><span class="bullet">- </span>environment：一个当前shell环境的字典，远程命令的默认执行环境</span><br></pre></td></tr></table></figure><blockquote><p><code>command</code>参数为要执行的<code>shell</code>命令，打开一个新通道并执行请求的命令</p><p>该函数的返回结果为一个元组，其中包含<code>stdin</code>、<code>stdout</code>和<code>stderr</code>，也就是我们常见的标准输入，输出以及出错</p><p>一般来说，命令的结果我们将通过<code>stdout</code>进行获取</p></blockquote><hr><ul><li><code>SSHClient.close()</code></li></ul><blockquote><p>关闭<code>SSH</code>连接</p></blockquote><hr><ul><li><code>SSHClient.invoke_shell(term=’vt100’, width=80, height=24, width_pixels=0, height_pixels=0, environment=None)</code></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 参数解释</span></span><br><span class="line"><span class="bullet">- </span>term：模拟终端类型</span><br><span class="line"><span class="bullet">- </span>width：终端长度</span><br><span class="line"><span class="bullet">- </span>height：终端宽度</span><br><span class="line"><span class="bullet">- </span>width_pixels：终端的像素宽度</span><br><span class="line"><span class="bullet">- </span>height_pixels：终端的像素高度</span><br><span class="line"><span class="bullet">- </span>environment：命令的shell环境</span><br></pre></td></tr></table></figure><blockquote><p>在<code>ssh</code>服务器上启动交互式<code>shell</code>会话</p><p>一个新的通道被打开并连接到，使用请求的终端类型和大小的伪终端，并作为返回值</p><p>换句通俗的话来讲，就是创建了一个实际的<code>shell</code>窗口空间进行命令交互</p></blockquote><hr><ul><li><code>SSHClient.set_missing_host_key_policy(policy)</code></li></ul><blockquote><p>设置连接到没有已知主机密钥的服务器时要使用的策略</p><p>常见使用策略为<code>paramiko.client.AutoAddPolicy</code>，其意义为自动将主机名和新主机密钥添加到本地主机密钥对象并保存</p></blockquote><h4 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h4><blockquote><p>以下是一个简单的通过<code>SSHClient</code>建立的通道进行命令的传输与返回结果的获取的代码！</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(hostname,username,password)</span>:</span></span><br><span class="line">client = paramiko.SSHClient() </span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    <span class="comment"># 设置密钥策略</span></span><br><span class="line">client.connect(hostname,username=username,password=password)</span><br><span class="line">    <span class="comment"># 连接主机</span></span><br><span class="line"><span class="keyword">return</span> client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec_cmd</span><span class="params">(client,cmd)</span>:</span></span><br><span class="line">stdin,stdout,stderr = client.exec_command(cmd)</span><br><span class="line"><span class="keyword">return</span> stdout.read().decode(),stderr.read().decode()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">hostname = <span class="string">'192.168.0.104'</span></span><br><span class="line">username = <span class="string">'pi'</span></span><br><span class="line">password = <span class="string">'123456'</span></span><br><span class="line">cmd = <span class="string">'ps -aux'</span></span><br><span class="line"></span><br><span class="line">client = connect(hostname,username,password)</span><br><span class="line">res = exec_cmd(client, cmd)</span><br><span class="line"><span class="keyword">if</span> res[<span class="number">0</span>]:</span><br><span class="line">print(res[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> res[<span class="number">1</span>]:</span><br><span class="line">print(<span class="string">'[E]:\n'</span>,res[<span class="number">1</span>])</span><br><span class="line">client.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码通过默认建立好的连接对象进行命令的传输以及返回结果的获取</p></blockquote><h4 id="invoke-shell"><a href="#invoke-shell" class="headerlink" title="invoke_shell"></a>invoke_shell</h4><ul><li>接下来使用<code>invoke_shell</code>进行虚拟终端的连接，首先初始化<code>SSH</code>通道</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SSHChannle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, username, password, port=<span class="number">22</span>)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">            初始化SSH通道</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.sh = paramiko.SSHClient()</span><br><span class="line">        self.sh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">        self.sh.connect(host, username=username, password=password)</span><br><span class="line">        self.channle = self.sh.invoke_shell()</span><br><span class="line">        self.cmd = <span class="string">''</span></span><br></pre></td></tr></table></figure><ul><li>思路为开启两个线程，分别负责命令的接收与命令的发送</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ssh_recv</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        接收SSH通道中发来的消息</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> self.channle.exit_status_ready():</span><br><span class="line">        <span class="comment"># 如果远程进程已退出并返回退出状态，则返回true</span></span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            buf = self.channle.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            print(buf,end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">            print(ex)</span><br><span class="line">        sys.stdout.flush()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_ssh_cmd</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        发送命令给SSH通道</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> self.channle.exit_status_ready():</span><br><span class="line">        self.cmd = input()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.channle.send(self.cmd + <span class="string">'\r'</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">            print(ex)</span><br><span class="line">        <span class="comment"># sys.stdin.flush()</span></span><br></pre></td></tr></table></figure><ul><li>在实例中定义<code>run</code>函数用来开启两个线程并负责线程的资源回收以及SSH通道的关闭</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    ssh_recv_thread = threading.Thread(target=self.get_ssh_recv)</span><br><span class="line">    ssh_send_thread = threading.Thread(target=self.send_ssh_cmd)</span><br><span class="line">    ssh_recv_thread.start()</span><br><span class="line">    ssh_send_thread.start()</span><br><span class="line"></span><br><span class="line">    ssh_recv_thread.join()</span><br><span class="line">    ssh_send_thread.join()</span><br><span class="line"></span><br><span class="line">    self.sh.close()  <span class="comment"># 关闭通道</span></span><br></pre></td></tr></table></figure><ul><li>在<code>win</code>下的<code>CMD</code>中查看效果，其中的乱码格式其实为连接后命令传输的特殊标记格式，可以在后面结合前端中类似<code>xterm.js</code>等插件查看到实际花里胡哨的效果</li></ul><p><a href="https://lienze.tech/blog/images/invoke_shell.gif" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/invoke_shell.gif" alt="invoke_shell"></a></p><h3 id="SFTPClient"><a href="#SFTPClient" class="headerlink" title="SFTPClient"></a>SFTPClient</h3><blockquote><p><code>SFTPClient</code>的作用类似与<code>Linux</code>的<code>sftp</code>命令，是对<code>SFTP</code>客户端的封装</p><p>用以实现远程文件操作，如文件上传、下载、修改文件权限等操作</p></blockquote><h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><ul><li>官方文档</li></ul><blockquote><p>docs.paramiko.org/en/2.4/api/sftp.html</p></blockquote><ul><li><code>sftp=paramiko.SFTPClient.from_transport(t,window_size=None,max_packet_size=None)</code></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 参数解释- t：该参数可以通过paramiko.<span class="constructor">Transport( (<span class="params">ip</span>,<span class="params">port</span> )</span>)，创建一个已通过验证的传输通道，参数为IP和端口的二元组</span><br></pre></td></tr></table></figure><blockquote><p>根据参数<code>t</code>指定的已验证传输通道进行<code>SFTP</code>客户端的创建</p></blockquote><ul><li><code>sftp.put(localpath, remotepath, callback=None, confirm=True)</code></li></ul><blockquote><p>上传本地路径为<code>localpath</code>的文件到目标主机<code>remotepath</code>处</p></blockquote><ul><li><code>sftp.get(remotepath, localpath, callback=None)</code></li></ul><blockquote><p>下载远程路径为<code>remotepath</code>路径的的文件到本地主机<code>localpath</code>处</p></blockquote><ul><li><code>open(filename, mode=’r’, bufsize=-1)</code></li></ul><blockquote><p>打开位于远程主机上的文件，与<code>open</code>函数类似，返回文件对象</p></blockquote><ul><li><code>listdir(path=&#39;.&#39;)</code></li></ul><blockquote><p>返回给定路径下文件及目录的列表，默认路径为当前工作目录</p></blockquote><ul><li><code>chdir(path=None)</code></li></ul><blockquote><p>修改当前<code>SFTP</code>连接会话的工作目录</p></blockquote><ul><li><code>lstat(path)</code></li></ul><blockquote><p>检索当前<code>path</code>所指向的文件信息</p></blockquote><ul><li><code>mkdir(path,mode=511)</code></li></ul><blockquote><p>根据<code>path</code>在目标主机创建默认权限为<code>511</code>的目录</p></blockquote><ul><li><code>rmdir(path)</code></li></ul><blockquote><p>删除给定<code>path</code>所指向的目录</p></blockquote><ul><li><code>remove(path)</code></li></ul><blockquote><p>删除给定<code>path</code>所指向的文件</p></blockquote><h4 id="实例代码-1"><a href="#实例代码-1" class="headerlink" title="实例代码"></a>实例代码</h4><blockquote><p>以下是一个比较简陋的关于<code>SFTPClient</code>的测试代码</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connecnt</span><span class="params">(hostname,username,password)</span>:</span> <span class="comment">#创建连接对象</span></span><br><span class="line">    client = paramiko.Transport( (hostname,<span class="number">22</span>))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        client.connect(username=username,password=password)</span><br><span class="line">    <span class="keyword">except</span> paramiko.SSHException:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    sftp_client = paramiko.SFTPClient.from_transport(client)</span><br><span class="line">    <span class="keyword">return</span> sftp_client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    hostname = <span class="string">'192.168.0.104'</span></span><br><span class="line">    username = <span class="string">'pi'</span></span><br><span class="line">    password = <span class="string">'123456'</span></span><br><span class="line">    sftp_client = connecnt(hostname,username,password)</span><br><span class="line">    remotefile_path = <span class="string">'/home/pi/test'</span> <span class="comment"># 目标主机文件路径</span></span><br><span class="line">    localfile_path = <span class="string">'/home/test'</span> <span class="comment"># 本地主机文件路径</span></span><br><span class="line"></span><br><span class="line">    sftp_client.put(localfile_path, remotefile_path) <span class="comment">#上传本地test文件到远程</span></span><br><span class="line">    sftp_client.get(remotefile_path, localfile_path) <span class="comment">#下载远程test文件到本地</span></span><br><span class="line">    print(sftp_client.listdir())</span><br><span class="line">    print(<span class="string">'--------------------'</span>)</span><br><span class="line">    print(sftp_client.lstat(remotefile_path))</span><br><span class="line">    print(<span class="string">'--------------------'</span>)</span><br><span class="line">    <span class="keyword">with</span> sftp_client.open(remotefile_path) <span class="keyword">as</span> fp:</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Paramiko&quot;&gt;&lt;a href=&quot;#Paramiko&quot; class=&quot;headerlink&quot; title=&quot;Paramiko&quot;&gt;&lt;/a&gt;Paramiko&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Paramiko&lt;/code&gt;是&lt;code&gt;SSHv2&lt;/code&gt;协议的&lt;code&gt;Python&lt;/code&gt;实现，提供客户端和服务器功能&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Paramiko&lt;/code&gt;本身是一个围绕&lt;code&gt;SSH&lt;/code&gt;网络概念的纯&lt;code&gt;Python&lt;/code&gt;接口&lt;/p&gt;
&lt;p&gt;利用&lt;code&gt;paramiko&lt;/code&gt;我们可以通过&lt;code&gt;Python&lt;/code&gt;方便的进行&lt;code&gt;ssh&lt;/code&gt;操作&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://cy-blogs.cn/categories/Linux/"/>
    
    
      <category term="Paramiko" scheme="https://cy-blogs.cn/tags/Paramiko/"/>
    
  </entry>
  
  <entry>
    <title>Ansible</title>
    <link href="https://cy-blogs.cn/Ansible/"/>
    <id>https://cy-blogs.cn/Ansible/</id>
    <published>2019-12-10T12:35:38.500Z</published>
    <updated>2019-12-10T12:35:24.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h2><blockquote><p><code>ansible</code>基于Python开发，集合了众多运维工具（<code>puppet</code>、<code>cfengine</code>、<code>chef</code>、<code>func</code>、<code>fabric</code>）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能<br>在使用时，<code>ansible</code>不需要在被控制安装客户端，<code>ansible</code>工作基于<code>ssh</code>，只要被控制端服务器有<code>ssh</code>服务，加上一个<code>Python</code>环境，就可以使用<code>ansible</code><br>另外，<code>ansible</code>在15年的时候，以1.5亿美元被<code>RedHat</code>公司收购，新版的<code>RedHat</code>操作系统内置<code>ansible</code>软件，很厉害的</p></blockquote><a id="more"></a><p>##Ansible部署</p><blockquote><p><code>ansible</code>安装可以通过源码，<code>yum</code>源以及<code>python</code>所提供的<code>pip</code>管理工具进行安装</p></blockquote><ul><li>使用pip管理工具进行安装</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install ansible</span><br></pre></td></tr></table></figure><ul><li>使用<code>yum</code>进行安装</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release <span class="comment"># 安装扩展源</span></span><br><span class="line">yum install ansible</span><br></pre></td></tr></table></figure><h2 id="Ansible配置"><a href="#Ansible配置" class="headerlink" title="Ansible配置"></a>Ansible配置</h2><blockquote><p>安装之后，默认<code>ansible</code>工具的配置文件在<code>/etc/ansible</code>下</p><p>如通过<code>pip</code>命令安装，是没有这个目录的，需要我们手动创建，其中所需主要配置文件如下</p></blockquote><ul><li><code>ansible.cfg</code>：<code>ansible</code>主配置文件</li><li><code>hosts</code>：被管理主机<code>IP</code>或者主句名列表文件，也是比较重要的一个文件</li><li><code>roles</code>：角色或插件目录（默认为空）</li></ul><blockquote><p>此外除了默认的<code>ansible</code>的配置文件路径，关于<code>ansible</code>的配置文件路径选择还有如下几种，按照序列表示优先级</p></blockquote><ul><li><code>export ANSIBLE_CONFI</code>：指定的全局变量</li><li><code>./ansible.cfg</code>：当前目录下的配置文件</li><li><code>~/.ansible.cfg</code>：当前用户目下的配置文件</li><li><code>/ext/ansible/ansible.cfg</code>：<code>etc</code>目录下的配置文件</li></ul><blockquote><p>如果以上四个路径下均没有<code>cfg</code>配置文件，则使用默认配置</p><p>如果通过源码进行安装，那么在<code>/etc/ansible</code>目录下会自动包含<code>ansible.cfg</code>文件</p><p>也可以通过访问在线的配置文件地址进行获取</p></blockquote><blockquote><p><a href="https://raw.githubusercontent.com/ansible/ansible/devel/examples/ansible.cfg" target="_blank" rel="noopener">https://raw.githubusercontent.com/ansible/ansible/devel/examples/ansible.cfg</a></p></blockquote><ul><li><code>ansible</code>配置文件中可以进行<code>ansible</code>的各项参数的设置，包括并发线程数量、用户、模块路径、调优等等<ul><li><code>defaluts</code>：默认的配置项，一般不需要修改</li><li><code>privilege_escalation</code>：执行命令的用户权限设置</li><li><code>paramiko_connection</code>：<code>paramiko</code>插件设置</li><li><code>ssh_connection</code>：<code>ssh</code>连接设置</li></ul></li><li>默认<code>ansible</code>使用<code>hosts</code>文件列举监控主句，格式为<code>ini</code>，可以进行<code>IP</code>的分组以及<code>IP</code>规则设置，比如如下的例子</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[webserver]</span></span><br><span class="line">192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.1001</span><span class="selector-pseudo">:22</span></span><br></pre></td></tr></table></figure><blockquote><p><code>ansible</code>支持很多模块来进行对被控制主机的管理，包括：<code>command</code>、<code>shell</code>、<code>script</code>、<code>yum</code>、<code>copy</code>、<code>File</code>、<code>async</code>、<code>docker</code>、<code>cron</code>、<code>mysql_user</code>、<code>ping</code>、<code>sysctl</code>、<code>user</code>、<code>acl</code>、<code>add_host</code>、<code>easy_install</code>、<code>haproxy</code>等。默认在执行命令时，使用模块为、<code>command</code>，接下来会进行介绍</p></blockquote><h2 id="Ansible使用参数"><a href="#Ansible使用参数" class="headerlink" title="Ansible使用参数"></a>Ansible使用参数</h2><blockquote><p><code>ansible</code>在工作时，需要使用我们安装好的、<code>ansible</code>来执行命令</p><p>经常在使用、<code>ansible</code>模块进行工作时，可能还需要额外提供一些参数来辅助工作，下面是常用参数</p></blockquote><table><thead><tr><th>命令参数</th><th>解释</th></tr></thead><tbody><tr><td><code>-v</code></td><td>打印详细信息</td></tr><tr><td><code>-m</code></td><td>指定使用的模块，默认为 <code>command</code>模块</td></tr><tr><td><code>-k</code></td><td>要求输入远程主机密码</td></tr><tr><td><code>-a</code></td><td>将参数或命令传入模块</td></tr><tr><td><code>-c</code></td><td>测试执行过程，但不真正执行</td></tr><tr><td><code>-sudo</code></td><td>基于 <code>sudo</code>用户执行</td></tr><tr><td><code>--list-hosts</code></td><td>列举命令生效的主机</td></tr><tr><td><code>-l</code></td><td>限制匹配规则的主机数</td></tr><tr><td><code>-i</code></td><td>指定 <code>hosts</code>文件路径</td></tr><tr><td><code>-u</code></td><td><code>SSH</code> 连接所使用用户</td></tr></tbody></table><blockquote><p>现在看到这些命令参数你可能有一些懵，不过不要着急，结合模块使用，你将很快了解这些参数的实际意义</p></blockquote><h2 id="配置免密登陆"><a href="#配置免密登陆" class="headerlink" title="配置免密登陆"></a>配置免密登陆</h2><blockquote><p>由于 <code>ansible</code>是通过 <code>ssh</code> 服务进行命令下达执行，那避免不了用户认证</p><p>但是在批量执行时，多次的重复认证会导致我们的效率极其低下，这里可以通过配置主控端与被控端知己之间 <code>SSH</code> 免密登陆来实现用户认证的跳过，可谓是一次配置，轻松很久</p></blockquote><ul><li>在主控服务器 <code>192.168.1.104</code> 下生成密钥</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="comment"># -t 指定加密的方式，默认为rsa</span></span><br></pre></td></tr></table></figure><ul><li>进行秘钥的分布</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@<span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span></span><br></pre></td></tr></table></figure><ul><li>输入对应远程主机的 <code>ssh</code> 账号密码之后，接下来在主控服务器就可以不进行 <code>SSH</code> 的用户认证也可以访问到被控制端，这里测试主机为 <code>192.168.1.104</code> （主控）， <code>192.168.1.101</code> （被控）</li></ul><h2 id="定义主机及组规则"><a href="#定义主机及组规则" class="headerlink" title="定义主机及组规则"></a>定义主机及组规则</h2><blockquote><p><code>ansible</code> 通过定义好的主句以组规则（<code>Inventory</code>） 在执行命令时通过匹配进行远程操作</p><p>这个文件默认就是我们上面所说的 <code>/etc/ansible/hosts</code> 文件，其中定义的几种方式如下</p></blockquote><ul><li>直接 <code>IP</code> 写入</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span></span><br></pre></td></tr></table></figure><ul><li>规则分组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[webserver]</span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span>:<span class="number">2333</span></span><br><span class="line">www.example.com</span><br></pre></td></tr></table></figure><blockquote><p>可以在规则的 <code>IP</code> 后指定端口</p></blockquote><ul><li>规则命名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myhost ansible_ssh_host=<span class="number">192.168</span><span class="number">.1</span><span class="number">.101</span></span><br><span class="line">[webservers]</span><br><span class="line">myhost</span><br></pre></td></tr></table></figure><blockquote><p>在使用时，直接利用<code>myhost</code>即可</p><p>除去示例中的指定方式，还有如下一些参数可以利用</p></blockquote><ul><li><code>ansible_ssh_host</code>：目标主机地址</li><li><code>ansible_ssh_port</code>：目标主机<code>ssh</code>服务端口</li><li><code>ansible_ssh_user</code>：目标主机<code>ssh</code>登录用户</li><li><code>ansible_ssh_pass</code>：目标主机<code>ssh</code>登录密码</li><li><code>ansible_connection</code>：连接类型：<code>local</code>、<code>ssh</code>、<code>paramiko</code></li><li><code>ansible_ssh_priveate_key_file</code>：连接所需<code>ssh</code>私钥文件；</li><li><code>ansible_shell_type</code>：目标主机的shell类型：<code>ash</code>、<strong>bash</strong>（默认使用的<code>shell</code>，可以结合<code>help</code>查看帮助文档）、<code>ksh</code>（支持42个内部命令）、<code>csh</code>、<code>zsh</code>（最庞大的shell，支持84个内部命令）</li><li>正则规则</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">webservers</span>][<span class="symbol">a:z</span>]bc.example.com192.168.1.10[1:5]</span><br></pre></td></tr></table></figure><blockquote><p>在主机处填写对应的正则规则，可以更加方便的映射某个网段下的<code>ip</code>地址</p></blockquote><h3 id="Ping模块"><a href="#Ping模块" class="headerlink" title="Ping模块"></a>Ping模块</h3><blockquote><p>ping模块可以判断被控主机是否在线， 返回值为changed和ping</p><p>首先在<code>/etc/ansible/hosts</code>文件下添加被控主机，并建立分组为<strong>webservers</strong></p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[webservers]</span>192<span class="selector-class">.168</span><span class="selector-class">.1</span><span class="selector-class">.101</span><span class="selector-pseudo">:22</span></span><br></pre></td></tr></table></figure><ul><li><code>ping</code>命令的用法，要进入到<code>python</code>安装目录下，找到对应的<code>ansible</code>可执行文件</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ansible <span class="keyword">all</span> -m ping</span><br></pre></td></tr></table></figure><blockquote><p>返回值<code>ping</code>如果为<code>pong</code>则代表可以<code>ping</code>通</p><p><code>ansible</code>命令行第二个参数可以是一个主机的正则规则，<code>all</code>代表所有<code>hosts</code>文件下<code>IP</code>，也可以指定使用某个分组</p></blockquote><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ansible webservers -m <span class="built_in">ping</span></span><br></pre></td></tr></table></figure><h3 id="Command模块"><a href="#Command模块" class="headerlink" title="Command模块"></a>Command模块</h3><blockquote><p>通过<code>ansible</code>执行命令时，默认使用<code>command</code>模块，该模块主要用于执行<code>linux</code>基础命令</p></blockquote><ul><li>注意：对比之后的<code>Shell</code>及<code>Script</code>功能模块，<code>Command</code>模块不支持管道</li><li><code>command</code>支持的额外参数</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./ansible-doc</span> -s <span class="keyword">command</span><span class="comment"># 文档</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>chdir</code></td><td align="left">执行命令时，先进入到该目录下</td></tr><tr><td align="left"><code>creates</code></td><td align="left">给定文件存在时，不执行该命令</td></tr><tr><td align="left"><code>free_form</code></td><td align="left">需要执行的脚本</td></tr><tr><td align="left"><code>removes</code></td><td align="left">给定文件存在，则执行该命令</td></tr></tbody></table><ul><li>对远程主机执行命令</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./ansible</span> webservers -m <span class="keyword">command</span> -a <span class="string">"ifconfig"</span></span><br></pre></td></tr></table></figure><ul><li>执行命令时更改工作目录</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./ansible</span> webservers -m <span class="keyword">command</span> -a <span class="string">"ls chdir=/home/"</span></span><br></pre></td></tr></table></figure><h3 id="Shell模块"><a href="#Shell模块" class="headerlink" title="Shell模块"></a>Shell模块</h3><blockquote><p><code>shell</code>使用远程主机下的<code>/bin/sh</code>进行命令执行，支持比<code>command</code>模块更多的命令，常用参数如下</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ansible-doc -s <span class="keyword">shell</span><span class="bash"><span class="comment"># 文档</span></span></span><br></pre></td></tr></table></figure><ul><li>额外参数</li></ul><table><thead><tr><th align="left">参数</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>chdir</code></td><td align="left">执行命令时，先进入到该目录下</td></tr><tr><td align="left"><code>creates</code></td><td align="left">给定文件存在时，不执行该命令</td></tr><tr><td align="left"><code>free_form</code></td><td align="left">需要执行的脚本</td></tr><tr><td align="left"><code>removes</code></td><td align="left">给定文件存在，则执行该命令</td></tr><tr><td align="left"><code>executable</code></td><td align="left">更换执行命令所使用的<code>shell</code>环境</td></tr></tbody></table><ul><li>远程主机编写<code>sh</code>脚本，向屏幕输出<code>hello</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"hello"</span></span><br></pre></td></tr></table></figure><ul><li>执行远程主机的<code>shell</code>脚本</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ansible webservers -m <span class="keyword">shell</span><span class="bash"> -a <span class="string">"sh ~/test.sh"</span></span></span><br></pre></td></tr></table></figure><h3 id="Script模块"><a href="#Script模块" class="headerlink" title="Script模块"></a>Script模块</h3><blockquote><p>该模块可以方便运行当前管理机上的脚本直接到远程被控端，而不需要先将脚本拷贝到远程主机后在执行</p></blockquote><ul><li>在主控制<code>home</code>目录下创建<code>sh</code>脚本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"this is Control"</span></span><br></pre></td></tr></table></figure><ul><li>将这个<code>sh</code>脚本通过<code>script</code>模块执行到远程被控端</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ansible webservers -m<span class="built_in"> script </span>-a <span class="string">"/root/test.sh"</span></span><br></pre></td></tr></table></figure><h3 id="Copy模块"><a href="#Copy模块" class="headerlink" title="Copy模块"></a>Copy模块</h3><blockquote><p><code>copy</code>模块可以方便的将当前主机下文件拷贝到远程主机，类似<code>scp</code>命令等</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ansible-doc -s <span class="keyword">copy</span><span class="bash"><span class="comment"># 文档地址</span></span></span><br></pre></td></tr></table></figure><ul><li>支持的参数</li></ul><table><thead><tr><th align="left">参数</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>src</code></td><td align="left">将本地路径复制到远程服务器; 可以是绝对路径或相对的。如果是一个目录，它将被递归地复制。如果路径以/结尾，则只有该目录下内容被复制到目的地，如果没有使用/来结尾，则包含目录在内的整个内容全部复制</td></tr><tr><td align="left"><code>content</code></td><td align="left">当用<code>content</code>代替<code>src</code>参数的时候，可以把文档的内容设置到特定的值</td></tr><tr><td align="left"><code>dest</code></td><td align="left">目标绝对路径。如果<code>src</code>是一个目录，<code>dest</code>也必须是一个目录。如果<code>dest</code>是不存在的路径，并且如果<code>dest</code>以/结尾或者<code>src</code>是目录，则<code>dest</code>被创建。如果<code>src</code>和<code>dest</code>是文件，如果<code>dest</code>的父目录不存在，任务将失败</td></tr><tr><td align="left"><code>backup</code></td><td align="left">如果文件修改，则在覆盖之前将原文件备份，备份文件包含时间信息</td></tr><tr><td align="left"><code>directory_mode</code></td><td align="left">设定目录的权限，在新建时使用，不会影响已存在的目录</td></tr><tr><td align="left"><code>force</code></td><td align="left">当目标内容不同于源时，将替换远程文件。设置为<code>no</code>时，只有在目标文件不存在的情况下才会传输文件</td></tr><tr><td align="left"><code>group</code></td><td align="left">设置文件/目录的所属组</td></tr><tr><td align="left"><code>mode</code></td><td align="left">设置文件权限</td></tr><tr><td align="left"><code>owner</code></td><td align="left">设置文件/目录的所属用户</td></tr></tbody></table><h3 id="Copy前备份"><a href="#Copy前备份" class="headerlink" title="Copy前备份"></a>Copy前备份</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ansible all -m copy -a <span class="string">"src=/root/ansible_copy_file backup=yes dest=/home/"</span></span><br></pre></td></tr></table></figure><blockquote><p>在第一次拷贝时，由于目标主机还并没有这个文件， 备份动作不生效</p><p>在对文件内容进行修改后重新执行该命令拷贝文件</p><p>此时目标主机下，不光会有我们上传的拷贝文件，还有之前文件的一个备份</p></blockquote><h4 id="覆盖内容"><a href="#覆盖内容" class="headerlink" title="覆盖内容"></a>覆盖内容</h4><blockquote><p>直接通过<code>content</code>参数指定内容，并对目标主机上已存在的<code>test_copy</code>文件进行覆盖</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ansible all -m <span class="keyword">copy</span><span class="bash"> -a <span class="string">"content='这是命令修改\n'  dest=/home/test_copy"</span></span></span><br></pre></td></tr></table></figure><blockquote><p>这条命令将会把远程主机<code>home</code>目录下的<code>test_copy</code>文件覆盖为我们的<code>content</code>内容</p></blockquote><h3 id="Stat模块"><a href="#Stat模块" class="headerlink" title="Stat模块"></a>Stat模块</h3><blockquote><p>该模块可以获取远程主机下的文件信息，需要使用<code>path</code>参数指明文件路径</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ansible all -m stat -<span class="selector-tag">a</span> <span class="string">"path=/home/test_copy"</span></span><br></pre></td></tr></table></figure><h3 id="Yum模块"><a href="#Yum模块" class="headerlink" title="Yum模块"></a>Yum模块</h3><blockquote><p>该模块可以对远程主机上的软件安装、卸载进行管理</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ansible-doc -s <span class="keyword">copy</span><span class="bash"><span class="comment"># 文档</span></span></span><br></pre></td></tr></table></figure><ul><li>支持参数</li></ul><table><thead><tr><th align="left">参数</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">name</td><td align="left">必须参数，用于指定需要管理的软件包，比如<code>nginx</code></td></tr><tr><td align="left">state</td><td align="left">用于指定软件包的状态，默认值为<code>present</code>，表示确保软件包已经安装 除了<code>present</code>，其他可用值有<code>installed</code>、<code>latest</code>、<code>absent</code>、<code>removed</code> 其中<code>installed</code>与<code>present</code>等效，<code>latest</code>表示安装<code>yum</code>中最新的版本，<code>absent</code>和<code>removed</code>等效，表示删除对应的软件包</td></tr></tbody></table><ul><li>在远程主机下安装<code>nginx</code></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ansible all -m yum -<span class="selector-tag">a</span> <span class="string">"name=nginx state=installed"</span></span><br></pre></td></tr></table></figure><ul><li>查看<code>nginx</code>服务状态</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systemctl status nginx</span></span><br></pre></td></tr></table></figure><h3 id="Service模块"><a href="#Service模块" class="headerlink" title="Service模块"></a>Service模块</h3><blockquote><p>该模块主要用于远程服务器上对应的服务管理，比如开启或关闭<code>apache</code>服务等</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./ansible-doc</span> -s yum<span class="comment"># 文档</span></span><br></pre></td></tr></table></figure><ul><li>支持参数</li></ul><table><thead><tr><th align="left">参数</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>name</code></td><td align="left">需要管理的服务名称，如<code>nginx</code></td></tr><tr><td align="left"><code>state</code></td><td align="left">此参数用于指定服务的状态 比如，我们想要启动远程主机中的<code>nginx</code>，则可以将<code>state</code>的值设置为<code>started</code> 如果想要停止远程主机中的服务，则可以将<code>state</code>的值设置为<code>stopped</code> 此参数的可用值有<code>started</code>、<code>stopped</code>、<code>restarted</code>、<code>reloaded</code></td></tr><tr><td align="left"><code>enabled</code></td><td align="left">此参数用于指定是否将服务设置为开机启动项，设置为<code>yes</code>表示将对应服务设置为开机启动，设置为<code>no</code>表示不会开机启动</td></tr></tbody></table><ul><li>将远程主机下的<code>httpd</code>服务开启</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ansible all -m<span class="built_in"> service </span>-a <span class="string">"name=httpd state=started"</span></span><br></pre></td></tr></table></figure><h3 id="File模块"><a href="#File模块" class="headerlink" title="File模块"></a>File模块</h3><blockquote><p><code>file</code>模块可以帮助我们完成一些对文件的基本操作</p><p>比如，<strong>创建文件</strong>或<strong>目录</strong>、<strong>删除文件</strong>或<strong>目录</strong>、<strong>修改文件权限</strong>等</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./ansible-doc</span> -s yum<span class="comment"># 文档</span></span><br></pre></td></tr></table></figure><ul><li>支持参数</li></ul><table><thead><tr><th align="left">参数</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left"><code>path</code></td><td align="left">指明需要操作的文件或目录路径</td></tr><tr><td align="left"><code>state</code></td><td align="left">此参数非常灵活，其对应的值需要根据情况设定。比如，我们想要在远程主机上创建<code>/testdir/a/b</code>目录，那么则需要设置<code>path=/testdir/a/b</code>，但是，我们无法从<code>/testdir/a/b</code>这个路径看出<code>b</code>是一个文件还是一个目录，<code>ansible</code>也同样无法单单从一个字符串就知道你要创建文件还是目录，所以，我们需要通过<code>state</code>参数进行说明 当我们想要创建的<code>/testdir/a/b</code>是一个目录时，需要将<code>state</code>的值设置为<code>directory</code>，<code>directory</code>为目录之意，当它与<code>path</code>结合，<code>ansible</code>就能知道我们要操作的目标是一个目录 当我们想要操作的<code>/testdir/a/b</code>是一个文件时，则需要将<code>state</code>的值设置为<code>touch</code> 当我们想要创建软链接文件时，需将<code>state</code>设置为<code>link</code>；想要创建硬链接文件时，需要将<code>state</code>设置为<code>hard</code> 当我们想要删除一个文件时（删除时不用区分目标是文件、目录、还是链接），则需要将<code>state</code>的值设置为<code>absent</code>，<code>absent</code>为缺席之意，当我们想让操作的目标”缺席”时，就表示我们想要删除目标</td></tr><tr><td align="left"><code>src</code></td><td align="left"><code>src</code>参数：当<code>state</code>设置为<code>link</code>或者<code>hard</code>时，表示我们想要创建一个软链或者硬链 所以，我们必须指明软链或硬链链接的哪个文件，通过<code>src</code>参数即可指定链接源</td></tr><tr><td align="left"><code>force</code></td><td align="left">当<code>state=link</code>的时候，可配合此参数强制创建链接文件，当<code>force=yes</code>时，表示强制创建链接文件。不过强制创建链接文件分为三种情况 情况一：当要创建的链接文件指向的源文件并不存在时，使用此参数，可以先强制创建出链接文件 情况二：当要创建链接文件的目录中已经存在与链接文件同名的文件时，将<code>force</code>设置为<code>yes</code>，会将同名文件覆盖为链接文件，相当于删除同名文件，创建链接文件 情况三：当要创建链接文件的目录中已经存在与链接文件同名的文件，并且链接文件指向的源文件也不存在，这时会强制替换同名文件为链接文件</td></tr><tr><td align="left"><code>owner</code></td><td align="left">指定文件所属用户</td></tr><tr><td align="left"><code>group</code></td><td align="left">指定文件所属组</td></tr><tr><td align="left"><code>mode</code></td><td align="left">指定文件权限</td></tr></tbody></table><ul><li>将远程主机下的<code>Python3</code>创建软连接到<code>home</code>目录</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/ansible all -m file -a "path=/</span>home<span class="regexp">/python3 state=link src=/u</span>sr<span class="regexp">/local/</span>python3<span class="regexp">/bin/</span>python3<span class="string">"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Ansible&quot;&gt;&lt;a href=&quot;#Ansible&quot; class=&quot;headerlink&quot; title=&quot;Ansible&quot;&gt;&lt;/a&gt;Ansible&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;ansible&lt;/code&gt;基于Python开发，集合了众多运维工具（&lt;code&gt;puppet&lt;/code&gt;、&lt;code&gt;cfengine&lt;/code&gt;、&lt;code&gt;chef&lt;/code&gt;、&lt;code&gt;func&lt;/code&gt;、&lt;code&gt;fabric&lt;/code&gt;）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能&lt;br&gt;在使用时，&lt;code&gt;ansible&lt;/code&gt;不需要在被控制安装客户端，&lt;code&gt;ansible&lt;/code&gt;工作基于&lt;code&gt;ssh&lt;/code&gt;，只要被控制端服务器有&lt;code&gt;ssh&lt;/code&gt;服务，加上一个&lt;code&gt;Python&lt;/code&gt;环境，就可以使用&lt;code&gt;ansible&lt;/code&gt;&lt;br&gt;另外，&lt;code&gt;ansible&lt;/code&gt;在15年的时候，以1.5亿美元被&lt;code&gt;RedHat&lt;/code&gt;公司收购，新版的&lt;code&gt;RedHat&lt;/code&gt;操作系统内置&lt;code&gt;ansible&lt;/code&gt;软件，很厉害的&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://cy-blogs.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://cy-blogs.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>GitHub操作</title>
    <link href="https://cy-blogs.cn/Git/"/>
    <id>https://cy-blogs.cn/Git/</id>
    <published>2019-12-09T11:56:21.542Z</published>
    <updated>2019-12-09T11:58:51.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GitHub操作起来真的是太简单啦！"><a href="#GitHub操作起来真的是太简单啦！" class="headerlink" title="GitHub操作起来真的是太简单啦！"></a>GitHub操作起来真的是太简单啦！</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><blockquote><p>Git是一个<strong>免费的开源</strong>分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务。</p><p>Git易于学习， 占地面积小，具有闪电般快速的性能。它超越了Subversion，CVS，Perforce和ClearCase等SCM工具，具有廉价本地分支，便捷的<strong>临时区域</strong>和<strong>多个工作流程</strong>等功能</p></blockquote><a id="more"></a><h3 id="git流程"><a href="#git流程" class="headerlink" title="git流程"></a>git流程</h3><p><a href="https://lienze.tech/blog/images/git流程图.jpg" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/git%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="git流程图"></a></p><ul><li><code>workspace</code>：工作区</li><li><code>Index/Stage</code>：暂存区</li><li><code>Repository</code>：仓库区/本地仓库</li><li><code>Remote</code>：远程仓库</li></ul><h3 id="SVN与Git的区别"><a href="#SVN与Git的区别" class="headerlink" title="SVN与Git的区别"></a>SVN与Git的区别</h3><ul><li><code>SVN</code></li></ul><blockquote><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的、而干活的时候，用的都是自己的电脑</p><p>首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器</p><p>集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了</p></blockquote><ul><li><code>Git</code></li></ul><blockquote><p>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库</p><p>这工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了</p><p>Git在本地磁盘上就保存着所有有关当前项目的历史更新，并且Git中的绝大多数操作都只需要访问本地文件和资源，不用连网，所以处理起来速度飞快</p><p>用SVN的话，没有网络或者断开VPN你就无法做任何事情</p><p>但用Git的话，就算你在飞机或者火车上，都可以非常愉快地频繁提交更新，等到了有网络的时候再上传到<strong>远程的镜像仓库</strong>。换作其他版本控制系统，这么做几乎不可能，抑或是非常麻烦</p></blockquote><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><ul><li><code>Windows</code>：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></li><li><code>Linux</code>：</li></ul><h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a><code>Git配置</code></h3><ul><li><code>git config --global</code>：全局git配置，这台机器所有的Git仓库均会使用这个配置</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.name <span class="string">"eastside"</span> # 你的名字</span><br><span class="line">git<span class="built_in"> config </span>--global user.email <span class="string">"..@xx.com"</span> # 你的邮箱</span><br></pre></td></tr></table></figure><h3 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h3><h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><ul><li>什么是版本库？</li></ul><blockquote><p>版本库又名仓库，英文名repository</p><p>你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件还原</p></blockquote><ul><li>选择，进入某个目录</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> projectcd project</span><br></pre></td></tr></table></figure><ul><li>初始化目录为本地仓库</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git init</span></span><br></pre></td></tr></table></figure><ul><li>初始化之后，目录下会多一个隐藏目录<code>.git</code>，该目录是<code>git</code>用来管理版本的，</li></ul><h3 id="添加项目文件"><a href="#添加项目文件" class="headerlink" title="添加项目文件"></a>添加项目文件</h3><ul><li>以创建django项目为例，在<code>git</code>本地仓库开启一个django项目</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">django-admin startproject testpro</span></span><br></pre></td></tr></table></figure><ul><li>添加项目文件或目录至暂存区</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> testpro</span></span><br></pre></td></tr></table></figure><ul><li>将暂存区内容提交至本地仓库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">commit</span> -m <span class="string">"a django project"</span></span><br><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"a django project"</span>[<span class="keyword">master</span> (root-<span class="keyword">commit</span>) adb00b3] a django <span class="keyword">project</span> <span class="number">5</span> files <span class="keyword">changed</span>, <span class="number">172</span> insertions(+) <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> testpro/manage.py <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> testpro/testpro/__init__.py <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> testpro/testpro/settings.py <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> testpro/testpro/urls.py <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> testpro/testpro/wsgi.py</span><br></pre></td></tr></table></figure><blockquote><p><code>-m</code>参数指定提交注释</p></blockquote><ul><li>查看此时仓库状态</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">lienze<span class="variable">@DESKTOP</span>-BIDA1PF MINGW64 ~<span class="regexp">/Desktop/project</span> (master)<span class="variable">$ </span>git statusOn branch masternothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h3 id="文件修改提交"><a href="#文件修改提交" class="headerlink" title="文件修改提交"></a>文件修改提交</h3><blockquote><p>如果在开发过程中，对其中的某个文件进行了修改，那么<code>git</code>在对比文件指纹的过程中发现了差异，此时也需要将新修改的文件进行提交</p></blockquote><ul><li>修改<code>settings.py</code>文件配置</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ALLOWED_HOSTS</span> = [<span class="string">"*"</span>,]<span class="comment"># ALLOWED_HOSTS = []</span></span><br></pre></td></tr></table></figure><ul><li>查看仓库状态</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">$ git statusOn branch masterChanges <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:  (use "git add &lt;file&gt;..." <span class="keyword">to</span> <span class="keyword">update</span> what will be <span class="keyword">committed</span>)  (use "git checkout -- &lt;file&gt;..." <span class="keyword">to</span> <span class="keyword">discard</span> changes <span class="keyword">in</span> working directory)        modified:   settings.pyno changes added <span class="keyword">to</span> <span class="keyword">commit</span> (use "git add" <span class="keyword">and</span>/<span class="keyword">or</span> "git commit -a")</span><br></pre></td></tr></table></figure><blockquote><p>此时仓库说，<code>modified: settings.py</code>，我们对其中某个文件进行了修改</p></blockquote><ul><li>将修改之后的文件加入暂存区</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> -A</span></span><br></pre></td></tr></table></figure><ul><li>此时查看状态</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">$ git statusOn branch masterChanges <span class="keyword">to</span> <span class="keyword">be</span> committed:  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)        modified:   settings.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><ul><li>将暂存区的内容提交至本地仓库</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">commit</span> -m <span class="string">'change settings'</span></span><br><span class="line"><span class="keyword">On</span> branch masternothing <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span><br></pre></td></tr></table></figure><ul><li>丢弃修改，可以丢弃工作区对于文件的修改</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="comment">-- settings.py</span></span><br></pre></td></tr></table></figure><ul><li>注意：命令<code>git checkout -- settings.py</code>中的<code>--</code>很重要，如果没有<code>--</code>的话，那么命令变成创建分支了</li></ul><h3 id="文件删除提交"><a href="#文件删除提交" class="headerlink" title="文件删除提交"></a>文件删除提交</h3><ul><li>在<code>django</code>项目的隔壁创建一个<code>1.py</code>文件</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">touch</span> <span class="number">1.</span>py</span><br></pre></td></tr></table></figure><ul><li>添加该文件</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> -Agit commit -m <span class="string">"add 1.py"</span></span></span><br></pre></td></tr></table></figure><ul><li>删除该文件</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm <span class="number">1.</span>py</span><br></pre></td></tr></table></figure><ul><li>恢复删除文件</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="comment">-- 1.py</span></span><br></pre></td></tr></table></figure><ul><li>提交至本地工作区</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -<span class="selector-tag">a</span> -m <span class="string">"rm 1.py"</span></span><br></pre></td></tr></table></figure><blockquote><p><code>git commit -a</code>：提交全部修改</p></blockquote><h2 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h2><blockquote><p>在团队开发中，我们需要每个开发者彼此配合，对同一款项目代码进行编写，此时需要我们借助线上仓库</p></blockquote><ul><li><code>github</code>：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com</a></li><li><code>gitee</code>：<a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com</a></li></ul><blockquote><p>由于网络环境，此处选择<code>gitee</code></p></blockquote><ul><li>将远程仓库添加到本地</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> edu git@gitee.com:eastside/edu.git</span></span><br></pre></td></tr></table></figure><blockquote><p>添加一个远程库，库名为<code>edu</code>，地址是<code>git@gitee.com:eastside/edu.git</code></p></blockquote><ul><li>列举当前所有的远程库</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git remote</span></span><br></pre></td></tr></table></figure><ul><li>删除某个远程库</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="builtin-name">remove</span> edu</span><br></pre></td></tr></table></figure><ul><li>将本地的仓库推到名为<code>edu</code>的远程仓库中</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 仓库地址：https:<span class="comment">//gitee.com/eastside/edu.gitgit push edu master</span></span></span><br></pre></td></tr></table></figure><ul><li>将远程仓库的代码拉取到本地，在第一次拉取时，可能因为缺少远程服务器上的<code>README.txt</code>文件，而导致远程和本地的分支不一样，通过以下命令</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin <span class="keyword">master</span> <span class="title"># 新建 README</span>文件</span><br><span class="line">git pull edu <span class="keyword">master</span> <span class="title">--allow-unrelated-histories</span></span><br></pre></td></tr></table></figure><ul><li>将远程仓库克隆到本地</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://gitee.com/eastside/edu.git</span><br></pre></td></tr></table></figure><blockquote><p>这是一个已经和远程仓库<code>master</code>分支关联的本地仓库</p></blockquote><ul><li>git全局配置多个用户名冲突时</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  git<span class="built_in"> config </span>--global --replace-all user.email <span class="string">"输入你的邮箱"</span> $  git<span class="built_in"> config </span>--global --replace-all user.name <span class="string">"输入你的用户名"</span></span><br></pre></td></tr></table></figure><h3 id="GIT分支"><a href="#GIT分支" class="headerlink" title="GIT分支"></a>GIT分支</h3><blockquote><p>每次提交，<code>Git</code>都把它们串成一条时间线，这条时间线就是一个分支</p><p>截止到目前，只有一条时间线，在<code>Git</code>里，这个分支叫<strong>主分支</strong>，即<code>master</code>分支</p><p>我们可以通过<code>checkout</code>命令进行分支的创建及切换</p></blockquote><ul><li><code>git checkout -b</code>：创建并切换分支<ul><li><code>git branch branchname</code>：创建分支</li><li><code>git checkout branchname</code>：切换分支</li></ul></li><li>创建一个测试分支</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -<span class="selector-tag">b</span> testbranch</span><br></pre></td></tr></table></figure><ul><li>删除一个分支</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-d testbranch</span><br></pre></td></tr></table></figure><ul><li>提交分支代码</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push <span class="comment">--all</span></span><br></pre></td></tr></table></figure><ul><li>合并分支</li></ul><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">merge</span> testbranch</span><br></pre></td></tr></table></figure><h3 id="GIT冲突"><a href="#GIT冲突" class="headerlink" title="GIT冲突"></a>GIT冲突</h3><blockquote><p>常见git冲突造成，是由于在多个分支下，或多个仓库中，对同一个文件修改，或添加了新的文件之后</p><p>由于某一方对于文件的修改没有及时在另一方生效，当另一方或另一分支在进行提交时，即会出现冲突</p></blockquote><ul><li>在testbranch分支下，修改1.py文件，并提交到云仓库</li><li>在master分支下，也修改1.py文件，并尝试提交</li></ul><p><a href="https://lienze.tech/blog/images/1565915294853.png" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/1565915294853.png" alt="1565915294853"></a></p><ul><li>此时冲突出现，使用<code>git status</code>命令查看当前仓库状态</li></ul><p><a href="https://lienze.tech/blog/images/git冲突status.png" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/git%E5%86%B2%E7%AA%81status.png" alt="git冲突status"></a></p><ul><li>查看被修改的文件<code>1.py</code></li></ul><p><a href="https://lienze.tech/blog/images/git冲突文件.png" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/git%E5%86%B2%E7%AA%81%E6%96%87%E4%BB%B6.png" alt="git冲突文件"></a></p><ul><li><code>Git</code>用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，<code>&gt;&gt;&gt;&gt;&gt; testbranch</code>是指<code>fenzhi1</code>上修改的内容，我们可以将差异部分的标注删掉重新提交，或是与对方协商，另行拷贝文件内容，重新clone仓库，将拷贝过的内容添加至内</li><li>之后再进行提交</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> 1.pygit commit -m <span class="string">"conflict fixed"</span></span></span><br></pre></td></tr></table></figure><ul><li>这样就可以搞定了</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;GitHub操作起来真的是太简单啦！&quot;&gt;&lt;a href=&quot;#GitHub操作起来真的是太简单啦！&quot; class=&quot;headerlink&quot; title=&quot;GitHub操作起来真的是太简单啦！&quot;&gt;&lt;/a&gt;GitHub操作起来真的是太简单啦！&lt;/h1&gt;&lt;h2 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Git是一个&lt;strong&gt;免费的开源&lt;/strong&gt;分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务。&lt;/p&gt;
&lt;p&gt;Git易于学习， 占地面积小，具有闪电般快速的性能。它超越了Subversion，CVS，Perforce和ClearCase等SCM工具，具有廉价本地分支，便捷的&lt;strong&gt;临时区域&lt;/strong&gt;和&lt;strong&gt;多个工作流程&lt;/strong&gt;等功能&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://cy-blogs.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://cy-blogs.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Cli</title>
    <link href="https://cy-blogs.cn/Vue-Cli/"/>
    <id>https://cy-blogs.cn/Vue-Cli/</id>
    <published>2019-12-09T11:52:36.348Z</published>
    <updated>2019-12-09T11:54:42.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件开发自动化工具"><a href="#组件开发自动化工具" class="headerlink" title="组件开发自动化工具"></a>组件开发自动化工具</h2><blockquote><p><code>Node.js</code>是一个新的后端(后台)语言，它的语法和<code>JavaScript</code>类似，所以可以说它是属于前端的后端语言</p></blockquote><blockquote><p><strong>运行环境：后端语言一般运行在服务器端，前端语言运行在客户端的浏览器上</strong></p><p><strong>功能：后端语言可以操作文件，可以读写数据库，前端语言不能操作文件，不能读写数据库。</strong></p></blockquote><a id="more"></a><ul><li><code>Node.js</code>如果安装成功，可以查看<code>Node.js</code>的版本,在终端输入如下命令</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br><span class="line">npm</span><br></pre></td></tr></table></figure><ul><li>全局安装<code>vue</code>脚手架，<code>vue-cli</code>，这玩意儿可以自动生成项目模板</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vue-<span class="keyword">cli</span></span><br><span class="line">cnpm install --<span class="keyword">global</span> vue-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure><h3 id="单页应用-SPWA"><a href="#单页应用-SPWA" class="headerlink" title="单页应用 SPWA"></a>单页应用 SPWA</h3><blockquote><p>单页<code>Web</code>应用（<strong>single page web application</strong>，<code>SPWA</code>），就是将系统所有的操作交互限定在一个<code>web</code>页面中。</p><p>单页应用程序 (<code>SPA</code>)是加载单个<code>HTML</code>页面，系统的不同功能通过加载不同功能组件的形式来切换，不同功能组件全部封装到了<code>js</code>文件中，这些文件在应用开始访问时就一起加载完；</p><p>整个系统在切换不同功能时，页面的地址是不变的，系统切换可以做到局部刷新，也可以叫做无刷新，这么做的目的是为了给用户提供更加流畅的用户体验</p></blockquote><ul><li>通过<code>vue-cli</code>脚手架开启一个项目：</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vue init webpack myproject</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- Project name: 项目名称，如果不需要就直接回车。注：此处项目名不能使用大写。</span><br><span class="line">- Project description: 项目描述，直接回车</span><br><span class="line">- Author：作者</span><br><span class="line">- vue build: 构建方式 默认即可</span><br><span class="line">- <span class="keyword">install</span> vue-router? 是否安装vue的路由插件</span><br><span class="line"></span><br><span class="line">- <span class="keyword">Use</span> ESLint <span class="keyword">to</span> lint your code? 是否使用ESLint检测你的代码？</span><br><span class="line">（ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。）</span><br><span class="line"></span><br><span class="line">- Pick an ESLint preset:选择分支风格</span><br><span class="line"><span class="number">1.</span>standard(https://github.com/feross/standard) js的标准风格</span><br><span class="line"><span class="number">2.</span>Airbnb(https://github.com/airbnb/javascript) JavaScript最合理的方法，这个github地址说是JavaScript最合理的方法</span><br><span class="line"><span class="number">3.</span><span class="keyword">none</span> (configure it yourself) 自己配置</span><br><span class="line"></span><br><span class="line">- Setup unit tests? 是否安装单元测试</span><br><span class="line">- Pick a <span class="keyword">test</span> runner 选择一个单元测试运行器</span><br><span class="line"><span class="number">1.</span>Jest（Jest是由Facebook发布的开源的、基于Jasmine的JavaScript单元测试框架）</span><br><span class="line"><span class="number">2.</span>Karma <span class="keyword">and</span> Mocha</span><br><span class="line"><span class="number">3.</span><span class="keyword">none</span></span><br><span class="line"></span><br><span class="line">- Setup e2e tests <span class="keyword">with</span> Nightwatch(Y/n)?是否安装E2E测试框架NightWatch</span><br><span class="line">（E2E，也就是<span class="keyword">End</span> <span class="keyword">To</span> <span class="keyword">End</span>，就是所谓的“用户真实场景”。）</span><br><span class="line"></span><br><span class="line">- Should we run <span class="string">'npm install'</span> <span class="keyword">for</span> you <span class="keyword">after</span> the <span class="keyword">project</span> has been created?</span><br><span class="line">项目创建后是否要为你运行“npm <span class="keyword">install</span>”?</span><br><span class="line">yes,<span class="keyword">use</span> npm(使用npm)</span><br><span class="line">yes,<span class="keyword">use</span> yarn(使用yarn)</span><br><span class="line"><span class="keyword">no</span>,I will handle that myself(自己操作)</span><br></pre></td></tr></table></figure><ul><li>启动开发服务器：</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd myproject <span class="comment"># 进入目录</span></span><br><span class="line">cnpm install <span class="comment"># 安装依赖</span></span><br><span class="line">cnpm <span class="keyword">run</span><span class="bash"> dev <span class="comment"># 开启服务</span></span></span><br></pre></td></tr></table></figure><blockquote><p><code>vue</code>启动服务之后，是通过一个小型的<code>express</code>服务进行测试开发环境部署，在这个服务中，主要是通过<code>webpack-dev-middleware</code>和<code>webpack-hot-middleware</code>这两个中间件完成，并且会在每次代码对于<code>src</code>目录下的代码进行修改时，服务端会动态检测并让浏览器自动刷新</p></blockquote><ul><li>项目目录介绍</li></ul><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> src <span class="comment"># 主开发目录，所有的单文件组件都会放在这个目录下</span></span></span><br><span class="line"><span class="ruby">- static <span class="comment"># 项目静态目录，所有的css、js都会放在这个文件夹下</span></span></span><br><span class="line"><span class="ruby">- dist <span class="comment"># 项目打包发布文件夹，最后要上线单文件夹项目都在这个文件夹中</span></span></span><br><span class="line"><span class="ruby">- node_modules <span class="comment"># node的包目录</span></span></span><br><span class="line"><span class="ruby">- config <span class="comment"># 配置目录，主要用于区分开发环境，测试环境，线上环境的不同</span></span></span><br><span class="line"><span class="ruby">- build <span class="comment"># 项目打包时依赖的目录</span></span></span><br></pre></td></tr></table></figure><h3 id="组件开发"><a href="#组件开发" class="headerlink" title="组件开发"></a>组件开发</h3><blockquote><p>将一个组件相关的<code>html</code>结构，<code>css</code>样式，以及交互的<code>JavaScript</code>代码从<code>html</code>文件中剥离出来，合成一个文件，这种文件就是单文件组件，相当于一个组件具有了结构、表现和行为的完整功能，方便组件之间随意组合以及组件的重用，这种文件的扩展名为<code>.vue</code>，比如：<code>menu.vue</code></p><p>组件文件一般定义在<code>src</code>目录下的<code>components</code>文件夹里</p></blockquote><ul><li><code>template</code>标签定义<code>HTML</code>部分</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;teamplate&gt;</span><br><span class="line">    &lt;div class=&quot;&quot; @click=&quot;&quot;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">        账号</span><br><span class="line">            &lt;input type=&quot;text&quot;&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/teamplate&gt;</span><br></pre></td></tr></table></figure><ul><li><code>js</code>写成模块导出的形式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用export default命令，为模块指定默认输出</span><br><span class="line">export default&#123;</span><br><span class="line">    data: function()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            name:&quot;张三&quot;,</span><br><span class="line">            age:16,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>样式中的编写，如果含有scope关键字，表示这些样式是组件局部的，</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">.beauty&#123;</span><br><span class="line">    width:100px;</span><br><span class="line">    line-height:50px;</span><br><span class="line">    border-bottom:1px solid #ddd;</span><br><span class="line">    margin:0px auto;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><blockquote><p>当拥有一个组件文件时，要在项目的<code>src</code>目录下的<code>router</code>目录下的<code>index.js</code>文件下</p><p>进行组件的路由加载配置</p></blockquote><blockquote><p>在导入组件文件时，可以使用<code>@</code>符号，代表从<code>src</code>目录起</p><p>比如：<em>import</em> index <em>from</em> ‘@/components/index’</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Router from &apos;vue-router&apos;</span><br><span class="line">import HelloWorld from &apos;@/components/HelloWorld&apos;</span><br><span class="line">import first from &apos;@/components/first&apos; // 从组件目录下导入组件文件，不需要加后缀</span><br><span class="line">import index from &apos;@/components/index&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &apos;history&apos;,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      component: index,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/first&apos;, // 访问路径</span><br><span class="line">      component: first</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>当配置好路由之后，需要在最主要的<code>App.Vue</code>文件下进行连接引入</p></blockquote><blockquote><p>通过<code>&lt;router-link to=&quot;连接地址&quot;&gt;首页&lt;/router-link&gt;</code>标签进行连接引入</p><p>通过<code>&lt;router-view&gt;&lt;/router-view&gt;</code>标签进行路由加载，可以简写为：<code>&lt;router-view/&gt;</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;</span><br><span class="line">    &lt;router-link to=&quot;/first&quot;&gt;第一个页面&lt;/router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在<code>App.Vue</code>文件下的<code>template</code>标签处如果已经引入了其他跳转连接；</p><p>那么在子组件的<code>template</code>部分不需要在进行引入</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>编写<code>components</code>组件</li><li><code>index.js</code>配置路由</li><li>在主入口<code>App.vue</code>中加载路由组件<code>&lt;router-view/&gt;</code>，一般默认已经写好</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;组件开发自动化工具&quot;&gt;&lt;a href=&quot;#组件开发自动化工具&quot; class=&quot;headerlink&quot; title=&quot;组件开发自动化工具&quot;&gt;&lt;/a&gt;组件开发自动化工具&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Node.js&lt;/code&gt;是一个新的后端(后台)语言，它的语法和&lt;code&gt;JavaScript&lt;/code&gt;类似，所以可以说它是属于前端的后端语言&lt;/p&gt;
&lt;/blockquote&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;运行环境：后端语言一般运行在服务器端，前端语言运行在客户端的浏览器上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能：后端语言可以操作文件，可以读写数据库，前端语言不能操作文件，不能读写数据库。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://cy-blogs.cn/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://cy-blogs.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="https://cy-blogs.cn/Vue/"/>
    <id>https://cy-blogs.cn/Vue/</id>
    <published>2019-12-09T11:52:36.346Z</published>
    <updated>2019-12-09T11:54:39.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h2><blockquote><p><code>Vue.js</code>是前端三大新框架：<code>Angular.js</code>、<code>React.js</code>、<code>Vue.js</code>之一，<code>Vue.js</code>目前的使用和关注程度在三大框架中稍微胜出，并且它的热度还在递增</p><p><code>Vue</code>的核心库只关注视图层，<code>Vue</code>的目标是通过尽可能简单的<code>API</code>实现响应的数据绑定，在这一点上<code>Vue.js</code>类似于后台的模板语言</p><p><code>Vue</code>也可以将界面拆分成一个个的组件，通过组件来构建界面，然后用自动化工具来生成单页面(<code>SPA - single page application</code>)系统</p></blockquote><a id="more"></a><ul><li><code>Vue.js</code>官方文档： <a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a></li><li><code>vue.js</code>下载地址： <a href="https://cn.vuejs.org/v2/guide/installation.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/installation.html</a></li></ul><h3 id="npm配置cnpm"><a href="#npm配置cnpm" class="headerlink" title="npm配置cnpm"></a>npm配置cnpm</h3><ul><li><code>windows</code>下配置<code>cnmp</code>环境：</li></ul><blockquote><p>默认的使用<code>NPM</code>可能会因为网络问题而导致无法使用或延迟居高，可以使<code>npm</code>升级为<code>cnpm</code>，从国内淘宝镜像中加载所需的<code>npm</code>软件源</p></blockquote><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g cnpm --registry=https:<span class="regexp">//</span>registry.<span class="built_in">npm</span>.taobao.org</span><br></pre></td></tr></table></figure><ul><li>设置安装包缓存路径</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm<span class="built_in"> config </span><span class="builtin-name">set</span> cache <span class="string">"C:\nodejs\node_cache"</span></span><br></pre></td></tr></table></figure><ul><li>设置安装包位置</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm<span class="built_in"> config </span><span class="builtin-name">set</span><span class="built_in"> prefix </span><span class="string">"C:\nodejs\node_global"</span></span><br></pre></td></tr></table></figure><blockquote><p>之后使用命令安装的模块存储在<strong>C:\nodejs\node_global\node_modules</strong>里</p><p>请按照个人需求设置你的文件位置</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm<span class="built_in"> config </span><span class="builtin-name">set</span> cache <span class="string">"C:\nodejs\node_cache"</span></span><br></pre></td></tr></table></figure><h3 id="Vue部署"><a href="#Vue部署" class="headerlink" title="Vue部署"></a>Vue部署</h3><ul><li>安装<code>Vue</code></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm <span class="keyword">install</span> vue -g</span><br></pre></td></tr></table></figure><ul><li>安装<code>vue</code>脚手架</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install vue-<span class="keyword">cli</span> -g</span><br></pre></td></tr></table></figure><blockquote><p><code>-g</code>参数代表全局位置安装，这样可以在环境变量生效的情况下直接在命令行等工具下使用vue命令行进行项目的开启</p></blockquote><h3 id="vue-devtools调试工具"><a href="#vue-devtools调试工具" class="headerlink" title="vue-devtools调试工具"></a>vue-devtools调试工具</h3><blockquote><p><code>vue-devtools</code>可以方便开发者进行<code>Vue</code>中变量等信息的调试跟踪</p></blockquote><ul><li>下载<code>vue-devtools</code></li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/vuejs/vue-devtools</span><br></pre></td></tr></table></figure><ul><li>进入到<code>vue-devtools</code>目录下安装依赖包</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cd</span> <span class="string">vue-devtools-dev</span></span><br><span class="line"><span class="attr">cnpm</span> <span class="string">install </span></span><br><span class="line"><span class="attr">cnpm</span> <span class="string">run build</span></span><br></pre></td></tr></table></figure><ul><li>注意：在进行调试工具安装时，首先需要修改<code>shells&gt;chrome</code>文件夹下的<code>mainifest.json</code>中的persistent为true</li><li>将插件目录下的<code>chrome</code>文件夹拖入到<code>chrome</code>浏览器的扩展程序下，记得打开调试模式</li></ul><blockquote><p>扩展程序可以通过浏览器访问</p></blockquote><p><a href="https://lienze.tech/blog/images/1561789924.png" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/1561789924.png" alt="1561789924"></a></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">chrome:</span><span class="comment">//extensions/</span></span><br></pre></td></tr></table></figure><h3 id="Vue-CDN"><a href="#Vue-CDN" class="headerlink" title="Vue-CDN"></a>Vue-CDN</h3><blockquote><p>除去通过<code>npm</code>安装的方式来使用<code>vue</code>，还可以直接使用<code>cdn</code>中的<code>vue.js</code>文件</p></blockquote><ul><li>vue.js：开发版本，包含了有帮助的命令行警告</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>vue.min.js：生产环境版本，优化了尺寸和速度</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Vue语法"><a href="#Vue语法" class="headerlink" title="Vue语法"></a>Vue语法</h3><blockquote><p>每个<code>vue</code>应用都是通过实例化一个新的<code>vue</code>对象开始的</p></blockquote><ul><li>创建第一个模板语法：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="comment">&lt;!-- 这个也叫做插值表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123; // vm这个变量不允许使用连字符，可以使用下划线，比如vm-data是不允许的</span><br><span class="line">    el: &quot;#content&quot;, </span><br><span class="line">    // 对应document中的一个标签，当vue对象创建后，这个标签内的区域就被接管</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &quot;这是vue里的变量&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>当一个<code>vue</code>实例被创建时，<code>vue</code>的响应式系统中加入了对其<code>data</code>对象中能找到的所有属性</li><li>当这些属性值被改变时，视图也会发生<strong>相应</strong>，并将对应属性更新为新的值</li><li>也可以通过定义函数来改变实例中<code>data</code>对象中的数据，数据改变，视图中的数据也将改变</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;ChangeMsg&quot;&gt;改变&lt;/button&gt;</span><br><span class="line">    &lt;!-- 绑定点击事件为定义好的vue函数 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &quot;我对应的是message的变量&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123; // 定义一个函数 并绑定在按钮的点击事件上</span><br><span class="line">            ChangeMsg:function()&#123;</span><br><span class="line">                this.message = &quot;我被改变了&quot;;</span><br><span class="line">                // 修改当前实例中的message变量</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的代码，将在点击按钮时，使当前的<code>message</code>变量发生变化</p><p>``这样的语法有点类似一些<code>Web</code>框架，比如<code>django</code>的模板语言中的模板变量</p></blockquote><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><blockquote><p>除了直接定义某个变量的固定值进行页面渲染，模板变量还支持通过函数的返回值进行赋值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; classType &#125;&#125;学习&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123; describe() &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;, // getElementById(&apos;app&apos;)</span><br><span class="line">        data: &#123;</span><br><span class="line">            classType: &quot;vue&quot;,</span><br><span class="line">            content: &quot;这是vue的一个测试&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            describe:function()&#123;</span><br><span class="line">                return &quot;这是一个函数的返回值&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue模板指令"><a href="#Vue模板指令" class="headerlink" title="Vue模板指令"></a>Vue模板指令</h3><ul><li>模板语法指的是如何将数据放入html中</li></ul><blockquote><p><strong>Vue.js使用了基于HTML的模板语法，允许开发者声明式地将DOM绑定至底层 Vue 实例的数据</strong></p><p><strong>所有 Vue.js的模板都是合法的 HTML ，所以能被遵循规范的浏览器和HTML 解析器解析</strong></p></blockquote><ul><li>插入值，模板变量</li></ul><blockquote><p>数据绑定最常见的形式就是使用<code>Mustache</code>语法(双大括号) 的文本插值，也就是上面示例中的``</p></blockquote><h4 id="内容绑定"><a href="#内容绑定" class="headerlink" title="内容绑定"></a>内容绑定</h4><h5 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h5><blockquote><p>将内容按照<code>html</code>格式进行插入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p v-html=&quot;contetn&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      content: &quot;&lt;b&gt;段落标签&lt;/b&gt;文本内容&quot;  </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在网站上动态渲染任意<code>HTML</code>是非常危险的，因为容易导致<code>XSS</code>攻击</p><p><code>v-html</code>一般只用在可信内容中，<strong>永不</strong>用在用户提交的内容上</p></blockquote><h5 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h5><blockquote><p>将内容按照文本格式进行插入，但会覆盖原有标签内的内容，不会有加载的闪烁问题</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p v-text=&quot;contetn&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">       &#123;&#123; gender ? &apos;男&apos; : &apos;女&apos; &#125;&#125;</span><br><span class="line">        &lt;!-- ok? true:false --&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      gender: true, // 变量值为true时，显示模板变量中左边的值</span><br><span class="line">      content: &quot;&lt;b&gt;段落标签&lt;/b&gt;文本内容&quot;  </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h5><blockquote><p>解决使用差值表达式时页面渲染过程，由于变量没有初始化而导致的闪烁问题</p></blockquote><blockquote><p>通俗的来说，比如<code>变量的实际内容没有被创建，那么此时页面只会展示出</code>这样的效果，之后当变量初始化之后，``将变化为实际的值，此时变化的过程我们称作闪烁</p></blockquote><blockquote><p>这个指令可以隐藏未编译的标签直到实例准备完毕</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            message: &quot;测试&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>在上面的代码中，如果网速够慢的清空下，页面首先加载显示出的内容是``</li><li><strong>解决办法</strong>：通过<code>v-clock</code>指令，在使用到模板变量的标签上写入，并设置一个<code>v-clock</code>的类样式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    [v-cloak]&#123;</span><br><span class="line">        display: none;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-cloak id=&quot;app&quot;&gt;</span><br><span class="line">&lt;p v-cloak&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h4><h5 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h5><blockquote><p>如果我们需要设置的模板变量是一个属性，比如<code>a</code>标签的<code>href</code>属性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;a v-bind:href=&quot;message&quot;&gt;连接&lt;/a&gt;</span><br><span class="line">    &lt;a :href=&quot;message +&apos;abc&apos;&quot;&gt;连接&lt;/a&gt;</span><br><span class="line">    &lt;!-- 属性内的模板变量写法已被移除，使用v-bind:attr 或 :attr --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">    message: &quot;https://www.baidu.com&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>可以通过<code>v-bind</code>指令或者<code>:</code>的简写对某个<code>dom</code>元素的属性进行绑定</p><p>在下面还有更加详细的属性绑定示例</p></blockquote><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><h5 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h5><blockquote><p>给元素绑定对应事件，以下是对于点击事件的绑定</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;show&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;show&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">el: &quot;#app&quot;,</span><br><span class="line">    method: &#123;</span><br><span class="line">    show: function()&#123;</span><br><span class="line">alert(&quot;弹一下&quot;)</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="跑马灯效果"><a href="#跑马灯效果" class="headerlink" title="跑马灯效果"></a>跑马灯效果</h4><blockquote><p>这里有一个跑马灯效果可以玩耍</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;button @click=&quot;start&quot;&gt;开始&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;stop&quot;&gt;停止&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &quot;这是一个跑马灯&quot;,</span><br><span class="line">        sT: null, // 定时器实例</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        work()&#123;</span><br><span class="line">            this.message = this.message.substring(1) + this.message[0] </span><br><span class="line">            // 循环定时器所作的事情</span><br><span class="line">        &#125;,</span><br><span class="line">        start()&#123;</span><br><span class="line">            if (this.sT==null) &#123; // 判断此时是否已有定时器开启</span><br><span class="line">                console.log(&quot;开启定时器&quot;)</span><br><span class="line">                this.sT = setInterval(this.work,400)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                console.log(&quot;已经开启 不在开启&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        stop()&#123; // 关闭定时器 设置定时器变量为null</span><br><span class="line">            console.log(&quot;关闭定时器&quot;)</span><br><span class="line">            clearInterval(this.sT)</span><br><span class="line">            this.sT = null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="绑定事件修饰符"><a href="#绑定事件修饰符" class="headerlink" title="绑定事件修饰符"></a>绑定事件修饰符</h4><h5 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h5><blockquote><p>比如一个按钮在一个<code>div</code>中，并且按钮和<code>div</code>均有自己的事件，那么此时点击按钮，事件会像冒泡一样从按钮开始一直到<code>div</code>进行触发，<code>.stop</code>修饰符用来阻止默认的事件触发行为</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;fDiv&quot; @click=&quot;divClick&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;fBtn&quot; @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#fDiv&quot;, // 控制区域</span><br><span class="line">            data: &#123;&#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                divClick()&#123;</span><br><span class="line">                    console.log(&quot;div被点击了&quot;)</span><br><span class="line">                &#125;,</span><br><span class="line">                btnClick()&#123;</span><br><span class="line">                    console.log(&quot;按钮被点击了&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>通过<code>.stop</code>修饰阻止冒泡</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;fDiv&quot; @click=&quot;divClick&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;fBtn&quot; @click.stop=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h5 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h5><blockquote><p>比如像<code>a</code>标签这样的，在点击时他有默认的跳转动作，可以通过<code>.prevent</code>阻止该默认行为</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;fDiv&quot;&gt;</span><br><span class="line">&lt;a href=&quot;https://www.baidu.com&quot; @click.prevent=&quot;aLink&quot;&gt;去百度&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue()&#123;</span><br><span class="line">    el: &quot;#fDiv&quot;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">    aLink()&#123;</span><br><span class="line">    console.log(&quot;连接被点击&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="捕获事件"><a href="#捕获事件" class="headerlink" title="捕获事件"></a>捕获事件</h5><blockquote><p>默认的事件触发处理机制是冒泡机制，capture代表具有该修饰的事件，会优先触发，脱离冒泡顺序；</p><p>也可理解为谁有该修饰符，先触发谁的事件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;fDiv&quot; @click.capture=&quot;divClick&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;fBtn&quot; @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &quot;#fDiv&quot;, // 控制区域</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            divClick()&#123;</span><br><span class="line">                console.log(&quot;div被点击了&quot;)</span><br><span class="line">            &#125;,</span><br><span class="line">            btnClick()&#123;</span><br><span class="line">                console.log(&quot;按钮被点击了&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="自身事件"><a href="#自身事件" class="headerlink" title="自身事件"></a>自身事件</h5><blockquote><p>与<code>capture</code>和冒泡不同，<code>.self</code>只有是自身触发的当前的事件才真正执行处理的回调函数</p><p>并且<code>.self</code>只会阻止当前元素的事件触发行为</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;fDiv&quot; @click.self=&quot;divClick&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;fBtn&quot; @click.self=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与上同</span></span><br></pre></td></tr></table></figure><h5 id="单次事件"><a href="#单次事件" class="headerlink" title="单次事件"></a>单次事件</h5><blockquote><p>使用<code>.once</code>只触发一次事件函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;fDiv&quot;&gt;</span><br><span class="line">    &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent.once=&quot;aLink&quot;&gt;去百度&lt;/a&gt;</span><br><span class="line">    &lt;!-- 连接无法跳转的阻止事件 只会出现一次 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue()&#123;</span><br><span class="line">    el: &quot;#fDiv&quot;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">    aLink()&#123;</span><br><span class="line">    console.log(&quot;连接被点击&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表单双向绑定"><a href="#表单双向绑定" class="headerlink" title="表单双向绑定"></a>表单双向绑定</h3><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><blockquote><p>使用v-model指令可以在表单<code>input</code>、<code>textarea</code>以及<code>select</code>元素上创建双向数据绑定</p><p>根据表单上的值，自动更新模板变量中的值</p></blockquote><blockquote><p><code>v-model</code>会忽略表单的初始值，比如：<code>checked</code>、<code>value</code>、<code>selected</code>，如果需要的话，应该在<code>javascript</code>中首先声明初始值</p></blockquote><h5 id="text"><a href="#text" class="headerlink" title="text"></a><strong>text</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &quot;这是个表单内容&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a><strong>textarea</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;textarea v-model=&quot;message&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同上</span></span><br></pre></td></tr></table></figure><h5 id="checkbox"><a href="#checkbox" class="headerlink" title="checkbox"></a><strong>checkbox</strong></h5><ul><li><strong>单个复选框</strong>：数据为绑定为<code>true</code>和<code>false</code>的布尔值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;checked&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                checked: true,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>多个复选框</strong>：选中的结果会绑定到同一个数组，将保存的<code>v-model</code>变量创建为数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;checked&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input name=&quot;fruit&quot; type=&quot;checkbox&quot; value=&quot;apple&quot;  v-model=&quot;checked&quot;&gt;苹果</span><br><span class="line">    &lt;input name=&quot;fruit&quot; type=&quot;checkbox&quot; value=&quot;banana&quot; v-model=&quot;checked&quot;&gt;香蕉</span><br><span class="line">    &lt;input name=&quot;fruit&quot; type=&quot;checkbox&quot; value=&quot;orange&quot; v-model=&quot;checked&quot;&gt;橘子</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                checked: new Array,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="radio"><a href="#radio" class="headerlink" title="radio"></a><strong>radio</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;picked&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;junior&quot; v-model=&quot;picked&quot;&gt;男</span><br><span class="line">    &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;girl&quot; v-model=&quot;picked&quot;&gt;女</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                picked: &quot;哈哈哈哈&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="select"><a href="#select" class="headerlink" title="select"></a><strong>select</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;selected&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;select v-model=&quot;selected&quot;&gt;</span><br><span class="line">        &lt;option disabled value=&quot;&quot;&gt;你想去哪&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;山西&quot;&gt;山西&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                selected: &quot;&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="selects"><a href="#selects" class="headerlink" title="selects"></a><strong>selects</strong></h5><blockquote><p>设置<code>select</code>标签的<code>multiple</code>属性即可设置为多选下拉菜单，按着<code>ctrl</code>键可以多选</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;selecteds&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;select multiple v-model=&quot;selecteds&quot;&gt;</span><br><span class="line">        &lt;option value=&quot;上衣&quot;&gt;上衣&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;裤子&quot;&gt;裤子&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;鞋&quot;&gt;鞋&lt;/option&gt;  </span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                selecteds: new Array, // 多重数据一般都要保存成数组</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><h5 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h5><blockquote><p>默认情况下，<code>v-model</code>在<code>input</code>和<code>textarea</code>表单中进行同步输入框的改动</p><p>添加了<code>.lazy</code>修饰符之后，对应的<code>v-model</code>绑定事件触发机制将变为<code>change</code>事件，只有在光标失去焦点时会触发</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model.lazy=&quot;message&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &quot;这是个表单内容&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h5><blockquote><p>如果用户希望将输入表单的内容处理为<code>Number</code>类型，可以使用<code>.number</code>给<code>v-model</code>进行修饰；如果表单字符串无法被处理为数字，则返回原始的值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;typeof message&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model.number=&quot;message&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h5 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h5><blockquote><p>使用<code>.trim</code>可以自动过滤输入框的首尾空格</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model.trim=&quot;message&quot;&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br><span class="line">    &lt;!-- 通过查看另一个表单中同步的缩进 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><blockquote><p>当某些情况下，无法确定表单中所代表的属性值，可以使用<code>v-bind</code>进行动态绑定，<code>v-model</code>获取到的表单输入此时则是我们定义的<code>v-bind</code>属性值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;radio&quot; v-model=&quot;message&quot; :value=&quot;choiceA&quot;&gt; A</span><br><span class="line">    &lt;input type=&quot;radio&quot; v-model=&quot;message&quot; :value=&quot;choiceB&quot;&gt; B</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &quot;&quot;, // 表单绑定变量</span><br><span class="line">                choiceA: &quot;Yes!&quot;, // 属性绑定变量，未来不需要修改标签中的value值即可动态修改</span><br><span class="line">                choiceB: &quot;No!&quot;,</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><ul><li>关键词：<code>computed</code></li></ul><blockquote><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的</p><p>在模板中放入太多的逻辑会让模板过重且难以维护</p><p>也就是说，某些时候页面中的模板变量如果需要复杂的运算处理，应该使用<strong>计算属性</strong>，而不是直接在模板位置进行计算。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">            var vm = new Vue(&#123;</span><br><span class="line">                el: &quot;#container&quot;,</span><br><span class="line">                data: &#123;</span><br><span class="line">                    String1:&quot;这是一个字符串&quot;,</span><br><span class="line">                &#125;,</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    MreverseString()&#123;</span><br><span class="line">                        return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;)</span><br><span class="line">                    &#125; // 定义一个函数进行字符串逆置</span><br><span class="line">                &#125;,</span><br><span class="line">                computed: &#123;</span><br><span class="line">                    CreverseString()&#123;</span><br><span class="line">                        return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;)</span><br><span class="line">                    &#125; // 定义一个计算属性进行字符串逆置</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-cloak id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p&gt;这是一个字符串:&#123;&#123; String1 &#125;&#125; &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;他的逆置:&#123;&#123; String1.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125;&#125; &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;他的逆置:&#123;&#123; CreverseString &#125;&#125; &lt;/p&gt;</span><br><span class="line">    &lt;!-- 计算属性直接写入函数名 --&gt;</span><br><span class="line">    &lt;p&gt;他的逆置:&#123;&#123; MreverseString() &#125;&#125; &lt;/p&gt;</span><br><span class="line">    &lt;!-- 普通methods函数调用需加括号 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：虽然计算属性和函数都可以达成同样的目的，但是<code>computed</code>会缓存结果，计算属性如果发现依赖的属性<code>message</code>未发生改变，再次访问计算属性不会重复运算函数，而是直接利用已有结果；如果依赖数据发生改动，计算属性函数才会重新运算。</li><li>在函数及计算属性中添加日志输出即可看到这个效果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    MreverseString() &#123;</span><br><span class="line">        console.log(&quot;MreverseString被运算了&quot;)</span><br><span class="line">        return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">CreverseString() &#123;</span><br><span class="line">console.log(&quot;CreverseString被运算了&quot;)</span><br><span class="line">return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在终端下进行计算属性以及函数的访问即可看到效果。</li></ul><h4 id="计算属性SetAttr"><a href="#计算属性SetAttr" class="headerlink" title="计算属性SetAttr"></a>计算属性SetAttr</h4><blockquote><p>默认的计算属性只有获取<code>getattr</code>的方式，我们可以手动为他添加一个<code>setter</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    CreverseString: &#123;</span><br><span class="line">        get: function()&#123;</span><br><span class="line">            return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        set: function(val)&#123;</span><br><span class="line">            this.String1 = val.split(&quot;&quot;).reverse().join(&quot;&quot;)</span><br><span class="line">            // 如果当前的逆置之后字符串为val，那么原本的字符串需要再颠倒一次</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="侦听属性"><a href="#侦听属性" class="headerlink" title="侦听属性"></a>侦听属性</h3><blockquote><p>侦听属性的作用是侦听某些属性的变化，从而做相应的操作，进行对数据变化的相应，</p><p>侦听属性是一个对象（字典），<code>key</code>值是要监听的元素，值是当监听的元素发生改变时要执行的函数；</p><p>监听函数有两个参数，一个是当前值，另一个是变化后的值</p></blockquote><ul><li>比如监听一个变量的变化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                content: &quot;&quot;, // 表单内容</span><br><span class="line">                count: 0, // 记录表单内用户敲了多少次</span><br><span class="line">            &#125;,</span><br><span class="line">            watch:&#123;</span><br><span class="line">                content:function (oldVal,newVal)&#123;</span><br><span class="line">                    // 只要在文本框输入内容影响到了age数据发生改变，就会触发</span><br><span class="line">                    this.count += 1</span><br><span class="line">                &#125;，</span><br><span class="line">            &#125;，</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p&gt;&lt;label&gt;你敲了:&#123;&#123; count &#125;&#125;次&lt;/label&gt;&lt;/p&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; placeholder=&quot;请输入你的年纪&quot; v-model=&quot;content&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="属性绑定-1"><a href="#属性绑定-1" class="headerlink" title="属性绑定"></a>属性绑定</h3><blockquote><p>使用<code>v-bind:class</code>指令来设置元素的class属性；</p><p>属性表达式的类型可以是字符串、对象或数组</p></blockquote><h4 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h4><blockquote><p>可以通过为元素绑定一个数组，用来为元素设置单个或多个样式，类名在数组中用单引号</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    .fontBold &#123;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">    &#125;</span><br><span class="line">    .fontRed &#123;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p :class=&quot;[&apos;fontBold&apos;,&apos;fontRed&apos;]&quot;&gt;这是一个段落&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h4><blockquote><p>可以通过为元素绑定一个对象，对象的key是样式类，对象的value是true或false来动态切换class</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                flag: true,</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                toggle() &#123;</span><br><span class="line">                    if (this.flag)&#123; // 判断当前toggle变量的属性，对称变换</span><br><span class="line">                        this.flag = false</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        this.flag = true</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p :class=&quot;&#123;fontBold: flag&#125;&quot; @click=&quot;toggle&quot;&gt;这是一个段落&lt;/p&gt;</span><br><span class="line">    &lt;p :class=&quot;&#123;flag? fontBold:&apos;&apos;&#125;&quot; @click=&quot;toggle&quot;&gt;这是一个段落&lt;/p&gt;</span><br><span class="line">    &lt;!-- 三元表达式 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="样式绑定"><a href="#样式绑定" class="headerlink" title="样式绑定"></a>样式绑定</h3><blockquote><p>使用<code>v-bind:style</code>语法，为元素绑定样式</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:style</span>=<span class="string">"&#123;color:'red','font-weight':'bold'&#125;"</span>&gt;</span></span><br><span class="line">    一段文字</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>也可以在<code>vue</code>的<code>data</code>中定义一个对象，用来描述样式，其中带有连字符的样式属性要加引号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p :style=&quot;styleObj&quot;&gt;一段文字&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">styleObj: &#123;</span><br><span class="line">color:&apos;red&apos;,</span><br><span class="line">&apos;font-weight&apos;:&apos;bold&apos;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li><code>data</code>中的对象也可以通过数组类型绑定到元素上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p :style=&quot;[styleObj1,styleObj2]&quot;&gt;一段文字&lt;/p&gt;</span><br><span class="line">    &lt;!-- 对于js的样式绑定不需要加引号，因为就是一个变量 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">styleObj1: &#123;</span><br><span class="line">    border: &apos;1px solid gray&apos;,</span><br><span class="line">    width: &apos;100px&apos;,</span><br><span class="line">&#125;,</span><br><span class="line">styleObj2:&#123;</span><br><span class="line">    background: &apos;black&apos;,</span><br><span class="line">    color: &apos;blue&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><blockquote><p>通过条件指令可以控制元素的显示及隐藏，或者说叫做创建和销毁</p></blockquote><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><blockquote><p><code>v-if</code>指令用于条件性的渲染一块内容。这块内容只会在指令的表达式返回<code>truthy</code>值的时候渲染</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-cloak id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-if=&quot;oh3&quot;&gt;h3标题&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p v-if=&quot;gender === &apos;girl&apos;&quot;&gt;你是女的&lt;/p&gt;</span><br><span class="line">    &lt;p v-else-if=&quot;gender === &apos;boy&apos;&quot;&gt;你是男的&lt;/p&gt;</span><br><span class="line">    &lt;p v-else&gt;不男不女&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                oh3:&quot;a&quot;,</span><br><span class="line">                gender: &apos;other&apos;</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li><code>truthy</code>和<code>ture</code>的区别：</li><li>隐含有<code>true</code>属性的变量不可以认为它是<code>true</code>，它不是<code>boolean</code>类型</li></ul><h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><blockquote><p>与<code>v-if</code>不同的是，<code>v-show</code> 的元素始终会被渲染并保留在<code>DOM</code>中</p><p><code>v-show</code> 只是简单地切换元素的<code>CSS</code>属性 <code>display</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-cloak id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-if=&quot;oh3&quot;&gt;h3标题&lt;/h3&gt;</span><br><span class="line">    &lt;h4 v-show=&quot;oh4&quot;&gt;h4标题&lt;/h4&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                oh3:&quot;1&quot;, // v-if 在该变量不为真时直接消失在document中</span><br><span class="line">                oh4:&quot;1&quot;, // v-show 处理不为真的变量条件 绑定元素不会消失</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h4><blockquote><p>把一个数组对应为一组元素</p><p>用 <code>v-for</code> 指令根据一组数组的选项列表进行渲染</p></blockquote><blockquote><p><code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，<code>items</code> 是源数据数组并且 <code>item</code> 是数组元素迭代的别名</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;li v-for=&quot;user in users&quot;&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; user.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                users: [</span><br><span class="line">                    &#123;name:&quot;张三&quot;,age:18&#125;,</span><br><span class="line">                    &#123;name:&quot;李四&quot;,age:20&#125;,</span><br><span class="line">                    &#123;name:&quot;王五&quot;,age:19&#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>v-for还可以支持将当前循环索引作为渲染时的第二个参数，第二个参数为访问索引位置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p  v-for=&quot;(user,index) in users&quot;&gt;</span><br><span class="line">    &#123;&#123; index &#125;&#125;:&#123;&#123; user.age &#125;&#125;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">    users: [</span><br><span class="line">        &#123;name:&quot;张三&quot;,age:18&#125;,</span><br><span class="line">        &#123;name:&quot;李四&quot;,age:20&#125;,</span><br><span class="line">        &#123;name:&quot;王五&quot;,age:19&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>使用<code>v-for</code>迭代访问一个对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-for=&quot;key in myself&quot;&gt; </span><br><span class="line">    &#123;&#123; key &#125;&#125;</span><br><span class="line">    &lt;!-- 当v-for渲染时只有一个参数，此时参数为value值 --&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myself : &#123;</span><br><span class="line">    name:&quot;赵六&quot;,</span><br><span class="line">    age:&quot;17&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>v-for</code>支持最多三个参数，同时获取遍历对象的<code>key</code>和<code>value</code>值，以及<code>index</code>索引位置</li></ul><blockquote><p>要注意的是，此时的<code>key</code>和<code>value</code>和<code>python</code>中的顺序是颠倒的，<code>key</code>在后，<code>value</code>在前</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-for=&quot;(value,key,index) in myself&quot;&gt;</span><br><span class="line">    &#123;&#123; index &#125;&#125;: &#123;&#123; key &#125;&#125; - &#123;&#123; value &#125;&#125;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myself : &#123;</span><br><span class="line">    name:&quot;孙七&quot;,</span><br><span class="line">    age:&quot;17&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>v-for</code>进行一段取值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p v-for=&quot;n in 8&quot;&gt;</span><br><span class="line">        &#123;&#123; n &#125;&#125;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;!-- 1 2 3 4 5 6 7 8 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="选项卡练习"><a href="#选项卡练习" class="headerlink" title="选项卡练习"></a>选项卡练习</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                choicId: null,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    li&#123;</span><br><span class="line">        list-style-type: none;</span><br><span class="line">        border: 3px outset lightgreen;</span><br><span class="line">        width: 100px;</span><br><span class="line">        background:lightblue;</span><br><span class="line">        margin:5px;</span><br><span class="line">    &#125;</span><br><span class="line">    li:hover&#123;</span><br><span class="line">        border: 3px inset gray;</span><br><span class="line">        cursor: pointer;</span><br><span class="line">    &#125;</span><br><span class="line">    [v-cloak]&#123;</span><br><span class="line">        display: none;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-cloak id=&quot;container&quot;&gt;   </span><br><span class="line">    &lt;ol list&gt;</span><br><span class="line">        &lt;li @click=&quot;choicId = 1&quot;&gt;A&lt;/li&gt;</span><br><span class="line">        &lt;li @click=&quot;choicId = 2&quot;&gt;B&lt;/li&gt;</span><br><span class="line">        &lt;li @click=&quot;choicId = 3&quot;&gt;C&lt;/li&gt;</span><br><span class="line">        &lt;li @click=&quot;choicId = 4&quot;&gt;D&lt;/li&gt;</span><br><span class="line">    &lt;/ol&gt;</span><br><span class="line">    &lt;p v-show=&quot;choicId == 1&quot;&gt;aaaaaaaaaa&lt;/p&gt;</span><br><span class="line">    &lt;p v-show=&quot;choicId == 2&quot;&gt;bbbbbbbbbb&lt;/p&gt;</span><br><span class="line">    &lt;p v-show=&quot;choicId == 3&quot;&gt;cccccccccc&lt;/p&gt;</span><br><span class="line">    &lt;p v-show=&quot;choicId == 4&quot;&gt;dddddddddd&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li><code>js</code>中两个等号和三个等号的区别：</li></ul><blockquote><p><code>==</code>表示： 如果两边值的类型不同的时候，是要先先进行类型转换后，才能做比较；<code>equality</code>等同</p></blockquote><blockquote><p><code>===</code>表示：不需要做类型转换，如果两边值的类型不同，就表示一定是不等的<code>identity</code>恒等</p></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p><code>Vue</code>无法检测到对于数组的索引设置及长度修改以及对于对象属性的删除或添加</p><p>但是可以通过以下方式进行属性添加触发状态更新</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.set($vm.Object,&quot;key&quot;,&quot;val&quot;) // 对于对象 这样的添加方式可以触发状态更新</span><br><span class="line">Vue.set($vm.Array, index, newVal) // 对于数组 添加元素 触发状态更新</span><br><span class="line">// vm.items.splice(newLength) // 设置数组长度</span><br></pre></td></tr></table></figure><ul><li><code>javascript.splice(where, num, [additem1,additem2...] )</code>：删除或添加元素</li></ul><blockquote><p>此外，当<code>v-for</code>与<code>v-if</code>同时使用时，<code>v-for</code>有更高的优先级，这会造成重复遍历得到的元素都要在做一次<code>v-if</code>的判断，如果我们是为了有目的判断当前是否需要渲染这个元素，或是跳过这个循环，可以将<code>v-if</code>放在外层元素，比如<code>template</code>标签中，(<code>template</code>标签无实际意义，默认不展示，但是可以起到包裹作用)</p></blockquote><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><blockquote><p><code>Vue.js</code>允许你自定义过滤器，可被用于一些常见的文本，对它们进行格式化</p></blockquote><blockquote><p>过滤器可以用在两个地方：<strong>双花括号插值和 v-bind 表达式</strong> (后者从 2.1.0+ 开始支持)</p><p>过滤器应该被添加在<code>JavaScript</code>表达式的尾部，由<code>管道</code>符号指示</p></blockquote><ul><li>语法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    &#123;&#123; message | filter &#125;&#125;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p v-bind:type=&quot;message | filter&quot;&gt; &lt;/p&gt;</span><br></pre></td></tr></table></figure><ul><li>过滤器本质上是一个函数，比如我们定义一个将表单输入的内容中所有的字母变大写的过滤器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div v-cloak id=&quot;container&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br><span class="line">        &lt;p&gt;展示: &#123;&#123; message | toUpper &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &quot;&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">            filters: &#123;</span><br><span class="line">                toUpper: function (value) &#123;</span><br><span class="line">                    if (!value) return &apos;&apos; // 字符串内容为空 直接返回</span><br><span class="line">                    console.log(&quot;正在变大小&quot;)</span><br><span class="line">                    return String(value).toUpperCase()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>过滤器函数也可以有多个参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filter(arg1, arg2) &#125;&#125;</span><br><span class="line">// message 第一个参数</span><br><span class="line">// arg1 第二个参数</span><br><span class="line">// arg2 第三个参数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-cloak id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br><span class="line">    &lt;p&gt;展示: &#123;&#123; message | toLong(&quot;| &quot;,&quot; |&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">    toLong(value,arg1,arg2)&#123;</span><br><span class="line">        if (!value) return &apos;&apos;</span><br><span class="line">        return arg1 + value + arg2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue实例生命周期"><a href="#Vue实例生命周期" class="headerlink" title="Vue实例生命周期"></a>Vue实例生命周期</h3><blockquote><p>每个<code>Vue</code>实例在被创建时都要经过一系列的初始化过程</p><p>例如：需要设置数据监听、编译模板、将实例挂载到<code>DOM</code>并在数据变化时更新<code>DOM</code>等</p><p>同时在这个过程中会自动运行一些叫做生命周期钩子的函数，我们可以使用这些函数，在实例的不同阶段加上我们需要的代码，实现特定的功能</p></blockquote><ul><li><code>beforeCreate</code>：数据还没有监听，没有绑定到<code>vue</code>对象实例，同时也没有挂载对象</li><li><code>created</code>：数据已经绑定到了对象实例，但是还没有挂载对象</li><li><code>beforeMount</code>：模板已经编译好了，根据数据和模板已经生成了对应的元素对象，将数据对象关联到了对象的<code>$el</code>属性</li></ul><blockquote><p><code>$el</code>属性是一个<code>HTMLElement</code>对象，也就是这个阶段，<code>vue</code>实例通过原生的<code>createElement</code>等方法来创建这个<code>html</code>片段，准备注入到我们<code>vue</code>实例指明的<code>el</code>属性所对应的挂载点</p></blockquote><ul><li><code>mounted</code>： 将<code>$el</code>的内容挂载到了<code>el</code>，相当于我们在<code>jQuery</code>执行了<code>$(el).html($el)</code>，生成页面上真正的<code>dom</code></li></ul><blockquote><p>上面我们就会发现页面的元素和我们<code>$el</code>的元素是一致的；在此之后，我们能够用方法来获取到<code>el</code>元素下的<code>dom</code>对象，并进行各种操作</p></blockquote><ul><li><code>beforeUpdate</code>：数据发生变化时调用</li><li><code>updated</code>：由于数据更改导致的虚拟<code>DOM</code>重新渲染和打补丁，在这之后会调用该钩子</li><li><code>beforeDestroy</code>：<code>Vue</code>实例销毁前</li><li><code>destroyed</code>：<code>Vue</code>实例销毁后</li></ul><blockquote><p><code>window.$vm.$destroy()</code></p></blockquote><ul><li>一大段代码进行钩子函数的调用过程监控</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">    function showData(process, vm) &#123;</span><br><span class="line">        console.log(process)</span><br><span class="line">        console.log(&quot;vue数据:&quot;, vm.message) // 当前Vue中的数据</span><br><span class="line">        console.log(&quot;Vue挂载el:&quot;) // Vue接管的元素</span><br><span class="line">        console.log(vm.$el) </span><br><span class="line">        console.log(&quot;真实Dom:&quot;)</span><br><span class="line">        console.log(document.getElementById(&quot;container&quot;).innerHTML)</span><br><span class="line">        console.log(&apos;-----------------&apos;)</span><br><span class="line">    &#125; // 这个函数用来输出相关信息的</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &quot;#container&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &quot;aaaaa&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeCreate: function () &#123;</span><br><span class="line">            showData(&quot;创建Vue实例前&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        created: function () &#123;</span><br><span class="line">            showData(&quot;创建Vue实例后&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount: function () &#123;</span><br><span class="line">            showData(&quot;挂载到Dom前&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted: function () &#123;</span><br><span class="line">            showData(&quot;挂载到Dom后&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate: function () &#123;</span><br><span class="line">            showData(&quot;数据发生变化时&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        updated: function () &#123;</span><br><span class="line">            showData(&quot;数据发生变化后&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeDestroy: function () &#123;</span><br><span class="line">            showData(&quot;Vue实例销毁前&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        destroyed: function () &#123;</span><br><span class="line">            showData(&quot;Vue实例销毁后&quot;, this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p v-html=&quot;message&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a>ES6语法</h4><blockquote><p><code>ES6</code>是<code>JavaScript</code>语言的新版本，它也可以叫做<code>ES2015</code>，之前学习的<code>JavaScript</code>属于<code>ES5</code>，<code>ES6</code>在它的基础上增加了一些语法</p><p><code>ES6</code>是未来<code>JavaScript</code>的趋势，而且<code>vue</code>组件开发中会使用很多的<code>ES6</code>的语法，所以掌握这些常用的<code>ES6</code>语法是必须的</p></blockquote><h5 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h5><ul><li><code>let</code>：定义封闭作用域的变量，并且变量只能声明一次</li><li><code>const</code>：定义封闭作用域的常量，并且变量只能声明一次</li></ul><blockquote><p><code>let</code>和<code>const</code>是新增的声明变量的开头的关键字，在这之前，变量声明是用<code>var</code>关键字</p><p>这两个关键字和<code>var</code>的区别是，它们声明的变量没有<strong>预解析</strong>，无法脱离定义空间使用</p><p><code>let</code>和<code>const</code>的区别是，<code>let</code>声明的是一般变量，<code>const</code>申明的常量，不可修改</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(a) // undefined</span><br><span class="line">console.log(b) // b is not defined</span><br><span class="line">console.log(c) // c is not defined</span><br><span class="line">var a =  1</span><br><span class="line">var a = 2</span><br><span class="line">let b = 2</span><br><span class="line">// let b = 3 // Identifier &apos;b&apos; has already been declared</span><br><span class="line">const c = 3</span><br><span class="line">// const c = 4 // Identifier &apos;c&apos; has already been declared</span><br><span class="line">c = 4 //  Assignment to constant variable</span><br></pre></td></tr></table></figure><h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><blockquote><p>可以把箭头函数理解成匿名函数的第二种写法，箭头函数的作用是可以在对象中绑定<code>this</code></p><p>解决了<code>JavaScript</code>中<code>this</code>指定混乱的问题</p></blockquote><ul><li>定义函数的一般方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function func()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>匿名赋值创建函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var func = function()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>箭头函数的写法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var func = (a, b) =&gt; &#123;</span><br><span class="line">    // 这样的函数在嵌套时，会自动绑定外部作用域下的this</span><br><span class="line">&#125;</span><br><span class="line">var func = a =&gt; &#123;</span><br><span class="line">    // 一个参数时，可以省略参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function () &#123;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &quot;#container&quot;,</span><br><span class="line">        data: &#123; message: &quot;abcdef&quot;, &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            show() &#123;</span><br><span class="line">                console.log(&quot;这是show函数:&quot;, this.message),</span><br><span class="line">                    func = () =&gt; &#123;</span><br><span class="line">                    console.log(&quot;我是内部函数:&quot;, this.message)</span><br><span class="line">                &#125;,</span><br><span class="line">                    func(), // 调用一下这个内部函数</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;show&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h4><blockquote><p>组件<code>Component</code>是<code>Vue.js</code>最强大的功能之一</p></blockquote><blockquote><p>组件可以扩展<code>HTML</code>元素，<strong>封装可重用的代码</strong></p><p>所有的<code>Vue</code>组件同时也都是<code>Vue</code>的实例，所以可接受相同的选项对象（除了一些根级特有的选项）并提供相同的生命周期钩子</p></blockquote><h5 id="注册全局组件"><a href="#注册全局组件" class="headerlink" title="注册全局组件"></a>注册全局组件</h5><ul><li>注册一个全局组件语法格式如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(tagName, options)</span><br><span class="line">// tagName：组件名</span><br><span class="line">// options：配置选项</span><br></pre></td></tr></table></figure><ul><li>比如这样一个全局组件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;button_show&apos;, &#123;</span><br><span class="line">    data: function () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            count: 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, // 当前组件会需要的数据，定义为函数的返回值</span><br><span class="line">    template: &apos;&lt;button @click=&quot;count++&quot;&gt;按钮:&#123;&#123; count &#125;&#125;&lt;/button&gt;&apos;</span><br><span class="line">    // 组件的标签模板</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>接下来可以在任何<code>Vue</code>接管的元素中使用该组件，</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;button_show&gt;&lt;/button_show&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function () &#123;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">    el: &quot;#container&quot;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="data必须是函数"><a href="#data必须是函数" class="headerlink" title="data必须是函数"></a>data必须是函数</h5><blockquote><p>组件就是<code>vue</code>的实例，所有<code>vue</code>实例中属性和方法，组件中也可以用</p><p>其中<code>data</code>属性必须是一个函数，因为组件会重复使用在多个地方，为了使用在多个地方的组件数据相对独立，<code>data</code>属性需要用一个函数的返回值来将数据处理为不同的每个个体</p></blockquote><h5 id="Prop传递数据"><a href="#Prop传递数据" class="headerlink" title="Prop传递数据"></a>Prop传递数据</h5><blockquote><p><code>Prop</code>是你可以在组件上注册的一些自定义特性</p><p>当一个值传递给一个<code>prop</code>特性的时候，它就变成了那个组件实例的一个属性</p><p>为了给组件传递数据，我们可以用一个 <code>props</code> 选项将一些特性值列举在其中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    Vue.component(&quot;myp&quot;,&#123;</span><br><span class="line">        props: [&quot;content&quot;,&quot;like&quot;], // 需要两个外界传入的值</span><br><span class="line">        template: &quot;&lt;p :class=&apos;like&apos;&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt;&quot;</span><br><span class="line">        // 组件绑定未来要接受的变量，要用到v:bind</span><br><span class="line">    &#125;)</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                content: &apos;这是p段落的文本&apos;,</span><br><span class="line">                like: &apos;beauty&apos;, // 要传递的变量</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">.beauty&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    color: red;</span><br><span class="line">    background: green;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;myp :like=&quot;like&quot; :content=&quot;content&quot;&gt;&lt;/myp&gt;</span><br><span class="line">    &lt;!-- 传递到组件中 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;VUE&quot;&gt;&lt;a href=&quot;#VUE&quot; class=&quot;headerlink&quot; title=&quot;VUE&quot;&gt;&lt;/a&gt;VUE&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Vue.js&lt;/code&gt;是前端三大新框架：&lt;code&gt;Angular.js&lt;/code&gt;、&lt;code&gt;React.js&lt;/code&gt;、&lt;code&gt;Vue.js&lt;/code&gt;之一，&lt;code&gt;Vue.js&lt;/code&gt;目前的使用和关注程度在三大框架中稍微胜出，并且它的热度还在递增&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Vue&lt;/code&gt;的核心库只关注视图层，&lt;code&gt;Vue&lt;/code&gt;的目标是通过尽可能简单的&lt;code&gt;API&lt;/code&gt;实现响应的数据绑定，在这一点上&lt;code&gt;Vue.js&lt;/code&gt;类似于后台的模板语言&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Vue&lt;/code&gt;也可以将界面拆分成一个个的组件，通过组件来构建界面，然后用自动化工具来生成单页面(&lt;code&gt;SPA - single page application&lt;/code&gt;)系统&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://cy-blogs.cn/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://cy-blogs.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue-路由组件</title>
    <link href="https://cy-blogs.cn/Vue-%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6/"/>
    <id>https://cy-blogs.cn/Vue-路由组件/</id>
    <published>2019-12-09T11:52:36.344Z</published>
    <updated>2019-12-09T11:54:44.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue-Router"></a>Vue-Router</h2><blockquote><p><code>Vue-router</code>做路径匹配时支持动态片段、全匹配片段以及查询参数（片段指的是<code>URL</code>中的一部分）</p><p>对于解析过的路由，这些信息都可以通过路由上下文对象（从现在起，我们会称其为路由对象）访问。</p><p>在使用了<code>vue-router</code>的应用中，路由对象会被注入每个组件中，赋值为<code>this.$route</code>，并且当路由切换时，路由对象会被更新</p></blockquote><a id="more"></a><h3 id="Vue的两种模式"><a href="#Vue的两种模式" class="headerlink" title="Vue的两种模式"></a>Vue的两种模式</h3><blockquote><p>一般单页面应用是(<code>SPA</code>)不会请求页面而是只更新视图</p><p><code>vue-router</code>提供了两种方式来实现前端路由：<code>Hash</code>模式和<code>History</code>模式,可以用<code>mode</code>参数来决定使用哪一种方式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &apos;history&apos;,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>hash</code>模式：<code>vue-router</code>默认使用<code>Hash</code>模式，使用 <code>url</code>的<code>hash</code>来模拟一个完整的<code>url</code>；此时<code>url</code>变化时，浏览器是不会重新加载的；<code>Hash(即#)</code>是<code>url</code>的锚点，代表的是网页中的一个位置，仅仅改变<code>#</code>后面部分，浏览器只会滚动对应的位置，而不会重新加载页面。<code>#</code>仅仅只是对浏览器进行指导，而对服务端是完全没有作用的！它不会被包括在<code>http</code>请求中，故也不会重新加载页面。同时<code>hash</code>发生变化时，<code>url</code>都会被浏览器记录下来，这样你就可以使用浏览器的后退了</li><li><code>History</code>模式：如果你不喜欢<code>hash</code>这种<code>#</code>样式，可以使用<code>history</code>模式。这种模式利用了<code>HTML5 History</code>新增的<code>pushState()</code>和<code>replaceState()</code>方法。除了之前的<code>back</code>，<code>forward</code>，<code>go</code>方法；这两个新方法可以应用在<strong>浏览器历史记录</strong>的增加替换功能上。使用<code>History</code>模式，通过历史记录修改<code>url</code>。但它不会立即向后端发送请求。</li></ul><blockquote><p>注意：虽然<code>History</code>模式可以丢掉不美观的<code>#</code>，也可以正常的前进后退，但是刷新<code>f5</code>后，此时浏览器就会访问服务器，在没有后台支持的情况下，此时就会得到一个<code>404</code>！</p><p>官方文档给出的描述是：<code>不过这种模式要玩好；还需要后台配置支持</code></p><p>因为我们的应用是单个客户端应用，如果后台没有正确的配置，当用户直接访问时,就会返回<code>404</code>，所以，要在服务端增加一个覆盖所有情况的的候选资源。如果<code>url</code>匹配不到任何静态资源；则应该返回同一个<code>index.html</code>页面</p></blockquote><h3 id="路由属性"><a href="#路由属性" class="headerlink" title="路由属性"></a>路由属性</h3><ul><li><p>路由对象<code>this.$route</code>支持属性</p><ul><li><code>$route.path</code>：字符串，等于当前路由对象的路径，会被解析为绝对路径</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/aaa/</span>bbb</span><br></pre></td></tr></table></figure><ul><li><code>$route.params</code>：包含路由中的动态片段和全匹配片段的键值对</li><li><code>$route.query</code>：获取连接中查询参数的键值对</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/foo?user=1</span><br><span class="line">// 可以获取到</span><br><span class="line">$route.query.user == 1</span><br></pre></td></tr></table></figure><ul><li><code>$route.router</code>：路由规则所属的路由器以及其所属的组件</li><li><code>$route.matched</code>：数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象</li><li><code>$route.name</code>：当前路径的名字</li></ul></li><li><p>路由中设置自定义参数</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.map(&#123;</span><br><span class="line">  &apos;/a&apos;: &#123;</span><br><span class="line">    component: &#123; ... &#125;,</span><br><span class="line">    auth: true // 这里 auth 是一个自定义字段</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>当 <code>/a</code> 被匹配时，<code>$route.auth</code> 的值将会是 <code>true</code>。我们可以利用这个特性在全局的钩子函数中进行身份验证</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(function (transition) &#123;</span><br><span class="line">  if (transition.to.auth) &#123;</span><br><span class="line">    // 对用户身份进行验证...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="动态路由（-号通配符）"><a href="#动态路由（-号通配符）" class="headerlink" title="动态路由（:号通配符）"></a>动态路由（:号通配符）</h3><blockquote><p>路由中的动态片段使用以冒号开头的路径片段定义</p><p>类比<code>django</code>中的路由传参</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path(&apos;&lt;int:name&gt;/&apos;,views.xx),</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path: &apos;/user/:username&apos;,</span><br><span class="line">component: &#123;</span><br><span class="line">    template: &apos;&lt;p&gt;用户名是&#123;&#123;$route.params.username&#125;&#125;&lt;/p&gt;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一条路径中可以包含多个动态片段，每个片段都会被解析成 <code>$route.params</code> 的一个键值对</p></blockquote><ul><li>解析模式</li></ul><table><thead><tr><th>模式</th><th>匹配的路径</th><th>$route.params</th></tr></thead><tbody><tr><td><code>/user/:username</code></td><td><code>/user/evan</code></td><td><code>{ username: &#39;evan&#39; }</code></td></tr><tr><td><code>/user/:username/post/:post_id</code></td><td><code>/user/evan/post/123</code></td><td><code>{ username: &#39;evan&#39;, post_id: 123 }</code></td></tr></tbody></table><h3 id="全匹配路由（-号通配符）"><a href="#全匹配路由（-号通配符）" class="headerlink" title="全匹配路由（*号通配符）"></a>全匹配路由（*号通配符）</h3><blockquote><p>动态片段只能匹配路径中的一个部分，而全匹配片段则基本类似于它的贪心版</p><p>例如 <code>/foo/*bar</code> 会匹配任何以 <code>/foo/</code> 开头的路径</p><p>当使用一个通配符时，<code>$route.params</code>内会自动添加一个名为<code>pathMatch</code>的参数，其中包含了在连接中通过通配符所匹配到的部分</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;/user/*/cc&apos;,</span><br><span class="line">    name: &apos;User&apos;,</span><br><span class="line">    component: User,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>访问的<code>URL</code>如下</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8080</span><span class="regexp">/user/</span><span class="number">1231</span><span class="regexp">/aaa/</span>cc</span><br></pre></td></tr></table></figure><ul><li>那么此时<code>*</code>通配符拿到的部分为</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"pathMatch"</span>: <span class="string">"1231/aaa"</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="具名路径（命名路由）"><a href="#具名路径（命名路由）" class="headerlink" title="具名路径（命名路由）"></a>具名路径（命名路由）</h3><ul><li>类似<code>django</code>的路由命名，<code>vue</code>路由映射中也可以为某一个路由通过<code>name</code>属性设置命名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;/user/:userid&apos;,</span><br><span class="line">    name: &apos;User&apos;,</span><br><span class="line">    component: User,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>在使用<code>v-link</code>标签进行路由跳转时，就可以更加方便啦</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;name: &apos;User&apos;, params: &#123;userid: &apos;zhangsan&apos; &#125;&#125;&quot;&gt;user&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><ul><li>也可以在<code>js</code>代码中使用<code>router.go</code>切换到该路径下</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">router</span><span class="selector-class">.go</span>(&#123; <span class="attribute">name</span>: <span class="string">'user'</span>, params: &#123; userId: <span class="number">123</span> &#125;&#125;)</span><br></pre></td></tr></table></figure><h2 id="V-link"><a href="#V-link" class="headerlink" title="V-link"></a>V-link</h2><ul><li><code>v-link</code> 是一个用来让用户在<code>vue-router</code>应用的不同路径间跳转的指令。该指令接受一个<code>JavaScript</code>表达式，并会在用户点击元素时用该表达式的值去调用 <code>router.go</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 字面量路径 --&gt;</span><br><span class="line">&lt;a v-link=&quot;&apos;home&apos;&quot;&gt;Home&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 效果同上 --&gt;</span><br><span class="line">&lt;a v-link=&quot;&#123; path: &apos;home&apos; &#125;&quot;&gt;Home&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 具名路径 --&gt;</span><br><span class="line">&lt;a v-link=&quot;&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/a&gt;</span><br></pre></td></tr></table></figure><ul><li>应该使用 <code>v-link</code> 而不是 <code>href</code> 来处理浏览时的跳转。原因如下<ul><li>它在<code>HTML5 history</code>模式和<code>hash</code>模式下的工作方式相同，所以如果你决定改变模式，或者<code>IE9</code>浏览器退化为<code>hash</code>模式时，都不需要做任何改变</li></ul></li><li>在<code>HTML5 history</code>模式下，<code>v-link</code> 会监听点击事件，防止浏览器尝试重新加载页面</li><li>在<code>HTML5 history</code>模式下使用 <code>root</code> 选项时，不需要在 <code>v-link</code> 的<code>URL</code>中包含<code>root</code>路径</li></ul><h3 id="V-Link其他选项"><a href="#V-Link其他选项" class="headerlink" title="V-Link其他选项"></a>V-Link其他选项</h3><ul><li>replace</li></ul><blockquote><p>一个带有 <code>replace: true</code> 的链接被点击时将会触发 <code>router.replace()</code> 而不是 <code>router.go()</code>。由此产生的跳转不会留下历史记录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;name: &apos;User&apos;, params: &#123;userid: &apos;zhangsan&apos; &#125;, replace: true &#125;&quot;&gt;replace&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><ul><li>append</li></ul><blockquote><p>带有 <code>append: true</code> 选项的相对路径链接会确保该相对路径始终添加到当前路径之后。举例来说，从 <code>/a</code> 跳转到相对路径 <code>b</code> 时，如果没有 <code>append: true</code> 我们会跳转到 <code>/b</code>，但有 <code>append: true</code> 则会跳转到 <code>/a/b</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;name: &apos;User&apos;, append: true &#125;&quot;&gt;append&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h2 id="路由钩子"><a href="#路由钩子" class="headerlink" title="路由钩子"></a>路由钩子</h2><blockquote><p>全局的钩子</p></blockquote><ul><li><code>beforeEach(to, from, next)</code></li></ul><blockquote><p>添加一个全局的前置钩子函数，这个函数会在路由切换开始时调用。调用发生在整个切换流水线之前。如果此钩子函数拒绝了切换，整个切换流水线根本就不会启动</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const router = new Router(&#123;</span><br><span class="line">   ...</span><br><span class="line">export default router</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // to and from are both route objects. must call `next`.</span><br><span class="line">  console.log(to) // to: Route: 即将要进入的目标 路由对象</span><br><span class="line">  console.log(&apos;-------------&apos;)</span><br><span class="line">  console.log(from) // from: Route: 当前导航正要离开的路由</span><br><span class="line">  console.log(&apos;-------------&apos;)</span><br><span class="line">  console.log(next) // 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>路由解析流程</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>导航被触发。</span><br><span class="line"><span class="number">2.</span>在失活的组件里调用离开守卫。</span><br><span class="line"><span class="number">3.</span>调用全局的 beforeEach 守卫。</span><br><span class="line"><span class="number">4.</span>在重用的组件里调用 beforeRouteUpdate 守卫 (<span class="number">2.2</span>+)。</span><br><span class="line"><span class="number">5.</span>在路由配置里调用 beforeEnter。</span><br><span class="line"><span class="number">6.</span>解析异步路由组件。</span><br><span class="line"><span class="number">7.</span>在被激活的组件里调用 beforeRouteEnter。</span><br><span class="line"><span class="number">8.</span>调用全局的 beforeResolve 守卫 (<span class="number">2.5</span>+)。</span><br><span class="line"><span class="number">9.</span>导航被确认。</span><br><span class="line"><span class="number">10.</span>调用全局的 afterEach 钩子。</span><br><span class="line"><span class="number">11.</span>触发 DOM 更新。</span><br><span class="line"><span class="number">12.</span>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</span><br></pre></td></tr></table></figure><ul><li>使用<code>beforeEach</code>控制路由跳转，拦截路由</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // to and from are both route objects. must call `next`.</span><br><span class="line">  let toQuery = JSON.parse(JSON.stringify(to.query));</span><br><span class="line">  console.log(toQuery) // 获取连接参数</span><br><span class="line">  if(to.meta.requiredAuth == true)&#123; // 如果要进入的路由需要用户登陆</span><br><span class="line">    if(window.localStorage.getItem(&apos;username&apos;))&#123; // 获取存储的用户名</span><br><span class="line">      next()</span><br><span class="line">    &#125; else&#123; // 没有获取到，则跳转到登陆页面</span><br><span class="line">      next(&#123;</span><br><span class="line">        path: &apos;/&apos;,</span><br><span class="line">        query: toQuery,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vue-Router&quot;&gt;&lt;a href=&quot;#Vue-Router&quot; class=&quot;headerlink&quot; title=&quot;Vue-Router&quot;&gt;&lt;/a&gt;Vue-Router&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Vue-router&lt;/code&gt;做路径匹配时支持动态片段、全匹配片段以及查询参数（片段指的是&lt;code&gt;URL&lt;/code&gt;中的一部分）&lt;/p&gt;
&lt;p&gt;对于解析过的路由，这些信息都可以通过路由上下文对象（从现在起，我们会称其为路由对象）访问。&lt;/p&gt;
&lt;p&gt;在使用了&lt;code&gt;vue-router&lt;/code&gt;的应用中，路由对象会被注入每个组件中，赋值为&lt;code&gt;this.$route&lt;/code&gt;，并且当路由切换时，路由对象会被更新&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://cy-blogs.cn/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://cy-blogs.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Django-DBrouter</title>
    <link href="https://cy-blogs.cn/Django%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    <id>https://cy-blogs.cn/Django数据库路由器/</id>
    <published>2019-12-09T11:29:54.640Z</published>
    <updated>2019-12-09T11:29:55.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DB-router"><a href="#DB-router" class="headerlink" title="DB-router"></a>DB-router</h2><blockquote><p>通过编写<strong>db-router</strong>可以灵性连接<strong>mysql</strong>主从复制等情况下的多数据库</p></blockquote><ul><li>假设你已经配置好了类似<strong>MYSQL</strong>主从复制的服务，如果没有可以参照<a href="https://lienze.tech/blog/mysql/c813917a.html" target="_blank" rel="noopener">这里</a></li></ul><a id="more"></a><h3 id="配置Django数据库连接"><a href="#配置Django数据库连接" class="headerlink" title="配置Django数据库连接"></a>配置Django数据库连接</h3><ul><li>settings.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;  </span><br><span class="line">    <span class="string">'default'</span>: &#123;     </span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,  </span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'192.168.1.101'</span>,   </span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,   </span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,    </span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,  </span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'test1'</span> </span><br><span class="line">    &#125;,    </span><br><span class="line">    <span class="string">'slave'</span>: &#123;     </span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,   </span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'192.168.1.102'</span>,  </span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,       </span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>, </span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,   </span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'test1'</span>  </span><br><span class="line">    &#125;&#125;</span><br><span class="line">DATABASE_ROUTERS = [<span class="string">'pro.utils.MasterSlaveDBRouter'</span>]</span><br></pre></td></tr></table></figure><ul><li>编写<strong>db-router</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MasterSlaveDBRouter</span>:</span>  </span><br><span class="line">    <span class="string">"""数据库主从读写分离路由"""</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_read</span><span class="params">(self, model, **hints)</span>:</span>   </span><br><span class="line">        <span class="string">"""读数据库"""</span>   </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"slave"</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_write</span><span class="params">(self, model, **hints)</span>:</span>  </span><br><span class="line">        <span class="string">"""写数据库"""</span>       </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"default"</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allow_relation</span><span class="params">(self, obj1, obj2, **hints)</span>:</span> </span><br><span class="line">        <span class="string">"""是否运行关联操作"""</span>     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>如出现以下错误，修改主库binlog日志格式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django.db.utils.InternalError: (1665, 'Cannot <span class="keyword">execute</span> <span class="keyword">statement</span>: impossible <span class="keyword">to</span> write <span class="keyword">to</span> <span class="built_in">binary</span> <span class="keyword">log</span> since BINLOG_FORMAT = <span class="keyword">STATEMENT</span> <span class="keyword">and</span> <span class="keyword">at</span> <span class="keyword">least</span> one <span class="keyword">table</span> uses a <span class="keyword">storage</span> <span class="keyword">engine</span> limited <span class="keyword">to</span> <span class="keyword">row</span>-based logging. <span class="keyword">InnoDB</span> <span class="keyword">is</span> limited <span class="keyword">to</span> <span class="keyword">row</span>-<span class="keyword">logging</span> <span class="keyword">when</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">is</span> <span class="keyword">READ</span> COMMITTED <span class="keyword">or</span> <span class="keyword">READ</span> UNCOMMITTED.<span class="string">')</span></span><br></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">binlog_format</span>=mixed</span><br></pre></td></tr></table></figure><h3 id="打开日志用以分析"><a href="#打开日志用以分析" class="headerlink" title="打开日志用以分析"></a>打开日志用以分析</h3><ul><li>可以通过配置<strong>mysql</strong>日志记录，用以查看主从在读写情况下的效果</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">general_log</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">general_log_file</span>=/var/lib/mysql/general.log</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DB-router&quot;&gt;&lt;a href=&quot;#DB-router&quot; class=&quot;headerlink&quot; title=&quot;DB-router&quot;&gt;&lt;/a&gt;DB-router&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;通过编写&lt;strong&gt;db-router&lt;/strong&gt;可以灵性连接&lt;strong&gt;mysql&lt;/strong&gt;主从复制等情况下的多数据库&lt;/p&gt;
&lt;/blockquote&gt;&lt;ul&gt;
&lt;li&gt;假设你已经配置好了类似&lt;strong&gt;MYSQL&lt;/strong&gt;主从复制的服务，如果没有可以参照&lt;a href=&quot;https://lienze.tech/blog/mysql/c813917a.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
  </entry>
  
  <entry>
    <title>Django-DBrouter</title>
    <link href="https://cy-blogs.cn/Django-DBrouter/"/>
    <id>https://cy-blogs.cn/Django-DBrouter/</id>
    <published>2019-12-09T09:11:32.684Z</published>
    <updated>2019-12-09T11:26:02.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DB-router"><a href="#DB-router" class="headerlink" title="DB-router"></a>DB-router</h2><blockquote><p>通过编写<strong>db-router</strong>可以灵性连接<strong>mysql</strong>主从复制等情况下的多数据库</p></blockquote><ul><li>假设你已经配置好了类似<strong>MYSQL</strong>主从复制的服务，如果没有可以参照<a href="https://lienze.tech/blog/mysql/c813917a.html" target="_blank" rel="noopener">这里</a></li></ul><a id="more"></a><h3 id="配置Django数据库连接"><a href="#配置Django数据库连接" class="headerlink" title="配置Django数据库连接"></a>配置Django数据库连接</h3><ul><li>settings.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;  </span><br><span class="line">    <span class="string">'default'</span>: &#123;     </span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,  </span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'192.168.1.101'</span>,   </span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,   </span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,    </span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,  </span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'test1'</span> </span><br><span class="line">    &#125;,    </span><br><span class="line">    <span class="string">'slave'</span>: &#123;     </span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,   </span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'192.168.1.102'</span>,  </span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,       </span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>, </span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,   </span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'test1'</span>  </span><br><span class="line">    &#125;&#125;</span><br><span class="line">DATABASE_ROUTERS = [<span class="string">'pro.utils.MasterSlaveDBRouter'</span>]</span><br></pre></td></tr></table></figure><ul><li>编写<strong>db-router</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MasterSlaveDBRouter</span>:</span>  </span><br><span class="line">    <span class="string">"""数据库主从读写分离路由"""</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_read</span><span class="params">(self, model, **hints)</span>:</span>   </span><br><span class="line">        <span class="string">"""读数据库"""</span>   </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"slave"</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_write</span><span class="params">(self, model, **hints)</span>:</span>  </span><br><span class="line">        <span class="string">"""写数据库"""</span>       </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"default"</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allow_relation</span><span class="params">(self, obj1, obj2, **hints)</span>:</span> </span><br><span class="line">        <span class="string">"""是否运行关联操作"""</span>     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>如出现以下错误，修改主库binlog日志格式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django.db.utils.InternalError: (1665, 'Cannot <span class="keyword">execute</span> <span class="keyword">statement</span>: impossible <span class="keyword">to</span> write <span class="keyword">to</span> <span class="built_in">binary</span> <span class="keyword">log</span> since BINLOG_FORMAT = <span class="keyword">STATEMENT</span> <span class="keyword">and</span> <span class="keyword">at</span> <span class="keyword">least</span> one <span class="keyword">table</span> uses a <span class="keyword">storage</span> <span class="keyword">engine</span> limited <span class="keyword">to</span> <span class="keyword">row</span>-based logging. <span class="keyword">InnoDB</span> <span class="keyword">is</span> limited <span class="keyword">to</span> <span class="keyword">row</span>-<span class="keyword">logging</span> <span class="keyword">when</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">is</span> <span class="keyword">READ</span> COMMITTED <span class="keyword">or</span> <span class="keyword">READ</span> UNCOMMITTED.<span class="string">')</span></span><br></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">binlog_format</span>=mixed</span><br></pre></td></tr></table></figure><h3 id="打开日志用以分析"><a href="#打开日志用以分析" class="headerlink" title="打开日志用以分析"></a>打开日志用以分析</h3><ul><li>可以通过配置<strong>mysql</strong>日志记录，用以查看主从在读写情况下的效果</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">general_log</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">general_log_file</span>=/var/lib/mysql/general.log</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DB-router&quot;&gt;&lt;a href=&quot;#DB-router&quot; class=&quot;headerlink&quot; title=&quot;DB-router&quot;&gt;&lt;/a&gt;DB-router&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;通过编写&lt;strong&gt;db-router&lt;/strong&gt;可以灵性连接&lt;strong&gt;mysql&lt;/strong&gt;主从复制等情况下的多数据库&lt;/p&gt;
&lt;/blockquote&gt;&lt;ul&gt;
&lt;li&gt;假设你已经配置好了类似&lt;strong&gt;MYSQL&lt;/strong&gt;主从复制的服务，如果没有可以参照&lt;a href=&quot;https://lienze.tech/blog/mysql/c813917a.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>WebSSH</title>
    <link href="https://cy-blogs.cn/WebSSH/"/>
    <id>https://cy-blogs.cn/WebSSH/</id>
    <published>2019-12-09T09:03:24.475Z</published>
    <updated>2019-12-09T11:26:56.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WebSSH"><a href="#WebSSH" class="headerlink" title="WebSSH"></a>WebSSH</h2><blockquote><p><code>webssh</code>从而<code>SSH</code>无需<code>Xshell</code>之类的模拟终端工具进行<code>SSH</code>连接，将<code>SSH</code>这一比较低层的操作也从<code>C/S</code>架构扭转成为<code>B/S</code>架构</p><p>这样的架构常用在运维制作开发一些堡垒机等系统，或者目前比较新型的在线教育方式，通过<code>WebSSH</code>向学生提供一个可以直接使用浏览器进行相关<code>Linux</code>操作或代码编写的学习方式</p><p><code>WebSSh</code>主要是建立客户端与服务端的即时通信</p></blockquote><a id="more"></a><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><ul><li>此种<code>WebSSH</code>实现方式，将通过结合<code>WebSocket</code>以及逐步的<code>Paramiko</code>来进行实现，所需要的技术栈如下</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">＃前端</span></span><br><span class="line"><span class="attr">vue</span> <span class="string"></span></span><br><span class="line"><span class="attr">websocket</span> <span class="string"></span></span><br><span class="line"><span class="attr">xterm.js</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后端</span></span><br><span class="line">django</span><br><span class="line">dwebsocket</span><br><span class="line">paramiko</span><br><span class="line">threading</span><br></pre></td></tr></table></figure><h3 id="技术介绍"><a href="#技术介绍" class="headerlink" title="技术介绍"></a>技术介绍</h3><ul><li><code>xterm</code></li></ul><blockquote><p>前端通过<code>xterm</code>插件进行<code>shell</code>黑窗口环境的构建，这个插件会自动解析由后台<code>paramiko</code>返回的带有标记样式的命令结果，并渲染到浏览器中，非常酷炫</p></blockquote><ul><li><code>websocket</code></li></ul><blockquote><p>这里通过<code>websocket</code>进行浏览器与<code>django</code>的数据交通同轴，<code>Websocket</code><a href="https://eastside.gitee.io/blog/django/d57108c1.html" target="_blank" rel="noopener">是什么</a></p></blockquote><ul><li><code>paramiko</code></li></ul><blockquote><p><code>paramiko</code>此时的角色采取承担<code>django</code>与<code>Linux</code>环境的互动，将前端发来的命令发送给后台，将后端发来的命令结果返回到前端的<code>xterm</code>组件中</p></blockquote><h3 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h3><blockquote><p>前端<code>xterm</code>组件使用：简单</p></blockquote><ul><li>安装<code>xterm</code></li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm安装xterm <span class="comment">--save</span></span><br></pre></td></tr></table></figure><ul><li><code>vue</code>框架中约会<code>xterm</code>的样式文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">// The Vue build version to load with the `import` command</span><br><span class="line">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import App from &apos;./App&apos;</span><br><span class="line">import router from &apos;./router&apos;</span><br><span class="line">import &apos;xterm/dist/xterm.css&apos; // 看这里，添加xterm css文件样式</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">/* eslint-disable no-new */</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>初始化<code>xterm</code>组件并添加两个插件：<code>attach</code>可以将终端附加到<code>websocket</code>流中，<code>fit</code>可以调整终端的大小以及行和列适应父级元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// index.vue</span><br><span class="line"></span><br><span class="line">import &#123; Terminal &#125; from &apos;xterm&apos;</span><br><span class="line">import * as attach from &apos;xterm/lib/addons/attach/attach&apos;</span><br><span class="line">import * as fit from &apos;xterm/lib/addons/fit/fit&apos;</span><br><span class="line"></span><br><span class="line">Terminal.applyAddon(attach)</span><br><span class="line">Terminal.applyAddon(fit)</span><br></pre></td></tr></table></figure><ul><li>构建<code>websocket</code>并绑定到终端，<code>websocket</code>地址为<code>ws</code>协议链接，此时使用的是即将在<code>django</code>中配置<code>Websocket</code>后台视图的路由，这一系列行为将挂载到钩子函数下进行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">    let terminalContainer = document.getElementById(<span class="string">'terminal'</span>)</span><br><span class="line">    this.term = new Terminal(this.terminal)</span><br><span class="line">    this.term.open(terminalContainer)</span><br><span class="line"></span><br><span class="line">    // open websocket</span><br><span class="line">    this.terminalSocket = new WebSocket(<span class="string">'ws://127.0.0.1:8000/webssh/'</span>)</span><br><span class="line">    this.terminalSocket.onopen = function()&#123;</span><br><span class="line">        console.log(<span class="string">'websocket is Connected...'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    this.terminalSocket.onclose = function()&#123;</span><br><span class="line">        console.log(<span class="string">'websocket is Closed...'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    this.terminalSocket.onerror = function()&#123;</span><br><span class="line">        console.log(<span class="string">'damn Websocket is broken!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    this.term.attach(this.terminalSocket)</span><br><span class="line">    // 绑定xterm到ws流中</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><ul><li>当浏览器关闭时，也代表着客户端关闭，此时主动插入连接，交给<code>vue</code>的钩子函数来处理这个问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beforeDestroy () &#123;</span><br><span class="line">  this.terminalSocket.close()</span><br><span class="line">  this.term.destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后端实现"><a href="#后端实现" class="headerlink" title="后端实现"></a>后端实现</h3><blockquote><p><code>django</code>这里使用<code>dwebsocket</code>模块进行<code>ws</code>的服务端编写与通信</p></blockquote><ul><li>首先确定路由，也是前端的<code>ws</code>连接地址</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">＃urls.py </span><br><span class="line"><span class="meta">... </span></span><br><span class="line">path（<span class="string">'webssh /'</span>，webssh）</span><br></pre></td></tr></table></figure><ul><li>定义函数，初始化<code>SSH</code>连接对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#views.py </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_ssh</span><span class="params">(host,username,password,port=<span class="number">22</span>)</span>:</span></span><br><span class="line">    sh = paramiko.SSHClient()</span><br><span class="line">    sh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    sh.connect(host, username=username, password=password)</span><br><span class="line">    channle = sh.invoke_shell(term=<span class="string">'xterm'</span>)</span><br><span class="line">    <span class="keyword">return</span> channle</span><br></pre></td></tr></table></figure><ul><li>由于在<code>SSH</code>通道中，服务端可能返回结果的方式并不与客户端发起的命令一唱一和，可能是一唱多和，类似类似<code>top</code>的命令，一次命令输入之后，服务端会返回<code>N</code>次结果，此时在<code>django</code>首先中采用多线程，专门处理命令结果的返回；以下是这个任务线程函数的定义</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_ssh_msg</span><span class="params">(channle,ws)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        channle: 建立好的SSH连接通道</span></span><br><span class="line"><span class="string">        这个函数会不停的接收ssh通道返回的命令</span></span><br><span class="line"><span class="string">        返回到前端的ws套接字里</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> channle.exit_status_ready():</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            buf = channle.recv(<span class="number">1024</span>) <span class="comment"># 接收命令的执行结果</span></span><br><span class="line">            ws.send(buf) <span class="comment"># 向Websocket通道返回</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><ul><li>剩余的就是视图函数的调用和线程开启部分了！</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@accept_websocket</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">webssh</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        1: 接收前端(ws)的命令，发给后台(ssh)</span></span><br><span class="line"><span class="string">        2: 接收后台的返回结果，给到前端</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> request.is_websocket:</span><br><span class="line">        channle = _ssh(host, username=username, password=password)</span><br><span class="line">        ws = request.websocket </span><br><span class="line">        t = threading.Thread(target=recv_ssh_msg,args=(channle,ws))</span><br><span class="line">        t.setDaemon(<span class="literal">True</span>) </span><br><span class="line">        t.start() <span class="comment"># 线程开启</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            cmd = ws.wait() <span class="comment"># 阻塞接收前端发来的命令</span></span><br><span class="line">            <span class="keyword">if</span> cmd:</span><br><span class="line">                channle.send(cmd) <span class="comment"># 由SSH通道转交给Linux环境</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 连接断开 跳出循环 </span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        ws.close() <span class="comment"># 释放对应套接字资源</span></span><br><span class="line">        channle.close()</span><br></pre></td></tr></table></figure><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><ul><li>如下</li></ul><p><a href="https://lienze.tech/blog/images/webssh.gif" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/webssh.gif" alt="Webssh"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;WebSSH&quot;&gt;&lt;a href=&quot;#WebSSH&quot; class=&quot;headerlink&quot; title=&quot;WebSSH&quot;&gt;&lt;/a&gt;WebSSH&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;webssh&lt;/code&gt;从而&lt;code&gt;SSH&lt;/code&gt;无需&lt;code&gt;Xshell&lt;/code&gt;之类的模拟终端工具进行&lt;code&gt;SSH&lt;/code&gt;连接，将&lt;code&gt;SSH&lt;/code&gt;这一比较低层的操作也从&lt;code&gt;C/S&lt;/code&gt;架构扭转成为&lt;code&gt;B/S&lt;/code&gt;架构&lt;/p&gt;
&lt;p&gt;这样的架构常用在运维制作开发一些堡垒机等系统，或者目前比较新型的在线教育方式，通过&lt;code&gt;WebSSH&lt;/code&gt;向学生提供一个可以直接使用浏览器进行相关&lt;code&gt;Linux&lt;/code&gt;操作或代码编写的学习方式&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WebSSh&lt;/code&gt;主要是建立客户端与服务端的即时通信&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Websocket</title>
    <link href="https://cy-blogs.cn/Websocket/"/>
    <id>https://cy-blogs.cn/Websocket/</id>
    <published>2019-12-09T09:00:08.693Z</published>
    <updated>2019-12-09T11:26:53.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h2><blockquote><p><code>WebSocket</code>实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端可以主动向客户端发送数据。</p><p>传统的<code>HTTP</code>协议是无状态的，种客户端是主动方，服务端是被动方的；对于涉及实时信息的<code>Web</code>应用带来了很大的不便，如带有即时通信、实时数据、订阅推送等功能的应用。在之前有两种办法解决这个问题</p></blockquote><a id="more"></a><blockquote><p>轮询是最原始的实现实时<code>Web</code>应用的解决方案。轮询技术要求客户端以设定的时间间隔周期性地向服务端发送请求，频繁地查询是否有新的数据改动。这种方法会导致过多不必要的请求，浪费流量和服务器资源。</p><p><code>Comet</code>技术又可以分为长轮询和流技术；长轮询改进了上述的轮询技术，减小了无用的请求。它会为某些数据设定过期时间，当数据过期后才会向服务端发送请求；这种机制适合数据的改动不是特别频繁的情况。流技术通常是指客户端使用一个隐藏的窗口与服务端建立一个<code>HTTP</code>长连接，服务端会不断更新连接状态以保持<code>HTTP</code>长连接存活；这样的话，服务端就可以通过这条长连接主动将数据发送给客户端；流技术在大并发环境下，可能会考验到服务端的性能。</p><p><code>WebSocket</code>真正实现了<code>Web</code>的实时通信，使<code>B/S</code>模式具备了<code>C/S</code>模式的实时通信能力</p><p><code>WebSocket</code>的工作流程是这样的：浏览器通过<code>JavaScript</code>向服务端发出建立<code>WebSocket</code>连接的请求，在<code>WebSocket</code>连接建立成功后，客户端和服务端就可以通过 TCP连接传输数据。因为<code>WebSocket</code>连接本质上是<code>TCP</code>连接，不需要每次传输都带上重复的头部数据，所以它的数据传输量比轮询和<code>Comet</code>技术小了很多</p></blockquote><blockquote><p><code>Websocket</code>在建立连接之前有一个<code>Handshake</code>（<code>Opening Handshake</code>）过程，在关闭连接前也有一个Handshake（<code>Closing Handshake</code>）过程，建立连接之后，双方即可双向通信</p></blockquote><h3 id="HTML的Websocket"><a href="#HTML的Websocket" class="headerlink" title="HTML的Websocket"></a>HTML的Websocket</h3><ul><li>初始化websocket</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ws = <span class="keyword">new</span> <span class="constructor">WebSocket(<span class="params">url</span>, [<span class="params">protocol</span>] )</span>;</span><br></pre></td></tr></table></figure><blockquote><p><code>url</code>：指定连接的<code>websocket</code></p><p><code>protocol</code>：可接受的子协议</p></blockquote><h4 id="响应事件"><a href="#响应事件" class="headerlink" title="响应事件"></a>响应事件</h4><blockquote><p>当<code>ws</code>套接字初始化成功之后，我们可以通过定义回调函数在某些事件触发时执行，以下是常见响应事件</p></blockquote><ul><li>当<code>ws</code>连接建立时触发</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// 连接开启</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当<code>ws</code>连接接收到数据时触发</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span><span class="params">(evt)</span></span>&#123;</span><br><span class="line">    <span class="comment">// evt.data即是接收到的数据对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当<code>ws</code>连接发生通信错误时触发</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onerror = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 连接出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当连接关闭时触发</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 连接关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>初次之外，还可以通过一些方法函数进行数据的传输或连接的关闭</p></blockquote><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>通过<code>ws</code>连接发送数据</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="built_in">send</span>(str)</span><br></pre></td></tr></table></figure><ul><li>关闭连接</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ws</span>.<span class="keyword">close</span>()</span><br></pre></td></tr></table></figure><h4 id="简单的示例"><a href="#简单的示例" class="headerlink" title="简单的示例"></a>简单的示例</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">ws</span> = <span class="keyword">new</span> WebSocket(<span class="string">'ws://127.0.0.1:3000'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ws</span>.onopen = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'连接建立'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ws</span>.onmessage = <span class="function"><span class="keyword">function</span><span class="params">(ev)</span>&#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'server:'</span>,ev.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ws</span>.onerror = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'连接建立'</span>)</span><br><span class="line">    <span class="keyword">ws</span>.<span class="keyword">close</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ws</span>.onclose = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'连接关闭'</span>)</span><br><span class="line">    <span class="keyword">ws</span>.<span class="keyword">close</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Django的Websocket"><a href="#Django的Websocket" class="headerlink" title="Django的Websocket"></a>Django的Websocket</h3><blockquote><p><code>dwebsocket</code>是一个在<code>django</code>用来实现<code>websocket</code>服务端的三方模块，使用上手非常简单，安装方式如下</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> dwebsocket</span><br></pre></td></tr></table></figure><ul><li><code>git</code>地址</li></ul><blockquote><p><a href="https://github.com/duanhongyi/dwebsocket" target="_blank" rel="noopener">https://github.com/duanhongyi/dwebsocket</a></p></blockquote><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><blockquote><p>在后台中，通过该三方模块可以让我们在<code>django</code>的视图中实现对于<code>websocket</code>的操作</p></blockquote><blockquote><p>首先是两个基本的装饰器，用来限定过滤<code>websocket</code>的连接</p></blockquote><ul><li><code>dwebsocket.accept_websocket</code></li></ul><blockquote><p>允许<code>http</code>与<code>websocket</code>连接</p></blockquote><ul><li><code>dwebsocket.require_websocke</code></li></ul><blockquote><p>只允许<code>websocket</code>连接</p></blockquote><blockquote><p>除去两种装饰器方法进行过滤判断，还可以通过在视图函数中的<code>request</code>进行<code>websocket</code>的判断</p></blockquote><ul><li><code>request.is_websocket</code></li></ul><blockquote><p>如果是个<code>websocket</code>请求返回<code>True</code>，如果是个普通的<code>http</code>请求返回<code>False</code></p><p>可以用这个方法区分普通连接与<code>websocket</code></p></blockquote><ul><li><code>request.websocket</code></li></ul><blockquote><p>在一个<code>websocket</code>请求建立之后，这个请求将会有一个<code>websocket</code>属性，用来给客户端提供一个简单的<code>api</code>通讯，如果<code>request.is_websocket()</code>是<code>False</code>，这个属性将是<code>None</code></p></blockquote><ul><li><code>request.websocket.wait</code></li></ul><blockquote><p>接收客户端发来的一条消息；如果在收到消息或客户端关闭连接之前，它不会有任何返回，只会返回None</p></blockquote><ul><li><code>request.websocket.read</code></li></ul><blockquote><p>如果从客户端接收到新消息，<code>read</code>函数返回这条消息；如果没有新消息，则返回None</p><p>这是一个替代<code>wait</code>的非阻塞读取数据的方法</p></blockquote><ul><li><code>request.websocket.count_messages()</code></li></ul><blockquote><p>返回消息队列数量</p></blockquote><ul><li><code>request.websocket.has_messages()</code></li></ul><blockquote><p>如果有新消息返回<code>True</code>，否则返回<code>False</code></p></blockquote><ul><li><code>request.websocket.send(message)</code></li></ul><blockquote><p>向客户端发送消息</p></blockquote><ul><li><code>requqest.websocket.__iter__</code></li></ul><blockquote><p><code>websocket</code>迭代器</p></blockquote><ul><li>关于<code>Django</code>的<code>Demo</code>将会在下一章节结合<code>paramiko</code>以及<code>xterm.js</code>来进行一个<code>webssh</code>的实现</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Websocket&quot;&gt;&lt;a href=&quot;#Websocket&quot; class=&quot;headerlink&quot; title=&quot;Websocket&quot;&gt;&lt;/a&gt;Websocket&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;WebSocket&lt;/code&gt;实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端可以主动向客户端发送数据。&lt;/p&gt;
&lt;p&gt;传统的&lt;code&gt;HTTP&lt;/code&gt;协议是无状态的，种客户端是主动方，服务端是被动方的；对于涉及实时信息的&lt;code&gt;Web&lt;/code&gt;应用带来了很大的不便，如带有即时通信、实时数据、订阅推送等功能的应用。在之前有两种办法解决这个问题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Tinymce富文本编辑器</title>
    <link href="https://cy-blogs.cn/Tinymce%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>https://cy-blogs.cn/Tinymce富文本编辑器/</id>
    <published>2019-12-09T08:53:20.976Z</published>
    <updated>2019-12-09T11:28:03.240Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图文混排"><a href="#图文混排" class="headerlink" title="图文混排"></a>图文混排</h2><blockquote><p>在某些富文本编辑器中，我们可以支持文件与图片的同时编写，将文字与图片混合排列</p><p>在<code>django</code>中可以使用<code>TimyMce</code>富文本编辑器进行图文混排功能的实现</p></blockquote><a id="more"></a><h3 id="TinyMce"><a href="#TinyMce" class="headerlink" title="TinyMce"></a>TinyMce</h3><blockquote><p><code>TinyMCE</code>：是一个轻量级的基于浏览器的所见即所得编辑器，支持目前流行的各种浏览器，由<code>JavaScript</code>写成</p><p>功能配置灵活简单，两行代码就可以将编辑器嵌入网页中，并且支持<code>AJAX</code>，加载速度非常快</p><p>最重要的是，<code>TinyMCE</code>是一个根据<code>LGPL license</code>发布的自由软件，你可以把它用于商业应用。下图是此编辑器的界面</p></blockquote><h3 id="配置上传路径"><a href="#配置上传路径" class="headerlink" title="配置上传路径"></a>配置上传路径</h3><blockquote><p>首先配置整个项目的上传文件路径，为了区别与自身的<code>static</code>静态目录</p><p>这里的上传文件我们将另外保存至<code>upload</code>文件夹</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#settings.py</span></span><br><span class="line">UPLOAD_ROOT = os.path.join(BASE_DIR,<span class="string">'upload'</span>)</span><br></pre></td></tr></table></figure><h3 id="配置模板页面"><a href="#配置模板页面" class="headerlink" title="配置模板页面"></a>配置模板页面</h3><blockquote><p>首先需要在使用到<code>tinymce</code>富文本编辑器的<code>html</code>页面下导入必备<code>js</code>文件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&#123;% static 'js/jquery-1.10.2.min.js' %&#125;"</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&#123;% static 'js/tinymce_setup.js' %&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&#123;% static 'tinymce/js/tinymce/tinymce.min.js' %&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>接下来，在模板页面中加入一个<code>id</code>为<code>content</code>的输入表单，这里我们以一个文章数据为例</p></blockquote><ul><li>首先是模型层文件定义</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#models.py </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>,verbose_name=<span class="string">'标题'</span>)</span><br><span class="line">    author = models.CharField(max_length=<span class="number">100</span>,verbose_name=<span class="string">'作者'</span>)</span><br><span class="line">    content = models.TextField(verbose_name=<span class="string">'内容'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>content</code>内容要用到富文本编辑器</p></blockquote><ul><li>接着是模板页面的主要部分</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">'/'</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"文章标题"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"文章作者"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"rich_content"</span> <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">value</span>=<span class="string">" "</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修改插件配置"><a href="#修改插件配置" class="headerlink" title="修改插件配置"></a>修改插件配置</h3><blockquote><p>这里搭配了一个<code>tinymce_setup.js</code>文件，用来控制富文本编辑器所使用的插件等</p><p>全文配置如下</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">tinymce.init(&#123;</span><br><span class="line">    // 选择id为content的标签作为编辑器</span><br><span class="line">    selector: <span class="string">'#rich_content'</span>,</span><br><span class="line">    // 方向从左到右</span><br><span class="line">    directionality:<span class="string">'ltr'</span>,</span><br><span class="line">    // 语言选择中文</span><br><span class="line">    language:<span class="string">'zh_CN'</span>,</span><br><span class="line">    // 高度为<span class="number">400</span> 宽度为一半</span><br><span class="line">    height:<span class="number">300</span>,</span><br><span class="line">    width: <span class="string">'50%'</span>,</span><br><span class="line">    // 工具栏上面的补丁按钮</span><br><span class="line">    plugins: [</span><br><span class="line">            <span class="string">'advlist autolink link image lists charmap print preview hr anchor pagebreak spellchecker'</span>,</span><br><span class="line">            <span class="string">'searchreplace wordcount visualblocks visualchars code fullscreen insertdatetime media nonbreaking'</span>,</span><br><span class="line">            <span class="string">'save table contextmenu directionality template paste textcolor'</span>,</span><br><span class="line">            <span class="string">'codesample imageupload'</span>,</span><br><span class="line">    ],</span><br><span class="line">    // 工具栏的补丁按钮</span><br><span class="line">     toolbar: <span class="string">'insertfile undo redo | \</span></span><br><span class="line"><span class="string">     styleselect | \</span></span><br><span class="line"><span class="string">     bold italic | \</span></span><br><span class="line"><span class="string">     alignleft aligncenter alignright alignjustify | \</span></span><br><span class="line"><span class="string">     bullist numlist outdent indent | \</span></span><br><span class="line"><span class="string">     link image | \</span></span><br><span class="line"><span class="string">     print preview media fullpage | \</span></span><br><span class="line"><span class="string">     forecolor backcolor emoticons |\</span></span><br><span class="line"><span class="string">     codesample fontsizeselect fullscreen |\</span></span><br><span class="line"><span class="string">     imageupload'</span>,</span><br><span class="line">    // 字体大小</span><br><span class="line">    fontsize_formats: <span class="string">'10pt 12pt 14pt 18pt 24pt 36pt'</span>,</span><br><span class="line">    // 按tab不换行</span><br><span class="line">    nonbreaking_force_tab: true,</span><br><span class="line">    imageupload_url: <span class="string">"/upload_img/"</span>,</span><br><span class="line">    // 上传后图片保存为绝对路径</span><br><span class="line">    relative_urls : false,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>注释已经很清晰</p><p>要注意的是<code>imageupload_url</code>配置用来确定当前图片上传所对应的视图路由</p></blockquote><h3 id="上传视图配置"><a href="#上传视图配置" class="headerlink" title="上传视图配置"></a>上传视图配置</h3><blockquote><p>接下来编写富文本编辑器的上传图片路由函数及对应的路由配置</p><p>路由映射<code>tinymce_setup.js</code>与中的<code>imageupload_url</code>配置路由相同</p><p>这里还要注意，由于此时<code>tinymce</code>的上传图片表单并不是和本身所容纳的<code>form</code>表单一起上传，所以并不会具备<code>csrf_token</code>值，需要我们将上传图片的函数额外进行装饰器装饰，取消<code>csrf_token</code>验证</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5</span><span class="params">(str_)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    m = hashlib.md5()</span><br><span class="line">    m.update(str(time.time()).encode())</span><br><span class="line">    filename = m.hexdigest()</span><br><span class="line">    <span class="keyword">return</span> filename + <span class="string">'.'</span> + str_.split(<span class="string">'.'</span>)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_img</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        img = request.FILES.get(<span class="string">'file'</span>)</span><br><span class="line">        <span class="keyword">if</span> img:</span><br><span class="line">            file_name_md5 = md5(img.name)</span><br><span class="line">            <span class="keyword">with</span> open(os.path.join(UPLOAD_ROOT,file_name_md5), <span class="string">'wb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">                <span class="keyword">for</span> buf <span class="keyword">in</span> img.chunks():</span><br><span class="line">                    fp.write(buf)</span><br><span class="line">                <span class="comment"># 迭代读取文件并写入到本地</span></span><br><span class="line">        response = &#123;&#125;</span><br><span class="line">        response[<span class="string">'path'</span>] = <span class="string">'/upload/'</span> + file_name_md5</span><br><span class="line">        response[<span class="string">'error'</span>] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(response))</span><br></pre></td></tr></table></figure><blockquote><p>视图函数还是老样子去接收上传文件并保存即可</p><p>这里还使用了<code>md5</code>的方式进行文件名保存，避免重名文件上传互相覆盖</p></blockquote><ul><li>路由配置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line">path(<span class="string">'upload_img/'</span>,views.upload_img),</span><br></pre></td></tr></table></figure><h3 id="表单接收视图"><a href="#表单接收视图" class="headerlink" title="表单接收视图"></a>表单接收视图</h3><blockquote><p>以上的视图函数只能处理上传图片的内容接收</p><p>我们的模板页面中还有作者及标题两样表单内容会被<code>POST</code>提交到后台</p><p>并且要主要的是，富文本编辑器里除了图片的内容，还有文字等其他内容，这里也需要我们保存下来</p></blockquote><ul><li>这里还需要一个视图函数去接管处理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">'index.html'</span>)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        title = request.POST.get(<span class="string">'title'</span>)</span><br><span class="line">        author = request.POST.get(<span class="string">'author'</span>)</span><br><span class="line">        content = request.POST.get(<span class="string">'content'</span>)</span><br><span class="line">        models.Article.objects.create(</span><br><span class="line">            title = title,</span><br><span class="line">            author = author,</span><br><span class="line">            content = content,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">'/show/'</span>)</span><br></pre></td></tr></table></figure><ul><li>表单路由</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line">path(<span class="string">''</span>,views.index),</span><br></pre></td></tr></table></figure><ul><li>这里上传之后，保存在后台的<code>content</code>数据是这个样子</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/upload/ec8f8c9a56ed32464a6727741fd58d8d.png"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>今天<span class="tag">&lt;<span class="name">em</span>&gt;</span>一切<span class="tag">&lt;/<span class="name">em</span>&gt;</span>都是<span class="tag">&lt;<span class="name">strong</span>&gt;</span>美丽<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>的，哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="图片访问路由"><a href="#图片访问路由" class="headerlink" title="图片访问路由"></a>图片访问路由</h3><blockquote><p>当有了上传图片的视图函数及所有内容的接收视图函数</p><p>这里还有一个特殊的问题，现在如果在富文本编辑器中选择上传图片，你会发现图片已经在选择时就已经存储到了后台<code>upload</code>文件夹下，这也是为什么我们的图片上传视图函数要单独编写，并且还需要取消<code>csrf_token</code>的验证的原因</p></blockquote><blockquote><p>除了这个问题你还会发现，在富文本编辑器中，上传的图片是看不到的，是一个坏掉的图片；</p><p>使用<code>F12</code>开发者工具你可以看到，这里的图片展示为一个<code>img</code>标签，而标签的<code>src</code>属性内容正是通过上传视图函数返回的<code>response</code>中的<code>path</code>值</p><p>想让这个<code>path</code>值在访问时，能获取到实际的图片效果，需要我们在路由文件中继续配置，配置专门的<code>upload/xxxx.jpg</code>的图片路由访问，让图片真正展示出来</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.views.static <span class="keyword">import</span> serve</span><br><span class="line">re_path(<span class="string">'^upload/(?P&lt;path&gt;.*)/$'</span>,serve,&#123;<span class="string">'document_root'</span>:UPLOAD_ROOT&#125;),</span><br></pre></td></tr></table></figure><blockquote><p>上传后图片的访问路径是<code>/upload/</code>，那么这里的路由也是<code>upload/</code>，之后通过静态文件映射函数<code>serve</code>查找<code>upload</code>文件夹下的同路径同名图片资源</p><p>当有了这条路由配置之后，再次再富文本编辑器中加入图片，你就会发现图片出现啦</p></blockquote><h3 id="上传并展示"><a href="#上传并展示" class="headerlink" title="上传并展示"></a>上传并展示</h3><blockquote><p>最后，我们将测试上传图片及文字</p><p>并且上传成功之后，重定向到<code>show</code>视图函数</p></blockquote><ul><li>这个视图函数用来提取当前最新的上传数据并返回到模板页面</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        article = models.Article.objects.all().last()</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'show.html'</span>,locals())</span><br></pre></td></tr></table></figure><ul><li>展示的模板页面</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>展示文章<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;% if article %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; article.title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;&#123; article.author &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; article.content|safe &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>其实本身富文本编辑器上传的文本内容就已经在一个<code>p</code>标签中，所以这里没有用段落标签</p><p>另外由于保存在数据库的文本为<code>html</code>格式，而后台传递来的模板变量<code>django</code>出于安全考虑会自动进行转义，直接观看到的效果不会<code>html</code>样式，只是一些普通字符串；</p><p>这里可以使用<code>safe</code>过滤器将内容认定为安全，展示为原始的<code>html</code>效果，其实还不错</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>富文本编辑器其实就是将用户输入的内容变为<code>html</code>代码</p><p>这里的图文混排，只是在图片加入时，单独将图片上传保存，并且回调获取到上传的路径</p><p>之后只需要服务端后台配置好相关的上传图片访问路由配置即可</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图文混排&quot;&gt;&lt;a href=&quot;#图文混排&quot; class=&quot;headerlink&quot; title=&quot;图文混排&quot;&gt;&lt;/a&gt;图文混排&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在某些富文本编辑器中，我们可以支持文件与图片的同时编写，将文字与图片混合排列&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;django&lt;/code&gt;中可以使用&lt;code&gt;TimyMce&lt;/code&gt;富文本编辑器进行图文混排功能的实现&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>HayStack全文检索在Django中应用</title>
    <link href="https://cy-blogs.cn/HayStack%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%9C%A8Django%E4%B8%AD%E5%BA%94%E7%94%A8/"/>
    <id>https://cy-blogs.cn/HayStack全文检索在Django中应用/</id>
    <published>2019-12-09T08:41:45.776Z</published>
    <updated>2019-12-09T11:26:38.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h2><p><a href="https://django-haystack.readthedocs.io/en/v2.4.1/tutorial.html" target="_blank" rel="noopener">官方文档</a></p><blockquote><p>全文检索就是针对所有内容进行动态匹配搜索的概念</p><p>针对特定的关键词进行<strong>建立索引</strong>并<strong>精确匹配</strong>取出搜索结果，并且达到性能优化的目的</p></blockquote><ul><li>为啥要有全文检索</li></ul><a id="more"></a><blockquote><p>最常见的全文检索就是我们在数据库中进行的模糊查询</p><p>但是模糊查询是针对整体内容的一个动态匹配过程，在数据量较大的情况下匹配效率极低</p><p>常规项目中数据量一般都比较多并且内容繁杂，所以正常的项目搜索功能中很少会使用模糊查询进行操作</p><p>如果你开发的项目用户量较少并且项目数据较少，那么此时模糊查询可以是你值得考虑的选项</p></blockquote><ul><li><code>django</code>使用啥进行全文检索</li></ul><blockquote><p><code>Python</code>提供了各种模块进行全文检索，最常见的是<code>haystack</code>模块</p><p>该模块设计为支持<code>whoosh</code>、<code>solr</code>、<code>Xapian</code>、<code>Elasticsearch</code>四种全文检索引擎后端</p><p>使用<code>haystack</code>模块，不用更改代码，直接切换引擎，可以极大的减少代码量</p><p><code>haystack</code>属于一种<strong>全文检索</strong>的框架</p></blockquote><hr><ul><li><strong><code>whoosh</code></strong></li></ul><blockquote><p>纯<code>Python</code>编写的全文搜索引擎，是目前最快的<code>python</code>所编写的检索引擎，虽然性能比不上<code>solr</code>、<code>Xapian</code>、<code>Elasticsearch</code>等；但是无二进制包，程序不会莫名其妙的崩溃，对于小型的站点，<code>whoosh</code>已经足够使用</p></blockquote><ul><li><strong><code>solr</code></strong></li></ul><blockquote><p><code>Solr</code>是一个高性能，采用<code>Java5</code>开发，基于<code>Lucene</code>的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎</p><p><code>Lucene</code>：不是一个完整的<strong>全文检索引擎</strong>，是一个全文检索引擎的<strong>架构</strong>，提供了完整的查询引擎和索引引擎，<code>Lucene</code>的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能</p></blockquote><ul><li><strong><code>Xapian</code></strong></li></ul><blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Xapian`是一个用`C++`编写的全文检索程序，他的作用类似于`Java`的`lucene</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><strong><code>Elasticsearch</code></strong></li></ul><blockquote><p><code>ElasticSearch</code>是一个基于<code>Lucene</code>的搜索服务器它提供了一个分布式多用户能力的全文搜索引擎，基于<code>RESTful web</code>接口</p><p><code>Elasticsearch</code>是用Java开发的，并作为<code>Apache</code>许可条款下的开放源码发布，是当前流行的企业级搜索引擎。该引擎常设计用于云计算中；能够达到<strong>实时搜索</strong>，<strong>稳定</strong>，<strong>可靠</strong>，<strong>快速</strong>，<strong>安装</strong>使用方便</p></blockquote><h3 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h3><blockquote><p><code>whoosh</code>作为一个全文搜索引擎模块</p><p>分词功能和检索功能已经非常强大，但是针对中文的处理还是比较欠缺</p><p>可以通过<code>Jieba</code>模块重写分词操作，支持<code>whoosh</code>对中文的强大操作</p></blockquote><ul><li>安装中文分词模块</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> jieba</span><br></pre></td></tr></table></figure><ul><li><p>除了<code>jieba</code>分词，现在还有很多付费的中文分词模块</p><blockquote><p><a href="http://ictclas.nlpir.org/nlpir/" target="_blank" rel="noopener">中科院计算所NLPIR</a></p><p><a href="https://github.com/NLPchina/ansj_seg" target="_blank" rel="noopener"><code>ansj</code>分词器</a></p><p><a href="https://github.com/HIT-SCIR/ltp" target="_blank" rel="noopener">哈工大的<code>LTP</code></a></p><p><a href="https://github.com/thunlp/THULAC" target="_blank" rel="noopener">清华大学<code>THULAC</code></a></p><p><a href="https://nlp.stanford.edu/software/segmenter.shtml" target="_blank" rel="noopener">斯坦福分词器</a></p><p><a href="https://github.com/hankcs/HanLP" target="_blank" rel="noopener"><code>Hanlp</code>分词器</a></p><p><a href="https://github.com/yanyiwu/cppjieba" target="_blank" rel="noopener">结巴分词</a></p><p><a href="https://github.com/koth/kcws" target="_blank" rel="noopener"><code>KCWS</code>分词器(字嵌入<code>+Bi-LSTM+CRF</code>)</a></p><p><a href="https://github.com/frcchang/zpar/releases" target="_blank" rel="noopener"><code>ZPar</code></a></p><p><a href="https://github.com/wks/ik-analyzer" target="_blank" rel="noopener"><code>IKAnalyzer</code></a></p></blockquote></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>首先安装<code>HayStack</code>框架以及<code>whoosh</code>搜索引擎</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install django-haystack</span><br><span class="line">pip install whoosh</span><br></pre></td></tr></table></figure><h3 id="settings配置"><a href="#settings配置" class="headerlink" title="settings配置"></a>settings配置</h3><ul><li>添加<code>haystack</code>应用到项目的<code>settings</code>文件下的<code>app</code>部分</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [ </span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    ...   </span><br><span class="line">    <span class="string">'haystack'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>添加搜索引擎，这里使用<code>whoosh</code>引擎</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HAYSTACK_CONNECTIONS = &#123;  </span><br><span class="line">    <span class="string">'default'</span>: &#123;      </span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'haystack.backends.whoosh_cn_backend.WhooshEngine'</span>,   </span><br><span class="line">        <span class="string">'PATH'</span>: os.path.join(BASE_DIR, <span class="string">'whoosh_index'</span>),  </span><br><span class="line">    &#125;&#125;</span><br><span class="line"><span class="comment">#这里使用django的信号机制，在数据表发生改动时自动更新whoosh的查询索引</span></span><br><span class="line">HAYSTACK_SIGNAL_PROCESSOR = <span class="string">'haystack.signals.RealtimeSignalProcessor'</span></span><br></pre></td></tr></table></figure><blockquote><p>这里要注意的是，我们使用的引擎为<code>whoosh_cn_backend</code></p><p>本身的<code>whoosh</code>引擎名为：<code>whoosh_backend</code></p><p><code>whoosh_cn_backend</code>将在接下来我们对安装目录下的引擎文件复制修改得来</p></blockquote><ul><li>在项目的路由文件下配置查询的路由映射</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include,re_path</span><br><span class="line">urlpatterns = [   </span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),  </span><br><span class="line">    re_path(<span class="string">'^search/'</span>,include(<span class="string">'haystack.urls'</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>当查询条件被提交时，会跳转至<code>search</code>路由</p><p>并且查询条件会作为<code>get</code>请求时的连接参数传入，参数<code>key</code>值为<code>q</code></p></blockquote><h3 id="创建索引文件"><a href="#创建索引文件" class="headerlink" title="创建索引文件"></a>创建索引文件</h3><ul><li>接下来，在需要被搜索的<code>app</code>下建立<code>search_indexes.py</code>文件，该文件名不许变更</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app.models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(models.Model)</span>:</span>    </span><br><span class="line">    <span class="comment"># 用户表 </span></span><br><span class="line">    name = models.CharField(   </span><br><span class="line">        max_length=<span class="number">50</span>,  </span><br><span class="line">        verbose_name=<span class="string">'昵称'</span>  </span><br><span class="line">    )   </span><br><span class="line">    account = models.CharField(max_length=<span class="number">50</span>,verbose_name=<span class="string">'账号'</span>,unique=<span class="literal">True</span>)</span><br><span class="line">    passwd = models.CharField(max_length=<span class="number">50</span>,verbose_name=<span class="string">'密码'</span>) </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>    </span><br><span class="line">        <span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app.search_indexes.py</span></span><br><span class="line"><span class="keyword">from</span> haystack <span class="keyword">import</span> indexes</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserIndex</span><span class="params">(indexes.SearchIndex, indexes.Indexable)</span>:</span></span><br><span class="line">    text = indexes.CharField(document=<span class="literal">True</span>, use_template=<span class="literal">True</span>) </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_model</span><span class="params">(self)</span>:</span>    </span><br><span class="line">        <span class="keyword">return</span> models.User  <span class="comment"># 当前模型文件下需要被检索的模型类   </span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index_queryset</span><span class="params">(self, using=None)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> self.get_model().objects.all()</span><br></pre></td></tr></table></figure><blockquote><p>该类为索引类，类名为模型类的名称<code>+Index</code>：比如模型类为<code>People</code>,则这里类名为<code>PeopleIndex</code></p><p><code>get_model</code>函数用来获取当前索引类所关联的模型类，这里我们关联上面的<code>User</code> 类对象</p><p><code>text=indexes.CharField</code>语句指定了将模型类中的哪些字段建立索引，而<code>use_template=True</code>说明后续我们将通过一个<strong>数据模板</strong>文件来指明需要检索的字段</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="attribute">document</span>=<span class="literal">True</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>为什么要创建索引：索引就像是一本书的目录，可以为读者提供更快速的导航与查找</p></blockquote><h3 id="创建模板数据文件"><a href="#创建模板数据文件" class="headerlink" title="创建模板数据文件"></a>创建模板数据文件</h3><ul><li>创建数据模板文件</li></ul><blockquote><p>数据模板文件路径：<code>templates/search/indexes/yourapp/note_text.txt</code></p><p>放在任何一个你的<code>Django</code>能搜索到的模板文件夹<code>template</code>下面均可，这个文件主要确定要检索的字段，为他们建立索引</p><p>文件名必须为要索引的类名<code>_text.txt</code>，比如这里我们检索的类名是<code>User</code>，那么对应的数据模板文件名为<code>user_text.txt</code>，文件名小写即可</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#template</span><span class="selector-class">.search</span><span class="selector-class">.indexes</span><span class="selector-class">.people</span><span class="selector-class">.user_text</span><span class="selector-class">.txt</span></span><br><span class="line">&#123;&#123; <span class="selector-tag">object</span><span class="selector-class">.name</span> &#125;&#125;</span><br><span class="line">&#123;&#123; <span class="selector-tag">object</span><span class="selector-class">.account</span> &#125;&#125;</span><br><span class="line">&#123;&#123; <span class="selector-tag">object</span><span class="selector-class">.online_time</span> &#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在数据模板文件中使用模板语法，写入需要建立索引的字段，这里我们将模型类中<code>name</code>、<code>account</code>以及<code>online_time</code>字段设置索引，当检索时会对这三个字段去做全文检索</p></blockquote><blockquote><p>接下来创建一个搜索结果展示页面</p></blockquote><h3 id="检索结果模板页面"><a href="#检索结果模板页面" class="headerlink" title="检索结果模板页面"></a>检索结果模板页面</h3><ul><li>创建检索结果展示页面</li></ul><blockquote><p>检索结果展示页面，需要在固定的目录路径下进行模板页面的编写</p><p>路径为：<code>templates/search/</code></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&#123;% if query %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>搜索结果如下：<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    &#123;% for result in page.object_list %&#125;</span><br><span class="line">        &#123;&#123; result.object.name &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        &#123;&#123; result.object.account &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        &#123;&#123; result.object.online_time &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;% empty %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>没找到<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    </span><br><span class="line">    &#123;% if page.has_previous or page.has_next %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            &#123;% if page.has_previous %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"?q=&#123;&#123; query &#125;&#125;&amp;amp;page=&#123;&#123; page.previous_page_number &#125;&#125;"</span>&gt;</span></span><br><span class="line">            上一页</span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">            &#123;% if page.has_next %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"?q=&#123;&#123; query &#125;&#125;&amp;amp;page=&#123;&#123; page.next_page_number &#125;&#125;"</span>&gt;</span></span><br><span class="line">            下一页</span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这个模板页面中已经自带了分页功能，可以按照需求修改</p></blockquote><ul><li>创建检索模板页面内容</li></ul><blockquote><p>还需要有一个表单，提交检索信息</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">'get'</span> <span class="attr">action</span>=<span class="string">"/search/"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"q"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"查询"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这部分检索的模板页面内容可以在你的项目中进行添加，查询方式为<code>get</code>，并且检索输入的表单框<code>name</code>属性必须为<code>q</code></p></blockquote><h3 id="中文分词配置"><a href="#中文分词配置" class="headerlink" title="中文分词配置"></a>中文分词配置</h3><ul><li>接下来，需要创建有关中文检索的配置文件，这里的配置文件创建为全局</li></ul><blockquote><p>进入到<code>python</code>的安装目录下，比如我的目录为：<code>C:\Python37\Lib\site-packages\haystack\backends</code></p><p>在该路径下创建名为<code>ChineseAnalyzer.py</code>的中文分词文件</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">from</span> whoosh.analysis <span class="keyword">import</span> Tokenizer, Token</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChineseTokenizer</span><span class="params">(Tokenizer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, value, positions=False, chars=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                 keeporiginal=False, removestops=True,start_pos=<span class="number">0</span>, start_char=<span class="number">0</span>, mode=<span class="string">''</span>, **kwargs)</span>:</span></span><br><span class="line">        t = Token(positions, chars, removestops=removestops, mode=mode, **kwargs)</span><br><span class="line">        seglist = jieba.cut(value, cut_all=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> seglist:</span><br><span class="line">            t.original = t.text = w</span><br><span class="line">            t.boost = <span class="number">1.0</span></span><br><span class="line">            <span class="keyword">if</span> positions:</span><br><span class="line">                t.pos = start_pos + value.find(w)</span><br><span class="line">            <span class="keyword">if</span> chars:</span><br><span class="line">                t.startchar = start_char + value.find(w)</span><br><span class="line">                t.endchar = start_char + value.find(w) + len(w)</span><br><span class="line">            <span class="keyword">yield</span> t</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ChineseAnalyzer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ChineseTokenizer()</span><br></pre></td></tr></table></figure><blockquote><p>在这个文件中，定义了一个<code>ChineseAnalyzer</code>的函数，这个函数将替代搜索引擎配置文件中的分词方式</p></blockquote><ul><li>复制引擎文件，修改分词方式为中文</li></ul><blockquote><p>同样在该文件夹下<code>C:\Python37\Lib\site-packages\haystack\backends</code>，复制<code>whoosh_backend.py</code>文件，创建一个新的文件名为<code>whoosh_cn_backend.py</code>，这里复制出一份文件也是为了之后如果不需要使用中文分词，可以直接在<code>settings</code>配置文件中修改引擎为<code>&#39;ENGINE&#39;:&#39;haystack.backends.whoosh_backend.WhooshEngine&#39;,</code></p></blockquote><blockquote><p>修改该引擎配置文件中的：<code>analyzer=StemmingAnalyzer()</code>变为<code>analyzer=ChineseAnalyzer()</code></p><p>并且要记得在头部引入刚才所编写的中文分词文件</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#whoosh_cn_backend.py</span></span><br><span class="line"><span class="keyword">from</span> .ChineseAnalyzer <span class="keyword">import</span> ChineseAnalyzer</span><br></pre></td></tr></table></figure><h3 id="初始化索引"><a href="#初始化索引" class="headerlink" title="初始化索引"></a>初始化索引</h3><ul><li>最后，初始化索引数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py rebuild_index</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;全文检索&quot;&gt;&lt;a href=&quot;#全文检索&quot; class=&quot;headerlink&quot; title=&quot;全文检索&quot;&gt;&lt;/a&gt;全文检索&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://django-haystack.readthedocs.io/en/v2.4.1/tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;全文检索就是针对所有内容进行动态匹配搜索的概念&lt;/p&gt;
&lt;p&gt;针对特定的关键词进行&lt;strong&gt;建立索引&lt;/strong&gt;并&lt;strong&gt;精确匹配&lt;/strong&gt;取出搜索结果，并且达到性能优化的目的&lt;/p&gt;
&lt;/blockquote&gt;&lt;ul&gt;
&lt;li&gt;为啥要有全文检索&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Admin</title>
    <link href="https://cy-blogs.cn/Django%E4%B8%AD%E7%9A%84Admin%E7%BB%84%E4%BB%B6/"/>
    <id>https://cy-blogs.cn/Django中的Admin组件/</id>
    <published>2019-12-09T08:29:50.000Z</published>
    <updated>2019-12-09T11:26:35.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Admin"><a href="#Admin" class="headerlink" title="Admin"></a>Admin</h2><blockquote><p><code>Django-admin</code>界面是框架为我们提供的<code>Web-APP</code>的管理工具</p><p>在之前的练习中，我们已经多次使用它进行<code>APP</code>中表的<code>DML</code>语句操作</p><p>接下来，我们可以继续来学习，如何将<code>Admin</code>界面进行优化扩展，更加方便我们后台管理</p></blockquote><a id="more"></a><h3 id="admin注册设置"><a href="#admin注册设置" class="headerlink" title="admin注册设置"></a>admin注册设置</h3><blockquote><p>在<code>admin</code>界面中，我们可以通过继承<code>admin.ModelAdmin</code>类进行自定义<code>admin</code>类的编写，用作控制展示后台所显示的数据，以及排序规则等等属性，基本语法像是下面这样</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">name = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#admin.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    fields = (<span class="string">'name'</span>,<span class="string">'age'</span>)</span><br><span class="line">    <span class="comment"># 控制admin界面模型类展示字段</span></span><br><span class="line">admin.site.register(User, UserAdmin)</span><br></pre></td></tr></table></figure><ul><li><h4 id="常用字段"><a href="#常用字段" class="headerlink" title="常用字段"></a>常用字段</h4><ul><li><code>list_display</code>：在<code>admin</code>控制台数据列表页面展示更多的字段</li><li><code>list_display_links</code>：用来设置当前列表中由<code>list_display</code>所设置的字段哪些可以点击</li><li><code>fieldsets</code>：将<code>admin</code>界面下的表单输入栏进行分块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    fields = (<span class="string">'name'</span>,<span class="string">'age'</span>)</span><br><span class="line">    fieldsets = (</span><br><span class="line">    (<span class="string">'第一个区域'</span>，</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="string">'fields'</span>: (<span class="string">'name'</span>,)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">       (<span class="string">'第二个区域'</span>，</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="string">'fields'</span>: (<span class="string">'age'</span>,)</span><br><span class="line">            &#125;</span><br><span class="line">        )     </span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li><li><p><code>search_fields</code>：在<code>admin</code>数据展示页，设置一个搜索框，设置的分段是可查找的属性</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search_fields</span> =（<span class="string">'name'</span>，）</span><br></pre></td></tr></table></figure></li><li><p><code>list_filter</code>：以什么分解进行过滤，在<code>admin</code>页面上方展示</p></li><li><p><code>ordering</code>：数据列表可以通过某些细分进行排序</p></li></ul><h3 id="利用现有用户系统"><a href="#利用现有用户系统" class="headerlink" title="利用现有用户系统"></a>利用现有用户系统</h3><blockquote><p><code>from django.contrib.auth.models import User</code></p></blockquote><h4 id="用户字段"><a href="#用户字段" class="headerlink" title="用户字段"></a>用户字段</h4><ul><li><p><code>username</code></p><blockquote><p>必选。少于等于30个字符。用户名可以包含字母，数字，<code>_</code>， ，<code>@</code>，。<code>+</code>状语从句：<code>-</code>字符</p></blockquote></li><li><p><code>first_name</code></p><blockquote><p>任选。等于等于30个字符</p></blockquote></li><li><p><code>last_name</code></p><blockquote><p>可选。可以输入30个字符</p></blockquote></li><li><p><code>email</code></p><blockquote><p>任选。邮箱地址</p></blockquote></li><li><p><code>password</code></p><blockquote><p>必选。密码的哈希及元数据。（<code>Django</code>不保存原始密码）。原始密码可以无限长而且可以包含任意字符</p></blockquote></li><li><p><code>is_staff</code></p><blockquote><p>布尔值。指示用户是否可以访问<code>Admin</code>站点</p></blockquote></li><li><p><code>is_active</code></p><blockquote><p>布尔值。用户的账号是否激活。长使用这个标志为False来代替删除账号</p></blockquote></li><li><p><code>is_superuser</code></p><blockquote><p>布尔值。指定这个用户拥有所有的权限而不需要给他们分配明确的权限</p></blockquote></li><li><p><code>last_login</code></p><blockquote><p>用户最后一次登录的时间。如果这个用户没有登录过，这个细分将会是<code>null</code></p><p>之前版本默认设置为的当前的<code>datetime</code></p></blockquote></li><li><p><code>date_joined</code></p><blockquote><p>帐户创建的时间。当账号创建时，替代设置为当前的<code>datetime</code></p></blockquote></li></ul><h4 id="用户实例方法"><a href="#用户实例方法" class="headerlink" title="用户实例方法"></a>用户实例方法</h4><ul><li><p><code>get_username()</code></p><blockquote><p>获取到当前的用户的用户名属性</p></blockquote></li><li><p><code>is_authenticated()</code></p><blockquote><p>检查用户是否已通过认证</p></blockquote></li><li><p><code>is_anonymous()</code></p><blockquote><p>检查用户是否未通过认证</p></blockquote></li><li><p><code>set_password(password)</code></p><blockquote><p>设置保存用户的密码，和会负责密码的哈希加密工作</p><p>通常修改密码之后还需要调用<code>save()</code>方法进行数据更新</p></blockquote></li></ul><h4 id="用户表方法"><a href="#用户表方法" class="headerlink" title="用户表方法"></a>用户表方法</h4><ul><li><p><code>create_user(username, email=None, password=None, **extra_fields)</code></p><blockquote><p><code>django</code>的用户创建需要使用<code>User</code>表管理器中的<code>create_user</code>函数进行</p><p>该函数可以创建并保存一个用户</p></blockquote></li><li><p><code>create_superuser(username, email, password, **extra_fields)</code></p><blockquote><p>与上一个创建用户函数功能相同，但是额外会设置用户的<code>is_staff</code>及<code>is_superuser</code>属性为<code>True</code></p><p>创建一个<code>admin</code>后台超级用户</p></blockquote></li></ul><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li><p><code>authenticate(username,password)</code></p><blockquote><p>验证是否为合法用户，如果用户存在合法则返回一个用户对象</p></blockquote></li><li><p><code>logout()</code></p><blockquote><p>清除当前浏览器下用户<code>session</code></p></blockquote></li><li><p><code>login(request,user)</code></p><blockquote><p>登录并保存当前用户<code>session</code></p><p>接受参数为<code>HttpRequest</code>请求及一个<code>User</code>用户对象</p><p>参数<code>user</code>必须为使用<code>authenticate</code>验证过后的用户对象</p></blockquote></li></ul><h4 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h4><ul><li>登陆所需表单类</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#forms.py</span></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span><span class="params">(forms.Form)</span>:</span></span><br><span class="line">username = forms.CharField(label=<span class="string">"用户名"</span>,required=<span class="literal">True</span>,)</span><br><span class="line">    password = forms.CharField(</span><br><span class="line">        widget=forms.PasswordInput(),</span><br><span class="line">        label=<span class="string">'密码'</span>,</span><br><span class="line">        required=<span class="literal">True</span>,</span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_username</span><span class="params">(self)</span>:</span></span><br><span class="line">        username = self.cleaned_data.get(<span class="string">"username"</span>).strip()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            User.objects.get(username=username)</span><br><span class="line">        <span class="keyword">except</span> User.DoesNotExist:</span><br><span class="line">            <span class="keyword">raise</span> forms.ValidationError(<span class="string">"用户名 %s 不存在"</span> % username)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> username</span><br></pre></td></tr></table></figure><ul><li>登录所需模板页面</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">'/login/'</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">&#123;% csrf_token %&#125;</span><br><span class="line">&#123;&#123; errors &#125;&#125;</span><br><span class="line">&#123;% for field in form %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">&#123;% if field.errors %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% for error in field.errors%&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; error &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; field.label &#125;&#125;: &#123;&#123; field &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>登陆主要视图逻辑</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> authenticate,logout <span class="keyword">as</span> auth_logout,login <span class="keyword">as</span> auth_login</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">form = userForm()</span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">"login.html"</span>,&#123;<span class="string">'form'</span>:form&#125;)</span><br><span class="line">form = userForm(request.POST)</span><br><span class="line">    username = form.data[<span class="string">'username'</span>]</span><br><span class="line">    password = form.data[<span class="string">'password'</span>]</span><br><span class="line">    user = authenticate(username=username,password=password)</span><br><span class="line">    <span class="comment"># 验证当前账号密码是否匹配合法</span></span><br><span class="line">    <span class="keyword">if</span> user <span class="keyword">and</span> user.is_active:</span><br><span class="line">        auth_login(request, user)</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">'/'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">"login.html"</span>,&#123;<span class="string">'form'</span>:form,<span class="string">'errors'</span>:<span class="string">'用户名或密码错误'</span>&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在用户登录成功之后，将会重新进入主页，主页展示当前登录用户</p><p>登录用户可以直接在<code>request.user</code>属性中获取到，主页的模板内容如下</p></blockquote><ul><li>主页模板</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">欢迎你: &#123;&#123; user &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>主页视图函数可以通过装饰器<code>@login_required</code>或判断<code>is_authenticated</code>状态来查看用户是否登录</p><p>只有登录用户可以访问该站点</p><p>使用当装饰器<code>@login_required</code>时，在需要<code>settings</code>下设置<code>LOGIN_URL = &#39;/login/&#39;</code></p><p>引入属性设置为登录路由</p></blockquote><ul><li>首页视图函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.decorators <span class="keyword">import</span> login_required</span><br><span class="line"><span class="comment">#@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.user.is_authenticated():</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">"index.html"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">'/login/'</span>)</span><br></pre></td></tr></table></figure><h4 id="注册功能"><a href="#注册功能" class="headerlink" title="注册功能"></a>注册功能</h4><ul><li>注册所需表单</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#forms.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterForm</span><span class="params">(forms.Form)</span>:</span></span><br><span class="line">    username = forms.CharField(label=<span class="string">"用户名"</span>,</span><br><span class="line">        max_length=<span class="number">30</span>,</span><br><span class="line">        required=<span class="literal">True</span>,</span><br><span class="line">        error_messages=&#123;<span class="string">'max_length'</span>:<span class="string">'账号长度最长为30'</span>&#125;,</span><br><span class="line">    )</span><br><span class="line">    password = forms.CharField(label=<span class="string">"密码"</span>,</span><br><span class="line">        min_length=<span class="number">6</span>, max_length=<span class="number">30</span>, </span><br><span class="line">        widget=forms.PasswordInput(), </span><br><span class="line">        required=<span class="literal">True</span>,</span><br><span class="line">            error_messages=&#123;<span class="string">'min_length'</span>:<span class="string">'密码长度最短为6'</span>&#125;,</span><br><span class="line">        )</span><br><span class="line">check_password = forms.CharField(label=<span class="string">"重复密码"</span>, </span><br><span class="line">min_length=<span class="number">6</span>, max_length=<span class="number">30</span>, </span><br><span class="line">widget=forms.PasswordInput(), </span><br><span class="line">required=<span class="literal">True</span>,</span><br><span class="line">error_messages=&#123;<span class="string">'min_length'</span>:<span class="string">'密码长度最短为6'</span>&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_check_password</span><span class="params">(self)</span>:</span></span><br><span class="line">password = self.cleaned_data.get(<span class="string">'password'</span>)</span><br><span class="line">check_password = self.cleaned_data.get(<span class="string">'check_password'</span>)</span><br><span class="line"><span class="keyword">if</span> password != check_password <span class="keyword">and</span> password <span class="keyword">and</span> check_password:</span><br><span class="line"><span class="keyword">raise</span> ValidationError(<span class="string">"重复输入密码错误"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_username</span><span class="params">(self)</span>:</span></span><br><span class="line">username = self.cleaned_data.get(<span class="string">'username'</span>)</span><br><span class="line"><span class="keyword">if</span> username[:<span class="number">1</span>] == <span class="string">'_'</span>:</span><br><span class="line"><span class="keyword">raise</span> forms.ValidationError(<span class="string">"用户名不能以下划线打头"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">User.objects.get(username=username)</span><br><span class="line"><span class="keyword">except</span> User.DoesNotExist:</span><br><span class="line"><span class="keyword">return</span> username </span><br><span class="line"><span class="keyword">raise</span> forms.ValidationError(<span class="string">"用户名已存在"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>表单中，将对用户两次输入的密码进行校验和判断是否为空，而且分开下划线作为用户名的开头字符</p></blockquote><ul><li>注册主要视图函数逻辑</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        form = RegisterForm(request.POST)</span><br><span class="line">        <span class="keyword">if</span> form.is_valid():</span><br><span class="line">            username = form.cleaned_data[<span class="string">'username'</span>]</span><br><span class="line">            password = form.cleaned_data[<span class="string">'password'</span>]</span><br><span class="line">            User.objects.create_user(username=username,password=password)</span><br><span class="line">            user = authenticate(username=username,password=password)</span><br><span class="line">            auth_login(request, user)</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">'/'</span>)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        form = RegisterForm()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"register.html"</span>,&#123;<span class="string">'form'</span>:form&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>通过表单验证，并获取到对应的用户账号密码，创建成功之后，验证并登录，并重定向到首页</p></blockquote><ul><li>主页模板页面</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&#123;% if request.user.is_authenticated %&#125;</span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>您已登录:<span class="tag">&lt;/<span class="name">p</span>&gt;</span> &#123;&#123; user &#125;&#125;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">'/register/'</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">&#123;% csrf_token %&#125;</span><br><span class="line">&#123;% for field in form %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">&#123;% if field.errors %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% for error in field.errors%&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; error &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; field.label &#125;&#125;: &#123;&#123; field &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"注册"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>当用户已经登录时，显示当前登录用户，反之则展示表单，以供用户填写</p></blockquote><h3 id="重载admin用户系统"><a href="#重载admin用户系统" class="headerlink" title="重载admin用户系统"></a>重载admin用户系统</h3><blockquote><p><code>django</code>自带的<code>admin</code>模块下的用户系统主要负责用户帐户，组，权限和基于<code>cookie</code>的会话等业务</p><p>认证系统由以下部分组成：</p><p>用户：包含用户数据细分，是实现业务功能逻辑的基础</p><p>权限：控制用户进入否可以执行某项任务的二进制（是/否）标志。</p><p>组：一种为多个用户加上标签和权限的常用方式。</p><p>消息：一种为指定用户生成简单消息嵌入的方式</p></blockquote><h4 id="默认字段"><a href="#默认字段" class="headerlink" title="默认字段"></a>默认字段</h4><ul><li><p><code>username</code></p><blockquote><p>必选项，小于等于30个字符；只能是字母数字（字母，数字和下划线）</p></blockquote></li><li><p><code>first_name</code></p><blockquote><p>可选项，等于等于30个字符</p></blockquote></li><li><p><code>last_name</code></p><blockquote><p>可选项，等于等于30个字符</p></blockquote></li><li><p><code>email</code></p><blockquote><p>可选项。电子邮件地址</p></blockquote></li><li><p><code>password</code></p><blockquote><p>必选，密码（哈希值，元数据）</p><p><code>Django</code>不储存原始密码</p><p>原始密码可以是任意长度的，包含任何字符</p><p>密码由哈希类型，盐值和哈希值组成，用美元符合分隔</p></blockquote></li><li><p><code>is_staff</code></p><blockquote><p>布尔值，指明这个用户是否可以进入管理站点的权限</p></blockquote></li><li><p><code>is_active</code></p><blockquote><p>布尔值，指明这个用户帐户是否是活动的</p><p>我们建议把这个标记设置为<code>False</code>来代替删除用户帐户，这样就不会影响指向用户的外键</p><p>这个属性不控制用户是否可以登录。登录验证时不会核查<code>is_active</code>标志。</p><p>因此，如果在登录时需要检查<code>is_active</code>标志，需要你在自己的登录视图中实现</p><p>用于<a href="http://docs.oneele.com/django/topics/auth.html#django.contrib.auth.views.login" target="_blank" rel="noopener"><code>login()</code></a>视图的<a href="http://docs.oneele.com/django/topics/auth.html#django.contrib.auth.forms.AuthenticationForm" target="_blank" rel="noopener"><code>AuthenticationForm</code></a>会执行这个检查，判断用户是否是活跃账户</p></blockquote></li><li><p><code>is_superuser</code></p><blockquote><p>布尔值，规范用户拥有所有权限（包括显式赋予和非显式赋予的）</p></blockquote></li><li><p><code>last_login</code></p><blockquote><p>预期情况下设置为用户最后一次登录的日期时间</p></blockquote></li><li><p><code>date_joined</code></p><blockquote><p>预期情况下设置为用户帐户创建的日期时间</p></blockquote></li></ul><h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><blockquote><p>在项目中，我们将使用电子邮件作为用户的用户名，那么可以在自带用户表中写明</p><p><code>USERNAME_FIELD = &#39;email&#39;</code></p><p>该属性设置当前表的登陆细分</p></blockquote><blockquote><p>描述我们自定义用户模型上作的唯一标识符分割名称的字符串，分段必须是唯一的，在定义中设置<code>unique=True</code></p><p><code>REQUIRED_FIELDS = [&#39;username&#39;]</code></p><p>设置当前该基线为必填细分</p></blockquote><ul><li><p><code>is_authenticated()</code></p><blockquote><p>判断用户是否已通过身份验证的方法，不意味任何权限，而且不检查用户的活动状态</p></blockquote></li><li><p><code>get_username()</code></p><blockquote><p>返回由USERNAME_FIELD制定的细分的值</p></blockquote></li><li><p>get_full_name（）</p><blockquote><p>返回<code>first_name</code>加上<code>last_name</code></p><p>中间加上一个空格，由于我们重新设置了表分区，那么这个变量函数需要我们重新给定返回值</p></blockquote></li><li><p><code>get_short_name()</code></p><blockquote><p>一个短的且非正式用户的标识符，返回<code>first_name</code></p><p>当你的项目重写该静态或直接去掉了<code>first_name</code>，所以我们必须重新给定这个函数的返回值</p></blockquote></li><li><p><code>set_password()</code></p><blockquote><p>将用户的密码设置为给定的字符串</p></blockquote></li><li><p><code>has_perm(perm, obj=None)</code></p><blockquote><p>用户是否具有某个权限，如果给定<code>obj</code>，则需要根据特定对象实例检查权限</p></blockquote></li><li><p><code>has_module_perms(app_label)</code></p><blockquote><p>如果用户有权访问给定应用中的模型，则返回<code>True</code></p><p>这里我们这两个分区都设置为<code>True</code>，可以让用户访问任一<code>APP</code></p></blockquote></li><li><p><code>is_staff()@property</code></p><blockquote><p>如果用户允许访问管理网站，则返回<code>True</code></p><p>这里我们返回<code>is_admin</code>的随机属性即可</p></blockquote></li></ul><blockquote><p>关于细分属性，如果需要进行高度扩展</p><p>可以使用继承<code>AbstractBaseUser</code>这个类</p><p>这个类中只含有<code>password</code>， ，<code>last_login</code>以及<code>is_active</code>三个字段属性</p></blockquote><h4 id="重载管理器"><a href="#重载管理器" class="headerlink" title="重载管理器"></a>重载管理器</h4><blockquote><p>由于已经覆盖了替代的<code>admin</code>用户表，现在需要将其对应的管理器函数进行编写</p><p>编写时主要关注一下两个父类函数的重写</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create_user(username_field,password_filed=<span class="literal">None</span>,**other_fields)</span><br><span class="line">normalize_email()将邮件地址规范化的类方法</span><br><span class="line">user.save(using=self._db)</span><br><span class="line">create_superuser(username, email, password)</span><br><span class="line"><span class="comment">#用户创建，is_admin设置为True即可</span></span><br><span class="line">    user.save(using=self._db)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> BaseUserManager</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUserManager</span><span class="params">(BaseUserManager)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_user</span><span class="params">(self, username, email, password=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> email :</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Users must have an email address'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> username:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Users must have an username'</span>)</span><br><span class="line">        <span class="comment">#判断邮件和用户名是否具有</span></span><br><span class="line">        now = timezone.now()</span><br><span class="line">        <span class="comment">#获取当前django的时间</span></span><br><span class="line">        user = self.model(</span><br><span class="line">            username=username,</span><br><span class="line">            email=self.normalize_email(email),</span><br><span class="line">            date_joined=now, </span><br><span class="line">            last_login=now,</span><br><span class="line">        )</span><br><span class="line">        user.set_password(password)</span><br><span class="line">        user.save(using=self._db)</span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_superuser</span><span class="params">(self, username, email, password)</span>:</span></span><br><span class="line">        user = self.create_user(username,</span><br><span class="line">            email,</span><br><span class="line">            password=password,</span><br><span class="line">        )</span><br><span class="line">        user.is_admin = <span class="literal">True</span></span><br><span class="line">        user.save(using=self._db)</span><br><span class="line">        <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure><blockquote><p>重新定义新用户表的管理器之后，想要生效，还需要在对应的模型类表中覆盖<code>objects</code>属性</p></blockquote><ul><li><code>objects = MyUserManager()</code></li></ul><h4 id="重载表"><a href="#重载表" class="headerlink" title="重载表"></a>重载表</h4><blockquote><p>下面是一个真实的重载自带用户表的模型类</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> AbstractBaseUser</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Member</span><span class="params">(AbstractBaseUser)</span>:</span></span><br><span class="line">    <span class="comment">#AbstractBaseUser中只含有3个field: password, last_login和is_active.</span></span><br><span class="line">    email = models.EmailField(verbose_name=<span class="string">'邮箱'</span>,max_length=<span class="number">255</span>,unique=<span class="literal">True</span>,)</span><br><span class="line">    username = models.CharField(verbose_name=<span class="string">"用户名"</span>, max_length=<span class="number">16</span>, unique=<span class="literal">True</span>)</span><br><span class="line">    weibo_id = models.CharField(verbose_name=<span class="string">"新浪微博"</span>, max_length=<span class="number">30</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    blog = models.CharField(verbose_name=<span class="string">"个人网站"</span>, max_length=<span class="number">200</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    location = models.CharField(verbose_name=<span class="string">"城市"</span>, max_length=<span class="number">10</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    profile = models.CharField(verbose_name=<span class="string">"个人简介"</span>, max_length=<span class="number">140</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    avatar = models.CharField(verbose_name=<span class="string">"头像"</span>, max_length=<span class="number">128</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    au = models.IntegerField(verbose_name=<span class="string">"用户活跃度"</span>, default=<span class="number">0</span>)</span><br><span class="line">    last_ip = models.IPAddressField(verbose_name=<span class="string">"上次访问IP"</span>, default=<span class="string">"0.0.0.0"</span>)</span><br><span class="line">    email_verified = models.BooleanField(verbose_name=<span class="string">"邮箱是否验证"</span>, default=<span class="literal">False</span>)</span><br><span class="line">    date_joined = models.DateTimeField(verbose_name=<span class="string">"用户注册时间"</span>, default=timezone.now)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    topic_num = models.IntegerField(verbose_name=<span class="string">"帖子数"</span>, default=<span class="number">0</span>)</span><br><span class="line">    comment_num = models.IntegerField(verbose_name=<span class="string">"评论数"</span>, default=<span class="number">0</span>)</span><br><span class="line">    is_active = models.BooleanField(default=<span class="literal">True</span>)</span><br><span class="line">    is_admin = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    objects = MyUserManager()</span><br><span class="line">    <span class="comment">#objects就是我们之前一直使用的管理器</span></span><br><span class="line">    <span class="comment">#管理器用来维护我们的增删改查</span></span><br><span class="line"></span><br><span class="line">    USERNAME_FIELD = <span class="string">'email'</span></span><br><span class="line">    REQUIRED_FIELDS = [<span class="string">'username'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.username</span><br><span class="line">    <span class="comment">#标签中的数据实例</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_email_verified</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.email_verified</span><br><span class="line">    <span class="comment">#我们可以在模板中，通过实例出来的对象数据进行这个函数的调取，获取他是否验证过</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_weibo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weibo_id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_username</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.username</span><br><span class="line">        <span class="comment">#方法的圆括号在templates标签中必需省略！！</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_email</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.email</span><br><span class="line">        <span class="comment">#方法的圆括号在templates标签中必需省略！！</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_full_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># The user is identified by their email address</span></span><br><span class="line">        <span class="keyword">return</span> self.email</span><br><span class="line">        <span class="comment">#get_full_name本来是获取first_name和last_name的</span></span><br><span class="line">        <span class="comment">#但是由于我们重新设置了表结构，那么这个函数必须自定义</span></span><br><span class="line">        <span class="comment">#方法的圆括号在templates标签中必需省略！！</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_short_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># The user is identified by their email address</span></span><br><span class="line">        <span class="keyword">return</span> self.username</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_perm</span><span class="params">(self, perm, obj=None)</span>:</span></span><br><span class="line">        <span class="string">"Does the user have a specific permission?"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_module_perms</span><span class="params">(self, app_label)</span>:</span></span><br><span class="line">        <span class="string">"Does the user have permissions to view the app `app_label`?"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_au</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        计算活跃度</span></span><br><span class="line"><span class="string">        公式：Topic * 5 + Comment * 1</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.au = self.topic_num * <span class="number">5</span> + self.comment_num * <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.au</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="comment">#类中函数可以直接做为属性使用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_staff</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"Is the user a member of staff?"</span></span><br><span class="line">        <span class="comment"># Simplest possible answer: All admins are staff</span></span><br><span class="line">        <span class="keyword">return</span> self.is_admin</span><br></pre></td></tr></table></figure><h4 id="重载Admin表单"><a href="#重载Admin表单" class="headerlink" title="重载Admin表单"></a>重载Admin表单</h4><blockquote><p>由于修改了默认的<code>django</code>表结构，此时在<code>admin</code>界面修改密码或添加用户数据已经不能再按照之前的表单系统啦</p><p>需要在<code>app</code>的<code>admin.py</code>中重写<code>UserCreationForm</code>和<code>UserChangeForm</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户创建表单</span></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.admin <span class="keyword">import</span> UserAdmin</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.forms <span class="keyword">import</span> ReadOnlyPasswordHashField</span><br><span class="line"><span class="keyword">from</span> people.models <span class="keyword">import</span> Member, Follower</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCreationForm</span><span class="params">(forms.ModelForm)</span>:</span></span><br><span class="line">    <span class="string">"""A form for creating new users. Includes all the required</span></span><br><span class="line"><span class="string">    fields, plus a repeated password."""</span></span><br><span class="line">    password1 = forms.CharField(label=<span class="string">'密码'</span>, widget=forms.PasswordInput)</span><br><span class="line">    password2 = forms.CharField(label=<span class="string">'确认密码'</span>, widget=forms.PasswordInput)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Member</span><br><span class="line">        fields = (<span class="string">'email'</span>, <span class="string">'username'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_password2</span><span class="params">(self)</span>:</span></span><br><span class="line">        password1 = self.cleaned_data.get(<span class="string">"password1"</span>)</span><br><span class="line">        password2 = self.cleaned_data.get(<span class="string">"password2"</span>)</span><br><span class="line">        <span class="keyword">if</span> password1 <span class="keyword">and</span> password2 <span class="keyword">and</span> password1 != password2:</span><br><span class="line">            <span class="keyword">raise</span> forms.ValidationError(<span class="string">"两次输入验证失败"</span>)</span><br><span class="line">        <span class="keyword">return</span> password2</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#在form中的clean__field函数会在is_valid()函数验证时自动调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, commit=True)</span>:</span></span><br><span class="line">        user = super(UserCreationForm, self).save(commit=<span class="literal">False</span>)</span><br><span class="line">        user.set_password(self.cleaned_data[<span class="string">"password1"</span>])</span><br><span class="line">        <span class="comment">#set_password将会采用django的加密算法将密码设置到对应的模型实例中</span></span><br><span class="line">        <span class="comment">#在内存中创建的好的对象只有通过commit=True才被真正执行到数据库上</span></span><br><span class="line">        <span class="keyword">if</span> commit:</span><br><span class="line">            user.save()</span><br><span class="line">        <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 密码改变时的展示表单</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserChangeForm</span><span class="params">(forms.ModelForm)</span>:</span></span><br><span class="line">    password = ReadOnlyPasswordHashField()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Member</span><br><span class="line">        fields = (<span class="string">'email'</span>, <span class="string">'password'</span>, <span class="string">'username'</span>, <span class="string">'is_active'</span>, <span class="string">'is_admin'</span>,)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_password</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.initial[<span class="string">"password"</span>]</span><br><span class="line">    <span class="comment">#使用默认的save函数即可</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 真正的用户admin界面管理方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUserAdmin</span><span class="params">(UserAdmin)</span>:</span></span><br><span class="line">    form = UserChangeForm</span><br><span class="line">    add_form = UserCreationForm</span><br><span class="line">    list_display = (<span class="string">'id'</span>, <span class="string">'email'</span>, <span class="string">'username'</span>, <span class="string">'email_verified'</span>, <span class="string">'last_login'</span>,<span class="string">'is_active'</span>,<span class="string">'is_admin'</span>,<span class="string">'last_ip'</span>)</span><br><span class="line">    list_display_links = (<span class="string">'id'</span>, <span class="string">'email'</span>, <span class="string">'username'</span>)</span><br><span class="line">    list_filter = (<span class="string">'email'</span>, <span class="string">'email_verified'</span>,)</span><br><span class="line">    fieldsets = (</span><br><span class="line">        (<span class="literal">None</span>, &#123;<span class="string">'fields'</span>: (<span class="string">'username'</span>, <span class="string">'email'</span>, <span class="string">'date_joined'</span>, <span class="string">'password'</span>,<span class="string">'is_active'</span>,<span class="string">'is_admin'</span>,<span class="string">'avatar'</span>)&#125;),</span><br><span class="line">        (<span class="string">'状态'</span>, &#123;<span class="string">'fields'</span>: (<span class="string">'email_verified'</span>, <span class="string">'last_ip'</span>, <span class="string">'au'</span>, <span class="string">'topic_num'</span>, <span class="string">'comment_num'</span>)&#125;),</span><br><span class="line">        (<span class="string">'社交网络'</span>, &#123;<span class="string">'fields'</span>: (<span class="string">'weibo_id'</span>, <span class="string">'blog'</span>)&#125;),</span><br><span class="line">    )</span><br><span class="line">    add_fieldsets = (</span><br><span class="line">        (<span class="literal">None</span>, &#123;</span><br><span class="line">            <span class="string">'classes'</span>: (<span class="string">'wide'</span>,),</span><br><span class="line">            <span class="comment">#admin样式设置</span></span><br><span class="line">            <span class="comment">#Fieldsets 使用 wide 样式将会有额外的水平空格.</span></span><br><span class="line">            <span class="string">'fields'</span>: (<span class="string">'email'</span>, <span class="string">'username'</span>, <span class="string">'password1'</span>, <span class="string">'password2'</span>,<span class="string">'is_active'</span>,<span class="string">'is_admin'</span>)&#125;</span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line">    search_fields = (<span class="string">'id'</span>, <span class="string">'email'</span>, <span class="string">'username'</span>)</span><br><span class="line">    ordering = (<span class="string">'id'</span>, <span class="string">'email'</span>, <span class="string">'email_verified'</span>)</span><br><span class="line">    filter_horizontal = ()</span><br><span class="line">    <span class="comment">#这个字段为了设置与groups关联的多选框</span></span><br><span class="line">admin.site.register(Member, MyUserAdmin)</span><br><span class="line">admin.site.register(Follower)</span><br></pre></td></tr></table></figure><h4 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h4><blockquote><p>还需要在<code>settings.py</code>文件下进行设置，覆盖最小的<code>User</code>模型</p></blockquote><ul><li><code>AUTH_USER_MODEL = &#39;people.Member&#39;</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Admin&quot;&gt;&lt;a href=&quot;#Admin&quot; class=&quot;headerlink&quot; title=&quot;Admin&quot;&gt;&lt;/a&gt;Admin&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Django-admin&lt;/code&gt;界面是框架为我们提供的&lt;code&gt;Web-APP&lt;/code&gt;的管理工具&lt;/p&gt;
&lt;p&gt;在之前的练习中，我们已经多次使用它进行&lt;code&gt;APP&lt;/code&gt;中表的&lt;code&gt;DML&lt;/code&gt;语句操作&lt;/p&gt;
&lt;p&gt;接下来，我们可以继续来学习，如何将&lt;code&gt;Admin&lt;/code&gt;界面进行优化扩展，更加方便我们后台管理&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
</feed>

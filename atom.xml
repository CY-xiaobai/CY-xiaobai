<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>哼着自己旳小调调</title>
  
  <subtitle>Happy hum their own small tune</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cy-blogs.cn/"/>
  <updated>2019-12-09T11:58:51.734Z</updated>
  <id>https://cy-blogs.cn/</id>
  
  <author>
    <name>哼着自己旳小调调</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GitHub操作</title>
    <link href="https://cy-blogs.cn/Git/"/>
    <id>https://cy-blogs.cn/Git/</id>
    <published>2019-12-09T11:56:21.542Z</published>
    <updated>2019-12-09T11:58:51.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GitHub操作起来真的是太简单啦！"><a href="#GitHub操作起来真的是太简单啦！" class="headerlink" title="GitHub操作起来真的是太简单啦！"></a>GitHub操作起来真的是太简单啦！</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><blockquote><p>Git是一个<strong>免费的开源</strong>分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务。</p><p>Git易于学习， 占地面积小，具有闪电般快速的性能。它超越了Subversion，CVS，Perforce和ClearCase等SCM工具，具有廉价本地分支，便捷的<strong>临时区域</strong>和<strong>多个工作流程</strong>等功能</p></blockquote><a id="more"></a><h3 id="git流程"><a href="#git流程" class="headerlink" title="git流程"></a>git流程</h3><p><a href="https://lienze.tech/blog/images/git流程图.jpg" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/git%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="git流程图"></a></p><ul><li><code>workspace</code>：工作区</li><li><code>Index/Stage</code>：暂存区</li><li><code>Repository</code>：仓库区/本地仓库</li><li><code>Remote</code>：远程仓库</li></ul><h3 id="SVN与Git的区别"><a href="#SVN与Git的区别" class="headerlink" title="SVN与Git的区别"></a>SVN与Git的区别</h3><ul><li><code>SVN</code></li></ul><blockquote><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的、而干活的时候，用的都是自己的电脑</p><p>首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器</p><p>集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了</p></blockquote><ul><li><code>Git</code></li></ul><blockquote><p>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库</p><p>这工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了</p><p>Git在本地磁盘上就保存着所有有关当前项目的历史更新，并且Git中的绝大多数操作都只需要访问本地文件和资源，不用连网，所以处理起来速度飞快</p><p>用SVN的话，没有网络或者断开VPN你就无法做任何事情</p><p>但用Git的话，就算你在飞机或者火车上，都可以非常愉快地频繁提交更新，等到了有网络的时候再上传到<strong>远程的镜像仓库</strong>。换作其他版本控制系统，这么做几乎不可能，抑或是非常麻烦</p></blockquote><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><ul><li><code>Windows</code>：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></li><li><code>Linux</code>：</li></ul><h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a><code>Git配置</code></h3><ul><li><code>git config --global</code>：全局git配置，这台机器所有的Git仓库均会使用这个配置</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.name <span class="string">"eastside"</span> # 你的名字</span><br><span class="line">git<span class="built_in"> config </span>--global user.email <span class="string">"..@xx.com"</span> # 你的邮箱</span><br></pre></td></tr></table></figure><h3 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h3><h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><ul><li>什么是版本库？</li></ul><blockquote><p>版本库又名仓库，英文名repository</p><p>你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件还原</p></blockquote><ul><li>选择，进入某个目录</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> projectcd project</span><br></pre></td></tr></table></figure><ul><li>初始化目录为本地仓库</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git init</span></span><br></pre></td></tr></table></figure><ul><li>初始化之后，目录下会多一个隐藏目录<code>.git</code>，该目录是<code>git</code>用来管理版本的，</li></ul><h3 id="添加项目文件"><a href="#添加项目文件" class="headerlink" title="添加项目文件"></a>添加项目文件</h3><ul><li>以创建django项目为例，在<code>git</code>本地仓库开启一个django项目</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">django-admin startproject testpro</span></span><br></pre></td></tr></table></figure><ul><li>添加项目文件或目录至暂存区</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> testpro</span></span><br></pre></td></tr></table></figure><ul><li>将暂存区内容提交至本地仓库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">commit</span> -m <span class="string">"a django project"</span></span><br><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"a django project"</span>[<span class="keyword">master</span> (root-<span class="keyword">commit</span>) adb00b3] a django <span class="keyword">project</span> <span class="number">5</span> files <span class="keyword">changed</span>, <span class="number">172</span> insertions(+) <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> testpro/manage.py <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> testpro/testpro/__init__.py <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> testpro/testpro/settings.py <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> testpro/testpro/urls.py <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> testpro/testpro/wsgi.py</span><br></pre></td></tr></table></figure><blockquote><p><code>-m</code>参数指定提交注释</p></blockquote><ul><li>查看此时仓库状态</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">lienze<span class="variable">@DESKTOP</span>-BIDA1PF MINGW64 ~<span class="regexp">/Desktop/project</span> (master)<span class="variable">$ </span>git statusOn branch masternothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h3 id="文件修改提交"><a href="#文件修改提交" class="headerlink" title="文件修改提交"></a>文件修改提交</h3><blockquote><p>如果在开发过程中，对其中的某个文件进行了修改，那么<code>git</code>在对比文件指纹的过程中发现了差异，此时也需要将新修改的文件进行提交</p></blockquote><ul><li>修改<code>settings.py</code>文件配置</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ALLOWED_HOSTS</span> = [<span class="string">"*"</span>,]<span class="comment"># ALLOWED_HOSTS = []</span></span><br></pre></td></tr></table></figure><ul><li>查看仓库状态</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">$ git statusOn branch masterChanges <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:  (use "git add &lt;file&gt;..." <span class="keyword">to</span> <span class="keyword">update</span> what will be <span class="keyword">committed</span>)  (use "git checkout -- &lt;file&gt;..." <span class="keyword">to</span> <span class="keyword">discard</span> changes <span class="keyword">in</span> working directory)        modified:   settings.pyno changes added <span class="keyword">to</span> <span class="keyword">commit</span> (use "git add" <span class="keyword">and</span>/<span class="keyword">or</span> "git commit -a")</span><br></pre></td></tr></table></figure><blockquote><p>此时仓库说，<code>modified: settings.py</code>，我们对其中某个文件进行了修改</p></blockquote><ul><li>将修改之后的文件加入暂存区</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> -A</span></span><br></pre></td></tr></table></figure><ul><li>此时查看状态</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">$ git statusOn branch masterChanges <span class="keyword">to</span> <span class="keyword">be</span> committed:  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)        modified:   settings.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><ul><li>将暂存区的内容提交至本地仓库</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">commit</span> -m <span class="string">'change settings'</span></span><br><span class="line"><span class="keyword">On</span> branch masternothing <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span><br></pre></td></tr></table></figure><ul><li>丢弃修改，可以丢弃工作区对于文件的修改</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="comment">-- settings.py</span></span><br></pre></td></tr></table></figure><ul><li>注意：命令<code>git checkout -- settings.py</code>中的<code>--</code>很重要，如果没有<code>--</code>的话，那么命令变成创建分支了</li></ul><h3 id="文件删除提交"><a href="#文件删除提交" class="headerlink" title="文件删除提交"></a>文件删除提交</h3><ul><li>在<code>django</code>项目的隔壁创建一个<code>1.py</code>文件</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">touch</span> <span class="number">1.</span>py</span><br></pre></td></tr></table></figure><ul><li>添加该文件</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> -Agit commit -m <span class="string">"add 1.py"</span></span></span><br></pre></td></tr></table></figure><ul><li>删除该文件</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm <span class="number">1.</span>py</span><br></pre></td></tr></table></figure><ul><li>恢复删除文件</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="comment">-- 1.py</span></span><br></pre></td></tr></table></figure><ul><li>提交至本地工作区</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -<span class="selector-tag">a</span> -m <span class="string">"rm 1.py"</span></span><br></pre></td></tr></table></figure><blockquote><p><code>git commit -a</code>：提交全部修改</p></blockquote><h2 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h2><blockquote><p>在团队开发中，我们需要每个开发者彼此配合，对同一款项目代码进行编写，此时需要我们借助线上仓库</p></blockquote><ul><li><code>github</code>：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com</a></li><li><code>gitee</code>：<a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com</a></li></ul><blockquote><p>由于网络环境，此处选择<code>gitee</code></p></blockquote><ul><li>将远程仓库添加到本地</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> edu git@gitee.com:eastside/edu.git</span></span><br></pre></td></tr></table></figure><blockquote><p>添加一个远程库，库名为<code>edu</code>，地址是<code>git@gitee.com:eastside/edu.git</code></p></blockquote><ul><li>列举当前所有的远程库</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git remote</span></span><br></pre></td></tr></table></figure><ul><li>删除某个远程库</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="builtin-name">remove</span> edu</span><br></pre></td></tr></table></figure><ul><li>将本地的仓库推到名为<code>edu</code>的远程仓库中</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 仓库地址：https:<span class="comment">//gitee.com/eastside/edu.gitgit push edu master</span></span></span><br></pre></td></tr></table></figure><ul><li>将远程仓库的代码拉取到本地，在第一次拉取时，可能因为缺少远程服务器上的<code>README.txt</code>文件，而导致远程和本地的分支不一样，通过以下命令</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin <span class="keyword">master</span> <span class="title"># 新建 README</span>文件</span><br><span class="line">git pull edu <span class="keyword">master</span> <span class="title">--allow-unrelated-histories</span></span><br></pre></td></tr></table></figure><ul><li>将远程仓库克隆到本地</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://gitee.com/eastside/edu.git</span><br></pre></td></tr></table></figure><blockquote><p>这是一个已经和远程仓库<code>master</code>分支关联的本地仓库</p></blockquote><ul><li>git全局配置多个用户名冲突时</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  git<span class="built_in"> config </span>--global --replace-all user.email <span class="string">"输入你的邮箱"</span> $  git<span class="built_in"> config </span>--global --replace-all user.name <span class="string">"输入你的用户名"</span></span><br></pre></td></tr></table></figure><h3 id="GIT分支"><a href="#GIT分支" class="headerlink" title="GIT分支"></a>GIT分支</h3><blockquote><p>每次提交，<code>Git</code>都把它们串成一条时间线，这条时间线就是一个分支</p><p>截止到目前，只有一条时间线，在<code>Git</code>里，这个分支叫<strong>主分支</strong>，即<code>master</code>分支</p><p>我们可以通过<code>checkout</code>命令进行分支的创建及切换</p></blockquote><ul><li><code>git checkout -b</code>：创建并切换分支<ul><li><code>git branch branchname</code>：创建分支</li><li><code>git checkout branchname</code>：切换分支</li></ul></li><li>创建一个测试分支</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -<span class="selector-tag">b</span> testbranch</span><br></pre></td></tr></table></figure><ul><li>删除一个分支</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-d testbranch</span><br></pre></td></tr></table></figure><ul><li>提交分支代码</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push <span class="comment">--all</span></span><br></pre></td></tr></table></figure><ul><li>合并分支</li></ul><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">merge</span> testbranch</span><br></pre></td></tr></table></figure><h3 id="GIT冲突"><a href="#GIT冲突" class="headerlink" title="GIT冲突"></a>GIT冲突</h3><blockquote><p>常见git冲突造成，是由于在多个分支下，或多个仓库中，对同一个文件修改，或添加了新的文件之后</p><p>由于某一方对于文件的修改没有及时在另一方生效，当另一方或另一分支在进行提交时，即会出现冲突</p></blockquote><ul><li>在testbranch分支下，修改1.py文件，并提交到云仓库</li><li>在master分支下，也修改1.py文件，并尝试提交</li></ul><p><a href="https://lienze.tech/blog/images/1565915294853.png" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/1565915294853.png" alt="1565915294853"></a></p><ul><li>此时冲突出现，使用<code>git status</code>命令查看当前仓库状态</li></ul><p><a href="https://lienze.tech/blog/images/git冲突status.png" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/git%E5%86%B2%E7%AA%81status.png" alt="git冲突status"></a></p><ul><li>查看被修改的文件<code>1.py</code></li></ul><p><a href="https://lienze.tech/blog/images/git冲突文件.png" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/git%E5%86%B2%E7%AA%81%E6%96%87%E4%BB%B6.png" alt="git冲突文件"></a></p><ul><li><code>Git</code>用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，<code>&gt;&gt;&gt;&gt;&gt; testbranch</code>是指<code>fenzhi1</code>上修改的内容，我们可以将差异部分的标注删掉重新提交，或是与对方协商，另行拷贝文件内容，重新clone仓库，将拷贝过的内容添加至内</li><li>之后再进行提交</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> 1.pygit commit -m <span class="string">"conflict fixed"</span></span></span><br></pre></td></tr></table></figure><ul><li>这样就可以搞定了</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;GitHub操作起来真的是太简单啦！&quot;&gt;&lt;a href=&quot;#GitHub操作起来真的是太简单啦！&quot; class=&quot;headerlink&quot; title=&quot;GitHub操作起来真的是太简单啦！&quot;&gt;&lt;/a&gt;GitHub操作起来真的是太简单啦！&lt;/h1&gt;&lt;h2 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Git是一个&lt;strong&gt;免费的开源&lt;/strong&gt;分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务。&lt;/p&gt;
&lt;p&gt;Git易于学习， 占地面积小，具有闪电般快速的性能。它超越了Subversion，CVS，Perforce和ClearCase等SCM工具，具有廉价本地分支，便捷的&lt;strong&gt;临时区域&lt;/strong&gt;和&lt;strong&gt;多个工作流程&lt;/strong&gt;等功能&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://cy-blogs.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://cy-blogs.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Cli</title>
    <link href="https://cy-blogs.cn/Vue-Cli/"/>
    <id>https://cy-blogs.cn/Vue-Cli/</id>
    <published>2019-12-09T11:52:36.348Z</published>
    <updated>2019-12-09T11:54:42.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件开发自动化工具"><a href="#组件开发自动化工具" class="headerlink" title="组件开发自动化工具"></a>组件开发自动化工具</h2><blockquote><p><code>Node.js</code>是一个新的后端(后台)语言，它的语法和<code>JavaScript</code>类似，所以可以说它是属于前端的后端语言</p></blockquote><blockquote><p><strong>运行环境：后端语言一般运行在服务器端，前端语言运行在客户端的浏览器上</strong></p><p><strong>功能：后端语言可以操作文件，可以读写数据库，前端语言不能操作文件，不能读写数据库。</strong></p></blockquote><ul><li><code>Node.js</code>如果安装成功，可以查看<code>Node.js</code>的版本,在终端输入如下命令</li></ul><a id="more"></a><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br><span class="line">npm</span><br></pre></td></tr></table></figure><ul><li>全局安装<code>vue</code>脚手架，<code>vue-cli</code>，这玩意儿可以自动生成项目模板</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vue-<span class="keyword">cli</span></span><br><span class="line">cnpm install --<span class="keyword">global</span> vue-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure><h3 id="单页应用-SPWA"><a href="#单页应用-SPWA" class="headerlink" title="单页应用 SPWA"></a>单页应用 SPWA</h3><blockquote><p>单页<code>Web</code>应用（<strong>single page web application</strong>，<code>SPWA</code>），就是将系统所有的操作交互限定在一个<code>web</code>页面中。</p><p>单页应用程序 (<code>SPA</code>)是加载单个<code>HTML</code>页面，系统的不同功能通过加载不同功能组件的形式来切换，不同功能组件全部封装到了<code>js</code>文件中，这些文件在应用开始访问时就一起加载完；</p><p>整个系统在切换不同功能时，页面的地址是不变的，系统切换可以做到局部刷新，也可以叫做无刷新，这么做的目的是为了给用户提供更加流畅的用户体验</p></blockquote><ul><li>通过<code>vue-cli</code>脚手架开启一个项目：</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vue init webpack myproject</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- Project name: 项目名称，如果不需要就直接回车。注：此处项目名不能使用大写。</span><br><span class="line">- Project description: 项目描述，直接回车</span><br><span class="line">- Author：作者</span><br><span class="line">- vue build: 构建方式 默认即可</span><br><span class="line">- <span class="keyword">install</span> vue-router? 是否安装vue的路由插件</span><br><span class="line"></span><br><span class="line">- <span class="keyword">Use</span> ESLint <span class="keyword">to</span> lint your code? 是否使用ESLint检测你的代码？</span><br><span class="line">（ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。）</span><br><span class="line"></span><br><span class="line">- Pick an ESLint preset:选择分支风格</span><br><span class="line"><span class="number">1.</span>standard(https://github.com/feross/standard) js的标准风格</span><br><span class="line"><span class="number">2.</span>Airbnb(https://github.com/airbnb/javascript) JavaScript最合理的方法，这个github地址说是JavaScript最合理的方法</span><br><span class="line"><span class="number">3.</span><span class="keyword">none</span> (configure it yourself) 自己配置</span><br><span class="line"></span><br><span class="line">- Setup unit tests? 是否安装单元测试</span><br><span class="line">- Pick a <span class="keyword">test</span> runner 选择一个单元测试运行器</span><br><span class="line"><span class="number">1.</span>Jest（Jest是由Facebook发布的开源的、基于Jasmine的JavaScript单元测试框架）</span><br><span class="line"><span class="number">2.</span>Karma <span class="keyword">and</span> Mocha</span><br><span class="line"><span class="number">3.</span><span class="keyword">none</span></span><br><span class="line"></span><br><span class="line">- Setup e2e tests <span class="keyword">with</span> Nightwatch(Y/n)?是否安装E2E测试框架NightWatch</span><br><span class="line">（E2E，也就是<span class="keyword">End</span> <span class="keyword">To</span> <span class="keyword">End</span>，就是所谓的“用户真实场景”。）</span><br><span class="line"></span><br><span class="line">- Should we run <span class="string">'npm install'</span> <span class="keyword">for</span> you <span class="keyword">after</span> the <span class="keyword">project</span> has been created?</span><br><span class="line">项目创建后是否要为你运行“npm <span class="keyword">install</span>”?</span><br><span class="line">yes,<span class="keyword">use</span> npm(使用npm)</span><br><span class="line">yes,<span class="keyword">use</span> yarn(使用yarn)</span><br><span class="line"><span class="keyword">no</span>,I will handle that myself(自己操作)</span><br></pre></td></tr></table></figure><ul><li>启动开发服务器：</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd myproject <span class="comment"># 进入目录</span></span><br><span class="line">cnpm install <span class="comment"># 安装依赖</span></span><br><span class="line">cnpm <span class="keyword">run</span><span class="bash"> dev <span class="comment"># 开启服务</span></span></span><br></pre></td></tr></table></figure><blockquote><p><code>vue</code>启动服务之后，是通过一个小型的<code>express</code>服务进行测试开发环境部署，在这个服务中，主要是通过<code>webpack-dev-middleware</code>和<code>webpack-hot-middleware</code>这两个中间件完成，并且会在每次代码对于<code>src</code>目录下的代码进行修改时，服务端会动态检测并让浏览器自动刷新</p></blockquote><ul><li>项目目录介绍</li></ul><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> src <span class="comment"># 主开发目录，所有的单文件组件都会放在这个目录下</span></span></span><br><span class="line"><span class="ruby">- static <span class="comment"># 项目静态目录，所有的css、js都会放在这个文件夹下</span></span></span><br><span class="line"><span class="ruby">- dist <span class="comment"># 项目打包发布文件夹，最后要上线单文件夹项目都在这个文件夹中</span></span></span><br><span class="line"><span class="ruby">- node_modules <span class="comment"># node的包目录</span></span></span><br><span class="line"><span class="ruby">- config <span class="comment"># 配置目录，主要用于区分开发环境，测试环境，线上环境的不同</span></span></span><br><span class="line"><span class="ruby">- build <span class="comment"># 项目打包时依赖的目录</span></span></span><br></pre></td></tr></table></figure><h3 id="组件开发"><a href="#组件开发" class="headerlink" title="组件开发"></a>组件开发</h3><blockquote><p>将一个组件相关的<code>html</code>结构，<code>css</code>样式，以及交互的<code>JavaScript</code>代码从<code>html</code>文件中剥离出来，合成一个文件，这种文件就是单文件组件，相当于一个组件具有了结构、表现和行为的完整功能，方便组件之间随意组合以及组件的重用，这种文件的扩展名为<code>.vue</code>，比如：<code>menu.vue</code></p><p>组件文件一般定义在<code>src</code>目录下的<code>components</code>文件夹里</p></blockquote><ul><li><code>template</code>标签定义<code>HTML</code>部分</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;teamplate&gt;</span><br><span class="line">    &lt;div class=&quot;&quot; @click=&quot;&quot;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">        账号</span><br><span class="line">            &lt;input type=&quot;text&quot;&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/teamplate&gt;</span><br></pre></td></tr></table></figure><ul><li><code>js</code>写成模块导出的形式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用export default命令，为模块指定默认输出</span><br><span class="line">export default&#123;</span><br><span class="line">    data: function()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            name:&quot;张三&quot;,</span><br><span class="line">            age:16,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>样式中的编写，如果含有scope关键字，表示这些样式是组件局部的，</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">.beauty&#123;</span><br><span class="line">    width:100px;</span><br><span class="line">    line-height:50px;</span><br><span class="line">    border-bottom:1px solid #ddd;</span><br><span class="line">    margin:0px auto;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><blockquote><p>当拥有一个组件文件时，要在项目的<code>src</code>目录下的<code>router</code>目录下的<code>index.js</code>文件下</p><p>进行组件的路由加载配置</p></blockquote><blockquote><p>在导入组件文件时，可以使用<code>@</code>符号，代表从<code>src</code>目录起</p><p>比如：<em>import</em> index <em>from</em> ‘@/components/index’</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Router from &apos;vue-router&apos;</span><br><span class="line">import HelloWorld from &apos;@/components/HelloWorld&apos;</span><br><span class="line">import first from &apos;@/components/first&apos; // 从组件目录下导入组件文件，不需要加后缀</span><br><span class="line">import index from &apos;@/components/index&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &apos;history&apos;,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      component: index,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/first&apos;, // 访问路径</span><br><span class="line">      component: first</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>当配置好路由之后，需要在最主要的<code>App.Vue</code>文件下进行连接引入</p></blockquote><blockquote><p>通过<code>&lt;router-link to=&quot;连接地址&quot;&gt;首页&lt;/router-link&gt;</code>标签进行连接引入</p><p>通过<code>&lt;router-view&gt;&lt;/router-view&gt;</code>标签进行路由加载，可以简写为：<code>&lt;router-view/&gt;</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt;</span><br><span class="line">    &lt;router-link to=&quot;/first&quot;&gt;第一个页面&lt;/router-link&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在<code>App.Vue</code>文件下的<code>template</code>标签处如果已经引入了其他跳转连接；</p><p>那么在子组件的<code>template</code>部分不需要在进行引入</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>编写<code>components</code>组件</li><li><code>index.js</code>配置路由</li><li>在主入口<code>App.vue</code>中加载路由组件<code>&lt;router-view/&gt;</code>，一般默认已经写好</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;组件开发自动化工具&quot;&gt;&lt;a href=&quot;#组件开发自动化工具&quot; class=&quot;headerlink&quot; title=&quot;组件开发自动化工具&quot;&gt;&lt;/a&gt;组件开发自动化工具&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Node.js&lt;/code&gt;是一个新的后端(后台)语言，它的语法和&lt;code&gt;JavaScript&lt;/code&gt;类似，所以可以说它是属于前端的后端语言&lt;/p&gt;
&lt;/blockquote&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;运行环境：后端语言一般运行在服务器端，前端语言运行在客户端的浏览器上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能：后端语言可以操作文件，可以读写数据库，前端语言不能操作文件，不能读写数据库。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Node.js&lt;/code&gt;如果安装成功，可以查看&lt;code&gt;Node.js&lt;/code&gt;的版本,在终端输入如下命令&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://cy-blogs.cn/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://cy-blogs.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="https://cy-blogs.cn/Vue/"/>
    <id>https://cy-blogs.cn/Vue/</id>
    <published>2019-12-09T11:52:36.346Z</published>
    <updated>2019-12-09T11:54:39.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h2><blockquote><p><code>Vue.js</code>是前端三大新框架：<code>Angular.js</code>、<code>React.js</code>、<code>Vue.js</code>之一，<code>Vue.js</code>目前的使用和关注程度在三大框架中稍微胜出，并且它的热度还在递增</p><p><code>Vue</code>的核心库只关注视图层，<code>Vue</code>的目标是通过尽可能简单的<code>API</code>实现响应的数据绑定，在这一点上<code>Vue.js</code>类似于后台的模板语言</p><p><code>Vue</code>也可以将界面拆分成一个个的组件，通过组件来构建界面，然后用自动化工具来生成单页面(<code>SPA - single page application</code>)系统</p></blockquote><a id="more"></a><ul><li><code>Vue.js</code>官方文档： <a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a></li><li><code>vue.js</code>下载地址： <a href="https://cn.vuejs.org/v2/guide/installation.html" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/installation.html</a></li></ul><h3 id="npm配置cnpm"><a href="#npm配置cnpm" class="headerlink" title="npm配置cnpm"></a>npm配置cnpm</h3><ul><li><code>windows</code>下配置<code>cnmp</code>环境：</li></ul><blockquote><p>默认的使用<code>NPM</code>可能会因为网络问题而导致无法使用或延迟居高，可以使<code>npm</code>升级为<code>cnpm</code>，从国内淘宝镜像中加载所需的<code>npm</code>软件源</p></blockquote><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g cnpm --registry=https:<span class="regexp">//</span>registry.<span class="built_in">npm</span>.taobao.org</span><br></pre></td></tr></table></figure><ul><li>设置安装包缓存路径</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm<span class="built_in"> config </span><span class="builtin-name">set</span> cache <span class="string">"C:\nodejs\node_cache"</span></span><br></pre></td></tr></table></figure><ul><li>设置安装包位置</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm<span class="built_in"> config </span><span class="builtin-name">set</span><span class="built_in"> prefix </span><span class="string">"C:\nodejs\node_global"</span></span><br></pre></td></tr></table></figure><blockquote><p>之后使用命令安装的模块存储在<strong>C:\nodejs\node_global\node_modules</strong>里</p><p>请按照个人需求设置你的文件位置</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm<span class="built_in"> config </span><span class="builtin-name">set</span> cache <span class="string">"C:\nodejs\node_cache"</span></span><br></pre></td></tr></table></figure><h3 id="Vue部署"><a href="#Vue部署" class="headerlink" title="Vue部署"></a>Vue部署</h3><ul><li>安装<code>Vue</code></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm <span class="keyword">install</span> vue -g</span><br></pre></td></tr></table></figure><ul><li>安装<code>vue</code>脚手架</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install vue-<span class="keyword">cli</span> -g</span><br></pre></td></tr></table></figure><blockquote><p><code>-g</code>参数代表全局位置安装，这样可以在环境变量生效的情况下直接在命令行等工具下使用vue命令行进行项目的开启</p></blockquote><h3 id="vue-devtools调试工具"><a href="#vue-devtools调试工具" class="headerlink" title="vue-devtools调试工具"></a>vue-devtools调试工具</h3><blockquote><p><code>vue-devtools</code>可以方便开发者进行<code>Vue</code>中变量等信息的调试跟踪</p></blockquote><ul><li>下载<code>vue-devtools</code></li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/vuejs/vue-devtools</span><br></pre></td></tr></table></figure><ul><li>进入到<code>vue-devtools</code>目录下安装依赖包</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cd</span> <span class="string">vue-devtools-dev</span></span><br><span class="line"><span class="attr">cnpm</span> <span class="string">install </span></span><br><span class="line"><span class="attr">cnpm</span> <span class="string">run build</span></span><br></pre></td></tr></table></figure><ul><li>注意：在进行调试工具安装时，首先需要修改<code>shells&gt;chrome</code>文件夹下的<code>mainifest.json</code>中的persistent为true</li><li>将插件目录下的<code>chrome</code>文件夹拖入到<code>chrome</code>浏览器的扩展程序下，记得打开调试模式</li></ul><blockquote><p>扩展程序可以通过浏览器访问</p></blockquote><p><a href="https://lienze.tech/blog/images/1561789924.png" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/1561789924.png" alt="1561789924"></a></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">chrome:</span><span class="comment">//extensions/</span></span><br></pre></td></tr></table></figure><h3 id="Vue-CDN"><a href="#Vue-CDN" class="headerlink" title="Vue-CDN"></a>Vue-CDN</h3><blockquote><p>除去通过<code>npm</code>安装的方式来使用<code>vue</code>，还可以直接使用<code>cdn</code>中的<code>vue.js</code>文件</p></blockquote><ul><li>vue.js：开发版本，包含了有帮助的命令行警告</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>vue.min.js：生产环境版本，优化了尺寸和速度</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Vue语法"><a href="#Vue语法" class="headerlink" title="Vue语法"></a>Vue语法</h3><blockquote><p>每个<code>vue</code>应用都是通过实例化一个新的<code>vue</code>对象开始的</p></blockquote><ul><li>创建第一个模板语法：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="comment">&lt;!-- 这个也叫做插值表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123; // vm这个变量不允许使用连字符，可以使用下划线，比如vm-data是不允许的</span><br><span class="line">    el: &quot;#content&quot;, </span><br><span class="line">    // 对应document中的一个标签，当vue对象创建后，这个标签内的区域就被接管</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &quot;这是vue里的变量&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>当一个<code>vue</code>实例被创建时，<code>vue</code>的响应式系统中加入了对其<code>data</code>对象中能找到的所有属性</li><li>当这些属性值被改变时，视图也会发生<strong>相应</strong>，并将对应属性更新为新的值</li><li>也可以通过定义函数来改变实例中<code>data</code>对象中的数据，数据改变，视图中的数据也将改变</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;ChangeMsg&quot;&gt;改变&lt;/button&gt;</span><br><span class="line">    &lt;!-- 绑定点击事件为定义好的vue函数 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &quot;我对应的是message的变量&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123; // 定义一个函数 并绑定在按钮的点击事件上</span><br><span class="line">            ChangeMsg:function()&#123;</span><br><span class="line">                this.message = &quot;我被改变了&quot;;</span><br><span class="line">                // 修改当前实例中的message变量</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的代码，将在点击按钮时，使当前的<code>message</code>变量发生变化</p><p>``这样的语法有点类似一些<code>Web</code>框架，比如<code>django</code>的模板语言中的模板变量</p></blockquote><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><blockquote><p>除了直接定义某个变量的固定值进行页面渲染，模板变量还支持通过函数的返回值进行赋值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; classType &#125;&#125;学习&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123; describe() &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;, // getElementById(&apos;app&apos;)</span><br><span class="line">        data: &#123;</span><br><span class="line">            classType: &quot;vue&quot;,</span><br><span class="line">            content: &quot;这是vue的一个测试&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            describe:function()&#123;</span><br><span class="line">                return &quot;这是一个函数的返回值&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue模板指令"><a href="#Vue模板指令" class="headerlink" title="Vue模板指令"></a>Vue模板指令</h3><ul><li>模板语法指的是如何将数据放入html中</li></ul><blockquote><p><strong>Vue.js使用了基于HTML的模板语法，允许开发者声明式地将DOM绑定至底层 Vue 实例的数据</strong></p><p><strong>所有 Vue.js的模板都是合法的 HTML ，所以能被遵循规范的浏览器和HTML 解析器解析</strong></p></blockquote><ul><li>插入值，模板变量</li></ul><blockquote><p>数据绑定最常见的形式就是使用<code>Mustache</code>语法(双大括号) 的文本插值，也就是上面示例中的``</p></blockquote><h4 id="内容绑定"><a href="#内容绑定" class="headerlink" title="内容绑定"></a>内容绑定</h4><h5 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h5><blockquote><p>将内容按照<code>html</code>格式进行插入</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p v-html=&quot;contetn&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      content: &quot;&lt;b&gt;段落标签&lt;/b&gt;文本内容&quot;  </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在网站上动态渲染任意<code>HTML</code>是非常危险的，因为容易导致<code>XSS</code>攻击</p><p><code>v-html</code>一般只用在可信内容中，<strong>永不</strong>用在用户提交的内容上</p></blockquote><h5 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h5><blockquote><p>将内容按照文本格式进行插入，但会覆盖原有标签内的内容，不会有加载的闪烁问题</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p v-text=&quot;contetn&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">       &#123;&#123; gender ? &apos;男&apos; : &apos;女&apos; &#125;&#125;</span><br><span class="line">        &lt;!-- ok? true:false --&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      gender: true, // 变量值为true时，显示模板变量中左边的值</span><br><span class="line">      content: &quot;&lt;b&gt;段落标签&lt;/b&gt;文本内容&quot;  </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h5><blockquote><p>解决使用差值表达式时页面渲染过程，由于变量没有初始化而导致的闪烁问题</p></blockquote><blockquote><p>通俗的来说，比如<code>变量的实际内容没有被创建，那么此时页面只会展示出</code>这样的效果，之后当变量初始化之后，``将变化为实际的值，此时变化的过程我们称作闪烁</p></blockquote><blockquote><p>这个指令可以隐藏未编译的标签直到实例准备完毕</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            message: &quot;测试&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>在上面的代码中，如果网速够慢的清空下，页面首先加载显示出的内容是``</li><li><strong>解决办法</strong>：通过<code>v-clock</code>指令，在使用到模板变量的标签上写入，并设置一个<code>v-clock</code>的类样式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    [v-cloak]&#123;</span><br><span class="line">        display: none;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-cloak id=&quot;app&quot;&gt;</span><br><span class="line">&lt;p v-cloak&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h4><h5 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h5><blockquote><p>如果我们需要设置的模板变量是一个属性，比如<code>a</code>标签的<code>href</code>属性</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;a v-bind:href=&quot;message&quot;&gt;连接&lt;/a&gt;</span><br><span class="line">    &lt;a :href=&quot;message +&apos;abc&apos;&quot;&gt;连接&lt;/a&gt;</span><br><span class="line">    &lt;!-- 属性内的模板变量写法已被移除，使用v-bind:attr 或 :attr --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">    message: &quot;https://www.baidu.com&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>可以通过<code>v-bind</code>指令或者<code>:</code>的简写对某个<code>dom</code>元素的属性进行绑定</p><p>在下面还有更加详细的属性绑定示例</p></blockquote><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><h5 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h5><blockquote><p>给元素绑定对应事件，以下是对于点击事件的绑定</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;show&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;show&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">el: &quot;#app&quot;,</span><br><span class="line">    method: &#123;</span><br><span class="line">    show: function()&#123;</span><br><span class="line">alert(&quot;弹一下&quot;)</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="跑马灯效果"><a href="#跑马灯效果" class="headerlink" title="跑马灯效果"></a>跑马灯效果</h4><blockquote><p>这里有一个跑马灯效果可以玩耍</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;button @click=&quot;start&quot;&gt;开始&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;stop&quot;&gt;停止&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &quot;这是一个跑马灯&quot;,</span><br><span class="line">        sT: null, // 定时器实例</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        work()&#123;</span><br><span class="line">            this.message = this.message.substring(1) + this.message[0] </span><br><span class="line">            // 循环定时器所作的事情</span><br><span class="line">        &#125;,</span><br><span class="line">        start()&#123;</span><br><span class="line">            if (this.sT==null) &#123; // 判断此时是否已有定时器开启</span><br><span class="line">                console.log(&quot;开启定时器&quot;)</span><br><span class="line">                this.sT = setInterval(this.work,400)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                console.log(&quot;已经开启 不在开启&quot;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        stop()&#123; // 关闭定时器 设置定时器变量为null</span><br><span class="line">            console.log(&quot;关闭定时器&quot;)</span><br><span class="line">            clearInterval(this.sT)</span><br><span class="line">            this.sT = null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="绑定事件修饰符"><a href="#绑定事件修饰符" class="headerlink" title="绑定事件修饰符"></a>绑定事件修饰符</h4><h5 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h5><blockquote><p>比如一个按钮在一个<code>div</code>中，并且按钮和<code>div</code>均有自己的事件，那么此时点击按钮，事件会像冒泡一样从按钮开始一直到<code>div</code>进行触发，<code>.stop</code>修饰符用来阻止默认的事件触发行为</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;fDiv&quot; @click=&quot;divClick&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;fBtn&quot; @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#fDiv&quot;, // 控制区域</span><br><span class="line">            data: &#123;&#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                divClick()&#123;</span><br><span class="line">                    console.log(&quot;div被点击了&quot;)</span><br><span class="line">                &#125;,</span><br><span class="line">                btnClick()&#123;</span><br><span class="line">                    console.log(&quot;按钮被点击了&quot;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>通过<code>.stop</code>修饰阻止冒泡</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;fDiv&quot; @click=&quot;divClick&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;fBtn&quot; @click.stop=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h5 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h5><blockquote><p>比如像<code>a</code>标签这样的，在点击时他有默认的跳转动作，可以通过<code>.prevent</code>阻止该默认行为</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;fDiv&quot;&gt;</span><br><span class="line">&lt;a href=&quot;https://www.baidu.com&quot; @click.prevent=&quot;aLink&quot;&gt;去百度&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue()&#123;</span><br><span class="line">    el: &quot;#fDiv&quot;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">    aLink()&#123;</span><br><span class="line">    console.log(&quot;连接被点击&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="捕获事件"><a href="#捕获事件" class="headerlink" title="捕获事件"></a>捕获事件</h5><blockquote><p>默认的事件触发处理机制是冒泡机制，capture代表具有该修饰的事件，会优先触发，脱离冒泡顺序；</p><p>也可理解为谁有该修饰符，先触发谁的事件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;fDiv&quot; @click.capture=&quot;divClick&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;fBtn&quot; @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &quot;#fDiv&quot;, // 控制区域</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            divClick()&#123;</span><br><span class="line">                console.log(&quot;div被点击了&quot;)</span><br><span class="line">            &#125;,</span><br><span class="line">            btnClick()&#123;</span><br><span class="line">                console.log(&quot;按钮被点击了&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="自身事件"><a href="#自身事件" class="headerlink" title="自身事件"></a>自身事件</h5><blockquote><p>与<code>capture</code>和冒泡不同，<code>.self</code>只有是自身触发的当前的事件才真正执行处理的回调函数</p><p>并且<code>.self</code>只会阻止当前元素的事件触发行为</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;fDiv&quot; @click.self=&quot;divClick&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;fBtn&quot; @click.self=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与上同</span></span><br></pre></td></tr></table></figure><h5 id="单次事件"><a href="#单次事件" class="headerlink" title="单次事件"></a>单次事件</h5><blockquote><p>使用<code>.once</code>只触发一次事件函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;fDiv&quot;&gt;</span><br><span class="line">    &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent.once=&quot;aLink&quot;&gt;去百度&lt;/a&gt;</span><br><span class="line">    &lt;!-- 连接无法跳转的阻止事件 只会出现一次 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue()&#123;</span><br><span class="line">    el: &quot;#fDiv&quot;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">    aLink()&#123;</span><br><span class="line">    console.log(&quot;连接被点击&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表单双向绑定"><a href="#表单双向绑定" class="headerlink" title="表单双向绑定"></a>表单双向绑定</h3><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><blockquote><p>使用v-model指令可以在表单<code>input</code>、<code>textarea</code>以及<code>select</code>元素上创建双向数据绑定</p><p>根据表单上的值，自动更新模板变量中的值</p></blockquote><blockquote><p><code>v-model</code>会忽略表单的初始值，比如：<code>checked</code>、<code>value</code>、<code>selected</code>，如果需要的话，应该在<code>javascript</code>中首先声明初始值</p></blockquote><h5 id="text"><a href="#text" class="headerlink" title="text"></a><strong>text</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &quot;这是个表单内容&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a><strong>textarea</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;textarea v-model=&quot;message&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同上</span></span><br></pre></td></tr></table></figure><h5 id="checkbox"><a href="#checkbox" class="headerlink" title="checkbox"></a><strong>checkbox</strong></h5><ul><li><strong>单个复选框</strong>：数据为绑定为<code>true</code>和<code>false</code>的布尔值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;checked&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                checked: true,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>多个复选框</strong>：选中的结果会绑定到同一个数组，将保存的<code>v-model</code>变量创建为数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;checked&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input name=&quot;fruit&quot; type=&quot;checkbox&quot; value=&quot;apple&quot;  v-model=&quot;checked&quot;&gt;苹果</span><br><span class="line">    &lt;input name=&quot;fruit&quot; type=&quot;checkbox&quot; value=&quot;banana&quot; v-model=&quot;checked&quot;&gt;香蕉</span><br><span class="line">    &lt;input name=&quot;fruit&quot; type=&quot;checkbox&quot; value=&quot;orange&quot; v-model=&quot;checked&quot;&gt;橘子</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                checked: new Array,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="radio"><a href="#radio" class="headerlink" title="radio"></a><strong>radio</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;picked&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;junior&quot; v-model=&quot;picked&quot;&gt;男</span><br><span class="line">    &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;girl&quot; v-model=&quot;picked&quot;&gt;女</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                picked: &quot;哈哈哈哈&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="select"><a href="#select" class="headerlink" title="select"></a><strong>select</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;selected&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;select v-model=&quot;selected&quot;&gt;</span><br><span class="line">        &lt;option disabled value=&quot;&quot;&gt;你想去哪&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;山西&quot;&gt;山西&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                selected: &quot;&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="selects"><a href="#selects" class="headerlink" title="selects"></a><strong>selects</strong></h5><blockquote><p>设置<code>select</code>标签的<code>multiple</code>属性即可设置为多选下拉菜单，按着<code>ctrl</code>键可以多选</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;selecteds&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;select multiple v-model=&quot;selecteds&quot;&gt;</span><br><span class="line">        &lt;option value=&quot;上衣&quot;&gt;上衣&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;裤子&quot;&gt;裤子&lt;/option&gt;</span><br><span class="line">        &lt;option value=&quot;鞋&quot;&gt;鞋&lt;/option&gt;  </span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                selecteds: new Array, // 多重数据一般都要保存成数组</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><h5 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h5><blockquote><p>默认情况下，<code>v-model</code>在<code>input</code>和<code>textarea</code>表单中进行同步输入框的改动</p><p>添加了<code>.lazy</code>修饰符之后，对应的<code>v-model</code>绑定事件触发机制将变为<code>change</code>事件，只有在光标失去焦点时会触发</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model.lazy=&quot;message&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &quot;这是个表单内容&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h5><blockquote><p>如果用户希望将输入表单的内容处理为<code>Number</code>类型，可以使用<code>.number</code>给<code>v-model</code>进行修饰；如果表单字符串无法被处理为数字，则返回原始的值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;typeof message&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model.number=&quot;message&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h5 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h5><blockquote><p>使用<code>.trim</code>可以自动过滤输入框的首尾空格</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model.trim=&quot;message&quot;&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br><span class="line">    &lt;!-- 通过查看另一个表单中同步的缩进 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><blockquote><p>当某些情况下，无法确定表单中所代表的属性值，可以使用<code>v-bind</code>进行动态绑定，<code>v-model</code>获取到的表单输入此时则是我们定义的<code>v-bind</code>属性值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-html=&quot;message&quot;&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;radio&quot; v-model=&quot;message&quot; :value=&quot;choiceA&quot;&gt; A</span><br><span class="line">    &lt;input type=&quot;radio&quot; v-model=&quot;message&quot; :value=&quot;choiceB&quot;&gt; B</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &quot;&quot;, // 表单绑定变量</span><br><span class="line">                choiceA: &quot;Yes!&quot;, // 属性绑定变量，未来不需要修改标签中的value值即可动态修改</span><br><span class="line">                choiceB: &quot;No!&quot;,</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><ul><li>关键词：<code>computed</code></li></ul><blockquote><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的</p><p>在模板中放入太多的逻辑会让模板过重且难以维护</p><p>也就是说，某些时候页面中的模板变量如果需要复杂的运算处理，应该使用<strong>计算属性</strong>，而不是直接在模板位置进行计算。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">            var vm = new Vue(&#123;</span><br><span class="line">                el: &quot;#container&quot;,</span><br><span class="line">                data: &#123;</span><br><span class="line">                    String1:&quot;这是一个字符串&quot;,</span><br><span class="line">                &#125;,</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    MreverseString()&#123;</span><br><span class="line">                        return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;)</span><br><span class="line">                    &#125; // 定义一个函数进行字符串逆置</span><br><span class="line">                &#125;,</span><br><span class="line">                computed: &#123;</span><br><span class="line">                    CreverseString()&#123;</span><br><span class="line">                        return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;)</span><br><span class="line">                    &#125; // 定义一个计算属性进行字符串逆置</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-cloak id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p&gt;这是一个字符串:&#123;&#123; String1 &#125;&#125; &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;他的逆置:&#123;&#123; String1.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125;&#125; &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;他的逆置:&#123;&#123; CreverseString &#125;&#125; &lt;/p&gt;</span><br><span class="line">    &lt;!-- 计算属性直接写入函数名 --&gt;</span><br><span class="line">    &lt;p&gt;他的逆置:&#123;&#123; MreverseString() &#125;&#125; &lt;/p&gt;</span><br><span class="line">    &lt;!-- 普通methods函数调用需加括号 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：虽然计算属性和函数都可以达成同样的目的，但是<code>computed</code>会缓存结果，计算属性如果发现依赖的属性<code>message</code>未发生改变，再次访问计算属性不会重复运算函数，而是直接利用已有结果；如果依赖数据发生改动，计算属性函数才会重新运算。</li><li>在函数及计算属性中添加日志输出即可看到这个效果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    MreverseString() &#123;</span><br><span class="line">        console.log(&quot;MreverseString被运算了&quot;)</span><br><span class="line">        return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">CreverseString() &#123;</span><br><span class="line">console.log(&quot;CreverseString被运算了&quot;)</span><br><span class="line">return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在终端下进行计算属性以及函数的访问即可看到效果。</li></ul><h4 id="计算属性SetAttr"><a href="#计算属性SetAttr" class="headerlink" title="计算属性SetAttr"></a>计算属性SetAttr</h4><blockquote><p>默认的计算属性只有获取<code>getattr</code>的方式，我们可以手动为他添加一个<code>setter</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    CreverseString: &#123;</span><br><span class="line">        get: function()&#123;</span><br><span class="line">            return this.String1.split(&quot;&quot;).reverse().join(&quot;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        set: function(val)&#123;</span><br><span class="line">            this.String1 = val.split(&quot;&quot;).reverse().join(&quot;&quot;)</span><br><span class="line">            // 如果当前的逆置之后字符串为val，那么原本的字符串需要再颠倒一次</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="侦听属性"><a href="#侦听属性" class="headerlink" title="侦听属性"></a>侦听属性</h3><blockquote><p>侦听属性的作用是侦听某些属性的变化，从而做相应的操作，进行对数据变化的相应，</p><p>侦听属性是一个对象（字典），<code>key</code>值是要监听的元素，值是当监听的元素发生改变时要执行的函数；</p><p>监听函数有两个参数，一个是当前值，另一个是变化后的值</p></blockquote><ul><li>比如监听一个变量的变化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                content: &quot;&quot;, // 表单内容</span><br><span class="line">                count: 0, // 记录表单内用户敲了多少次</span><br><span class="line">            &#125;,</span><br><span class="line">            watch:&#123;</span><br><span class="line">                content:function (oldVal,newVal)&#123;</span><br><span class="line">                    // 只要在文本框输入内容影响到了age数据发生改变，就会触发</span><br><span class="line">                    this.count += 1</span><br><span class="line">                &#125;，</span><br><span class="line">            &#125;，</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p&gt;&lt;label&gt;你敲了:&#123;&#123; count &#125;&#125;次&lt;/label&gt;&lt;/p&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; placeholder=&quot;请输入你的年纪&quot; v-model=&quot;content&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="属性绑定-1"><a href="#属性绑定-1" class="headerlink" title="属性绑定"></a>属性绑定</h3><blockquote><p>使用<code>v-bind:class</code>指令来设置元素的class属性；</p><p>属性表达式的类型可以是字符串、对象或数组</p></blockquote><h4 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h4><blockquote><p>可以通过为元素绑定一个数组，用来为元素设置单个或多个样式，类名在数组中用单引号</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    .fontBold &#123;</span><br><span class="line">        font-weight: bold;</span><br><span class="line">    &#125;</span><br><span class="line">    .fontRed &#123;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p :class=&quot;[&apos;fontBold&apos;,&apos;fontRed&apos;]&quot;&gt;这是一个段落&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h4><blockquote><p>可以通过为元素绑定一个对象，对象的key是样式类，对象的value是true或false来动态切换class</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                flag: true,</span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line">                toggle() &#123;</span><br><span class="line">                    if (this.flag)&#123; // 判断当前toggle变量的属性，对称变换</span><br><span class="line">                        this.flag = false</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        this.flag = true</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p :class=&quot;&#123;fontBold: flag&#125;&quot; @click=&quot;toggle&quot;&gt;这是一个段落&lt;/p&gt;</span><br><span class="line">    &lt;p :class=&quot;&#123;flag? fontBold:&apos;&apos;&#125;&quot; @click=&quot;toggle&quot;&gt;这是一个段落&lt;/p&gt;</span><br><span class="line">    &lt;!-- 三元表达式 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="样式绑定"><a href="#样式绑定" class="headerlink" title="样式绑定"></a>样式绑定</h3><blockquote><p>使用<code>v-bind:style</code>语法，为元素绑定样式</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:style</span>=<span class="string">"&#123;color:'red','font-weight':'bold'&#125;"</span>&gt;</span></span><br><span class="line">    一段文字</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>也可以在<code>vue</code>的<code>data</code>中定义一个对象，用来描述样式，其中带有连字符的样式属性要加引号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p :style=&quot;styleObj&quot;&gt;一段文字&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">styleObj: &#123;</span><br><span class="line">color:&apos;red&apos;,</span><br><span class="line">&apos;font-weight&apos;:&apos;bold&apos;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li><code>data</code>中的对象也可以通过数组类型绑定到元素上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p :style=&quot;[styleObj1,styleObj2]&quot;&gt;一段文字&lt;/p&gt;</span><br><span class="line">    &lt;!-- 对于js的样式绑定不需要加引号，因为就是一个变量 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">styleObj1: &#123;</span><br><span class="line">    border: &apos;1px solid gray&apos;,</span><br><span class="line">    width: &apos;100px&apos;,</span><br><span class="line">&#125;,</span><br><span class="line">styleObj2:&#123;</span><br><span class="line">    background: &apos;black&apos;,</span><br><span class="line">    color: &apos;blue&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><blockquote><p>通过条件指令可以控制元素的显示及隐藏，或者说叫做创建和销毁</p></blockquote><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><blockquote><p><code>v-if</code>指令用于条件性的渲染一块内容。这块内容只会在指令的表达式返回<code>truthy</code>值的时候渲染</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-cloak id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-if=&quot;oh3&quot;&gt;h3标题&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p v-if=&quot;gender === &apos;girl&apos;&quot;&gt;你是女的&lt;/p&gt;</span><br><span class="line">    &lt;p v-else-if=&quot;gender === &apos;boy&apos;&quot;&gt;你是男的&lt;/p&gt;</span><br><span class="line">    &lt;p v-else&gt;不男不女&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                oh3:&quot;a&quot;,</span><br><span class="line">                gender: &apos;other&apos;</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li><code>truthy</code>和<code>ture</code>的区别：</li><li>隐含有<code>true</code>属性的变量不可以认为它是<code>true</code>，它不是<code>boolean</code>类型</li></ul><h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><blockquote><p>与<code>v-if</code>不同的是，<code>v-show</code> 的元素始终会被渲染并保留在<code>DOM</code>中</p><p><code>v-show</code> 只是简单地切换元素的<code>CSS</code>属性 <code>display</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-cloak id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;h3 v-if=&quot;oh3&quot;&gt;h3标题&lt;/h3&gt;</span><br><span class="line">    &lt;h4 v-show=&quot;oh4&quot;&gt;h4标题&lt;/h4&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                oh3:&quot;1&quot;, // v-if 在该变量不为真时直接消失在document中</span><br><span class="line">                oh4:&quot;1&quot;, // v-show 处理不为真的变量条件 绑定元素不会消失</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h4><blockquote><p>把一个数组对应为一组元素</p><p>用 <code>v-for</code> 指令根据一组数组的选项列表进行渲染</p></blockquote><blockquote><p><code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，<code>items</code> 是源数据数组并且 <code>item</code> 是数组元素迭代的别名</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;li v-for=&quot;user in users&quot;&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; user.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data:&#123;</span><br><span class="line">                users: [</span><br><span class="line">                    &#123;name:&quot;张三&quot;,age:18&#125;,</span><br><span class="line">                    &#123;name:&quot;李四&quot;,age:20&#125;,</span><br><span class="line">                    &#123;name:&quot;王五&quot;,age:19&#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>v-for还可以支持将当前循环索引作为渲染时的第二个参数，第二个参数为访问索引位置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p  v-for=&quot;(user,index) in users&quot;&gt;</span><br><span class="line">    &#123;&#123; index &#125;&#125;:&#123;&#123; user.age &#125;&#125;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">    users: [</span><br><span class="line">        &#123;name:&quot;张三&quot;,age:18&#125;,</span><br><span class="line">        &#123;name:&quot;李四&quot;,age:20&#125;,</span><br><span class="line">        &#123;name:&quot;王五&quot;,age:19&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>使用<code>v-for</code>迭代访问一个对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-for=&quot;key in myself&quot;&gt; </span><br><span class="line">    &#123;&#123; key &#125;&#125;</span><br><span class="line">    &lt;!-- 当v-for渲染时只有一个参数，此时参数为value值 --&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myself : &#123;</span><br><span class="line">    name:&quot;赵六&quot;,</span><br><span class="line">    age:&quot;17&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>v-for</code>支持最多三个参数，同时获取遍历对象的<code>key</code>和<code>value</code>值，以及<code>index</code>索引位置</li></ul><blockquote><p>要注意的是，此时的<code>key</code>和<code>value</code>和<code>python</code>中的顺序是颠倒的，<code>key</code>在后，<code>value</code>在前</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-for=&quot;(value,key,index) in myself&quot;&gt;</span><br><span class="line">    &#123;&#123; index &#125;&#125;: &#123;&#123; key &#125;&#125; - &#123;&#123; value &#125;&#125;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myself : &#123;</span><br><span class="line">    name:&quot;孙七&quot;,</span><br><span class="line">    age:&quot;17&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>v-for</code>进行一段取值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p v-for=&quot;n in 8&quot;&gt;</span><br><span class="line">        &#123;&#123; n &#125;&#125;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;!-- 1 2 3 4 5 6 7 8 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="选项卡练习"><a href="#选项卡练习" class="headerlink" title="选项卡练习"></a>选项卡练习</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                choicId: null,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    li&#123;</span><br><span class="line">        list-style-type: none;</span><br><span class="line">        border: 3px outset lightgreen;</span><br><span class="line">        width: 100px;</span><br><span class="line">        background:lightblue;</span><br><span class="line">        margin:5px;</span><br><span class="line">    &#125;</span><br><span class="line">    li:hover&#123;</span><br><span class="line">        border: 3px inset gray;</span><br><span class="line">        cursor: pointer;</span><br><span class="line">    &#125;</span><br><span class="line">    [v-cloak]&#123;</span><br><span class="line">        display: none;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-cloak id=&quot;container&quot;&gt;   </span><br><span class="line">    &lt;ol list&gt;</span><br><span class="line">        &lt;li @click=&quot;choicId = 1&quot;&gt;A&lt;/li&gt;</span><br><span class="line">        &lt;li @click=&quot;choicId = 2&quot;&gt;B&lt;/li&gt;</span><br><span class="line">        &lt;li @click=&quot;choicId = 3&quot;&gt;C&lt;/li&gt;</span><br><span class="line">        &lt;li @click=&quot;choicId = 4&quot;&gt;D&lt;/li&gt;</span><br><span class="line">    &lt;/ol&gt;</span><br><span class="line">    &lt;p v-show=&quot;choicId == 1&quot;&gt;aaaaaaaaaa&lt;/p&gt;</span><br><span class="line">    &lt;p v-show=&quot;choicId == 2&quot;&gt;bbbbbbbbbb&lt;/p&gt;</span><br><span class="line">    &lt;p v-show=&quot;choicId == 3&quot;&gt;cccccccccc&lt;/p&gt;</span><br><span class="line">    &lt;p v-show=&quot;choicId == 4&quot;&gt;dddddddddd&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li><code>js</code>中两个等号和三个等号的区别：</li></ul><blockquote><p><code>==</code>表示： 如果两边值的类型不同的时候，是要先先进行类型转换后，才能做比较；<code>equality</code>等同</p></blockquote><blockquote><p><code>===</code>表示：不需要做类型转换，如果两边值的类型不同，就表示一定是不等的<code>identity</code>恒等</p></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p><code>Vue</code>无法检测到对于数组的索引设置及长度修改以及对于对象属性的删除或添加</p><p>但是可以通过以下方式进行属性添加触发状态更新</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.set($vm.Object,&quot;key&quot;,&quot;val&quot;) // 对于对象 这样的添加方式可以触发状态更新</span><br><span class="line">Vue.set($vm.Array, index, newVal) // 对于数组 添加元素 触发状态更新</span><br><span class="line">// vm.items.splice(newLength) // 设置数组长度</span><br></pre></td></tr></table></figure><ul><li><code>javascript.splice(where, num, [additem1,additem2...] )</code>：删除或添加元素</li></ul><blockquote><p>此外，当<code>v-for</code>与<code>v-if</code>同时使用时，<code>v-for</code>有更高的优先级，这会造成重复遍历得到的元素都要在做一次<code>v-if</code>的判断，如果我们是为了有目的判断当前是否需要渲染这个元素，或是跳过这个循环，可以将<code>v-if</code>放在外层元素，比如<code>template</code>标签中，(<code>template</code>标签无实际意义，默认不展示，但是可以起到包裹作用)</p></blockquote><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><blockquote><p><code>Vue.js</code>允许你自定义过滤器，可被用于一些常见的文本，对它们进行格式化</p></blockquote><blockquote><p>过滤器可以用在两个地方：<strong>双花括号插值和 v-bind 表达式</strong> (后者从 2.1.0+ 开始支持)</p><p>过滤器应该被添加在<code>JavaScript</code>表达式的尾部，由<code>管道</code>符号指示</p></blockquote><ul><li>语法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">    &#123;&#123; message | filter &#125;&#125;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p v-bind:type=&quot;message | filter&quot;&gt; &lt;/p&gt;</span><br></pre></td></tr></table></figure><ul><li>过滤器本质上是一个函数，比如我们定义一个将表单输入的内容中所有的字母变大写的过滤器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div v-cloak id=&quot;container&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br><span class="line">        &lt;p&gt;展示: &#123;&#123; message | toUpper &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                message: &quot;&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">            filters: &#123;</span><br><span class="line">                toUpper: function (value) &#123;</span><br><span class="line">                    if (!value) return &apos;&apos; // 字符串内容为空 直接返回</span><br><span class="line">                    console.log(&quot;正在变大小&quot;)</span><br><span class="line">                    return String(value).toUpperCase()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>过滤器函数也可以有多个参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filter(arg1, arg2) &#125;&#125;</span><br><span class="line">// message 第一个参数</span><br><span class="line">// arg1 第二个参数</span><br><span class="line">// arg2 第三个参数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-cloak id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;</span><br><span class="line">    &lt;p&gt;展示: &#123;&#123; message | toLong(&quot;| &quot;,&quot; |&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">    toLong(value,arg1,arg2)&#123;</span><br><span class="line">        if (!value) return &apos;&apos;</span><br><span class="line">        return arg1 + value + arg2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue实例生命周期"><a href="#Vue实例生命周期" class="headerlink" title="Vue实例生命周期"></a>Vue实例生命周期</h3><blockquote><p>每个<code>Vue</code>实例在被创建时都要经过一系列的初始化过程</p><p>例如：需要设置数据监听、编译模板、将实例挂载到<code>DOM</code>并在数据变化时更新<code>DOM</code>等</p><p>同时在这个过程中会自动运行一些叫做生命周期钩子的函数，我们可以使用这些函数，在实例的不同阶段加上我们需要的代码，实现特定的功能</p></blockquote><ul><li><code>beforeCreate</code>：数据还没有监听，没有绑定到<code>vue</code>对象实例，同时也没有挂载对象</li><li><code>created</code>：数据已经绑定到了对象实例，但是还没有挂载对象</li><li><code>beforeMount</code>：模板已经编译好了，根据数据和模板已经生成了对应的元素对象，将数据对象关联到了对象的<code>$el</code>属性</li></ul><blockquote><p><code>$el</code>属性是一个<code>HTMLElement</code>对象，也就是这个阶段，<code>vue</code>实例通过原生的<code>createElement</code>等方法来创建这个<code>html</code>片段，准备注入到我们<code>vue</code>实例指明的<code>el</code>属性所对应的挂载点</p></blockquote><ul><li><code>mounted</code>： 将<code>$el</code>的内容挂载到了<code>el</code>，相当于我们在<code>jQuery</code>执行了<code>$(el).html($el)</code>，生成页面上真正的<code>dom</code></li></ul><blockquote><p>上面我们就会发现页面的元素和我们<code>$el</code>的元素是一致的；在此之后，我们能够用方法来获取到<code>el</code>元素下的<code>dom</code>对象，并进行各种操作</p></blockquote><ul><li><code>beforeUpdate</code>：数据发生变化时调用</li><li><code>updated</code>：由于数据更改导致的虚拟<code>DOM</code>重新渲染和打补丁，在这之后会调用该钩子</li><li><code>beforeDestroy</code>：<code>Vue</code>实例销毁前</li><li><code>destroyed</code>：<code>Vue</code>实例销毁后</li></ul><blockquote><p><code>window.$vm.$destroy()</code></p></blockquote><ul><li>一大段代码进行钩子函数的调用过程监控</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">    function showData(process, vm) &#123;</span><br><span class="line">        console.log(process)</span><br><span class="line">        console.log(&quot;vue数据:&quot;, vm.message) // 当前Vue中的数据</span><br><span class="line">        console.log(&quot;Vue挂载el:&quot;) // Vue接管的元素</span><br><span class="line">        console.log(vm.$el) </span><br><span class="line">        console.log(&quot;真实Dom:&quot;)</span><br><span class="line">        console.log(document.getElementById(&quot;container&quot;).innerHTML)</span><br><span class="line">        console.log(&apos;-----------------&apos;)</span><br><span class="line">    &#125; // 这个函数用来输出相关信息的</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &quot;#container&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            message: &quot;aaaaa&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeCreate: function () &#123;</span><br><span class="line">            showData(&quot;创建Vue实例前&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        created: function () &#123;</span><br><span class="line">            showData(&quot;创建Vue实例后&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeMount: function () &#123;</span><br><span class="line">            showData(&quot;挂载到Dom前&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted: function () &#123;</span><br><span class="line">            showData(&quot;挂载到Dom后&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeUpdate: function () &#123;</span><br><span class="line">            showData(&quot;数据发生变化时&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        updated: function () &#123;</span><br><span class="line">            showData(&quot;数据发生变化后&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        beforeDestroy: function () &#123;</span><br><span class="line">            showData(&quot;Vue实例销毁前&quot;, this)</span><br><span class="line">        &#125;,</span><br><span class="line">        destroyed: function () &#123;</span><br><span class="line">            showData(&quot;Vue实例销毁后&quot;, this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;p v-html=&quot;message&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a>ES6语法</h4><blockquote><p><code>ES6</code>是<code>JavaScript</code>语言的新版本，它也可以叫做<code>ES2015</code>，之前学习的<code>JavaScript</code>属于<code>ES5</code>，<code>ES6</code>在它的基础上增加了一些语法</p><p><code>ES6</code>是未来<code>JavaScript</code>的趋势，而且<code>vue</code>组件开发中会使用很多的<code>ES6</code>的语法，所以掌握这些常用的<code>ES6</code>语法是必须的</p></blockquote><h5 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h5><ul><li><code>let</code>：定义封闭作用域的变量，并且变量只能声明一次</li><li><code>const</code>：定义封闭作用域的常量，并且变量只能声明一次</li></ul><blockquote><p><code>let</code>和<code>const</code>是新增的声明变量的开头的关键字，在这之前，变量声明是用<code>var</code>关键字</p><p>这两个关键字和<code>var</code>的区别是，它们声明的变量没有<strong>预解析</strong>，无法脱离定义空间使用</p><p><code>let</code>和<code>const</code>的区别是，<code>let</code>声明的是一般变量，<code>const</code>申明的常量，不可修改</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(a) // undefined</span><br><span class="line">console.log(b) // b is not defined</span><br><span class="line">console.log(c) // c is not defined</span><br><span class="line">var a =  1</span><br><span class="line">var a = 2</span><br><span class="line">let b = 2</span><br><span class="line">// let b = 3 // Identifier &apos;b&apos; has already been declared</span><br><span class="line">const c = 3</span><br><span class="line">// const c = 4 // Identifier &apos;c&apos; has already been declared</span><br><span class="line">c = 4 //  Assignment to constant variable</span><br></pre></td></tr></table></figure><h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><blockquote><p>可以把箭头函数理解成匿名函数的第二种写法，箭头函数的作用是可以在对象中绑定<code>this</code></p><p>解决了<code>JavaScript</code>中<code>this</code>指定混乱的问题</p></blockquote><ul><li>定义函数的一般方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function func()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>匿名赋值创建函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var func = function()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>箭头函数的写法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var func = (a, b) =&gt; &#123;</span><br><span class="line">    // 这样的函数在嵌套时，会自动绑定外部作用域下的this</span><br><span class="line">&#125;</span><br><span class="line">var func = a =&gt; &#123;</span><br><span class="line">    // 一个参数时，可以省略参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function () &#123;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">        el: &quot;#container&quot;,</span><br><span class="line">        data: &#123; message: &quot;abcdef&quot;, &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            show() &#123;</span><br><span class="line">                console.log(&quot;这是show函数:&quot;, this.message),</span><br><span class="line">                    func = () =&gt; &#123;</span><br><span class="line">                    console.log(&quot;我是内部函数:&quot;, this.message)</span><br><span class="line">                &#125;,</span><br><span class="line">                    func(), // 调用一下这个内部函数</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;show&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h4><blockquote><p>组件<code>Component</code>是<code>Vue.js</code>最强大的功能之一</p></blockquote><blockquote><p>组件可以扩展<code>HTML</code>元素，<strong>封装可重用的代码</strong></p><p>所有的<code>Vue</code>组件同时也都是<code>Vue</code>的实例，所以可接受相同的选项对象（除了一些根级特有的选项）并提供相同的生命周期钩子</p></blockquote><h5 id="注册全局组件"><a href="#注册全局组件" class="headerlink" title="注册全局组件"></a>注册全局组件</h5><ul><li>注册一个全局组件语法格式如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(tagName, options)</span><br><span class="line">// tagName：组件名</span><br><span class="line">// options：配置选项</span><br></pre></td></tr></table></figure><ul><li>比如这样一个全局组件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;button_show&apos;, &#123;</span><br><span class="line">    data: function () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            count: 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, // 当前组件会需要的数据，定义为函数的返回值</span><br><span class="line">    template: &apos;&lt;button @click=&quot;count++&quot;&gt;按钮:&#123;&#123; count &#125;&#125;&lt;/button&gt;&apos;</span><br><span class="line">    // 组件的标签模板</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>接下来可以在任何<code>Vue</code>接管的元素中使用该组件，</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;button_show&gt;&lt;/button_show&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function () &#123;</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">    el: &quot;#container&quot;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="data必须是函数"><a href="#data必须是函数" class="headerlink" title="data必须是函数"></a>data必须是函数</h5><blockquote><p>组件就是<code>vue</code>的实例，所有<code>vue</code>实例中属性和方法，组件中也可以用</p><p>其中<code>data</code>属性必须是一个函数，因为组件会重复使用在多个地方，为了使用在多个地方的组件数据相对独立，<code>data</code>属性需要用一个函数的返回值来将数据处理为不同的每个个体</p></blockquote><h5 id="Prop传递数据"><a href="#Prop传递数据" class="headerlink" title="Prop传递数据"></a>Prop传递数据</h5><blockquote><p><code>Prop</code>是你可以在组件上注册的一些自定义特性</p><p>当一个值传递给一个<code>prop</code>特性的时候，它就变成了那个组件实例的一个属性</p><p>为了给组件传递数据，我们可以用一个 <code>props</code> 选项将一些特性值列举在其中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    Vue.component(&quot;myp&quot;,&#123;</span><br><span class="line">        props: [&quot;content&quot;,&quot;like&quot;], // 需要两个外界传入的值</span><br><span class="line">        template: &quot;&lt;p :class=&apos;like&apos;&gt;&#123;&#123; content &#125;&#125;&lt;/p&gt;&quot;</span><br><span class="line">        // 组件绑定未来要接受的变量，要用到v:bind</span><br><span class="line">    &#125;)</span><br><span class="line">    window.onload = function()&#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &quot;#container&quot;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                content: &apos;这是p段落的文本&apos;,</span><br><span class="line">                like: &apos;beauty&apos;, // 要传递的变量</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">.beauty&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    color: red;</span><br><span class="line">    background: green;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">    &lt;myp :like=&quot;like&quot; :content=&quot;content&quot;&gt;&lt;/myp&gt;</span><br><span class="line">    &lt;!-- 传递到组件中 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;VUE&quot;&gt;&lt;a href=&quot;#VUE&quot; class=&quot;headerlink&quot; title=&quot;VUE&quot;&gt;&lt;/a&gt;VUE&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Vue.js&lt;/code&gt;是前端三大新框架：&lt;code&gt;Angular.js&lt;/code&gt;、&lt;code&gt;React.js&lt;/code&gt;、&lt;code&gt;Vue.js&lt;/code&gt;之一，&lt;code&gt;Vue.js&lt;/code&gt;目前的使用和关注程度在三大框架中稍微胜出，并且它的热度还在递增&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Vue&lt;/code&gt;的核心库只关注视图层，&lt;code&gt;Vue&lt;/code&gt;的目标是通过尽可能简单的&lt;code&gt;API&lt;/code&gt;实现响应的数据绑定，在这一点上&lt;code&gt;Vue.js&lt;/code&gt;类似于后台的模板语言&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Vue&lt;/code&gt;也可以将界面拆分成一个个的组件，通过组件来构建界面，然后用自动化工具来生成单页面(&lt;code&gt;SPA - single page application&lt;/code&gt;)系统&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://cy-blogs.cn/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://cy-blogs.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue-路由组件</title>
    <link href="https://cy-blogs.cn/Vue-%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6/"/>
    <id>https://cy-blogs.cn/Vue-路由组件/</id>
    <published>2019-12-09T11:52:36.344Z</published>
    <updated>2019-12-09T11:54:44.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue-Router"></a>Vue-Router</h2><blockquote><p><code>Vue-router</code>做路径匹配时支持动态片段、全匹配片段以及查询参数（片段指的是<code>URL</code>中的一部分）</p><p>对于解析过的路由，这些信息都可以通过路由上下文对象（从现在起，我们会称其为路由对象）访问。</p><p>在使用了<code>vue-router</code>的应用中，路由对象会被注入每个组件中，赋值为<code>this.$route</code>，并且当路由切换时，路由对象会被更新</p></blockquote><a id="more"></a><h3 id="Vue的两种模式"><a href="#Vue的两种模式" class="headerlink" title="Vue的两种模式"></a>Vue的两种模式</h3><blockquote><p>一般单页面应用是(<code>SPA</code>)不会请求页面而是只更新视图</p><p><code>vue-router</code>提供了两种方式来实现前端路由：<code>Hash</code>模式和<code>History</code>模式,可以用<code>mode</code>参数来决定使用哪一种方式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &apos;history&apos;,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>hash</code>模式：<code>vue-router</code>默认使用<code>Hash</code>模式，使用 <code>url</code>的<code>hash</code>来模拟一个完整的<code>url</code>；此时<code>url</code>变化时，浏览器是不会重新加载的；<code>Hash(即#)</code>是<code>url</code>的锚点，代表的是网页中的一个位置，仅仅改变<code>#</code>后面部分，浏览器只会滚动对应的位置，而不会重新加载页面。<code>#</code>仅仅只是对浏览器进行指导，而对服务端是完全没有作用的！它不会被包括在<code>http</code>请求中，故也不会重新加载页面。同时<code>hash</code>发生变化时，<code>url</code>都会被浏览器记录下来，这样你就可以使用浏览器的后退了</li><li><code>History</code>模式：如果你不喜欢<code>hash</code>这种<code>#</code>样式，可以使用<code>history</code>模式。这种模式利用了<code>HTML5 History</code>新增的<code>pushState()</code>和<code>replaceState()</code>方法。除了之前的<code>back</code>，<code>forward</code>，<code>go</code>方法；这两个新方法可以应用在<strong>浏览器历史记录</strong>的增加替换功能上。使用<code>History</code>模式，通过历史记录修改<code>url</code>。但它不会立即向后端发送请求。</li></ul><blockquote><p>注意：虽然<code>History</code>模式可以丢掉不美观的<code>#</code>，也可以正常的前进后退，但是刷新<code>f5</code>后，此时浏览器就会访问服务器，在没有后台支持的情况下，此时就会得到一个<code>404</code>！</p><p>官方文档给出的描述是：<code>不过这种模式要玩好；还需要后台配置支持</code></p><p>因为我们的应用是单个客户端应用，如果后台没有正确的配置，当用户直接访问时,就会返回<code>404</code>，所以，要在服务端增加一个覆盖所有情况的的候选资源。如果<code>url</code>匹配不到任何静态资源；则应该返回同一个<code>index.html</code>页面</p></blockquote><h3 id="路由属性"><a href="#路由属性" class="headerlink" title="路由属性"></a>路由属性</h3><ul><li><p>路由对象<code>this.$route</code>支持属性</p><ul><li><code>$route.path</code>：字符串，等于当前路由对象的路径，会被解析为绝对路径</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/aaa/</span>bbb</span><br></pre></td></tr></table></figure><ul><li><code>$route.params</code>：包含路由中的动态片段和全匹配片段的键值对</li><li><code>$route.query</code>：获取连接中查询参数的键值对</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/foo?user=1</span><br><span class="line">// 可以获取到</span><br><span class="line">$route.query.user == 1</span><br></pre></td></tr></table></figure><ul><li><code>$route.router</code>：路由规则所属的路由器以及其所属的组件</li><li><code>$route.matched</code>：数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象</li><li><code>$route.name</code>：当前路径的名字</li></ul></li><li><p>路由中设置自定义参数</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.map(&#123;</span><br><span class="line">  &apos;/a&apos;: &#123;</span><br><span class="line">    component: &#123; ... &#125;,</span><br><span class="line">    auth: true // 这里 auth 是一个自定义字段</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>当 <code>/a</code> 被匹配时，<code>$route.auth</code> 的值将会是 <code>true</code>。我们可以利用这个特性在全局的钩子函数中进行身份验证</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(function (transition) &#123;</span><br><span class="line">  if (transition.to.auth) &#123;</span><br><span class="line">    // 对用户身份进行验证...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="动态路由（-号通配符）"><a href="#动态路由（-号通配符）" class="headerlink" title="动态路由（:号通配符）"></a>动态路由（:号通配符）</h3><blockquote><p>路由中的动态片段使用以冒号开头的路径片段定义</p><p>类比<code>django</code>中的路由传参</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path(&apos;&lt;int:name&gt;/&apos;,views.xx),</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path: &apos;/user/:username&apos;,</span><br><span class="line">component: &#123;</span><br><span class="line">    template: &apos;&lt;p&gt;用户名是&#123;&#123;$route.params.username&#125;&#125;&lt;/p&gt;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一条路径中可以包含多个动态片段，每个片段都会被解析成 <code>$route.params</code> 的一个键值对</p></blockquote><ul><li>解析模式</li></ul><table><thead><tr><th>模式</th><th>匹配的路径</th><th>$route.params</th></tr></thead><tbody><tr><td><code>/user/:username</code></td><td><code>/user/evan</code></td><td><code>{ username: &#39;evan&#39; }</code></td></tr><tr><td><code>/user/:username/post/:post_id</code></td><td><code>/user/evan/post/123</code></td><td><code>{ username: &#39;evan&#39;, post_id: 123 }</code></td></tr></tbody></table><h3 id="全匹配路由（-号通配符）"><a href="#全匹配路由（-号通配符）" class="headerlink" title="全匹配路由（*号通配符）"></a>全匹配路由（*号通配符）</h3><blockquote><p>动态片段只能匹配路径中的一个部分，而全匹配片段则基本类似于它的贪心版</p><p>例如 <code>/foo/*bar</code> 会匹配任何以 <code>/foo/</code> 开头的路径</p><p>当使用一个通配符时，<code>$route.params</code>内会自动添加一个名为<code>pathMatch</code>的参数，其中包含了在连接中通过通配符所匹配到的部分</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;/user/*/cc&apos;,</span><br><span class="line">    name: &apos;User&apos;,</span><br><span class="line">    component: User,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>访问的<code>URL</code>如下</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8080</span><span class="regexp">/user/</span><span class="number">1231</span><span class="regexp">/aaa/</span>cc</span><br></pre></td></tr></table></figure><ul><li>那么此时<code>*</code>通配符拿到的部分为</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"pathMatch"</span>: <span class="string">"1231/aaa"</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="具名路径（命名路由）"><a href="#具名路径（命名路由）" class="headerlink" title="具名路径（命名路由）"></a>具名路径（命名路由）</h3><ul><li>类似<code>django</code>的路由命名，<code>vue</code>路由映射中也可以为某一个路由通过<code>name</code>属性设置命名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &apos;/user/:userid&apos;,</span><br><span class="line">    name: &apos;User&apos;,</span><br><span class="line">    component: User,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li>在使用<code>v-link</code>标签进行路由跳转时，就可以更加方便啦</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;name: &apos;User&apos;, params: &#123;userid: &apos;zhangsan&apos; &#125;&#125;&quot;&gt;user&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><ul><li>也可以在<code>js</code>代码中使用<code>router.go</code>切换到该路径下</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">router</span><span class="selector-class">.go</span>(&#123; <span class="attribute">name</span>: <span class="string">'user'</span>, params: &#123; userId: <span class="number">123</span> &#125;&#125;)</span><br></pre></td></tr></table></figure><h2 id="V-link"><a href="#V-link" class="headerlink" title="V-link"></a>V-link</h2><ul><li><code>v-link</code> 是一个用来让用户在<code>vue-router</code>应用的不同路径间跳转的指令。该指令接受一个<code>JavaScript</code>表达式，并会在用户点击元素时用该表达式的值去调用 <code>router.go</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 字面量路径 --&gt;</span><br><span class="line">&lt;a v-link=&quot;&apos;home&apos;&quot;&gt;Home&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 效果同上 --&gt;</span><br><span class="line">&lt;a v-link=&quot;&#123; path: &apos;home&apos; &#125;&quot;&gt;Home&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 具名路径 --&gt;</span><br><span class="line">&lt;a v-link=&quot;&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/a&gt;</span><br></pre></td></tr></table></figure><ul><li>应该使用 <code>v-link</code> 而不是 <code>href</code> 来处理浏览时的跳转。原因如下<ul><li>它在<code>HTML5 history</code>模式和<code>hash</code>模式下的工作方式相同，所以如果你决定改变模式，或者<code>IE9</code>浏览器退化为<code>hash</code>模式时，都不需要做任何改变</li></ul></li><li>在<code>HTML5 history</code>模式下，<code>v-link</code> 会监听点击事件，防止浏览器尝试重新加载页面</li><li>在<code>HTML5 history</code>模式下使用 <code>root</code> 选项时，不需要在 <code>v-link</code> 的<code>URL</code>中包含<code>root</code>路径</li></ul><h3 id="V-Link其他选项"><a href="#V-Link其他选项" class="headerlink" title="V-Link其他选项"></a>V-Link其他选项</h3><ul><li>replace</li></ul><blockquote><p>一个带有 <code>replace: true</code> 的链接被点击时将会触发 <code>router.replace()</code> 而不是 <code>router.go()</code>。由此产生的跳转不会留下历史记录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;name: &apos;User&apos;, params: &#123;userid: &apos;zhangsan&apos; &#125;, replace: true &#125;&quot;&gt;replace&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><ul><li>append</li></ul><blockquote><p>带有 <code>append: true</code> 选项的相对路径链接会确保该相对路径始终添加到当前路径之后。举例来说，从 <code>/a</code> 跳转到相对路径 <code>b</code> 时，如果没有 <code>append: true</code> 我们会跳转到 <code>/b</code>，但有 <code>append: true</code> 则会跳转到 <code>/a/b</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123;name: &apos;User&apos;, append: true &#125;&quot;&gt;append&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h2 id="路由钩子"><a href="#路由钩子" class="headerlink" title="路由钩子"></a>路由钩子</h2><blockquote><p>全局的钩子</p></blockquote><ul><li><code>beforeEach(to, from, next)</code></li></ul><blockquote><p>添加一个全局的前置钩子函数，这个函数会在路由切换开始时调用。调用发生在整个切换流水线之前。如果此钩子函数拒绝了切换，整个切换流水线根本就不会启动</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const router = new Router(&#123;</span><br><span class="line">   ...</span><br><span class="line">export default router</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // to and from are both route objects. must call `next`.</span><br><span class="line">  console.log(to) // to: Route: 即将要进入的目标 路由对象</span><br><span class="line">  console.log(&apos;-------------&apos;)</span><br><span class="line">  console.log(from) // from: Route: 当前导航正要离开的路由</span><br><span class="line">  console.log(&apos;-------------&apos;)</span><br><span class="line">  console.log(next) // 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>路由解析流程</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>导航被触发。</span><br><span class="line"><span class="number">2.</span>在失活的组件里调用离开守卫。</span><br><span class="line"><span class="number">3.</span>调用全局的 beforeEach 守卫。</span><br><span class="line"><span class="number">4.</span>在重用的组件里调用 beforeRouteUpdate 守卫 (<span class="number">2.2</span>+)。</span><br><span class="line"><span class="number">5.</span>在路由配置里调用 beforeEnter。</span><br><span class="line"><span class="number">6.</span>解析异步路由组件。</span><br><span class="line"><span class="number">7.</span>在被激活的组件里调用 beforeRouteEnter。</span><br><span class="line"><span class="number">8.</span>调用全局的 beforeResolve 守卫 (<span class="number">2.5</span>+)。</span><br><span class="line"><span class="number">9.</span>导航被确认。</span><br><span class="line"><span class="number">10.</span>调用全局的 afterEach 钩子。</span><br><span class="line"><span class="number">11.</span>触发 DOM 更新。</span><br><span class="line"><span class="number">12.</span>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</span><br></pre></td></tr></table></figure><ul><li>使用<code>beforeEach</code>控制路由跳转，拦截路由</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  // to and from are both route objects. must call `next`.</span><br><span class="line">  let toQuery = JSON.parse(JSON.stringify(to.query));</span><br><span class="line">  console.log(toQuery) // 获取连接参数</span><br><span class="line">  if(to.meta.requiredAuth == true)&#123; // 如果要进入的路由需要用户登陆</span><br><span class="line">    if(window.localStorage.getItem(&apos;username&apos;))&#123; // 获取存储的用户名</span><br><span class="line">      next()</span><br><span class="line">    &#125; else&#123; // 没有获取到，则跳转到登陆页面</span><br><span class="line">      next(&#123;</span><br><span class="line">        path: &apos;/&apos;,</span><br><span class="line">        query: toQuery,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vue-Router&quot;&gt;&lt;a href=&quot;#Vue-Router&quot; class=&quot;headerlink&quot; title=&quot;Vue-Router&quot;&gt;&lt;/a&gt;Vue-Router&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Vue-router&lt;/code&gt;做路径匹配时支持动态片段、全匹配片段以及查询参数（片段指的是&lt;code&gt;URL&lt;/code&gt;中的一部分）&lt;/p&gt;
&lt;p&gt;对于解析过的路由，这些信息都可以通过路由上下文对象（从现在起，我们会称其为路由对象）访问。&lt;/p&gt;
&lt;p&gt;在使用了&lt;code&gt;vue-router&lt;/code&gt;的应用中，路由对象会被注入每个组件中，赋值为&lt;code&gt;this.$route&lt;/code&gt;，并且当路由切换时，路由对象会被更新&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Vue" scheme="https://cy-blogs.cn/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://cy-blogs.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Django-DBrouter</title>
    <link href="https://cy-blogs.cn/Django%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    <id>https://cy-blogs.cn/Django数据库路由器/</id>
    <published>2019-12-09T11:29:54.640Z</published>
    <updated>2019-12-09T11:29:55.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DB-router"><a href="#DB-router" class="headerlink" title="DB-router"></a>DB-router</h2><blockquote><p>通过编写<strong>db-router</strong>可以灵性连接<strong>mysql</strong>主从复制等情况下的多数据库</p></blockquote><ul><li>假设你已经配置好了类似<strong>MYSQL</strong>主从复制的服务，如果没有可以参照<a href="https://lienze.tech/blog/mysql/c813917a.html" target="_blank" rel="noopener">这里</a></li></ul><h3 id="配置Django数据库连接"><a href="#配置Django数据库连接" class="headerlink" title="配置Django数据库连接"></a>配置Django数据库连接</h3><ul><li>settings.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;  </span><br><span class="line">    <span class="string">'default'</span>: &#123;     </span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,  </span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'192.168.1.101'</span>,   </span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,   </span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,    </span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,  </span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'test1'</span> </span><br><span class="line">    &#125;,    </span><br><span class="line">    <span class="string">'slave'</span>: &#123;     </span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,   </span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'192.168.1.102'</span>,  </span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,       </span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>, </span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,   </span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'test1'</span>  </span><br><span class="line">    &#125;&#125;</span><br><span class="line">DATABASE_ROUTERS = [<span class="string">'pro.utils.MasterSlaveDBRouter'</span>]</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>编写<strong>db-router</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MasterSlaveDBRouter</span>:</span>  </span><br><span class="line">    <span class="string">"""数据库主从读写分离路由"""</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_read</span><span class="params">(self, model, **hints)</span>:</span>   </span><br><span class="line">        <span class="string">"""读数据库"""</span>   </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"slave"</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_write</span><span class="params">(self, model, **hints)</span>:</span>  </span><br><span class="line">        <span class="string">"""写数据库"""</span>       </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"default"</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allow_relation</span><span class="params">(self, obj1, obj2, **hints)</span>:</span> </span><br><span class="line">        <span class="string">"""是否运行关联操作"""</span>     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>如出现以下错误，修改主库binlog日志格式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django.db.utils.InternalError: (1665, 'Cannot <span class="keyword">execute</span> <span class="keyword">statement</span>: impossible <span class="keyword">to</span> write <span class="keyword">to</span> <span class="built_in">binary</span> <span class="keyword">log</span> since BINLOG_FORMAT = <span class="keyword">STATEMENT</span> <span class="keyword">and</span> <span class="keyword">at</span> <span class="keyword">least</span> one <span class="keyword">table</span> uses a <span class="keyword">storage</span> <span class="keyword">engine</span> limited <span class="keyword">to</span> <span class="keyword">row</span>-based logging. <span class="keyword">InnoDB</span> <span class="keyword">is</span> limited <span class="keyword">to</span> <span class="keyword">row</span>-<span class="keyword">logging</span> <span class="keyword">when</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">is</span> <span class="keyword">READ</span> COMMITTED <span class="keyword">or</span> <span class="keyword">READ</span> UNCOMMITTED.<span class="string">')</span></span><br></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">binlog_format</span>=mixed</span><br></pre></td></tr></table></figure><h3 id="打开日志用以分析"><a href="#打开日志用以分析" class="headerlink" title="打开日志用以分析"></a>打开日志用以分析</h3><ul><li>可以通过配置<strong>mysql</strong>日志记录，用以查看主从在读写情况下的效果</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">general_log</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">general_log_file</span>=/var/lib/mysql/general.log</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DB-router&quot;&gt;&lt;a href=&quot;#DB-router&quot; class=&quot;headerlink&quot; title=&quot;DB-router&quot;&gt;&lt;/a&gt;DB-router&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;通过编写&lt;strong&gt;db-router&lt;/strong&gt;可以灵性连接&lt;strong&gt;mysql&lt;/strong&gt;主从复制等情况下的多数据库&lt;/p&gt;
&lt;/blockquote&gt;&lt;ul&gt;
&lt;li&gt;假设你已经配置好了类似&lt;strong&gt;MYSQL&lt;/strong&gt;主从复制的服务，如果没有可以参照&lt;a href=&quot;https://lienze.tech/blog/mysql/c813917a.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;配置Django数据库连接&quot;&gt;&lt;a href=&quot;#配置Django数据库连接&quot; class=&quot;headerlink&quot; title=&quot;配置Django数据库连接&quot;&gt;&lt;/a&gt;配置Django数据库连接&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;settings.py&lt;/li&gt;
&lt;/ul&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DATABASES = &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;default&#39;&lt;/span&gt;: &amp;#123;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ENGINE&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;django.db.backends.mysql&#39;&lt;/span&gt;,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;HOST&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;192.168.1.101&#39;&lt;/span&gt;,   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;PORT&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3306&lt;/span&gt;,   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;USER&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;root&#39;&lt;/span&gt;,    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;PASSWORD&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;123456&#39;&lt;/span&gt;,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;NAME&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;test1&#39;&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;slave&#39;&lt;/span&gt;: &amp;#123;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ENGINE&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;django.db.backends.mysql&#39;&lt;/span&gt;,   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;HOST&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;192.168.1.102&#39;&lt;/span&gt;,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;PORT&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3306&lt;/span&gt;,       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;USER&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;root&#39;&lt;/span&gt;, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;PASSWORD&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;123456&#39;&lt;/span&gt;,   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;NAME&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;test1&#39;&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DATABASE_ROUTERS = [&lt;span class=&quot;string&quot;&gt;&#39;pro.utils.MasterSlaveDBRouter&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
  </entry>
  
  <entry>
    <title>Django-DBrouter</title>
    <link href="https://cy-blogs.cn/Django-DBrouter/"/>
    <id>https://cy-blogs.cn/Django-DBrouter/</id>
    <published>2019-12-09T09:11:32.684Z</published>
    <updated>2019-12-09T11:26:02.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DB-router"><a href="#DB-router" class="headerlink" title="DB-router"></a>DB-router</h2><blockquote><p>通过编写<strong>db-router</strong>可以灵性连接<strong>mysql</strong>主从复制等情况下的多数据库</p></blockquote><ul><li>假设你已经配置好了类似<strong>MYSQL</strong>主从复制的服务，如果没有可以参照<a href="https://lienze.tech/blog/mysql/c813917a.html" target="_blank" rel="noopener">这里</a></li></ul><h3 id="配置Django数据库连接"><a href="#配置Django数据库连接" class="headerlink" title="配置Django数据库连接"></a>配置Django数据库连接</h3><ul><li>settings.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;  </span><br><span class="line">    <span class="string">'default'</span>: &#123;     </span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,  </span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'192.168.1.101'</span>,   </span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,   </span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,    </span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,  </span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'test1'</span> </span><br><span class="line">    &#125;,    </span><br><span class="line">    <span class="string">'slave'</span>: &#123;     </span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,   </span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'192.168.1.102'</span>,  </span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,       </span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>, </span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,   </span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'test1'</span>  </span><br><span class="line">    &#125;&#125;</span><br><span class="line">DATABASE_ROUTERS = [<span class="string">'pro.utils.MasterSlaveDBRouter'</span>]</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>编写<strong>db-router</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MasterSlaveDBRouter</span>:</span>  </span><br><span class="line">    <span class="string">"""数据库主从读写分离路由"""</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_read</span><span class="params">(self, model, **hints)</span>:</span>   </span><br><span class="line">        <span class="string">"""读数据库"""</span>   </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"slave"</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">db_for_write</span><span class="params">(self, model, **hints)</span>:</span>  </span><br><span class="line">        <span class="string">"""写数据库"""</span>       </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"default"</span>   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allow_relation</span><span class="params">(self, obj1, obj2, **hints)</span>:</span> </span><br><span class="line">        <span class="string">"""是否运行关联操作"""</span>     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li>如出现以下错误，修改主库binlog日志格式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django.db.utils.InternalError: (1665, 'Cannot <span class="keyword">execute</span> <span class="keyword">statement</span>: impossible <span class="keyword">to</span> write <span class="keyword">to</span> <span class="built_in">binary</span> <span class="keyword">log</span> since BINLOG_FORMAT = <span class="keyword">STATEMENT</span> <span class="keyword">and</span> <span class="keyword">at</span> <span class="keyword">least</span> one <span class="keyword">table</span> uses a <span class="keyword">storage</span> <span class="keyword">engine</span> limited <span class="keyword">to</span> <span class="keyword">row</span>-based logging. <span class="keyword">InnoDB</span> <span class="keyword">is</span> limited <span class="keyword">to</span> <span class="keyword">row</span>-<span class="keyword">logging</span> <span class="keyword">when</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">is</span> <span class="keyword">READ</span> COMMITTED <span class="keyword">or</span> <span class="keyword">READ</span> UNCOMMITTED.<span class="string">')</span></span><br></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">binlog_format</span>=mixed</span><br></pre></td></tr></table></figure><h3 id="打开日志用以分析"><a href="#打开日志用以分析" class="headerlink" title="打开日志用以分析"></a>打开日志用以分析</h3><ul><li>可以通过配置<strong>mysql</strong>日志记录，用以查看主从在读写情况下的效果</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">general_log</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">general_log_file</span>=/var/lib/mysql/general.log</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DB-router&quot;&gt;&lt;a href=&quot;#DB-router&quot; class=&quot;headerlink&quot; title=&quot;DB-router&quot;&gt;&lt;/a&gt;DB-router&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;通过编写&lt;strong&gt;db-router&lt;/strong&gt;可以灵性连接&lt;strong&gt;mysql&lt;/strong&gt;主从复制等情况下的多数据库&lt;/p&gt;
&lt;/blockquote&gt;&lt;ul&gt;
&lt;li&gt;假设你已经配置好了类似&lt;strong&gt;MYSQL&lt;/strong&gt;主从复制的服务，如果没有可以参照&lt;a href=&quot;https://lienze.tech/blog/mysql/c813917a.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;配置Django数据库连接&quot;&gt;&lt;a href=&quot;#配置Django数据库连接&quot; class=&quot;headerlink&quot; title=&quot;配置Django数据库连接&quot;&gt;&lt;/a&gt;配置Django数据库连接&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;settings.py&lt;/li&gt;
&lt;/ul&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DATABASES = &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;default&#39;&lt;/span&gt;: &amp;#123;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ENGINE&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;django.db.backends.mysql&#39;&lt;/span&gt;,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;HOST&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;192.168.1.101&#39;&lt;/span&gt;,   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;PORT&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3306&lt;/span&gt;,   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;USER&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;root&#39;&lt;/span&gt;,    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;PASSWORD&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;123456&#39;&lt;/span&gt;,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;NAME&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;test1&#39;&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;slave&#39;&lt;/span&gt;: &amp;#123;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;ENGINE&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;django.db.backends.mysql&#39;&lt;/span&gt;,   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;HOST&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;192.168.1.102&#39;&lt;/span&gt;,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;PORT&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3306&lt;/span&gt;,       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;USER&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;root&#39;&lt;/span&gt;, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;PASSWORD&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;123456&#39;&lt;/span&gt;,   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;NAME&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;test1&#39;&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DATABASE_ROUTERS = [&lt;span class=&quot;string&quot;&gt;&#39;pro.utils.MasterSlaveDBRouter&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>WebSSH</title>
    <link href="https://cy-blogs.cn/WebSSH/"/>
    <id>https://cy-blogs.cn/WebSSH/</id>
    <published>2019-12-09T09:03:24.475Z</published>
    <updated>2019-12-09T11:26:56.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WebSSH"><a href="#WebSSH" class="headerlink" title="WebSSH"></a>WebSSH</h2><blockquote><p><code>webssh</code>从而<code>SSH</code>无需<code>Xshell</code>之类的模拟终端工具进行<code>SSH</code>连接，将<code>SSH</code>这一比较低层的操作也从<code>C/S</code>架构扭转成为<code>B/S</code>架构</p><p>这样的架构常用在运维制作开发一些堡垒机等系统，或者目前比较新型的在线教育方式，通过<code>WebSSH</code>向学生提供一个可以直接使用浏览器进行相关<code>Linux</code>操作或代码编写的学习方式</p><p><code>WebSSh</code>主要是建立客户端与服务端的即时通信</p></blockquote><a id="more"></a><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><ul><li>此种<code>WebSSH</code>实现方式，将通过结合<code>WebSocket</code>以及逐步的<code>Paramiko</code>来进行实现，所需要的技术栈如下</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">＃前端</span></span><br><span class="line"><span class="attr">vue</span> <span class="string"></span></span><br><span class="line"><span class="attr">websocket</span> <span class="string"></span></span><br><span class="line"><span class="attr">xterm.js</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后端</span></span><br><span class="line">django</span><br><span class="line">dwebsocket</span><br><span class="line">paramiko</span><br><span class="line">threading</span><br></pre></td></tr></table></figure><h3 id="技术介绍"><a href="#技术介绍" class="headerlink" title="技术介绍"></a>技术介绍</h3><ul><li><code>xterm</code></li></ul><blockquote><p>前端通过<code>xterm</code>插件进行<code>shell</code>黑窗口环境的构建，这个插件会自动解析由后台<code>paramiko</code>返回的带有标记样式的命令结果，并渲染到浏览器中，非常酷炫</p></blockquote><ul><li><code>websocket</code></li></ul><blockquote><p>这里通过<code>websocket</code>进行浏览器与<code>django</code>的数据交通同轴，<code>Websocket</code><a href="https://eastside.gitee.io/blog/django/d57108c1.html" target="_blank" rel="noopener">是什么</a></p></blockquote><ul><li><code>paramiko</code></li></ul><blockquote><p><code>paramiko</code>此时的角色采取承担<code>django</code>与<code>Linux</code>环境的互动，将前端发来的命令发送给后台，将后端发来的命令结果返回到前端的<code>xterm</code>组件中</p></blockquote><h3 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h3><blockquote><p>前端<code>xterm</code>组件使用：简单</p></blockquote><ul><li>安装<code>xterm</code></li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm安装xterm <span class="comment">--save</span></span><br></pre></td></tr></table></figure><ul><li><code>vue</code>框架中约会<code>xterm</code>的样式文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">// The Vue build version to load with the `import` command</span><br><span class="line">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import App from &apos;./App&apos;</span><br><span class="line">import router from &apos;./router&apos;</span><br><span class="line">import &apos;xterm/dist/xterm.css&apos; // 看这里，添加xterm css文件样式</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">/* eslint-disable no-new */</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &apos;&lt;App/&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>初始化<code>xterm</code>组件并添加两个插件：<code>attach</code>可以将终端附加到<code>websocket</code>流中，<code>fit</code>可以调整终端的大小以及行和列适应父级元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// index.vue</span><br><span class="line"></span><br><span class="line">import &#123; Terminal &#125; from &apos;xterm&apos;</span><br><span class="line">import * as attach from &apos;xterm/lib/addons/attach/attach&apos;</span><br><span class="line">import * as fit from &apos;xterm/lib/addons/fit/fit&apos;</span><br><span class="line"></span><br><span class="line">Terminal.applyAddon(attach)</span><br><span class="line">Terminal.applyAddon(fit)</span><br></pre></td></tr></table></figure><ul><li>构建<code>websocket</code>并绑定到终端，<code>websocket</code>地址为<code>ws</code>协议链接，此时使用的是即将在<code>django</code>中配置<code>Websocket</code>后台视图的路由，这一系列行为将挂载到钩子函数下进行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">    let terminalContainer = document.getElementById(<span class="string">'terminal'</span>)</span><br><span class="line">    this.term = new Terminal(this.terminal)</span><br><span class="line">    this.term.open(terminalContainer)</span><br><span class="line"></span><br><span class="line">    // open websocket</span><br><span class="line">    this.terminalSocket = new WebSocket(<span class="string">'ws://127.0.0.1:8000/webssh/'</span>)</span><br><span class="line">    this.terminalSocket.onopen = function()&#123;</span><br><span class="line">        console.log(<span class="string">'websocket is Connected...'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    this.terminalSocket.onclose = function()&#123;</span><br><span class="line">        console.log(<span class="string">'websocket is Closed...'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    this.terminalSocket.onerror = function()&#123;</span><br><span class="line">        console.log(<span class="string">'damn Websocket is broken!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    this.term.attach(this.terminalSocket)</span><br><span class="line">    // 绑定xterm到ws流中</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><ul><li>当浏览器关闭时，也代表着客户端关闭，此时主动插入连接，交给<code>vue</code>的钩子函数来处理这个问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beforeDestroy () &#123;</span><br><span class="line">  this.terminalSocket.close()</span><br><span class="line">  this.term.destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后端实现"><a href="#后端实现" class="headerlink" title="后端实现"></a>后端实现</h3><blockquote><p><code>django</code>这里使用<code>dwebsocket</code>模块进行<code>ws</code>的服务端编写与通信</p></blockquote><ul><li>首先确定路由，也是前端的<code>ws</code>连接地址</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">＃urls.py </span><br><span class="line"><span class="meta">... </span></span><br><span class="line">path（<span class="string">'webssh /'</span>，webssh）</span><br></pre></td></tr></table></figure><ul><li>定义函数，初始化<code>SSH</code>连接对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#views.py </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_ssh</span><span class="params">(host,username,password,port=<span class="number">22</span>)</span>:</span></span><br><span class="line">    sh = paramiko.SSHClient()</span><br><span class="line">    sh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">    sh.connect(host, username=username, password=password)</span><br><span class="line">    channle = sh.invoke_shell(term=<span class="string">'xterm'</span>)</span><br><span class="line">    <span class="keyword">return</span> channle</span><br></pre></td></tr></table></figure><ul><li>由于在<code>SSH</code>通道中，服务端可能返回结果的方式并不与客户端发起的命令一唱一和，可能是一唱多和，类似类似<code>top</code>的命令，一次命令输入之后，服务端会返回<code>N</code>次结果，此时在<code>django</code>首先中采用多线程，专门处理命令结果的返回；以下是这个任务线程函数的定义</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_ssh_msg</span><span class="params">(channle,ws)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        channle: 建立好的SSH连接通道</span></span><br><span class="line"><span class="string">        这个函数会不停的接收ssh通道返回的命令</span></span><br><span class="line"><span class="string">        返回到前端的ws套接字里</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> channle.exit_status_ready():</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            buf = channle.recv(<span class="number">1024</span>) <span class="comment"># 接收命令的执行结果</span></span><br><span class="line">            ws.send(buf) <span class="comment"># 向Websocket通道返回</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><ul><li>剩余的就是视图函数的调用和线程开启部分了！</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@accept_websocket</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">webssh</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">        1: 接收前端(ws)的命令，发给后台(ssh)</span></span><br><span class="line"><span class="string">        2: 接收后台的返回结果，给到前端</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> request.is_websocket:</span><br><span class="line">        channle = _ssh(host, username=username, password=password)</span><br><span class="line">        ws = request.websocket </span><br><span class="line">        t = threading.Thread(target=recv_ssh_msg,args=(channle,ws))</span><br><span class="line">        t.setDaemon(<span class="literal">True</span>) </span><br><span class="line">        t.start() <span class="comment"># 线程开启</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            cmd = ws.wait() <span class="comment"># 阻塞接收前端发来的命令</span></span><br><span class="line">            <span class="keyword">if</span> cmd:</span><br><span class="line">                channle.send(cmd) <span class="comment"># 由SSH通道转交给Linux环境</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 连接断开 跳出循环 </span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        ws.close() <span class="comment"># 释放对应套接字资源</span></span><br><span class="line">        channle.close()</span><br></pre></td></tr></table></figure><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><ul><li>如下</li></ul><p><a href="https://lienze.tech/blog/images/webssh.gif" target="_blank" rel="noopener"><img src="https://lienze.tech/blog/images/webssh.gif" alt="Webssh"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;WebSSH&quot;&gt;&lt;a href=&quot;#WebSSH&quot; class=&quot;headerlink&quot; title=&quot;WebSSH&quot;&gt;&lt;/a&gt;WebSSH&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;webssh&lt;/code&gt;从而&lt;code&gt;SSH&lt;/code&gt;无需&lt;code&gt;Xshell&lt;/code&gt;之类的模拟终端工具进行&lt;code&gt;SSH&lt;/code&gt;连接，将&lt;code&gt;SSH&lt;/code&gt;这一比较低层的操作也从&lt;code&gt;C/S&lt;/code&gt;架构扭转成为&lt;code&gt;B/S&lt;/code&gt;架构&lt;/p&gt;
&lt;p&gt;这样的架构常用在运维制作开发一些堡垒机等系统，或者目前比较新型的在线教育方式，通过&lt;code&gt;WebSSH&lt;/code&gt;向学生提供一个可以直接使用浏览器进行相关&lt;code&gt;Linux&lt;/code&gt;操作或代码编写的学习方式&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WebSSh&lt;/code&gt;主要是建立客户端与服务端的即时通信&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Websocket</title>
    <link href="https://cy-blogs.cn/Websocket/"/>
    <id>https://cy-blogs.cn/Websocket/</id>
    <published>2019-12-09T09:00:08.693Z</published>
    <updated>2019-12-09T11:26:53.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h2><blockquote><p><code>WebSocket</code>实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端可以主动向客户端发送数据。</p><p>传统的<code>HTTP</code>协议是无状态的，种客户端是主动方，服务端是被动方的；对于涉及实时信息的<code>Web</code>应用带来了很大的不便，如带有即时通信、实时数据、订阅推送等功能的应用。在之前有两种办法解决这个问题</p></blockquote><a id="more"></a><blockquote><p>轮询是最原始的实现实时<code>Web</code>应用的解决方案。轮询技术要求客户端以设定的时间间隔周期性地向服务端发送请求，频繁地查询是否有新的数据改动。这种方法会导致过多不必要的请求，浪费流量和服务器资源。</p><p><code>Comet</code>技术又可以分为长轮询和流技术；长轮询改进了上述的轮询技术，减小了无用的请求。它会为某些数据设定过期时间，当数据过期后才会向服务端发送请求；这种机制适合数据的改动不是特别频繁的情况。流技术通常是指客户端使用一个隐藏的窗口与服务端建立一个<code>HTTP</code>长连接，服务端会不断更新连接状态以保持<code>HTTP</code>长连接存活；这样的话，服务端就可以通过这条长连接主动将数据发送给客户端；流技术在大并发环境下，可能会考验到服务端的性能。</p><p><code>WebSocket</code>真正实现了<code>Web</code>的实时通信，使<code>B/S</code>模式具备了<code>C/S</code>模式的实时通信能力</p><p><code>WebSocket</code>的工作流程是这样的：浏览器通过<code>JavaScript</code>向服务端发出建立<code>WebSocket</code>连接的请求，在<code>WebSocket</code>连接建立成功后，客户端和服务端就可以通过 TCP连接传输数据。因为<code>WebSocket</code>连接本质上是<code>TCP</code>连接，不需要每次传输都带上重复的头部数据，所以它的数据传输量比轮询和<code>Comet</code>技术小了很多</p></blockquote><blockquote><p><code>Websocket</code>在建立连接之前有一个<code>Handshake</code>（<code>Opening Handshake</code>）过程，在关闭连接前也有一个Handshake（<code>Closing Handshake</code>）过程，建立连接之后，双方即可双向通信</p></blockquote><h3 id="HTML的Websocket"><a href="#HTML的Websocket" class="headerlink" title="HTML的Websocket"></a>HTML的Websocket</h3><ul><li>初始化websocket</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ws = <span class="keyword">new</span> <span class="constructor">WebSocket(<span class="params">url</span>, [<span class="params">protocol</span>] )</span>;</span><br></pre></td></tr></table></figure><blockquote><p><code>url</code>：指定连接的<code>websocket</code></p><p><code>protocol</code>：可接受的子协议</p></blockquote><h4 id="响应事件"><a href="#响应事件" class="headerlink" title="响应事件"></a>响应事件</h4><blockquote><p>当<code>ws</code>套接字初始化成功之后，我们可以通过定义回调函数在某些事件触发时执行，以下是常见响应事件</p></blockquote><ul><li>当<code>ws</code>连接建立时触发</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// 连接开启</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当<code>ws</code>连接接收到数据时触发</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span><span class="params">(evt)</span></span>&#123;</span><br><span class="line">    <span class="comment">// evt.data即是接收到的数据对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当<code>ws</code>连接发生通信错误时触发</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onerror = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 连接出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当连接关闭时触发</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 连接关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>初次之外，还可以通过一些方法函数进行数据的传输或连接的关闭</p></blockquote><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>通过<code>ws</code>连接发送数据</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="built_in">send</span>(str)</span><br></pre></td></tr></table></figure><ul><li>关闭连接</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ws</span>.<span class="keyword">close</span>()</span><br></pre></td></tr></table></figure><h4 id="简单的示例"><a href="#简单的示例" class="headerlink" title="简单的示例"></a>简单的示例</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">ws</span> = <span class="keyword">new</span> WebSocket(<span class="string">'ws://127.0.0.1:3000'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ws</span>.onopen = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'连接建立'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ws</span>.onmessage = <span class="function"><span class="keyword">function</span><span class="params">(ev)</span>&#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'server:'</span>,ev.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ws</span>.onerror = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'连接建立'</span>)</span><br><span class="line">    <span class="keyword">ws</span>.<span class="keyword">close</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ws</span>.onclose = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'连接关闭'</span>)</span><br><span class="line">    <span class="keyword">ws</span>.<span class="keyword">close</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Django的Websocket"><a href="#Django的Websocket" class="headerlink" title="Django的Websocket"></a>Django的Websocket</h3><blockquote><p><code>dwebsocket</code>是一个在<code>django</code>用来实现<code>websocket</code>服务端的三方模块，使用上手非常简单，安装方式如下</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> dwebsocket</span><br></pre></td></tr></table></figure><ul><li><code>git</code>地址</li></ul><blockquote><p><a href="https://github.com/duanhongyi/dwebsocket" target="_blank" rel="noopener">https://github.com/duanhongyi/dwebsocket</a></p></blockquote><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><blockquote><p>在后台中，通过该三方模块可以让我们在<code>django</code>的视图中实现对于<code>websocket</code>的操作</p></blockquote><blockquote><p>首先是两个基本的装饰器，用来限定过滤<code>websocket</code>的连接</p></blockquote><ul><li><code>dwebsocket.accept_websocket</code></li></ul><blockquote><p>允许<code>http</code>与<code>websocket</code>连接</p></blockquote><ul><li><code>dwebsocket.require_websocke</code></li></ul><blockquote><p>只允许<code>websocket</code>连接</p></blockquote><blockquote><p>除去两种装饰器方法进行过滤判断，还可以通过在视图函数中的<code>request</code>进行<code>websocket</code>的判断</p></blockquote><ul><li><code>request.is_websocket</code></li></ul><blockquote><p>如果是个<code>websocket</code>请求返回<code>True</code>，如果是个普通的<code>http</code>请求返回<code>False</code></p><p>可以用这个方法区分普通连接与<code>websocket</code></p></blockquote><ul><li><code>request.websocket</code></li></ul><blockquote><p>在一个<code>websocket</code>请求建立之后，这个请求将会有一个<code>websocket</code>属性，用来给客户端提供一个简单的<code>api</code>通讯，如果<code>request.is_websocket()</code>是<code>False</code>，这个属性将是<code>None</code></p></blockquote><ul><li><code>request.websocket.wait</code></li></ul><blockquote><p>接收客户端发来的一条消息；如果在收到消息或客户端关闭连接之前，它不会有任何返回，只会返回None</p></blockquote><ul><li><code>request.websocket.read</code></li></ul><blockquote><p>如果从客户端接收到新消息，<code>read</code>函数返回这条消息；如果没有新消息，则返回None</p><p>这是一个替代<code>wait</code>的非阻塞读取数据的方法</p></blockquote><ul><li><code>request.websocket.count_messages()</code></li></ul><blockquote><p>返回消息队列数量</p></blockquote><ul><li><code>request.websocket.has_messages()</code></li></ul><blockquote><p>如果有新消息返回<code>True</code>，否则返回<code>False</code></p></blockquote><ul><li><code>request.websocket.send(message)</code></li></ul><blockquote><p>向客户端发送消息</p></blockquote><ul><li><code>requqest.websocket.__iter__</code></li></ul><blockquote><p><code>websocket</code>迭代器</p></blockquote><ul><li>关于<code>Django</code>的<code>Demo</code>将会在下一章节结合<code>paramiko</code>以及<code>xterm.js</code>来进行一个<code>webssh</code>的实现</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Websocket&quot;&gt;&lt;a href=&quot;#Websocket&quot; class=&quot;headerlink&quot; title=&quot;Websocket&quot;&gt;&lt;/a&gt;Websocket&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;WebSocket&lt;/code&gt;实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端可以主动向客户端发送数据。&lt;/p&gt;
&lt;p&gt;传统的&lt;code&gt;HTTP&lt;/code&gt;协议是无状态的，种客户端是主动方，服务端是被动方的；对于涉及实时信息的&lt;code&gt;Web&lt;/code&gt;应用带来了很大的不便，如带有即时通信、实时数据、订阅推送等功能的应用。在之前有两种办法解决这个问题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Tinymce富文本编辑器</title>
    <link href="https://cy-blogs.cn/Tinymce%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>https://cy-blogs.cn/Tinymce富文本编辑器/</id>
    <published>2019-12-09T08:53:20.976Z</published>
    <updated>2019-12-09T11:28:03.240Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图文混排"><a href="#图文混排" class="headerlink" title="图文混排"></a>图文混排</h2><blockquote><p>在某些富文本编辑器中，我们可以支持文件与图片的同时编写，将文字与图片混合排列</p><p>在<code>django</code>中可以使用<code>TimyMce</code>富文本编辑器进行图文混排功能的实现</p></blockquote><h3 id="TinyMce"><a href="#TinyMce" class="headerlink" title="TinyMce"></a>TinyMce</h3><blockquote><p><code>TinyMCE</code>：是一个轻量级的基于浏览器的所见即所得编辑器，支持目前流行的各种浏览器，由<code>JavaScript</code>写成</p><p>功能配置灵活简单，两行代码就可以将编辑器嵌入网页中，并且支持<code>AJAX</code>，加载速度非常快</p><p>最重要的是，<code>TinyMCE</code>是一个根据<code>LGPL license</code>发布的自由软件，你可以把它用于商业应用。下图是此编辑器的界面</p></blockquote><a id="more"></a><h3 id="配置上传路径"><a href="#配置上传路径" class="headerlink" title="配置上传路径"></a>配置上传路径</h3><blockquote><p>首先配置整个项目的上传文件路径，为了区别与自身的<code>static</code>静态目录</p><p>这里的上传文件我们将另外保存至<code>upload</code>文件夹</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#settings.py</span></span><br><span class="line">UPLOAD_ROOT = os.path.join(BASE_DIR,<span class="string">'upload'</span>)</span><br></pre></td></tr></table></figure><h3 id="配置模板页面"><a href="#配置模板页面" class="headerlink" title="配置模板页面"></a>配置模板页面</h3><blockquote><p>首先需要在使用到<code>tinymce</code>富文本编辑器的<code>html</code>页面下导入必备<code>js</code>文件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&#123;% static 'js/jquery-1.10.2.min.js' %&#125;"</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&#123;% static 'js/tinymce_setup.js' %&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&#123;% static 'tinymce/js/tinymce/tinymce.min.js' %&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>接下来，在模板页面中加入一个<code>id</code>为<code>content</code>的输入表单，这里我们以一个文章数据为例</p></blockquote><ul><li>首先是模型层文件定义</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#models.py </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>,verbose_name=<span class="string">'标题'</span>)</span><br><span class="line">    author = models.CharField(max_length=<span class="number">100</span>,verbose_name=<span class="string">'作者'</span>)</span><br><span class="line">    content = models.TextField(verbose_name=<span class="string">'内容'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>content</code>内容要用到富文本编辑器</p></blockquote><ul><li>接着是模板页面的主要部分</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">'/'</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"文章标题"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"文章作者"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"rich_content"</span> <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">value</span>=<span class="string">" "</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修改插件配置"><a href="#修改插件配置" class="headerlink" title="修改插件配置"></a>修改插件配置</h3><blockquote><p>这里搭配了一个<code>tinymce_setup.js</code>文件，用来控制富文本编辑器所使用的插件等</p><p>全文配置如下</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">tinymce.init(&#123;</span><br><span class="line">    // 选择id为content的标签作为编辑器</span><br><span class="line">    selector: <span class="string">'#rich_content'</span>,</span><br><span class="line">    // 方向从左到右</span><br><span class="line">    directionality:<span class="string">'ltr'</span>,</span><br><span class="line">    // 语言选择中文</span><br><span class="line">    language:<span class="string">'zh_CN'</span>,</span><br><span class="line">    // 高度为<span class="number">400</span> 宽度为一半</span><br><span class="line">    height:<span class="number">300</span>,</span><br><span class="line">    width: <span class="string">'50%'</span>,</span><br><span class="line">    // 工具栏上面的补丁按钮</span><br><span class="line">    plugins: [</span><br><span class="line">            <span class="string">'advlist autolink link image lists charmap print preview hr anchor pagebreak spellchecker'</span>,</span><br><span class="line">            <span class="string">'searchreplace wordcount visualblocks visualchars code fullscreen insertdatetime media nonbreaking'</span>,</span><br><span class="line">            <span class="string">'save table contextmenu directionality template paste textcolor'</span>,</span><br><span class="line">            <span class="string">'codesample imageupload'</span>,</span><br><span class="line">    ],</span><br><span class="line">    // 工具栏的补丁按钮</span><br><span class="line">     toolbar: <span class="string">'insertfile undo redo | \</span></span><br><span class="line"><span class="string">     styleselect | \</span></span><br><span class="line"><span class="string">     bold italic | \</span></span><br><span class="line"><span class="string">     alignleft aligncenter alignright alignjustify | \</span></span><br><span class="line"><span class="string">     bullist numlist outdent indent | \</span></span><br><span class="line"><span class="string">     link image | \</span></span><br><span class="line"><span class="string">     print preview media fullpage | \</span></span><br><span class="line"><span class="string">     forecolor backcolor emoticons |\</span></span><br><span class="line"><span class="string">     codesample fontsizeselect fullscreen |\</span></span><br><span class="line"><span class="string">     imageupload'</span>,</span><br><span class="line">    // 字体大小</span><br><span class="line">    fontsize_formats: <span class="string">'10pt 12pt 14pt 18pt 24pt 36pt'</span>,</span><br><span class="line">    // 按tab不换行</span><br><span class="line">    nonbreaking_force_tab: true,</span><br><span class="line">    imageupload_url: <span class="string">"/upload_img/"</span>,</span><br><span class="line">    // 上传后图片保存为绝对路径</span><br><span class="line">    relative_urls : false,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>注释已经很清晰</p><p>要注意的是<code>imageupload_url</code>配置用来确定当前图片上传所对应的视图路由</p></blockquote><h3 id="上传视图配置"><a href="#上传视图配置" class="headerlink" title="上传视图配置"></a>上传视图配置</h3><blockquote><p>接下来编写富文本编辑器的上传图片路由函数及对应的路由配置</p><p>路由映射<code>tinymce_setup.js</code>与中的<code>imageupload_url</code>配置路由相同</p><p>这里还要注意，由于此时<code>tinymce</code>的上传图片表单并不是和本身所容纳的<code>form</code>表单一起上传，所以并不会具备<code>csrf_token</code>值，需要我们将上传图片的函数额外进行装饰器装饰，取消<code>csrf_token</code>验证</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">md5</span><span class="params">(str_)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    m = hashlib.md5()</span><br><span class="line">    m.update(str(time.time()).encode())</span><br><span class="line">    filename = m.hexdigest()</span><br><span class="line">    <span class="keyword">return</span> filename + <span class="string">'.'</span> + str_.split(<span class="string">'.'</span>)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_img</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        img = request.FILES.get(<span class="string">'file'</span>)</span><br><span class="line">        <span class="keyword">if</span> img:</span><br><span class="line">            file_name_md5 = md5(img.name)</span><br><span class="line">            <span class="keyword">with</span> open(os.path.join(UPLOAD_ROOT,file_name_md5), <span class="string">'wb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">                <span class="keyword">for</span> buf <span class="keyword">in</span> img.chunks():</span><br><span class="line">                    fp.write(buf)</span><br><span class="line">                <span class="comment"># 迭代读取文件并写入到本地</span></span><br><span class="line">        response = &#123;&#125;</span><br><span class="line">        response[<span class="string">'path'</span>] = <span class="string">'/upload/'</span> + file_name_md5</span><br><span class="line">        response[<span class="string">'error'</span>] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(response))</span><br></pre></td></tr></table></figure><blockquote><p>视图函数还是老样子去接收上传文件并保存即可</p><p>这里还使用了<code>md5</code>的方式进行文件名保存，避免重名文件上传互相覆盖</p></blockquote><ul><li>路由配置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line">path(<span class="string">'upload_img/'</span>,views.upload_img),</span><br></pre></td></tr></table></figure><h3 id="表单接收视图"><a href="#表单接收视图" class="headerlink" title="表单接收视图"></a>表单接收视图</h3><blockquote><p>以上的视图函数只能处理上传图片的内容接收</p><p>我们的模板页面中还有作者及标题两样表单内容会被<code>POST</code>提交到后台</p><p>并且要主要的是，富文本编辑器里除了图片的内容，还有文字等其他内容，这里也需要我们保存下来</p></blockquote><ul><li>这里还需要一个视图函数去接管处理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">'index.html'</span>)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        title = request.POST.get(<span class="string">'title'</span>)</span><br><span class="line">        author = request.POST.get(<span class="string">'author'</span>)</span><br><span class="line">        content = request.POST.get(<span class="string">'content'</span>)</span><br><span class="line">        models.Article.objects.create(</span><br><span class="line">            title = title,</span><br><span class="line">            author = author,</span><br><span class="line">            content = content,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">'/show/'</span>)</span><br></pre></td></tr></table></figure><ul><li>表单路由</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line">path(<span class="string">''</span>,views.index),</span><br></pre></td></tr></table></figure><ul><li>这里上传之后，保存在后台的<code>content</code>数据是这个样子</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/upload/ec8f8c9a56ed32464a6727741fd58d8d.png"</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>今天<span class="tag">&lt;<span class="name">em</span>&gt;</span>一切<span class="tag">&lt;/<span class="name">em</span>&gt;</span>都是<span class="tag">&lt;<span class="name">strong</span>&gt;</span>美丽<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>的，哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="图片访问路由"><a href="#图片访问路由" class="headerlink" title="图片访问路由"></a>图片访问路由</h3><blockquote><p>当有了上传图片的视图函数及所有内容的接收视图函数</p><p>这里还有一个特殊的问题，现在如果在富文本编辑器中选择上传图片，你会发现图片已经在选择时就已经存储到了后台<code>upload</code>文件夹下，这也是为什么我们的图片上传视图函数要单独编写，并且还需要取消<code>csrf_token</code>的验证的原因</p></blockquote><blockquote><p>除了这个问题你还会发现，在富文本编辑器中，上传的图片是看不到的，是一个坏掉的图片；</p><p>使用<code>F12</code>开发者工具你可以看到，这里的图片展示为一个<code>img</code>标签，而标签的<code>src</code>属性内容正是通过上传视图函数返回的<code>response</code>中的<code>path</code>值</p><p>想让这个<code>path</code>值在访问时，能获取到实际的图片效果，需要我们在路由文件中继续配置，配置专门的<code>upload/xxxx.jpg</code>的图片路由访问，让图片真正展示出来</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.views.static <span class="keyword">import</span> serve</span><br><span class="line">re_path(<span class="string">'^upload/(?P&lt;path&gt;.*)/$'</span>,serve,&#123;<span class="string">'document_root'</span>:UPLOAD_ROOT&#125;),</span><br></pre></td></tr></table></figure><blockquote><p>上传后图片的访问路径是<code>/upload/</code>，那么这里的路由也是<code>upload/</code>，之后通过静态文件映射函数<code>serve</code>查找<code>upload</code>文件夹下的同路径同名图片资源</p><p>当有了这条路由配置之后，再次再富文本编辑器中加入图片，你就会发现图片出现啦</p></blockquote><h3 id="上传并展示"><a href="#上传并展示" class="headerlink" title="上传并展示"></a>上传并展示</h3><blockquote><p>最后，我们将测试上传图片及文字</p><p>并且上传成功之后，重定向到<code>show</code>视图函数</p></blockquote><ul><li>这个视图函数用来提取当前最新的上传数据并返回到模板页面</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        article = models.Article.objects.all().last()</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'show.html'</span>,locals())</span><br></pre></td></tr></table></figure><ul><li>展示的模板页面</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>展示文章<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;% if article %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; article.title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;&#123; article.author &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; article.content|safe &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>其实本身富文本编辑器上传的文本内容就已经在一个<code>p</code>标签中，所以这里没有用段落标签</p><p>另外由于保存在数据库的文本为<code>html</code>格式，而后台传递来的模板变量<code>django</code>出于安全考虑会自动进行转义，直接观看到的效果不会<code>html</code>样式，只是一些普通字符串；</p><p>这里可以使用<code>safe</code>过滤器将内容认定为安全，展示为原始的<code>html</code>效果，其实还不错</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>富文本编辑器其实就是将用户输入的内容变为<code>html</code>代码</p><p>这里的图文混排，只是在图片加入时，单独将图片上传保存，并且回调获取到上传的路径</p><p>之后只需要服务端后台配置好相关的上传图片访问路由配置即可</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图文混排&quot;&gt;&lt;a href=&quot;#图文混排&quot; class=&quot;headerlink&quot; title=&quot;图文混排&quot;&gt;&lt;/a&gt;图文混排&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在某些富文本编辑器中，我们可以支持文件与图片的同时编写，将文字与图片混合排列&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;django&lt;/code&gt;中可以使用&lt;code&gt;TimyMce&lt;/code&gt;富文本编辑器进行图文混排功能的实现&lt;/p&gt;
&lt;/blockquote&gt;&lt;h3 id=&quot;TinyMce&quot;&gt;&lt;a href=&quot;#TinyMce&quot; class=&quot;headerlink&quot; title=&quot;TinyMce&quot;&gt;&lt;/a&gt;TinyMce&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TinyMCE&lt;/code&gt;：是一个轻量级的基于浏览器的所见即所得编辑器，支持目前流行的各种浏览器，由&lt;code&gt;JavaScript&lt;/code&gt;写成&lt;/p&gt;
&lt;p&gt;功能配置灵活简单，两行代码就可以将编辑器嵌入网页中，并且支持&lt;code&gt;AJAX&lt;/code&gt;，加载速度非常快&lt;/p&gt;
&lt;p&gt;最重要的是，&lt;code&gt;TinyMCE&lt;/code&gt;是一个根据&lt;code&gt;LGPL license&lt;/code&gt;发布的自由软件，你可以把它用于商业应用。下图是此编辑器的界面&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>HayStack全文检索在Django中应用</title>
    <link href="https://cy-blogs.cn/HayStack%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%9C%A8Django%E4%B8%AD%E5%BA%94%E7%94%A8/"/>
    <id>https://cy-blogs.cn/HayStack全文检索在Django中应用/</id>
    <published>2019-12-09T08:41:45.776Z</published>
    <updated>2019-12-09T11:26:38.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h2><p><a href="https://django-haystack.readthedocs.io/en/v2.4.1/tutorial.html" target="_blank" rel="noopener">官方文档</a></p><blockquote><p>全文检索就是针对所有内容进行动态匹配搜索的概念</p><p>针对特定的关键词进行<strong>建立索引</strong>并<strong>精确匹配</strong>取出搜索结果，并且达到性能优化的目的</p></blockquote><ul><li>为啥要有全文检索</li></ul><blockquote><p>最常见的全文检索就是我们在数据库中进行的模糊查询</p><p>但是模糊查询是针对整体内容的一个动态匹配过程，在数据量较大的情况下匹配效率极低</p><p>常规项目中数据量一般都比较多并且内容繁杂，所以正常的项目搜索功能中很少会使用模糊查询进行操作</p><p>如果你开发的项目用户量较少并且项目数据较少，那么此时模糊查询可以是你值得考虑的选项</p></blockquote><a id="more"></a><ul><li><code>django</code>使用啥进行全文检索</li></ul><blockquote><p><code>Python</code>提供了各种模块进行全文检索，最常见的是<code>haystack</code>模块</p><p>该模块设计为支持<code>whoosh</code>、<code>solr</code>、<code>Xapian</code>、<code>Elasticsearch</code>四种全文检索引擎后端</p><p>使用<code>haystack</code>模块，不用更改代码，直接切换引擎，可以极大的减少代码量</p><p><code>haystack</code>属于一种<strong>全文检索</strong>的框架</p></blockquote><hr><ul><li><strong><code>whoosh</code></strong></li></ul><blockquote><p>纯<code>Python</code>编写的全文搜索引擎，是目前最快的<code>python</code>所编写的检索引擎，虽然性能比不上<code>solr</code>、<code>Xapian</code>、<code>Elasticsearch</code>等；但是无二进制包，程序不会莫名其妙的崩溃，对于小型的站点，<code>whoosh</code>已经足够使用</p></blockquote><ul><li><strong><code>solr</code></strong></li></ul><blockquote><p><code>Solr</code>是一个高性能，采用<code>Java5</code>开发，基于<code>Lucene</code>的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎</p><p><code>Lucene</code>：不是一个完整的<strong>全文检索引擎</strong>，是一个全文检索引擎的<strong>架构</strong>，提供了完整的查询引擎和索引引擎，<code>Lucene</code>的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能</p></blockquote><ul><li><strong><code>Xapian</code></strong></li></ul><blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Xapian`是一个用`C++`编写的全文检索程序，他的作用类似于`Java`的`lucene</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><strong><code>Elasticsearch</code></strong></li></ul><blockquote><p><code>ElasticSearch</code>是一个基于<code>Lucene</code>的搜索服务器它提供了一个分布式多用户能力的全文搜索引擎，基于<code>RESTful web</code>接口</p><p><code>Elasticsearch</code>是用Java开发的，并作为<code>Apache</code>许可条款下的开放源码发布，是当前流行的企业级搜索引擎。该引擎常设计用于云计算中；能够达到<strong>实时搜索</strong>，<strong>稳定</strong>，<strong>可靠</strong>，<strong>快速</strong>，<strong>安装</strong>使用方便</p></blockquote><h3 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h3><blockquote><p><code>whoosh</code>作为一个全文搜索引擎模块</p><p>分词功能和检索功能已经非常强大，但是针对中文的处理还是比较欠缺</p><p>可以通过<code>Jieba</code>模块重写分词操作，支持<code>whoosh</code>对中文的强大操作</p></blockquote><ul><li>安装中文分词模块</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> jieba</span><br></pre></td></tr></table></figure><ul><li><p>除了<code>jieba</code>分词，现在还有很多付费的中文分词模块</p><blockquote><p><a href="http://ictclas.nlpir.org/nlpir/" target="_blank" rel="noopener">中科院计算所NLPIR</a></p><p><a href="https://github.com/NLPchina/ansj_seg" target="_blank" rel="noopener"><code>ansj</code>分词器</a></p><p><a href="https://github.com/HIT-SCIR/ltp" target="_blank" rel="noopener">哈工大的<code>LTP</code></a></p><p><a href="https://github.com/thunlp/THULAC" target="_blank" rel="noopener">清华大学<code>THULAC</code></a></p><p><a href="https://nlp.stanford.edu/software/segmenter.shtml" target="_blank" rel="noopener">斯坦福分词器</a></p><p><a href="https://github.com/hankcs/HanLP" target="_blank" rel="noopener"><code>Hanlp</code>分词器</a></p><p><a href="https://github.com/yanyiwu/cppjieba" target="_blank" rel="noopener">结巴分词</a></p><p><a href="https://github.com/koth/kcws" target="_blank" rel="noopener"><code>KCWS</code>分词器(字嵌入<code>+Bi-LSTM+CRF</code>)</a></p><p><a href="https://github.com/frcchang/zpar/releases" target="_blank" rel="noopener"><code>ZPar</code></a></p><p><a href="https://github.com/wks/ik-analyzer" target="_blank" rel="noopener"><code>IKAnalyzer</code></a></p></blockquote></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>首先安装<code>HayStack</code>框架以及<code>whoosh</code>搜索引擎</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install django-haystack</span><br><span class="line">pip install whoosh</span><br></pre></td></tr></table></figure><h3 id="settings配置"><a href="#settings配置" class="headerlink" title="settings配置"></a>settings配置</h3><ul><li>添加<code>haystack</code>应用到项目的<code>settings</code>文件下的<code>app</code>部分</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [ </span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    ...   </span><br><span class="line">    <span class="string">'haystack'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>添加搜索引擎，这里使用<code>whoosh</code>引擎</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HAYSTACK_CONNECTIONS = &#123;  </span><br><span class="line">    <span class="string">'default'</span>: &#123;      </span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'haystack.backends.whoosh_cn_backend.WhooshEngine'</span>,   </span><br><span class="line">        <span class="string">'PATH'</span>: os.path.join(BASE_DIR, <span class="string">'whoosh_index'</span>),  </span><br><span class="line">    &#125;&#125;</span><br><span class="line"><span class="comment">#这里使用django的信号机制，在数据表发生改动时自动更新whoosh的查询索引</span></span><br><span class="line">HAYSTACK_SIGNAL_PROCESSOR = <span class="string">'haystack.signals.RealtimeSignalProcessor'</span></span><br></pre></td></tr></table></figure><blockquote><p>这里要注意的是，我们使用的引擎为<code>whoosh_cn_backend</code></p><p>本身的<code>whoosh</code>引擎名为：<code>whoosh_backend</code></p><p><code>whoosh_cn_backend</code>将在接下来我们对安装目录下的引擎文件复制修改得来</p></blockquote><ul><li>在项目的路由文件下配置查询的路由映射</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include,re_path</span><br><span class="line">urlpatterns = [   </span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),  </span><br><span class="line">    re_path(<span class="string">'^search/'</span>,include(<span class="string">'haystack.urls'</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>当查询条件被提交时，会跳转至<code>search</code>路由</p><p>并且查询条件会作为<code>get</code>请求时的连接参数传入，参数<code>key</code>值为<code>q</code></p></blockquote><h3 id="创建索引文件"><a href="#创建索引文件" class="headerlink" title="创建索引文件"></a>创建索引文件</h3><ul><li>接下来，在需要被搜索的<code>app</code>下建立<code>search_indexes.py</code>文件，该文件名不许变更</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app.models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(models.Model)</span>:</span>    </span><br><span class="line">    <span class="comment"># 用户表 </span></span><br><span class="line">    name = models.CharField(   </span><br><span class="line">        max_length=<span class="number">50</span>,  </span><br><span class="line">        verbose_name=<span class="string">'昵称'</span>  </span><br><span class="line">    )   </span><br><span class="line">    account = models.CharField(max_length=<span class="number">50</span>,verbose_name=<span class="string">'账号'</span>,unique=<span class="literal">True</span>)</span><br><span class="line">    passwd = models.CharField(max_length=<span class="number">50</span>,verbose_name=<span class="string">'密码'</span>) </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>    </span><br><span class="line">        <span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#app.search_indexes.py</span></span><br><span class="line"><span class="keyword">from</span> haystack <span class="keyword">import</span> indexes</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserIndex</span><span class="params">(indexes.SearchIndex, indexes.Indexable)</span>:</span></span><br><span class="line">    text = indexes.CharField(document=<span class="literal">True</span>, use_template=<span class="literal">True</span>) </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_model</span><span class="params">(self)</span>:</span>    </span><br><span class="line">        <span class="keyword">return</span> models.User  <span class="comment"># 当前模型文件下需要被检索的模型类   </span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index_queryset</span><span class="params">(self, using=None)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> self.get_model().objects.all()</span><br></pre></td></tr></table></figure><blockquote><p>该类为索引类，类名为模型类的名称<code>+Index</code>：比如模型类为<code>People</code>,则这里类名为<code>PeopleIndex</code></p><p><code>get_model</code>函数用来获取当前索引类所关联的模型类，这里我们关联上面的<code>User</code> 类对象</p><p><code>text=indexes.CharField</code>语句指定了将模型类中的哪些字段建立索引，而<code>use_template=True</code>说明后续我们将通过一个<strong>数据模板</strong>文件来指明需要检索的字段</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="attribute">document</span>=<span class="literal">True</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>为什么要创建索引：索引就像是一本书的目录，可以为读者提供更快速的导航与查找</p></blockquote><h3 id="创建模板数据文件"><a href="#创建模板数据文件" class="headerlink" title="创建模板数据文件"></a>创建模板数据文件</h3><ul><li>创建数据模板文件</li></ul><blockquote><p>数据模板文件路径：<code>templates/search/indexes/yourapp/note_text.txt</code></p><p>放在任何一个你的<code>Django</code>能搜索到的模板文件夹<code>template</code>下面均可，这个文件主要确定要检索的字段，为他们建立索引</p><p>文件名必须为要索引的类名<code>_text.txt</code>，比如这里我们检索的类名是<code>User</code>，那么对应的数据模板文件名为<code>user_text.txt</code>，文件名小写即可</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#template</span><span class="selector-class">.search</span><span class="selector-class">.indexes</span><span class="selector-class">.people</span><span class="selector-class">.user_text</span><span class="selector-class">.txt</span></span><br><span class="line">&#123;&#123; <span class="selector-tag">object</span><span class="selector-class">.name</span> &#125;&#125;</span><br><span class="line">&#123;&#123; <span class="selector-tag">object</span><span class="selector-class">.account</span> &#125;&#125;</span><br><span class="line">&#123;&#123; <span class="selector-tag">object</span><span class="selector-class">.online_time</span> &#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在数据模板文件中使用模板语法，写入需要建立索引的字段，这里我们将模型类中<code>name</code>、<code>account</code>以及<code>online_time</code>字段设置索引，当检索时会对这三个字段去做全文检索</p></blockquote><blockquote><p>接下来创建一个搜索结果展示页面</p></blockquote><h3 id="检索结果模板页面"><a href="#检索结果模板页面" class="headerlink" title="检索结果模板页面"></a>检索结果模板页面</h3><ul><li>创建检索结果展示页面</li></ul><blockquote><p>检索结果展示页面，需要在固定的目录路径下进行模板页面的编写</p><p>路径为：<code>templates/search/</code></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&#123;% if query %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>搜索结果如下：<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    &#123;% for result in page.object_list %&#125;</span><br><span class="line">        &#123;&#123; result.object.name &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        &#123;&#123; result.object.account &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        &#123;&#123; result.object.online_time &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;% empty %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>没找到<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    </span><br><span class="line">    &#123;% if page.has_previous or page.has_next %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            &#123;% if page.has_previous %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"?q=&#123;&#123; query &#125;&#125;&amp;amp;page=&#123;&#123; page.previous_page_number &#125;&#125;"</span>&gt;</span></span><br><span class="line">            上一页</span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">            &#123;% if page.has_next %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"?q=&#123;&#123; query &#125;&#125;&amp;amp;page=&#123;&#123; page.next_page_number &#125;&#125;"</span>&gt;</span></span><br><span class="line">            下一页</span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这个模板页面中已经自带了分页功能，可以按照需求修改</p></blockquote><ul><li>创建检索模板页面内容</li></ul><blockquote><p>还需要有一个表单，提交检索信息</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">'get'</span> <span class="attr">action</span>=<span class="string">"/search/"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"q"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"查询"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这部分检索的模板页面内容可以在你的项目中进行添加，查询方式为<code>get</code>，并且检索输入的表单框<code>name</code>属性必须为<code>q</code></p></blockquote><h3 id="中文分词配置"><a href="#中文分词配置" class="headerlink" title="中文分词配置"></a>中文分词配置</h3><ul><li>接下来，需要创建有关中文检索的配置文件，这里的配置文件创建为全局</li></ul><blockquote><p>进入到<code>python</code>的安装目录下，比如我的目录为：<code>C:\Python37\Lib\site-packages\haystack\backends</code></p><p>在该路径下创建名为<code>ChineseAnalyzer.py</code>的中文分词文件</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">from</span> whoosh.analysis <span class="keyword">import</span> Tokenizer, Token</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChineseTokenizer</span><span class="params">(Tokenizer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, value, positions=False, chars=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                 keeporiginal=False, removestops=True,start_pos=<span class="number">0</span>, start_char=<span class="number">0</span>, mode=<span class="string">''</span>, **kwargs)</span>:</span></span><br><span class="line">        t = Token(positions, chars, removestops=removestops, mode=mode, **kwargs)</span><br><span class="line">        seglist = jieba.cut(value, cut_all=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> seglist:</span><br><span class="line">            t.original = t.text = w</span><br><span class="line">            t.boost = <span class="number">1.0</span></span><br><span class="line">            <span class="keyword">if</span> positions:</span><br><span class="line">                t.pos = start_pos + value.find(w)</span><br><span class="line">            <span class="keyword">if</span> chars:</span><br><span class="line">                t.startchar = start_char + value.find(w)</span><br><span class="line">                t.endchar = start_char + value.find(w) + len(w)</span><br><span class="line">            <span class="keyword">yield</span> t</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ChineseAnalyzer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ChineseTokenizer()</span><br></pre></td></tr></table></figure><blockquote><p>在这个文件中，定义了一个<code>ChineseAnalyzer</code>的函数，这个函数将替代搜索引擎配置文件中的分词方式</p></blockquote><ul><li>复制引擎文件，修改分词方式为中文</li></ul><blockquote><p>同样在该文件夹下<code>C:\Python37\Lib\site-packages\haystack\backends</code>，复制<code>whoosh_backend.py</code>文件，创建一个新的文件名为<code>whoosh_cn_backend.py</code>，这里复制出一份文件也是为了之后如果不需要使用中文分词，可以直接在<code>settings</code>配置文件中修改引擎为<code>&#39;ENGINE&#39;:&#39;haystack.backends.whoosh_backend.WhooshEngine&#39;,</code></p></blockquote><blockquote><p>修改该引擎配置文件中的：<code>analyzer=StemmingAnalyzer()</code>变为<code>analyzer=ChineseAnalyzer()</code></p><p>并且要记得在头部引入刚才所编写的中文分词文件</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#whoosh_cn_backend.py</span></span><br><span class="line"><span class="keyword">from</span> .ChineseAnalyzer <span class="keyword">import</span> ChineseAnalyzer</span><br></pre></td></tr></table></figure><h3 id="初始化索引"><a href="#初始化索引" class="headerlink" title="初始化索引"></a>初始化索引</h3><ul><li>最后，初始化索引数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py rebuild_index</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;全文检索&quot;&gt;&lt;a href=&quot;#全文检索&quot; class=&quot;headerlink&quot; title=&quot;全文检索&quot;&gt;&lt;/a&gt;全文检索&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://django-haystack.readthedocs.io/en/v2.4.1/tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;全文检索就是针对所有内容进行动态匹配搜索的概念&lt;/p&gt;
&lt;p&gt;针对特定的关键词进行&lt;strong&gt;建立索引&lt;/strong&gt;并&lt;strong&gt;精确匹配&lt;/strong&gt;取出搜索结果，并且达到性能优化的目的&lt;/p&gt;
&lt;/blockquote&gt;&lt;ul&gt;
&lt;li&gt;为啥要有全文检索&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;最常见的全文检索就是我们在数据库中进行的模糊查询&lt;/p&gt;
&lt;p&gt;但是模糊查询是针对整体内容的一个动态匹配过程，在数据量较大的情况下匹配效率极低&lt;/p&gt;
&lt;p&gt;常规项目中数据量一般都比较多并且内容繁杂，所以正常的项目搜索功能中很少会使用模糊查询进行操作&lt;/p&gt;
&lt;p&gt;如果你开发的项目用户量较少并且项目数据较少，那么此时模糊查询可以是你值得考虑的选项&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Admin</title>
    <link href="https://cy-blogs.cn/Django%E4%B8%AD%E7%9A%84Admin%E7%BB%84%E4%BB%B6/"/>
    <id>https://cy-blogs.cn/Django中的Admin组件/</id>
    <published>2019-12-09T08:29:50.000Z</published>
    <updated>2019-12-09T11:26:35.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Admin"><a href="#Admin" class="headerlink" title="Admin"></a>Admin</h2><blockquote><p><code>Django-admin</code>界面是框架为我们提供的<code>Web-APP</code>的管理工具</p><p>在之前的练习中，我们已经多次使用它进行<code>APP</code>中表的<code>DML</code>语句操作</p><p>接下来，我们可以继续来学习，如何将<code>Admin</code>界面进行优化扩展，更加方便我们后台管理</p></blockquote><h3 id="admin注册设置"><a href="#admin注册设置" class="headerlink" title="admin注册设置"></a>admin注册设置</h3><blockquote><p>在<code>admin</code>界面中，我们可以通过继承<code>admin.ModelAdmin</code>类进行自定义<code>admin</code>类的编写，用作控制展示后台所显示的数据，以及排序规则等等属性，基本语法像是下面这样</p></blockquote><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">name = models.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">    age = models.IntegerField()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#admin.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    fields = (<span class="string">'name'</span>,<span class="string">'age'</span>)</span><br><span class="line">    <span class="comment"># 控制admin界面模型类展示字段</span></span><br><span class="line">admin.site.register(User, UserAdmin)</span><br></pre></td></tr></table></figure><ul><li><h4 id="常用字段"><a href="#常用字段" class="headerlink" title="常用字段"></a>常用字段</h4><ul><li><code>list_display</code>：在<code>admin</code>控制台数据列表页面展示更多的字段</li><li><code>list_display_links</code>：用来设置当前列表中由<code>list_display</code>所设置的字段哪些可以点击</li><li><code>fieldsets</code>：将<code>admin</code>界面下的表单输入栏进行分块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    fields = (<span class="string">'name'</span>,<span class="string">'age'</span>)</span><br><span class="line">    fieldsets = (</span><br><span class="line">    (<span class="string">'第一个区域'</span>，</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="string">'fields'</span>: (<span class="string">'name'</span>,)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">       (<span class="string">'第二个区域'</span>，</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="string">'fields'</span>: (<span class="string">'age'</span>,)</span><br><span class="line">            &#125;</span><br><span class="line">        )     </span><br><span class="line">    )</span><br></pre></td></tr></table></figure></li><li><p><code>search_fields</code>：在<code>admin</code>数据展示页，设置一个搜索框，设置的分段是可查找的属性</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search_fields</span> =（<span class="string">'name'</span>，）</span><br></pre></td></tr></table></figure></li><li><p><code>list_filter</code>：以什么分解进行过滤，在<code>admin</code>页面上方展示</p></li><li><p><code>ordering</code>：数据列表可以通过某些细分进行排序</p></li></ul><h3 id="利用现有用户系统"><a href="#利用现有用户系统" class="headerlink" title="利用现有用户系统"></a>利用现有用户系统</h3><blockquote><p><code>from django.contrib.auth.models import User</code></p></blockquote><h4 id="用户字段"><a href="#用户字段" class="headerlink" title="用户字段"></a>用户字段</h4><ul><li><p><code>username</code></p><blockquote><p>必选。少于等于30个字符。用户名可以包含字母，数字，<code>_</code>， ，<code>@</code>，。<code>+</code>状语从句：<code>-</code>字符</p></blockquote></li><li><p><code>first_name</code></p><blockquote><p>任选。等于等于30个字符</p></blockquote></li><li><p><code>last_name</code></p><blockquote><p>可选。可以输入30个字符</p></blockquote></li><li><p><code>email</code></p><blockquote><p>任选。邮箱地址</p></blockquote></li><li><p><code>password</code></p><blockquote><p>必选。密码的哈希及元数据。（<code>Django</code>不保存原始密码）。原始密码可以无限长而且可以包含任意字符</p></blockquote></li><li><p><code>is_staff</code></p><blockquote><p>布尔值。指示用户是否可以访问<code>Admin</code>站点</p></blockquote></li><li><p><code>is_active</code></p><blockquote><p>布尔值。用户的账号是否激活。长使用这个标志为False来代替删除账号</p></blockquote></li><li><p><code>is_superuser</code></p><blockquote><p>布尔值。指定这个用户拥有所有的权限而不需要给他们分配明确的权限</p></blockquote></li><li><p><code>last_login</code></p><blockquote><p>用户最后一次登录的时间。如果这个用户没有登录过，这个细分将会是<code>null</code></p><p>之前版本默认设置为的当前的<code>datetime</code></p></blockquote></li><li><p><code>date_joined</code></p><blockquote><p>帐户创建的时间。当账号创建时，替代设置为当前的<code>datetime</code></p></blockquote></li></ul><h4 id="用户实例方法"><a href="#用户实例方法" class="headerlink" title="用户实例方法"></a>用户实例方法</h4><ul><li><p><code>get_username()</code></p><blockquote><p>获取到当前的用户的用户名属性</p></blockquote></li><li><p><code>is_authenticated()</code></p><blockquote><p>检查用户是否已通过认证</p></blockquote></li><li><p><code>is_anonymous()</code></p><blockquote><p>检查用户是否未通过认证</p></blockquote></li><li><p><code>set_password(password)</code></p><blockquote><p>设置保存用户的密码，和会负责密码的哈希加密工作</p><p>通常修改密码之后还需要调用<code>save()</code>方法进行数据更新</p></blockquote></li></ul><h4 id="用户表方法"><a href="#用户表方法" class="headerlink" title="用户表方法"></a>用户表方法</h4><ul><li><p><code>create_user(username, email=None, password=None, **extra_fields)</code></p><blockquote><p><code>django</code>的用户创建需要使用<code>User</code>表管理器中的<code>create_user</code>函数进行</p><p>该函数可以创建并保存一个用户</p></blockquote></li><li><p><code>create_superuser(username, email, password, **extra_fields)</code></p><blockquote><p>与上一个创建用户函数功能相同，但是额外会设置用户的<code>is_staff</code>及<code>is_superuser</code>属性为<code>True</code></p><p>创建一个<code>admin</code>后台超级用户</p></blockquote></li></ul><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li><p><code>authenticate(username,password)</code></p><blockquote><p>验证是否为合法用户，如果用户存在合法则返回一个用户对象</p></blockquote></li><li><p><code>logout()</code></p><blockquote><p>清除当前浏览器下用户<code>session</code></p></blockquote></li><li><p><code>login(request,user)</code></p><blockquote><p>登录并保存当前用户<code>session</code></p><p>接受参数为<code>HttpRequest</code>请求及一个<code>User</code>用户对象</p><p>参数<code>user</code>必须为使用<code>authenticate</code>验证过后的用户对象</p></blockquote></li></ul><h4 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h4><ul><li>登陆所需表单类</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#forms.py</span></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span><span class="params">(forms.Form)</span>:</span></span><br><span class="line">username = forms.CharField(label=<span class="string">"用户名"</span>,required=<span class="literal">True</span>,)</span><br><span class="line">    password = forms.CharField(</span><br><span class="line">        widget=forms.PasswordInput(),</span><br><span class="line">        label=<span class="string">'密码'</span>,</span><br><span class="line">        required=<span class="literal">True</span>,</span><br><span class="line">        )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_username</span><span class="params">(self)</span>:</span></span><br><span class="line">        username = self.cleaned_data.get(<span class="string">"username"</span>).strip()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            User.objects.get(username=username)</span><br><span class="line">        <span class="keyword">except</span> User.DoesNotExist:</span><br><span class="line">            <span class="keyword">raise</span> forms.ValidationError(<span class="string">"用户名 %s 不存在"</span> % username)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> username</span><br></pre></td></tr></table></figure><ul><li>登录所需模板页面</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">'/login/'</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">&#123;% csrf_token %&#125;</span><br><span class="line">&#123;&#123; errors &#125;&#125;</span><br><span class="line">&#123;% for field in form %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">&#123;% if field.errors %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% for error in field.errors%&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; error &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; field.label &#125;&#125;: &#123;&#123; field &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>登陆主要视图逻辑</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> authenticate,logout <span class="keyword">as</span> auth_logout,login <span class="keyword">as</span> auth_login</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">form = userForm()</span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">"login.html"</span>,&#123;<span class="string">'form'</span>:form&#125;)</span><br><span class="line">form = userForm(request.POST)</span><br><span class="line">    username = form.data[<span class="string">'username'</span>]</span><br><span class="line">    password = form.data[<span class="string">'password'</span>]</span><br><span class="line">    user = authenticate(username=username,password=password)</span><br><span class="line">    <span class="comment"># 验证当前账号密码是否匹配合法</span></span><br><span class="line">    <span class="keyword">if</span> user <span class="keyword">and</span> user.is_active:</span><br><span class="line">        auth_login(request, user)</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">'/'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">"login.html"</span>,&#123;<span class="string">'form'</span>:form,<span class="string">'errors'</span>:<span class="string">'用户名或密码错误'</span>&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在用户登录成功之后，将会重新进入主页，主页展示当前登录用户</p><p>登录用户可以直接在<code>request.user</code>属性中获取到，主页的模板内容如下</p></blockquote><ul><li>主页模板</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">欢迎你: &#123;&#123; user &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>主页视图函数可以通过装饰器<code>@login_required</code>或判断<code>is_authenticated</code>状态来查看用户是否登录</p><p>只有登录用户可以访问该站点</p><p>使用当装饰器<code>@login_required</code>时，在需要<code>settings</code>下设置<code>LOGIN_URL = &#39;/login/&#39;</code></p><p>引入属性设置为登录路由</p></blockquote><ul><li>首页视图函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.decorators <span class="keyword">import</span> login_required</span><br><span class="line"><span class="comment">#@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.user.is_authenticated():</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">"index.html"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">'/login/'</span>)</span><br></pre></td></tr></table></figure><h4 id="注册功能"><a href="#注册功能" class="headerlink" title="注册功能"></a>注册功能</h4><ul><li>注册所需表单</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#forms.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterForm</span><span class="params">(forms.Form)</span>:</span></span><br><span class="line">    username = forms.CharField(label=<span class="string">"用户名"</span>,</span><br><span class="line">        max_length=<span class="number">30</span>,</span><br><span class="line">        required=<span class="literal">True</span>,</span><br><span class="line">        error_messages=&#123;<span class="string">'max_length'</span>:<span class="string">'账号长度最长为30'</span>&#125;,</span><br><span class="line">    )</span><br><span class="line">    password = forms.CharField(label=<span class="string">"密码"</span>,</span><br><span class="line">        min_length=<span class="number">6</span>, max_length=<span class="number">30</span>, </span><br><span class="line">        widget=forms.PasswordInput(), </span><br><span class="line">        required=<span class="literal">True</span>,</span><br><span class="line">            error_messages=&#123;<span class="string">'min_length'</span>:<span class="string">'密码长度最短为6'</span>&#125;,</span><br><span class="line">        )</span><br><span class="line">check_password = forms.CharField(label=<span class="string">"重复密码"</span>, </span><br><span class="line">min_length=<span class="number">6</span>, max_length=<span class="number">30</span>, </span><br><span class="line">widget=forms.PasswordInput(), </span><br><span class="line">required=<span class="literal">True</span>,</span><br><span class="line">error_messages=&#123;<span class="string">'min_length'</span>:<span class="string">'密码长度最短为6'</span>&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_check_password</span><span class="params">(self)</span>:</span></span><br><span class="line">password = self.cleaned_data.get(<span class="string">'password'</span>)</span><br><span class="line">check_password = self.cleaned_data.get(<span class="string">'check_password'</span>)</span><br><span class="line"><span class="keyword">if</span> password != check_password <span class="keyword">and</span> password <span class="keyword">and</span> check_password:</span><br><span class="line"><span class="keyword">raise</span> ValidationError(<span class="string">"重复输入密码错误"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_username</span><span class="params">(self)</span>:</span></span><br><span class="line">username = self.cleaned_data.get(<span class="string">'username'</span>)</span><br><span class="line"><span class="keyword">if</span> username[:<span class="number">1</span>] == <span class="string">'_'</span>:</span><br><span class="line"><span class="keyword">raise</span> forms.ValidationError(<span class="string">"用户名不能以下划线打头"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">User.objects.get(username=username)</span><br><span class="line"><span class="keyword">except</span> User.DoesNotExist:</span><br><span class="line"><span class="keyword">return</span> username </span><br><span class="line"><span class="keyword">raise</span> forms.ValidationError(<span class="string">"用户名已存在"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>表单中，将对用户两次输入的密码进行校验和判断是否为空，而且分开下划线作为用户名的开头字符</p></blockquote><ul><li>注册主要视图函数逻辑</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        form = RegisterForm(request.POST)</span><br><span class="line">        <span class="keyword">if</span> form.is_valid():</span><br><span class="line">            username = form.cleaned_data[<span class="string">'username'</span>]</span><br><span class="line">            password = form.cleaned_data[<span class="string">'password'</span>]</span><br><span class="line">            User.objects.create_user(username=username,password=password)</span><br><span class="line">            user = authenticate(username=username,password=password)</span><br><span class="line">            auth_login(request, user)</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">'/'</span>)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        form = RegisterForm()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"register.html"</span>,&#123;<span class="string">'form'</span>:form&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>通过表单验证，并获取到对应的用户账号密码，创建成功之后，验证并登录，并重定向到首页</p></blockquote><ul><li>主页模板页面</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&#123;% if request.user.is_authenticated %&#125;</span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>您已登录:<span class="tag">&lt;/<span class="name">p</span>&gt;</span> &#123;&#123; user &#125;&#125;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">'/register/'</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">&#123;% csrf_token %&#125;</span><br><span class="line">&#123;% for field in form %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">&#123;% if field.errors %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% for error in field.errors%&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; error &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; field.label &#125;&#125;: &#123;&#123; field &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"注册"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>当用户已经登录时，显示当前登录用户，反之则展示表单，以供用户填写</p></blockquote><h3 id="重载admin用户系统"><a href="#重载admin用户系统" class="headerlink" title="重载admin用户系统"></a>重载admin用户系统</h3><blockquote><p><code>django</code>自带的<code>admin</code>模块下的用户系统主要负责用户帐户，组，权限和基于<code>cookie</code>的会话等业务</p><p>认证系统由以下部分组成：</p><p>用户：包含用户数据细分，是实现业务功能逻辑的基础</p><p>权限：控制用户进入否可以执行某项任务的二进制（是/否）标志。</p><p>组：一种为多个用户加上标签和权限的常用方式。</p><p>消息：一种为指定用户生成简单消息嵌入的方式</p></blockquote><h4 id="默认字段"><a href="#默认字段" class="headerlink" title="默认字段"></a>默认字段</h4><ul><li><p><code>username</code></p><blockquote><p>必选项，小于等于30个字符；只能是字母数字（字母，数字和下划线）</p></blockquote></li><li><p><code>first_name</code></p><blockquote><p>可选项，等于等于30个字符</p></blockquote></li><li><p><code>last_name</code></p><blockquote><p>可选项，等于等于30个字符</p></blockquote></li><li><p><code>email</code></p><blockquote><p>可选项。电子邮件地址</p></blockquote></li><li><p><code>password</code></p><blockquote><p>必选，密码（哈希值，元数据）</p><p><code>Django</code>不储存原始密码</p><p>原始密码可以是任意长度的，包含任何字符</p><p>密码由哈希类型，盐值和哈希值组成，用美元符合分隔</p></blockquote></li><li><p><code>is_staff</code></p><blockquote><p>布尔值，指明这个用户是否可以进入管理站点的权限</p></blockquote></li><li><p><code>is_active</code></p><blockquote><p>布尔值，指明这个用户帐户是否是活动的</p><p>我们建议把这个标记设置为<code>False</code>来代替删除用户帐户，这样就不会影响指向用户的外键</p><p>这个属性不控制用户是否可以登录。登录验证时不会核查<code>is_active</code>标志。</p><p>因此，如果在登录时需要检查<code>is_active</code>标志，需要你在自己的登录视图中实现</p><p>用于<a href="http://docs.oneele.com/django/topics/auth.html#django.contrib.auth.views.login" target="_blank" rel="noopener"><code>login()</code></a>视图的<a href="http://docs.oneele.com/django/topics/auth.html#django.contrib.auth.forms.AuthenticationForm" target="_blank" rel="noopener"><code>AuthenticationForm</code></a>会执行这个检查，判断用户是否是活跃账户</p></blockquote></li><li><p><code>is_superuser</code></p><blockquote><p>布尔值，规范用户拥有所有权限（包括显式赋予和非显式赋予的）</p></blockquote></li><li><p><code>last_login</code></p><blockquote><p>预期情况下设置为用户最后一次登录的日期时间</p></blockquote></li><li><p><code>date_joined</code></p><blockquote><p>预期情况下设置为用户帐户创建的日期时间</p></blockquote></li></ul><h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><blockquote><p>在项目中，我们将使用电子邮件作为用户的用户名，那么可以在自带用户表中写明</p><p><code>USERNAME_FIELD = &#39;email&#39;</code></p><p>该属性设置当前表的登陆细分</p></blockquote><blockquote><p>描述我们自定义用户模型上作的唯一标识符分割名称的字符串，分段必须是唯一的，在定义中设置<code>unique=True</code></p><p><code>REQUIRED_FIELDS = [&#39;username&#39;]</code></p><p>设置当前该基线为必填细分</p></blockquote><ul><li><p><code>is_authenticated()</code></p><blockquote><p>判断用户是否已通过身份验证的方法，不意味任何权限，而且不检查用户的活动状态</p></blockquote></li><li><p><code>get_username()</code></p><blockquote><p>返回由USERNAME_FIELD制定的细分的值</p></blockquote></li><li><p>get_full_name（）</p><blockquote><p>返回<code>first_name</code>加上<code>last_name</code></p><p>中间加上一个空格，由于我们重新设置了表分区，那么这个变量函数需要我们重新给定返回值</p></blockquote></li><li><p><code>get_short_name()</code></p><blockquote><p>一个短的且非正式用户的标识符，返回<code>first_name</code></p><p>当你的项目重写该静态或直接去掉了<code>first_name</code>，所以我们必须重新给定这个函数的返回值</p></blockquote></li><li><p><code>set_password()</code></p><blockquote><p>将用户的密码设置为给定的字符串</p></blockquote></li><li><p><code>has_perm(perm, obj=None)</code></p><blockquote><p>用户是否具有某个权限，如果给定<code>obj</code>，则需要根据特定对象实例检查权限</p></blockquote></li><li><p><code>has_module_perms(app_label)</code></p><blockquote><p>如果用户有权访问给定应用中的模型，则返回<code>True</code></p><p>这里我们这两个分区都设置为<code>True</code>，可以让用户访问任一<code>APP</code></p></blockquote></li><li><p><code>is_staff()@property</code></p><blockquote><p>如果用户允许访问管理网站，则返回<code>True</code></p><p>这里我们返回<code>is_admin</code>的随机属性即可</p></blockquote></li></ul><blockquote><p>关于细分属性，如果需要进行高度扩展</p><p>可以使用继承<code>AbstractBaseUser</code>这个类</p><p>这个类中只含有<code>password</code>， ，<code>last_login</code>以及<code>is_active</code>三个字段属性</p></blockquote><h4 id="重载管理器"><a href="#重载管理器" class="headerlink" title="重载管理器"></a>重载管理器</h4><blockquote><p>由于已经覆盖了替代的<code>admin</code>用户表，现在需要将其对应的管理器函数进行编写</p><p>编写时主要关注一下两个父类函数的重写</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create_user(username_field,password_filed=<span class="literal">None</span>,**other_fields)</span><br><span class="line">normalize_email()将邮件地址规范化的类方法</span><br><span class="line">user.save(using=self._db)</span><br><span class="line">create_superuser(username, email, password)</span><br><span class="line"><span class="comment">#用户创建，is_admin设置为True即可</span></span><br><span class="line">    user.save(using=self._db)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> BaseUserManager</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUserManager</span><span class="params">(BaseUserManager)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_user</span><span class="params">(self, username, email, password=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> email :</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Users must have an email address'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> username:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Users must have an username'</span>)</span><br><span class="line">        <span class="comment">#判断邮件和用户名是否具有</span></span><br><span class="line">        now = timezone.now()</span><br><span class="line">        <span class="comment">#获取当前django的时间</span></span><br><span class="line">        user = self.model(</span><br><span class="line">            username=username,</span><br><span class="line">            email=self.normalize_email(email),</span><br><span class="line">            date_joined=now, </span><br><span class="line">            last_login=now,</span><br><span class="line">        )</span><br><span class="line">        user.set_password(password)</span><br><span class="line">        user.save(using=self._db)</span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_superuser</span><span class="params">(self, username, email, password)</span>:</span></span><br><span class="line">        user = self.create_user(username,</span><br><span class="line">            email,</span><br><span class="line">            password=password,</span><br><span class="line">        )</span><br><span class="line">        user.is_admin = <span class="literal">True</span></span><br><span class="line">        user.save(using=self._db)</span><br><span class="line">        <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure><blockquote><p>重新定义新用户表的管理器之后，想要生效，还需要在对应的模型类表中覆盖<code>objects</code>属性</p></blockquote><ul><li><code>objects = MyUserManager()</code></li></ul><h4 id="重载表"><a href="#重载表" class="headerlink" title="重载表"></a>重载表</h4><blockquote><p>下面是一个真实的重载自带用户表的模型类</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> AbstractBaseUser</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Member</span><span class="params">(AbstractBaseUser)</span>:</span></span><br><span class="line">    <span class="comment">#AbstractBaseUser中只含有3个field: password, last_login和is_active.</span></span><br><span class="line">    email = models.EmailField(verbose_name=<span class="string">'邮箱'</span>,max_length=<span class="number">255</span>,unique=<span class="literal">True</span>,)</span><br><span class="line">    username = models.CharField(verbose_name=<span class="string">"用户名"</span>, max_length=<span class="number">16</span>, unique=<span class="literal">True</span>)</span><br><span class="line">    weibo_id = models.CharField(verbose_name=<span class="string">"新浪微博"</span>, max_length=<span class="number">30</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    blog = models.CharField(verbose_name=<span class="string">"个人网站"</span>, max_length=<span class="number">200</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    location = models.CharField(verbose_name=<span class="string">"城市"</span>, max_length=<span class="number">10</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    profile = models.CharField(verbose_name=<span class="string">"个人简介"</span>, max_length=<span class="number">140</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    avatar = models.CharField(verbose_name=<span class="string">"头像"</span>, max_length=<span class="number">128</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    au = models.IntegerField(verbose_name=<span class="string">"用户活跃度"</span>, default=<span class="number">0</span>)</span><br><span class="line">    last_ip = models.IPAddressField(verbose_name=<span class="string">"上次访问IP"</span>, default=<span class="string">"0.0.0.0"</span>)</span><br><span class="line">    email_verified = models.BooleanField(verbose_name=<span class="string">"邮箱是否验证"</span>, default=<span class="literal">False</span>)</span><br><span class="line">    date_joined = models.DateTimeField(verbose_name=<span class="string">"用户注册时间"</span>, default=timezone.now)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    topic_num = models.IntegerField(verbose_name=<span class="string">"帖子数"</span>, default=<span class="number">0</span>)</span><br><span class="line">    comment_num = models.IntegerField(verbose_name=<span class="string">"评论数"</span>, default=<span class="number">0</span>)</span><br><span class="line">    is_active = models.BooleanField(default=<span class="literal">True</span>)</span><br><span class="line">    is_admin = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    objects = MyUserManager()</span><br><span class="line">    <span class="comment">#objects就是我们之前一直使用的管理器</span></span><br><span class="line">    <span class="comment">#管理器用来维护我们的增删改查</span></span><br><span class="line"></span><br><span class="line">    USERNAME_FIELD = <span class="string">'email'</span></span><br><span class="line">    REQUIRED_FIELDS = [<span class="string">'username'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.username</span><br><span class="line">    <span class="comment">#标签中的数据实例</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_email_verified</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.email_verified</span><br><span class="line">    <span class="comment">#我们可以在模板中，通过实例出来的对象数据进行这个函数的调取，获取他是否验证过</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_weibo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weibo_id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_username</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.username</span><br><span class="line">        <span class="comment">#方法的圆括号在templates标签中必需省略！！</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_email</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.email</span><br><span class="line">        <span class="comment">#方法的圆括号在templates标签中必需省略！！</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_full_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># The user is identified by their email address</span></span><br><span class="line">        <span class="keyword">return</span> self.email</span><br><span class="line">        <span class="comment">#get_full_name本来是获取first_name和last_name的</span></span><br><span class="line">        <span class="comment">#但是由于我们重新设置了表结构，那么这个函数必须自定义</span></span><br><span class="line">        <span class="comment">#方法的圆括号在templates标签中必需省略！！</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_short_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># The user is identified by their email address</span></span><br><span class="line">        <span class="keyword">return</span> self.username</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_perm</span><span class="params">(self, perm, obj=None)</span>:</span></span><br><span class="line">        <span class="string">"Does the user have a specific permission?"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_module_perms</span><span class="params">(self, app_label)</span>:</span></span><br><span class="line">        <span class="string">"Does the user have permissions to view the app `app_label`?"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_au</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        计算活跃度</span></span><br><span class="line"><span class="string">        公式：Topic * 5 + Comment * 1</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.au = self.topic_num * <span class="number">5</span> + self.comment_num * <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.au</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="comment">#类中函数可以直接做为属性使用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_staff</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"Is the user a member of staff?"</span></span><br><span class="line">        <span class="comment"># Simplest possible answer: All admins are staff</span></span><br><span class="line">        <span class="keyword">return</span> self.is_admin</span><br></pre></td></tr></table></figure><h4 id="重载Admin表单"><a href="#重载Admin表单" class="headerlink" title="重载Admin表单"></a>重载Admin表单</h4><blockquote><p>由于修改了默认的<code>django</code>表结构，此时在<code>admin</code>界面修改密码或添加用户数据已经不能再按照之前的表单系统啦</p><p>需要在<code>app</code>的<code>admin.py</code>中重写<code>UserCreationForm</code>和<code>UserChangeForm</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户创建表单</span></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.admin <span class="keyword">import</span> UserAdmin</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.forms <span class="keyword">import</span> ReadOnlyPasswordHashField</span><br><span class="line"><span class="keyword">from</span> people.models <span class="keyword">import</span> Member, Follower</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCreationForm</span><span class="params">(forms.ModelForm)</span>:</span></span><br><span class="line">    <span class="string">"""A form for creating new users. Includes all the required</span></span><br><span class="line"><span class="string">    fields, plus a repeated password."""</span></span><br><span class="line">    password1 = forms.CharField(label=<span class="string">'密码'</span>, widget=forms.PasswordInput)</span><br><span class="line">    password2 = forms.CharField(label=<span class="string">'确认密码'</span>, widget=forms.PasswordInput)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Member</span><br><span class="line">        fields = (<span class="string">'email'</span>, <span class="string">'username'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_password2</span><span class="params">(self)</span>:</span></span><br><span class="line">        password1 = self.cleaned_data.get(<span class="string">"password1"</span>)</span><br><span class="line">        password2 = self.cleaned_data.get(<span class="string">"password2"</span>)</span><br><span class="line">        <span class="keyword">if</span> password1 <span class="keyword">and</span> password2 <span class="keyword">and</span> password1 != password2:</span><br><span class="line">            <span class="keyword">raise</span> forms.ValidationError(<span class="string">"两次输入验证失败"</span>)</span><br><span class="line">        <span class="keyword">return</span> password2</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#在form中的clean__field函数会在is_valid()函数验证时自动调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, commit=True)</span>:</span></span><br><span class="line">        user = super(UserCreationForm, self).save(commit=<span class="literal">False</span>)</span><br><span class="line">        user.set_password(self.cleaned_data[<span class="string">"password1"</span>])</span><br><span class="line">        <span class="comment">#set_password将会采用django的加密算法将密码设置到对应的模型实例中</span></span><br><span class="line">        <span class="comment">#在内存中创建的好的对象只有通过commit=True才被真正执行到数据库上</span></span><br><span class="line">        <span class="keyword">if</span> commit:</span><br><span class="line">            user.save()</span><br><span class="line">        <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 密码改变时的展示表单</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserChangeForm</span><span class="params">(forms.ModelForm)</span>:</span></span><br><span class="line">    password = ReadOnlyPasswordHashField()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Member</span><br><span class="line">        fields = (<span class="string">'email'</span>, <span class="string">'password'</span>, <span class="string">'username'</span>, <span class="string">'is_active'</span>, <span class="string">'is_admin'</span>,)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_password</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.initial[<span class="string">"password"</span>]</span><br><span class="line">    <span class="comment">#使用默认的save函数即可</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 真正的用户admin界面管理方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUserAdmin</span><span class="params">(UserAdmin)</span>:</span></span><br><span class="line">    form = UserChangeForm</span><br><span class="line">    add_form = UserCreationForm</span><br><span class="line">    list_display = (<span class="string">'id'</span>, <span class="string">'email'</span>, <span class="string">'username'</span>, <span class="string">'email_verified'</span>, <span class="string">'last_login'</span>,<span class="string">'is_active'</span>,<span class="string">'is_admin'</span>,<span class="string">'last_ip'</span>)</span><br><span class="line">    list_display_links = (<span class="string">'id'</span>, <span class="string">'email'</span>, <span class="string">'username'</span>)</span><br><span class="line">    list_filter = (<span class="string">'email'</span>, <span class="string">'email_verified'</span>,)</span><br><span class="line">    fieldsets = (</span><br><span class="line">        (<span class="literal">None</span>, &#123;<span class="string">'fields'</span>: (<span class="string">'username'</span>, <span class="string">'email'</span>, <span class="string">'date_joined'</span>, <span class="string">'password'</span>,<span class="string">'is_active'</span>,<span class="string">'is_admin'</span>,<span class="string">'avatar'</span>)&#125;),</span><br><span class="line">        (<span class="string">'状态'</span>, &#123;<span class="string">'fields'</span>: (<span class="string">'email_verified'</span>, <span class="string">'last_ip'</span>, <span class="string">'au'</span>, <span class="string">'topic_num'</span>, <span class="string">'comment_num'</span>)&#125;),</span><br><span class="line">        (<span class="string">'社交网络'</span>, &#123;<span class="string">'fields'</span>: (<span class="string">'weibo_id'</span>, <span class="string">'blog'</span>)&#125;),</span><br><span class="line">    )</span><br><span class="line">    add_fieldsets = (</span><br><span class="line">        (<span class="literal">None</span>, &#123;</span><br><span class="line">            <span class="string">'classes'</span>: (<span class="string">'wide'</span>,),</span><br><span class="line">            <span class="comment">#admin样式设置</span></span><br><span class="line">            <span class="comment">#Fieldsets 使用 wide 样式将会有额外的水平空格.</span></span><br><span class="line">            <span class="string">'fields'</span>: (<span class="string">'email'</span>, <span class="string">'username'</span>, <span class="string">'password1'</span>, <span class="string">'password2'</span>,<span class="string">'is_active'</span>,<span class="string">'is_admin'</span>)&#125;</span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line">    search_fields = (<span class="string">'id'</span>, <span class="string">'email'</span>, <span class="string">'username'</span>)</span><br><span class="line">    ordering = (<span class="string">'id'</span>, <span class="string">'email'</span>, <span class="string">'email_verified'</span>)</span><br><span class="line">    filter_horizontal = ()</span><br><span class="line">    <span class="comment">#这个字段为了设置与groups关联的多选框</span></span><br><span class="line">admin.site.register(Member, MyUserAdmin)</span><br><span class="line">admin.site.register(Follower)</span><br></pre></td></tr></table></figure><h4 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h4><blockquote><p>还需要在<code>settings.py</code>文件下进行设置，覆盖最小的<code>User</code>模型</p></blockquote><ul><li><code>AUTH_USER_MODEL = &#39;people.Member&#39;</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Admin&quot;&gt;&lt;a href=&quot;#Admin&quot; class=&quot;headerlink&quot; title=&quot;Admin&quot;&gt;&lt;/a&gt;Admin&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Django-admin&lt;/code&gt;界面是框架为我们提供的&lt;code&gt;Web-APP&lt;/code&gt;的管理工具&lt;/p&gt;
&lt;p&gt;在之前的练习中，我们已经多次使用它进行&lt;code&gt;APP&lt;/code&gt;中表的&lt;code&gt;DML&lt;/code&gt;语句操作&lt;/p&gt;
&lt;p&gt;接下来，我们可以继续来学习，如何将&lt;code&gt;Admin&lt;/code&gt;界面进行优化扩展，更加方便我们后台管理&lt;/p&gt;
&lt;/blockquote&gt;&lt;h3 id=&quot;admin注册设置&quot;&gt;&lt;a href=&quot;#admin注册设置&quot; class=&quot;headerlink&quot; title=&quot;admin注册设置&quot;&gt;&lt;/a&gt;admin注册设置&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在&lt;code&gt;admin&lt;/code&gt;界面中，我们可以通过继承&lt;code&gt;admin.ModelAdmin&lt;/code&gt;类进行自定义&lt;code&gt;admin&lt;/code&gt;类的编写，用作控制展示后台所显示的数据，以及排序规则等等属性，基本语法像是下面这样&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django邮件发送及华丽呼哨的邮件格式</title>
    <link href="https://cy-blogs.cn/Django%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E5%8F%8A%E5%8D%8E%E4%B8%BD%E5%91%BC%E5%93%A8%E7%9A%84%E9%82%AE%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <id>https://cy-blogs.cn/Django邮件发送及华丽呼哨的邮件格式/</id>
    <published>2019-12-09T08:19:22.320Z</published>
    <updated>2019-12-09T11:26:32.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h2><blockquote><p><code>django</code>中内置了许多方法可以使开发者方便的进行邮件发送</p></blockquote><h3 id="邮件配置"><a href="#邮件配置" class="headerlink" title="邮件配置"></a>邮件配置</h3><blockquote><p>发送邮件，首先需要在项目的<code>settings.py</code>文件下配置邮件服务器连接等信息</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EMAIL_USE_SSL = <span class="literal">True</span> <span class="comment"># Secure Sockets Layer 安全套接层, 取决于邮件服务器是否开启加密协议</span></span><br><span class="line">EMAIL_HOST = <span class="string">'smtp.qq.com'</span>  <span class="comment"># 邮件服务器地址</span></span><br><span class="line">EMAIL_PORT = <span class="number">465</span> <span class="comment"># 邮件服务器端口 </span></span><br><span class="line">EMAIL_HOST_USER = <span class="string">'account@qq.com'</span> <span class="comment"># 登陆邮件服务器的账号</span></span><br><span class="line">EMAIL_HOST_PASSWORD = <span class="string">'password'</span>  <span class="comment"># 登陆邮件服务器的密码</span></span><br><span class="line">DEFAULT_FROM_EMAIL = EMAIL_HOST_USER <span class="comment"># 邮件的发送者</span></span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p><strong>注意</strong>：<code>EMAIL_HOST_PASSWORD</code>所设置的登陆邮件服务器的密码为邮件客户端后台所设置的第三方客户端登陆密码，这个值并非直接账号密码</p><p>如：<code>QQ</code>邮箱的该值密码在网页版<code>QQ</code>邮件客户端的设置<code>-&gt;</code>帐户<code>-&gt;</code>开启<code>POP3/SMTP服务|IMAP/SMTP服务</code></p></blockquote><h3 id="发送文本邮件"><a href="#发送文本邮件" class="headerlink" title="发送文本邮件"></a>发送文本邮件</h3><blockquote><p>发送普通邮件可以使用<code>django.core.mail</code>模块下的<code>send_mail</code>函数进行</p></blockquote><ul><li><p><code>send_mail(subject, message, from_email, recipient_list, fail_silently=False, html_message=None)</code></p><blockquote><p>将邮件发送至<code>recipient_list</code>中的每一个收件人处</p></blockquote><blockquote><p><code>subject</code>：发送邮件标题</p><p><code>message</code>：发送邮件正文</p><p><code>from_email</code>：发件人邮箱地址</p><p><code>recipient_list</code>：一个字符串列表，每一个数据为接收者的邮箱地址</p><p><code>html_message</code>：如果指定该值，则发送的内容类型为<code>text/html</code>为一个<code>html</code>邮件内容</p></blockquote></li><li><p>发送普通邮件视图函数</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">(request)</span>:</span></span><br><span class="line">    subject = <span class="string">'邮件测试'</span></span><br><span class="line">    message = <span class="string">'&lt;a href="http://www.python.org"&gt;学习Python，我很快乐&lt;/a&gt;'</span></span><br><span class="line">    send_mail(</span><br><span class="line">        subject = subject,</span><br><span class="line">        message = message,</span><br><span class="line">        from_email = <span class="string">'from@qq.com'</span>,</span><br><span class="line">        recipient_list = [<span class="string">'recv@qq.com'</span>,<span class="string">'recv1@qq.com'</span>]</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Down'</span>)</span><br></pre></td></tr></table></figure><h3 id="发送HTML邮件"><a href="#发送HTML邮件" class="headerlink" title="发送HTML邮件"></a>发送HTML邮件</h3><blockquote><p>发送这里的邮件内容为一个<code>HTML</code>的<code>a</code>标签，但是真正接收者接到该邮件时，<code>a</code>标签并不会解释称为真正的<code>a</code>标签，只是一个普通的字符串，这是因为当前发送邮件的类型为<code>text/plain</code>，可以使用<code>html_message</code>参数进行<code>HTML</code>内容的发送</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">(request)</span>:</span>    </span><br><span class="line">    subject = <span class="string">'邮件测试'</span></span><br><span class="line">    message = <span class="string">'&lt;a href="http://www.python.org"&gt;学习Python，我很快乐&lt;/a&gt;'</span></span><br><span class="line">    send_mail(</span><br><span class="line">        subject = subject,</span><br><span class="line">        message = <span class="string">''</span>, <span class="comment"># 该参数为必须参数，必须填写</span></span><br><span class="line">        html_message = message,</span><br><span class="line">        from_email = <span class="string">'from@qq.com'</span>,</span><br><span class="line">        recipient_list =[<span class="string">'recv@qq.com'</span>,<span class="string">'recv1@qq.com'</span>]</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Down'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>发送<code>html</code>格式邮件还可以使用<code>django.core.mail</code>模块下的<code>EmailMultiAlternatives</code>类进行邮件体的构造，然后进行邮件发送</p></blockquote><ul><li><p><code>EmailMultiAlternatives(subject=&#39;&#39;, body=&#39;&#39;, from_email=None, to=None)</code></p><blockquote><p><code>subject</code>：邮件标题</p><p><code>body</code>：邮件内容</p><p><code>from_email</code>：邮件发送者</p><p><code>to</code>：邮件接收人列表</p></blockquote></li><li><p><code>EmailMultiAlternatives.attach_alternative(content, mimetype)</code></p><blockquote><p>向<code>EmailMultiAlternatives</code>实例中添加<code>mimetype</code>支持的邮件内容</p><p><code>content</code>：添加的邮件内容</p><p><code>mimetype</code>：添加内容的<code>mime</code>类型</p></blockquote></li><li><p><code>EmailMultiAlternatives.send()</code></p><blockquote><p>发送邮件</p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> EmailMultiAlternatives</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">(request)</span>:</span></span><br><span class="line">    subject = <span class="string">'邮件测试'</span></span><br><span class="line">    text_message = <span class="string">'学习Python，我很快乐'</span></span><br><span class="line">    html_message = <span class="string">'&lt;a href="http://www.python.org"&gt;学习Python，我很快乐&lt;/a&gt;'</span></span><br><span class="line">    email = EmailMultiAlternatives(</span><br><span class="line">        subject = subject,</span><br><span class="line">        body = text_message,</span><br><span class="line">        from_email = <span class="string">'1747266529@qq.com'</span>,</span><br><span class="line">        to = [<span class="string">'recv@qq.com'</span>,<span class="string">'recv1@qq.com'</span>]</span><br><span class="line">    )</span><br><span class="line">    email.attach_alternative(html_message,<span class="string">'text/html'</span>) <span class="comment"># 添加HTML邮件部分</span></span><br><span class="line">    email.send() <span class="comment"># 发送邮件</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Down'</span>)</span><br></pre></td></tr></table></figure><h3 id="发送富文本邮件"><a href="#发送富文本邮件" class="headerlink" title="发送富文本邮件"></a>发送富文本邮件</h3><blockquote><p>经常需要我们在邮件中加入图片等静态资源</p><p>需要用到<code>python</code>中<code>email.mime.image</code>模块下的<code>MIMEImage</code>类进行图片内容的构造</p><p>这里发送邮件使用<code>EmailMessage</code>类，来自于<code>django.core.mail</code>模块下</p><p>并在使用对应该类实例的<code>attach</code>添加图片资源数据</p><p>最后使用实例的<code>send</code>函数发送邮件</p></blockquote><ul><li><p><code>EmailMessage(subject=&#39;&#39;, body=&#39;&#39;, from_email=None, to=None)</code></p><blockquote><p>``subject`：邮件标题</p><p><code>body</code>：邮件内容</p><p><code>from_email</code>：邮件发送者</p><p><code>to</code>：邮件接收人列表</p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sendmailpro.settings <span class="keyword">import</span> STATICFILES_DIRS</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> email.mime.image <span class="keyword">import</span> MIMEImage</span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> EmailMessage</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">(request)</span>:</span></span><br><span class="line">    subject = <span class="string">'图片邮件测试'</span></span><br><span class="line">    file_1 = os.path.join(STATICFILES_DIRS[<span class="number">0</span>],<span class="string">'img/1.png'</span>)</span><br><span class="line">    <span class="keyword">with</span> open(file_1, <span class="string">'rb'</span>) <span class="keyword">as</span> fp: </span><br><span class="line">        <span class="comment"># 打开第一张图片</span></span><br><span class="line">        image_1 = MIMEImage(fp.read())</span><br><span class="line">        </span><br><span class="line">    file_2 = os.path.join(STATICFILES_DIRS[<span class="number">0</span>],<span class="string">'img/2.png'</span>)</span><br><span class="line">    <span class="keyword">with</span> open(file_2, <span class="string">'rb'</span>) <span class="keyword">as</span> fp: </span><br><span class="line">        <span class="comment"># 打开第二张图片</span></span><br><span class="line">        image_2 = MIMEImage(fp.read())</span><br><span class="line">        </span><br><span class="line">    body = <span class="string">"&lt;img src='cid:first_id'&gt;&lt;br&gt;&lt;img src='cid:sec_id'&gt;"</span></span><br><span class="line">    <span class="comment"># 发送邮件主体内容</span></span><br><span class="line">    </span><br><span class="line">image_1.add_header(<span class="string">'Content-ID'</span>,<span class="string">'&lt;%s&gt;'</span> % <span class="string">'first_id'</span>) </span><br><span class="line">    <span class="comment"># 通过 CID 对称图片在邮件内容中的位置</span></span><br><span class="line">    image_2.add_header(<span class="string">'Content-ID'</span>,<span class="string">'&lt;%s&gt;'</span> % <span class="string">'sec_id'</span>)</span><br><span class="line">    </span><br><span class="line">    message = EmailMessage( <span class="comment"># 构建发送的邮件主体</span></span><br><span class="line">                subject=subject,</span><br><span class="line">                body=body,</span><br><span class="line">                from_email=<span class="string">'from@qq.com'</span>,</span><br><span class="line">                to=[<span class="string">'recv@qq.com'</span>,<span class="string">'recv1@qq.com'</span>]</span><br><span class="line">            )</span><br><span class="line">    message.content_subtype = <span class="string">'html'</span></span><br><span class="line">    message.attach(image_1) <span class="comment"># 添加两张图片</span></span><br><span class="line">    message.attach(image_2)</span><br><span class="line">    message.send() <span class="comment"># 发送邮件</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Down'</span>)</span><br></pre></td></tr></table></figure><h3 id="发送附件邮件"><a href="#发送附件邮件" class="headerlink" title="发送附件邮件"></a>发送附件邮件</h3><blockquote><p>发送附件，也可以使用<code>django.core.mail</code>模块下的<code>EmailMessage</code>类进行附件邮件体构造</p><p>通过<code>EmailMessage</code>实例的<code>attach|attach_file</code>两个函数在邮件主体中添加附件内容</p><p><code>attach_file</code>添加邮件附件直接加入路径即可，但是<code>attach</code>添加附件内容需要提供附件内容</p></blockquote><ul><li><p><code>attach(filename=None, content=None, mimetype=None)</code></p><blockquote><p>添加附件内容</p></blockquote><blockquote><p><code>filename</code>：附件文件名称</p><p><code>content</code>：附件内容</p><p><code>mimetype</code>：附件的<code>MIME</code>类型</p></blockquote></li><li><p><code>attach_file(path, mimetype=None)</code></p><blockquote><p>直接通过路径添加附件</p></blockquote><blockquote><p><code>path</code>：附件路径</p><p><code>mimetype</code>：附件的<code>MIME</code>类型</p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sendmailpro.settings <span class="keyword">import</span> STATICFILES_DIRS</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> email.mime.image <span class="keyword">import</span> MIMEImage</span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> EmailMessage</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_email</span><span class="params">(request)</span>:</span></span><br><span class="line">    subject = <span class="string">'附件邮件测试'</span></span><br><span class="line">    email = EmailMessage(</span><br><span class="line">        subject=subject,</span><br><span class="line">        body=<span class="string">'这是一封具有图片附件的邮件'</span>,</span><br><span class="line">        from_email=<span class="string">'from@qq.com'</span>,</span><br><span class="line">        to=[<span class="string">'recv@qq.com'</span>,<span class="string">'recv1@qq.com'</span>]</span><br><span class="line">    )</span><br><span class="line">    file_1 = os.path.join(STATICFILES_DIRS[<span class="number">0</span>],<span class="string">'img/1.png'</span>)</span><br><span class="line">    image_1 = open(file_1,<span class="string">'rb'</span>).read()</span><br><span class="line">    email.attach(<span class="string">'1.png'</span>,image_1,<span class="string">'image/png'</span>) <span class="comment"># 使用attach实例函数添加附件内容</span></span><br><span class="line"></span><br><span class="line">    file_2 = os.path.join(STATICFILES_DIRS[<span class="number">0</span>],<span class="string">'img/2.png'</span>)</span><br><span class="line">    email.attach_file(file_2,mimetype=<span class="string">'image/png'</span>) <span class="comment"># 使用attach_file实例函数添加附件路径</span></span><br><span class="line"></span><br><span class="line">    email.send()</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Down'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;发送邮件&quot;&gt;&lt;a href=&quot;#发送邮件&quot; class=&quot;headerlink&quot; title=&quot;发送邮件&quot;&gt;&lt;/a&gt;发送邮件&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;django&lt;/code&gt;中内置了许多方法可以使开发者方便的进行邮件发送&lt;/p&gt;
&lt;/blockquote&gt;&lt;h3 id=&quot;邮件配置&quot;&gt;&lt;a href=&quot;#邮件配置&quot; class=&quot;headerlink&quot; title=&quot;邮件配置&quot;&gt;&lt;/a&gt;邮件配置&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;发送邮件，首先需要在项目的&lt;code&gt;settings.py&lt;/code&gt;文件下配置邮件服务器连接等信息&lt;/p&gt;
&lt;/blockquote&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;EMAIL_USE_SSL = &lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# Secure Sockets Layer 安全套接层, 取决于邮件服务器是否开启加密协议&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EMAIL_HOST = &lt;span class=&quot;string&quot;&gt;&#39;smtp.qq.com&#39;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;# 邮件服务器地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EMAIL_PORT = &lt;span class=&quot;number&quot;&gt;465&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# 邮件服务器端口 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EMAIL_HOST_USER = &lt;span class=&quot;string&quot;&gt;&#39;account@qq.com&#39;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# 登陆邮件服务器的账号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EMAIL_HOST_PASSWORD = &lt;span class=&quot;string&quot;&gt;&#39;password&#39;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;# 登陆邮件服务器的密码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DEFAULT_FROM_EMAIL = EMAIL_HOST_USER &lt;span class=&quot;comment&quot;&gt;# 邮件的发送者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django缓存系统</title>
    <link href="https://cy-blogs.cn/Django%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F/"/>
    <id>https://cy-blogs.cn/Django缓存系统/</id>
    <published>2019-12-09T08:16:28.960Z</published>
    <updated>2019-12-09T11:26:29.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><blockquote><p><code>Django</code> 是动态<code>Web</code>后台框架，需要实时生成用户访问的页面，进行多次的数据库操作，但是多次的数据库访问操作对于整个<code>Web</code>系统来说，会影响效率，尤其是当访问量增大时，数据库的压力也会越来越大。</p><p>相对于磁盘及内存操作，数据库的访问操作付出的成本要大的多</p></blockquote><blockquote><p>浏览器第一次请求时，<code>cache</code>会缓存单个变量或整个网页等内容到硬盘或者内存中，同时设置<code>response</code>头部</p><p>当浏览器再次发起请求时，会与缓存中的过期时间相比较，如果缓存时间比较新，则会重新请求数据，并缓存起来然后返回<code>response</code>给客户端，如果缓存没有过期，则直接从缓存中提取数据，返回给<code>response</code>给客户端</p></blockquote><a id="more"></a><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><blockquote><p><code>HTTP</code>协议头<code>Cache-Control</code>，<code>Cache-Control</code>与<code>Expires</code>的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过<code>Cache-Control</code>的选择更多，设置更细致，如果同时设置的话，其优先级高于<code>Expires</code></p></blockquote><blockquote><p>在<code>python</code>中使用<code>memcached</code>需要我们额外安装<code>memcached</code>作为<code>memcache</code>客户端的支持</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install python-memcached -<span class="selector-tag">i</span> https:<span class="comment">//pypi.tuna.tsinghua.edu.cn/simple</span></span><br></pre></td></tr></table></figure><h3 id="Cache设置"><a href="#Cache设置" class="headerlink" title="Cache设置"></a>Cache设置</h3><h4 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h4><ul><li><p>安装<code>memcached</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install memcached</span><br><span class="line"><span class="comment"># debian</span></span><br><span class="line">yum install memcached </span><br><span class="line"><span class="comment"># centos</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件：<code>/etc/memcached.conf</code></p><blockquote><p>配置文件中有两个可能需要修改的参数</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-m <span class="number">64</span> #memcached所能使用的内存大小</span><br><span class="line">-l <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> #监听的IP地址</span><br></pre></td></tr></table></figure></li><li><p>开启|关闭<code>memcached</code>服务</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> memcached <span class="comment"># 开启</span></span><br><span class="line">systemctl <span class="literal">stop</span> memcached <span class="comment"># 关闭</span></span><br></pre></td></tr></table></figure></li><li><p>查看服务状态</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systemctl status memcached</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="settings配置"><a href="#settings配置" class="headerlink" title="settings配置"></a>settings配置</h4><blockquote><p>使用<code>memcached</code>缓存，首先需要在项目的<code>settings</code>文件下进行配置</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.core.cache.backends.memcached.MemcachedCache'</span>,  </span><br><span class="line">        <span class="comment"># 指定缓存使用的引擎</span></span><br><span class="line">        <span class="string">'LOCATION'</span>:<span class="string">'172.16.19.26:11211'</span>, </span><br><span class="line">        <span class="comment"># 指定缓存服务器地址，常为本机地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="视图缓存"><a href="#视图缓存" class="headerlink" title="视图缓存"></a>视图缓存</h4><blockquote><p>可以只为某些视图函数进行缓存</p><p>使用<code>django.views.decorators.cache</code>下的装饰器<code>cache_page</code>进行视图函数装饰即可</p></blockquote><ul><li>模型类的表代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>,verbose_name=<span class="string">'名字'</span>)</span><br></pre></td></tr></table></figure><ul><li>视图函数代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.cache <span class="keyword">import</span> cache_page</span><br><span class="line"></span><br><span class="line"><span class="meta">@cache_page(10) # 缓存10秒</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    print(<span class="string">'视图函数被调用'</span>)</span><br><span class="line">    ss = models.People.objects.all()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'index.html'</span>, locals())</span><br></pre></td></tr></table></figure><ul><li>模板页面代码</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>展示数据<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    &#123;% for s in ss %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; s.name &#125;&#125; <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在第一次刷新浏览器之后，</p><p>立即在数据库中添加一个新的数据对象</p><p>接着继续刷新浏览器，前端页面将会读取缓存中的结果，而不会显示刚才添加的用户</p></blockquote><blockquote><p>除了在视图函数上使用装饰器进行缓存设置，还可以在路由匹配部分使用相同装饰器函数进行设置</p></blockquote><h4 id="全站缓存"><a href="#全站缓存" class="headerlink" title="全站缓存"></a>全站缓存</h4><blockquote><p>将整站所有视图设置缓存，需要在配置文件的中间件设置首尾部分添加如下内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">'django.middleware.cache.UpdateCacheMiddleware'</span>, <span class="comment"># 首部要添加的中间件</span></span><br><span class="line">    <span class="comment"># 将response缓存起来 </span></span><br><span class="line">    <span class="string">'django.middleware.security.SecurityMiddleware'</span>,</span><br><span class="line">...</span><br><span class="line">    <span class="string">'django.middleware.cache.FetchFromCacheMiddleware'</span>,<span class="comment"># 尾部要添加的中间件</span></span><br><span class="line">    <span class="comment"># 将缓存的response取出来</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>以及搭配设置当前全站缓存有效时间的全局变量</p></blockquote><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CACHE_MIDDLEWARE_SECONDS</span> = <span class="number">10</span> <span class="comment"># 每页页面缓存的秒数，默认为600</span></span><br></pre></td></tr></table></figure><h4 id="局部缓存"><a href="#局部缓存" class="headerlink" title="局部缓存"></a>局部缓存</h4><blockquote><p>局部缓存主要为在模板页面，选择某个区域进行缓存，当用户再次访问相同页面时，如设置缓存未过期，则渲染时局部缓存不会重新生成</p></blockquote><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">load</span></span> cache %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">局部缓存首先需要加载cache标签</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">cache</span> sec key %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">endcache</span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><blockquote><p>以时间模板变量为例，做一个简单的测试，后台视图函数每次在访问时，返回当前时间</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time </span><br><span class="line">now = time.strftime(<span class="string">'%H:%M:%S'</span>, time.localtime())</span><br></pre></td></tr></table></figure><blockquote><p>模板页面在使用时的代码</p></blockquote><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">load</span></span> cache %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是未缓存的时间:</span><span class="template-variable">&#123;&#123; now &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">cache</span> 10 time %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这里是缓存的时间:</span><span class="template-variable">&#123;&#123; now &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name">endcache</span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><h4 id="手动缓存"><a href="#手动缓存" class="headerlink" title="手动缓存"></a>手动缓存</h4><blockquote><p>除了以上应用于各个业务中的缓存方式，还可以使用<code>django</code>所提供的<code>cache</code>接口进行缓存设置以及获取</p></blockquote><ul><li>设置缓存</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.cache <span class="keyword">import</span> cache</span><br><span class="line"><span class="comment">#存储缓存数据</span></span><br><span class="line">cache.set(<span class="string">'cache_key'</span>,data,<span class="number">60</span>*<span class="number">15</span>)</span><br><span class="line"><span class="comment">#cache_key为存储在缓存中的唯一值，data为存储的数据，60*15为缓存有效时间</span></span><br></pre></td></tr></table></figure><ul><li>获取缓存</li></ul><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#获取缓存数据</span></span><br><span class="line">cache.<span class="keyword">get</span>(<span class="string">'cache_key'</span>,<span class="string">'获取不到的默认值'</span>)</span><br><span class="line"><span class="meta">#cache_key为储存缓存数据的唯一值</span></span><br></pre></td></tr></table></figure><ul><li>避免<code>key</code>值重复导致更新缓存，可以使用<code>cache.add</code>函数，基本用法与<code>set</code>相同</li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">status = cache.add(<span class="string">'add_key'</span>, <span class="string">'New value'</span>)</span><br><span class="line"># 当指定key值的缓存存在，add方法不会尝试更新缓存</span><br><span class="line"># 返回值status为<span class="literal">True</span>时，代表存储成功，<span class="literal">False</span>代表存储失败</span><br></pre></td></tr></table></figure><ul><li>清除缓存，通过<code>cache.delete</code>方法，该方法接收一个缓存<code>key</code>值</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache.<span class="keyword">delete</span>(<span class="string">'cache_key'</span>)</span><br></pre></td></tr></table></figure><ul><li>清空缓存，通过<code>cache.clear</code>方法，直接从缓存中清除所有</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache.<span class="built_in">clear</span>()</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p><code>memcached</code>不允许使用超过<code>250</code>个字符或包含空格或控制字符的缓存键值</p><p>使用这样的键值将会导致异常</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缓存&quot;&gt;&lt;a href=&quot;#缓存&quot; class=&quot;headerlink&quot; title=&quot;缓存&quot;&gt;&lt;/a&gt;缓存&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Django&lt;/code&gt; 是动态&lt;code&gt;Web&lt;/code&gt;后台框架，需要实时生成用户访问的页面，进行多次的数据库操作，但是多次的数据库访问操作对于整个&lt;code&gt;Web&lt;/code&gt;系统来说，会影响效率，尤其是当访问量增大时，数据库的压力也会越来越大。&lt;/p&gt;
&lt;p&gt;相对于磁盘及内存操作，数据库的访问操作付出的成本要大的多&lt;/p&gt;
&lt;/blockquote&gt;&lt;blockquote&gt;
&lt;p&gt;浏览器第一次请求时，&lt;code&gt;cache&lt;/code&gt;会缓存单个变量或整个网页等内容到硬盘或者内存中，同时设置&lt;code&gt;response&lt;/code&gt;头部&lt;/p&gt;
&lt;p&gt;当浏览器再次发起请求时，会与缓存中的过期时间相比较，如果缓存时间比较新，则会重新请求数据，并缓存起来然后返回&lt;code&gt;response&lt;/code&gt;给客户端，如果缓存没有过期，则直接从缓存中提取数据，返回给&lt;code&gt;response&lt;/code&gt;给客户端&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django的消息框架(message)与Django分页组件(paginator)</title>
    <link href="https://cy-blogs.cn/Django%E7%9A%84%E6%B6%88%E6%81%AF%E6%A1%86%E6%9E%B6(message)%E4%B8%8EDjango%E5%88%86%E9%A1%B5%E7%BB%84%E4%BB%B6(paginator)/"/>
    <id>https://cy-blogs.cn/Django的消息框架(message)与Django分页组件(paginator)/</id>
    <published>2019-12-09T08:11:25.363Z</published>
    <updated>2019-12-09T11:26:22.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Messages消息框架"><a href="#Messages消息框架" class="headerlink" title="Messages消息框架"></a>Messages消息框架</h2><blockquote><p>在网页应用中，你经常需要在处理完表单或其它类型的用户输入后。显示一个通知消息（也叫做<code>flash message</code>给用户</p><p>对于这个功能，<code>Django</code>提供基于<code>Cookie</code> 和会话的消息，无论是匿名用户还是认证的用户。</p><p>其消息框架允许你临时将消息存储在请求中，并在接下来的请求（通常就是下一个请求）中提取它们并显示。每个消息都带有一个特定<code>level</code> 标签，表示其优先级（例如<code>info</code>、<code>warning</code> 或<code>error</code>）</p></blockquote><a id="more"></a><blockquote><p><code>django-admin startproject</code> 创建的默认<code>settings.py</code> 已经包含启用消息框架功能需要的所有的设置</p></blockquote><blockquote><ul><li><code>INSTALLED_APPS</code> 中的<code>&#39;django.contrib.messages&#39;</code>。</li><li><code>MIDDLEWARE_CLASSES</code> 中的<code>&#39;django.contrib.sessions.middleware.SessionMiddleware&#39;</code> 和<code>&#39;django.contrib.messages.middleware.MessageMiddleware&#39;</code></li></ul><p>默认的后端存储 依赖<code>[sessions]</code></p><p>所以<code>MIDDLEWARE_CLASSES</code> 中必须启用<code>SessionMiddleware</code> 并出现在<code>MessageMiddleware</code> 之前</p><ul><li><code>TEMPLATES</code> 设置中定义的<code>DjangoTemplates</code> 的<code>&#39;context_processors&#39;</code> 选项包含<code>&#39;django.contrib.messages.context_processors.messages&#39;</code></li></ul></blockquote><h3 id="消息级别"><a href="#消息级别" class="headerlink" title="消息级别"></a>消息级别</h3><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">from</span> django.contrib <span class="keyword">import</span> messages</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><code>messages.debug</code></li><li><code>messages.info</code></li><li><code>messages.success</code></li><li><code>messages.warning</code></li><li><code>messages.error</code></li></ul><h3 id="使用消息框架"><a href="#使用消息框架" class="headerlink" title="使用消息框架"></a>使用消息框架</h3><blockquote><p>视图函数只需要创建<code>messages</code>消息对象即可</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">messages.warning(request,<span class="string">'登陆失败，用户名或密码无效'</span>)</span><br><span class="line"><span class="keyword">return</span> render(request,<span class="string">'login.html'</span>,locals())</span><br></pre></td></tr></table></figure><blockquote><p>前端模板中判断是否含有<code>messages</code>消息，遍历取出即可</p><p>也可以结合<code>bootstrap</code>框架让提示消息变得更加美丽</p></blockquote><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> messages %&#125;</span><span class="xml">   </span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">for</span></span> message <span class="keyword">in</span> messages %&#125;</span><span class="xml">  </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"alert alert-</span></span></span><span class="template-variable">&#123;&#123; message.tags &#125;&#125;</span><span class="xml"><span class="tag"><span class="string"> fade in"</span>&gt;</span>   </span></span><br><span class="line"><span class="xml"></span><span class="template-variable">&#123;&#123; message &#125;&#125;</span><span class="xml">     </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endfor</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：<code>messages</code>对象是一个数据集，并不是单独的一条消息，需要我们在使用时，必须通过<code>for</code>循环进行访问</p></blockquote><h2 id="Paginator分页组件"><a href="#Paginator分页组件" class="headerlink" title="Paginator分页组件"></a>Paginator分页组件</h2><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">from</span> django.core.paginator <span class="keyword">import</span> Paginator, EmptyPage, PageNotAnInteger</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Paginator</span></span><br></pre></td></tr></table></figure><p>：创建分页对象</p><h3 id="分页对象内置属性"><a href="#分页对象内置属性" class="headerlink" title="分页对象内置属性"></a>分页对象内置属性</h3></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">all_ = models.objects.all()p = Paginator(all_, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 分页all_数据，每页显示10条数据</span></span><br><span class="line">p.count</span><br><span class="line"><span class="comment"># 总数据量</span></span><br><span class="line">p.num_pages() </span><br><span class="line"><span class="comment"># 分页数</span></span><br><span class="line">p.page_range() </span><br><span class="line"><span class="comment"># 列表形式返回当前可有的页数 [1,2,3]</span></span><br><span class="line">page_1 = p.page(<span class="number">1</span>) </span><br><span class="line"><span class="comment"># 选择第一页，返回第一页数据对象</span></span><br><span class="line">page_1.object_list</span><br><span class="line"><span class="comment"># 返回第一页所有数据</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> page_1:</span><br><span class="line">    print(var)ABC...</span><br></pre></td></tr></table></figure><h3 id="某一页内置属性"><a href="#某一页内置属性" class="headerlink" title="某一页内置属性"></a>某一页内置属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">page_1.number </span><br><span class="line"><span class="comment"># 当前页的页码</span></span><br><span class="line">page_1.has_next() </span><br><span class="line"><span class="comment"># 是否有下一页</span></span><br><span class="line">page_1.has_previous()</span><br><span class="line"><span class="comment"># 是否有上一页</span></span><br><span class="line">page_1.has_other_pages()</span><br><span class="line"><span class="comment"># 是否含有其他页</span></span><br><span class="line">page_1.next_page_number() </span><br><span class="line"><span class="comment"># 下一页的页码</span></span><br><span class="line">page_1.previous_page_number()</span><br><span class="line"><span class="comment"># 上一页的页码</span></span><br><span class="line">page_1.start_index() </span><br><span class="line"><span class="comment"># 该页第一个数据的索引</span></span><br><span class="line">page_1.end_index()</span><br><span class="line"><span class="comment"># 该页最后一个数据的索引</span></span><br></pre></td></tr></table></figure><ul><li><p><code>EmptyPage</code>：取不到页面数据，抛出该异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">all_ = models.objects.all()</span><br><span class="line">p = Paginator(all_, <span class="number">10</span>)<span class="keyword">try</span>:   </span><br><span class="line">    list_ = p.page(page_num)</span><br><span class="line">    <span class="keyword">except</span> EmptyPage:</span><br><span class="line">        <span class="comment">#没有第page_num页   </span></span><br><span class="line">        list_ = paginator.page(<span class="number">1</span>) </span><br><span class="line">        <span class="comment"># 取不到该也数据，直接返回第一页数据</span></span><br></pre></td></tr></table></figure></li><li><p><code>PageNotAnInteger</code>：当页数是一个非整数类型时，抛出该异常</p></li></ul><h3 id="模板页面基本使用方式"><a href="#模板页面基本使用方式" class="headerlink" title="模板页面基本使用方式"></a>模板页面基本使用方式</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> topic_list.has_previous %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 当前页是否含有上一页 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"?page=</span></span></span><span class="template-variable">&#123;&#123; list_.previous_page_number &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span>上一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 连接传参形式传递上一页的页码ID --&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> topic_list.has_next %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 当前页是否含有下一页 --&gt;</span> </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"?page=</span></span></span><span class="template-variable">&#123;&#123; list_.next_page_number &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span>下一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 连接传参形式传递下一页的页码ID --&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Messages消息框架&quot;&gt;&lt;a href=&quot;#Messages消息框架&quot; class=&quot;headerlink&quot; title=&quot;Messages消息框架&quot;&gt;&lt;/a&gt;Messages消息框架&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在网页应用中，你经常需要在处理完表单或其它类型的用户输入后。显示一个通知消息（也叫做&lt;code&gt;flash message&lt;/code&gt;给用户&lt;/p&gt;
&lt;p&gt;对于这个功能，&lt;code&gt;Django&lt;/code&gt;提供基于&lt;code&gt;Cookie&lt;/code&gt; 和会话的消息，无论是匿名用户还是认证的用户。&lt;/p&gt;
&lt;p&gt;其消息框架允许你临时将消息存储在请求中，并在接下来的请求（通常就是下一个请求）中提取它们并显示。每个消息都带有一个特定&lt;code&gt;level&lt;/code&gt; 标签，表示其优先级（例如&lt;code&gt;info&lt;/code&gt;、&lt;code&gt;warning&lt;/code&gt; 或&lt;code&gt;error&lt;/code&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django的CBV类视图</title>
    <link href="https://cy-blogs.cn/Django%E7%9A%84CBV%E7%B1%BB%E8%A7%86%E5%9B%BE/"/>
    <id>https://cy-blogs.cn/Django的CBV类视图/</id>
    <published>2019-12-09T08:07:02.109Z</published>
    <updated>2019-12-09T11:26:26.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CBV"><a href="#CBV" class="headerlink" title="CBV"></a>CBV</h2><blockquote><p><strong>CBV（class base views）</strong> 就是在视图里使用类处理请求</p><p>之前的代码中，我们的视图函数都是通过函数来进行<code>request</code>的响应以及<code>response</code>的返回，并且通常我们需要判断的请求方式<code>get</code>或是<code>post</code>都需要我们在代码中通过<code>if</code>进行条件判断，这样的视图功能编写就叫做<code>FBV</code></p></blockquote><blockquote><p>但现在在<code>django</code>中还提供了一种方式叫做<code>CBV</code>，在类中编写视图功能， 并且将传统的<code>get</code>、<code>post</code>判断设置为了类中函数，这样当用户发起不同的请求，会自动进入到对应的类中函数上，像是下面这样</p></blockquote><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleView</span><span class="params">(View)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span>   </span><br><span class="line">        <span class="keyword">raise</span> Http404   </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> request.is_ajax():  </span><br><span class="line">                id_ = request.POST.get(<span class="string">'id_'</span>)    </span><br><span class="line">                result = models.Article.objects.get(id=id_).content    </span><br><span class="line">                data = result.replace(<span class="string">'\r\n'</span>,<span class="string">'&lt;br&gt;'</span>)  </span><br><span class="line">                <span class="keyword">return</span> HttpResponse(json.dumps(data,ensure_ascii=<span class="literal">False</span>) )  </span><br><span class="line">            <span class="keyword">raise</span> Http404</span><br></pre></td></tr></table></figure><blockquote><p>通过将请求类型定义为函数，可以更加方便进行请求方式判断</p><p>用户访问时，会经由<code>View</code>基类中的<code>as_view -&gt; dispatch</code>进行判断，通过请求类型分发到不同对应请求的函数名下；也就是通过<code>get</code>方式访问，那么对应会调用到名为<code>get</code>的函数</p><p>此外，类中函数必须为小写，</p></blockquote><ul><li>对应路由此时设置为，需要使用试图类的<code>as_view</code>函数进行实例化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#url.py</span></span><br><span class="line">path(<span class="string">'article/'</span>,ajaxviews.ArticleView.as_view())</span><br></pre></td></tr></table></figure><blockquote><p>通过类视图可以方便我们进行请求条件的判断</p><p>并且可以在进行接口开发时，实现同一资源路由在使用不同请求访问时的功能解耦和</p><p>意思就是不用再把所有的功能都堆到一个视图函数里啦。多方便！</p><p>并且，在<code>Django-Restframework</code>框架中，也将频繁使用<code>CBV</code>形式进行视图编写</p></blockquote><h4 id="类视图装饰器"><a href="#类视图装饰器" class="headerlink" title="类视图装饰器"></a>类视图装饰器</h4><blockquote><p>在类视图中使用为函数视图准备的装饰器时，不能直接添加装饰器</p><p>需要使用method_decorator将其转换为适用于类视图方法的装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li>全部装饰</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(func)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nei</span><span class="params">(request)</span>:</span> </span><br><span class="line">        <span class="comment"># dispatch函数有参数request</span></span><br><span class="line">        print(<span class="string">'这是装饰器在调用'</span>)  </span><br><span class="line">        <span class="keyword">return</span> func(request) </span><br><span class="line">    <span class="keyword">return</span> nei@method_decorator(my_decorator, name=<span class="string">'dispatch'</span>)</span><br><span class="line"><span class="comment"># 为全部请求方法添加装饰器class DemoView(View): </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span>    </span><br><span class="line">    print(<span class="string">'get方法'</span>)     </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span>    </span><br><span class="line">    print(<span class="string">'post方法'</span>)     </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)</span><br></pre></td></tr></table></figure><ul><li>为部分装饰，只需要通过<code>method_decorator</code>方法的<code>name</code>参数选择装饰的函数名即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@method_decorator(my_decorator, name='post')</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoView</span><span class="params">(View)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span>  </span><br><span class="line">        print(<span class="string">'get方法'</span>)       </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span>     </span><br><span class="line">        print(<span class="string">'post方法'</span>)       </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)</span><br></pre></td></tr></table></figure><ul><li>为特定的多个类视图函数进行装饰，只需要在每个函数上使用<code>method_decorator</code>装饰器即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoView</span><span class="params">(View)</span>:</span>  </span><br><span class="line"><span class="meta">    @method_decorator(my_decorator) </span></span><br><span class="line">    <span class="comment"># 为get方法添加了装饰器  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)</span><br><span class="line"><span class="meta">    @method_decorator(my_decorator) </span></span><br><span class="line">    <span class="comment"># 为post方法添加了装饰器    </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)</span><br></pre></td></tr></table></figure><h4 id="类视图csrf-token装饰"><a href="#类视图csrf-token装饰" class="headerlink" title="类视图csrf_token装饰"></a>类视图<code>csrf_token</code>装饰</h4><blockquote><p>当类视图需要允许跨站提交数据时，使用<code>csrf_exempt</code>装饰器装饰函数可以被跨域访问</p><p>但是使用上面的方法进行<code>csrf_exempt</code>是不行的，需要在类视图基类的<code>dispatch</code>函数上进行装饰</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="comment">#@method_decorator(csrf_exempt,name='dispatch')</span></span><br><span class="line"><span class="comment"># 直接加载类视图上也是可以修饰的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoView</span><span class="params">(View)</span>:</span> </span><br><span class="line"><span class="meta">    @method_decorator(csrf_exempt)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span><span class="params">(self, request, *args, **kwargs)</span>:</span> </span><br><span class="line">        <span class="keyword">return</span> super(DemoView,self).dispatch(request, *args, **kwargs) </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span> </span><br><span class="line">        print(<span class="string">'get方法'</span>)    </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span>   </span><br><span class="line">        print(<span class="string">'post方法'</span>)      </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'ok'</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>csrf</code>装饰只能在类视图的<code>dispatch</code>函数上才能被生效</p></blockquote><blockquote><p>除了在类视图的<code>dispatch</code>函数上进行装饰，在路由映射处使用<code>csrf_exempt</code>函数修饰路由规则也是可以的</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line">urlpatterns = [  </span><br><span class="line">    ...   </span><br><span class="line">    path(<span class="string">''</span>,csrf_exempt(ajaxviews.DemoView.as_view()))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CBV&quot;&gt;&lt;a href=&quot;#CBV&quot; class=&quot;headerlink&quot; title=&quot;CBV&quot;&gt;&lt;/a&gt;CBV&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;CBV（class base views）&lt;/strong&gt; 就是在视图里使用类处理请求&lt;/p&gt;
&lt;p&gt;之前的代码中，我们的视图函数都是通过函数来进行&lt;code&gt;request&lt;/code&gt;的响应以及&lt;code&gt;response&lt;/code&gt;的返回，并且通常我们需要判断的请求方式&lt;code&gt;get&lt;/code&gt;或是&lt;code&gt;post&lt;/code&gt;都需要我们在代码中通过&lt;code&gt;if&lt;/code&gt;进行条件判断，这样的视图功能编写就叫做&lt;code&gt;FBV&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;blockquote&gt;
&lt;p&gt;但现在在&lt;code&gt;django&lt;/code&gt;中还提供了一种方式叫做&lt;code&gt;CBV&lt;/code&gt;，在类中编写视图功能， 并且将传统的&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;post&lt;/code&gt;判断设置为了类中函数，这样当用户发起不同的请求，会自动进入到对应的类中函数上，像是下面这样&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django初识</title>
    <link href="https://cy-blogs.cn/Django%E5%88%9D%E8%AF%86/"/>
    <id>https://cy-blogs.cn/Django初识/</id>
    <published>2019-12-09T07:48:31.829Z</published>
    <updated>2019-12-09T11:35:21.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始玩耍Django"><a href="#开始玩耍Django" class="headerlink" title="开始玩耍Django"></a>开始玩耍Django</h2><blockquote><p><em>Django</em>是一个开放源代码的<code>Web</code>应用框架，由<code>Python</code>写成。采用了<code>MVT</code>的框架模式；最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是<code>CMS</code>（内容管理系统）软件</p><p>框架是以比利时的吉普赛爵士吉他手<code>Django Reinhardt</code>来命名的</p></blockquote><h3 id="django安装"><a href="#django安装" class="headerlink" title="django安装"></a>django安装</h3><a id="more"></a><blockquote><p><code>pip install django==2.0.4</code>(版本号)</p><p><code>pip install django</code>默认安装最新版本</p></blockquote><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> django-admin startproject myproject</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><h3 id="开启开发服务器"><a href="#开启开发服务器" class="headerlink" title="开启开发服务器"></a>开启开发服务器</h3><blockquote><p><code>cd myproject</code>：进入项目目录</p><p><code>python manage.py runserver</code>：开启服务</p><p><code>python manage.py runserver 7000</code>：改变服务监听端口</p><p><code>python manage.py runserver 0:8000</code>：改变服务监听IP:端口</p></blockquote><h3 id="项目文件夹"><a href="#项目文件夹" class="headerlink" title="项目文件夹"></a>项目文件夹</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">manage.<span class="keyword">py</span>：用来管理当前项目的一个命令行工具</span><br><span class="line">myproject/： 项目主文件夹</span><br><span class="line">myproject/__init__.<span class="keyword">py</span>：空文件，用来指明当前的myproject为一个可导入的模块包</span><br><span class="line">myproject/settings.<span class="keyword">py</span>：项目主要配置文件myproject/urls.<span class="keyword">py</span>：项目主要路由配置文件myproject/wsgi.<span class="keyword">py</span>：项目部署WSGI并发服务器时所需要的配置文件</span><br></pre></td></tr></table></figure><h3 id="Settings-py"><a href="#Settings-py" class="headerlink" title="Settings.py"></a>Settings.py</h3><blockquote><p>该文件是整个项目的主控文件，其中相关配置选项如下</p><p><a href="https://docs.djangoproject.com/zh-hans/2.0/ref/settings/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.0/ref/settings/</a></p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>BASE_DIR: 当前项目工作目录，用来在每一次开启项目时动态找到相关资源路径</span><br><span class="line"><span class="bullet">- </span>SECRET_KEY: 加密的hash值以及保护某些签名数据的关键密钥</span><br><span class="line"><span class="bullet">- </span>DEBUG: 调试模式</span><br><span class="line"><span class="bullet">- </span>ALLOWED_HOSTS: 有哪些主机或域名可以访问当前django站点，如设置为*代表全部可访问。</span><br><span class="line"><span class="bullet">- </span>INSTALL_APPS: django项目中所有使用的应用名称，自创建子应用也要加到这里，不然ORM数据库无法被识别到！</span><br><span class="line"><span class="bullet">- </span>MIDDLEWARE: django中间件，用来在request或reponse过程中添加功能，比如确保安全性，传输保存Session等</span><br><span class="line"><span class="bullet">- </span>SecurityMiddleware: xss脚本过滤，一些安全设置</span><br><span class="line"><span class="bullet">- </span>SessionMiddleware: session支持中间件，在每次用户访问django项目时，添加session对每一个浏览器</span><br><span class="line"><span class="bullet">- </span>CommonMiddleware: 通用组件，比如为路由添加末尾斜杠</span><br><span class="line"><span class="bullet">- </span>CsrfViewMiddleware: 防跨站请求伪造令牌，为客户端添加csrf_token密钥，在表单提交时需提交该值</span><br><span class="line"><span class="bullet">- </span>AuthenticationMiddleware: admin用户组件，每个request对象都会被添加admin下的user属性</span><br><span class="line"><span class="bullet">- </span>MessageMiddleware: 消息中间件 展示一些后台消息给前端</span><br><span class="line"><span class="bullet">- </span>XFrameOptionsMiddleware: 防止欺骗点击攻击出现；自身页面被嵌入到他人页面中，点击欺骗</span><br><span class="line"><span class="bullet">- </span>ROOT_URLCONF: 主路由配置文件，字符串填写url.py文件路径</span><br><span class="line"><span class="bullet">- </span>TEMPLATES: 模板文件配置项</span><br><span class="line"><span class="bullet">- </span>WSGI_APPLICATION: WSGI服务器配置项，找到当前django下的wsgi引入APP文件</span><br><span class="line"><span class="bullet">- </span>DATABASES: 数据库配置项，默认使用SQLite3，一个本地文件数据库</span><br><span class="line"><span class="bullet">- </span>AUTH<span class="emphasis">_PASSWORD_</span>VALIDATORS: 检查用户密码强度的验证程序列表，不过是针对admin界面下的用户，而非自定义</span><br><span class="line"><span class="bullet">- </span>LANGUAGE_CODE: django所使用语言文件</span><br><span class="line"><span class="bullet">- </span>TIME_ZONE: django所使用时区</span><br><span class="line"><span class="bullet">- </span>USE_I18N: 国际化支持 18表示Internationalization这个单词首字母I和结尾字母N之间的字母有18个</span><br><span class="line"><span class="bullet">- </span>USE_L10N: 是localization的缩写形式，意即在l和n之间有10个字母</span><br><span class="line"><span class="bullet">- </span>USE_TZ:开启了Time Zone功能，则所有的存储和内部处理，包括print显示的时间将是是UTC时间格式</span><br><span class="line"><span class="bullet">- </span>STATIC_URL: URL访问静态资源时的路径</span><br></pre></td></tr></table></figure><h2 id="来搞个Hello-world"><a href="#来搞个Hello-world" class="headerlink" title="来搞个Hello world"></a>来搞个Hello world</h2><h3 id="django创建子应用"><a href="#django创建子应用" class="headerlink" title="django创建子应用"></a>django创建子应用</h3><blockquote><p>项目和应用有啥区别？</p><p>应用是一个专门做某件事的网络应用程序：比如博客系统，或者公共记录的数据库，或者简单的投票程序</p><p>项目则是一个网站使用的配置和应用的集合。项目可以包含很多个<code>app</code>应用，应用可以被很多个项目使用</p></blockquote><ul><li><p><code>python manage.py startapp myapp</code></p><blockquote><p>创建子应用</p></blockquote></li></ul><h3 id="app目录"><a href="#app目录" class="headerlink" title="app目录"></a>app目录</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- admin<span class="selector-class">.py</span>: app在admin注册展示时需要的文件</span><br><span class="line">- views<span class="selector-class">.py</span>: app的功能视图函数文件</span><br><span class="line">- models<span class="selector-class">.py</span>: app需要使用数据库时的文件</span><br><span class="line">- urls<span class="selector-class">.py</span>: 当使用include路由分发时，每个app应该有他自己的子路由文件，这个是默认没有创建好的</span><br></pre></td></tr></table></figure><h3 id="视图函数"><a href="#视图函数" class="headerlink" title="视图函数"></a>视图函数</h3><blockquote><p>打开<code>app</code>下的<code>views.py</code>文件</p><p><code>Web</code>访问起始就是通过一个<code>URL</code>连接地址访问到服务器上的一个函数</p><p>在<code>views.py</code>中我们通过编写函数的形式，接收用户请求的<code>request</code>并返回一个<code>response</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每一个视图函数都需要有一个必须参数 </span></span><br><span class="line">request,用来接收用户访问时的请求内容</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span>   </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"&lt;h1&gt;Hello world&lt;/h1&gt;"</span>)</span><br></pre></td></tr></table></figure><ul><li><code>HttpResponse</code>函数用来向用户返回一个字符串</li></ul><h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><blockquote><p>创建好了一个可以在请求时返回<code>H1</code>标签的视图函数，但是现在通过浏览器还是访问不到</p><p>需要我们为这个<code>app</code>下的函数进行路由配置</p></blockquote><blockquote><p>第一种简单的路由配置，直接在主控路由文件下，找到这个视图函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myproject/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [    path(<span class="string">'admin/'</span>, admin.site.urls), </span><br><span class="line">               <span class="comment">#admin控制界面路由   </span></span><br><span class="line">               path(<span class="string">''</span>,views.index)  </span><br><span class="line">               <span class="comment">#path函数第一个参数为访问地址，空字符串代表：当用户直接访问首页时  </span></span><br><span class="line">               <span class="comment">#第二个参数代表访问该地址时对应的视图函数，我们引入了app下的views中的index视图函数</span></span><br><span class="line">              ]</span><br></pre></td></tr></table></figure><ul><li>接下来访问<code>127.0.0.1:8000</code>，那么你会看到一个非常大的<code>Hello world</code></li></ul><blockquote><p>以上将视图函数的查找直接写到主控路由并不是最好的办法</p><p>我们的项目通常会有非常多的路由配置项，如果都堆到这个文件中肯定是非常乱的，难以维护</p></blockquote><ul><li>我们可以在对应<code>app</code>下创建一个子路由控制文件，并在其中设置视图的路由配置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myapp/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [    path(<span class="string">""</span>,views.index)]</span><br></pre></td></tr></table></figure><blockquote><p>现在虽然配置了<code>app</code>下的路由文件，但是访问时，是看不到对应视图的结果</p><p>这是因为默认的<code>url</code>查找动作将会从主控路由文件开始，我们还需要在主控路由文件下进行路由分发设置</p><p>让主控路由可以找到子<code>app</code>下的路由映射文件</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myproject/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [    path(<span class="string">'admin/'</span>, admin.site.urls),  </span><br><span class="line">               <span class="comment">#path('',views.index)   </span></span><br><span class="line">               path(<span class="string">''</span>,include(<span class="string">"myapp.urls"</span>)), </span><br><span class="line">               <span class="comment"># 函数 include() 允许引用其它 URLconfs</span></span><br><span class="line">              ]</span><br></pre></td></tr></table></figure><ul><li>接下来再次尝试，在浏览器中访问主机域名；如果可以看到的话，恭喜你，效果已经很棒了！</li></ul><h4 id="路由查找流程"><a href="#路由查找流程" class="headerlink" title="路由查找流程"></a>路由查找流程</h4><ol><li>查找主控路由文件下的<code>urlpatterns</code>全局变量，这是一个序列数据类型，其中每一个元素都是对应的一个路由匹配规则</li><li>如果在规则中查找到符合匹配规则的，则执行其中的对应执行函数</li><li>如果对应的不是一个执行函数，而是一个<code>include</code>路由包含，那么截断与此项匹配的<code>URL</code>的部分，并将剩余的路由字符串发送到<code>include</code>所包含的子路由文件中以供进一步处理</li><li>如果没有匹配到的任何结果，<code>django</code>默认抛出<code>Page not found (404)</code></li></ol><blockquote><p><strong>注意</strong>：<code>Django</code>的路由不考虑HTTP请求方式，仅根据<code>URL</code>进行路由，即，只要<code>URL</code>相同，无论<code>POST</code>、<code>GET</code>等哪种请求方式都指向同一个操作函数</p></blockquote><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><blockquote><p><code>path</code>函数用来处理一个路由对应的视图映射</p></blockquote><ul><li><p><code>path(route, view, name)</code></p><blockquote><p><code>route</code>： 匹配规则，是一个字符串</p><p><code>view</code>：对应的视图函数</p><p><code>name</code>：未来我们会用到他，用来为匹配规则命名，这样方便日后修改路由而不影响全局下的路由使用</p></blockquote></li></ul><h4 id="re-path"><a href="#re-path" class="headerlink" title="re_path"></a>re_path</h4><blockquote><p><code>re_path</code>是<code>path</code>函数的加强版</p><p>可以在<code>re_path</code>函数的第一个位置的字符串参数，是一个标准<code>Python</code>正则表达式，其余参数与<code>path</code>相同</p></blockquote><blockquote><p><strong>注意</strong>：匹配模式的最开头不需要添加<code>/</code>，因为默认情况下，每个<code>url</code>都带一个最前面的<code>/</code>，既然大家都有的部分，就不用浪费时间特别写一个了，所以一定要注意在写路由映射关系时，记得加末尾的<code>/</code></p></blockquote><h3 id="模板页面"><a href="#模板页面" class="headerlink" title="模板页面"></a>模板页面</h3><blockquote><p>返回一个字符串这肯定是不行的，太<code>low</code>了，也不好看，现在来返回一个正式的<code>HTML</code>页面</p><p>并在<code>HTML</code>页面中加入模板变量，由视图函数动态传递值；</p></blockquote><ul><li>配置<code>django</code>中模板页面的保存路径，在项目目录下的<code>settings.py</code>文件中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myproject/settings.py</span></span><br><span class="line">TEMPLATES = [  </span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.template.backends.django.DjangoTemplates'</span>,  </span><br><span class="line">        <span class="string">'DIRS'</span>: [os.path.join(BASE_DIR,<span class="string">'template'</span>)], </span><br><span class="line">        <span class="comment"># 就是这一行 设置静态模板路径   </span></span><br><span class="line">        <span class="string">'APP_DIRS'</span>: <span class="literal">True</span>,     </span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;       </span><br><span class="line">            <span class="string">'context_processors'</span>: [        </span><br><span class="line">                <span class="string">'django.template.context_processors.debug'</span>, </span><br><span class="line">                <span class="string">'django.template.context_processors.request'</span>,    </span><br><span class="line">                <span class="string">'django.contrib.auth.context_processors.auth'</span>, </span><br><span class="line">                <span class="string">'django.contrib.messages.context_processors.messages'</span>,  </span><br><span class="line">            ],    </span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,]</span><br></pre></td></tr></table></figure><ul><li><code>创建template</code>目录并在其中创建<code>index.html</code>文件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在<code>HTML</code>页面中，我们并没有明确指出<code>H1</code>标签的内容；通过一个``来等待接收视图函数传来的数据，在<code>HTML</code>页面中这样的变量也叫做<strong>模板变量</strong>，双大括号为使用语法</p></blockquote><ul><li>接下来修改之前的视图函数，由视图函数传递变量给到<code>HTML</code>页面</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myapp/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span> </span><br><span class="line">    <span class="comment">#return HttpResponse("&lt;h1&gt;Hello world&lt;/h1&gt;")  </span></span><br><span class="line">    content = &#123;       </span><br><span class="line">        <span class="string">"message"</span>:<span class="string">"你好，世界"</span> <span class="comment">#此处的key值message对应页面中我们写的&#123;&#123; message &#125;&#125;     </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'index.html'</span>,content)</span><br></pre></td></tr></table></figure><h4 id="render"><a href="#render" class="headerlink" title="render"></a>render</h4><blockquote><p>render函数用来返回一个模板页面，并将一个字典组合成的模板变量传递到模板页面上，完成页面的渲染</p></blockquote><ul><li><p><code>render(request, template_name, context=None)</code></p><blockquote><p>返回一个HTTP响应</p></blockquote><blockquote><p><code>request</code>： 固定接收<code>request</code>请求</p><p><code>template_name</code>： 为一个可以找到的模板页面</p><p><code>context</code>： 模板页面所需模板变量</p></blockquote></li></ul><h4 id="模板变量"><a href="#模板变量" class="headerlink" title="模板变量"></a>模板变量</h4><blockquote><p>在<code>django</code>中的<code>HTML</code>页面，不光可以编写原本的标签等内容，还可以像<code>Vue</code>一样在页面中使用双大括号，来提前定义一些模板变量，之后动态的渲染到<code>HTML</code>模板页面中</p></blockquote><blockquote><p>模板变量可以由后台视图函数构建一个<strong>字典数据类型</strong>传递，</p><p>字典的<code>key</code>是模板变量名，<code>value</code>值该模板变量对应的数据</p><p>当然，模板变量的内容远不止此，还会再后面继续为大家叙述</p></blockquote><h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><blockquote><p>虽然有了模板页面，可以来展示一些标签的效果，但是整个HTML还是感觉很丑陋</p><p>我们还要继续引入一些类似<code>css、img</code>这样的静态资源，来装饰我们的页面</p><p>在<code>django</code>中模板页面的静态资源使用，不能像之前写<code>HTML</code>代码直接引入</p><p>需要我们首先在项目中创建目录保存对应的静态资源，该目录名常为<code>static</code></p></blockquote><ul><li>在settings中配置静态文件保存目录，<strong>添加</strong>如下内容</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STATICFILES_DIRS = (    os.path.join(BASE_DIR, <span class="string">'static'</span>),)</span><br><span class="line"><span class="comment"># STATICFILES_DIRS 该配置项用来告诉django在查找静态资源时，应该访问哪个目录</span></span><br></pre></td></tr></table></figure><ul><li>在项目中创建<code>static</code>目录，<code>static</code>目录下创建专门保存图片的<code>img</code>目录，在里面存一张图片<code>1.jpg</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#此时的目录结构myproject/myproject/myapp/template/static/img/1.jpg</span></span><br></pre></td></tr></table></figure><ul><li>有了图片，接下来在模板页面中去引入并使用它，打开<code>index.html</code>进行修</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span> </span><br><span class="line">    &#123;% load staticfiles %&#125;<span class="tag">&lt;<span class="name">head</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">'&#123;% static "img/1.jpg" %&#125;'</span> <span class="attr">alt</span>=<span class="string">"图片"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">&gt; 这里用到了一个特殊语法：</span><span class="template-tag">&#123;% <span class="name">tag</span> %&#125;</span><span class="xml"> 这个叫静态标签，静态标签不同于模板变量，静态标签经常用来加载数据，或创建逻辑，比如之后我们要学到的</span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> %&#125;</span><span class="xml">，使用静态标签可以方便我们在模板页面上实现某些只有在后台代码中才可以实现的逻辑功能</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">&gt; 在页面中要引入静态资源：图片，`CSS`，`JS`文件在引入时都需要通过</span><span class="template-tag">&#123;% <span class="name"><span class="name">static</span></span> “path” %&#125;</span><span class="xml">来进行引入</span></span><br><span class="line"><span class="xml">&gt;</span></span><br><span class="line"><span class="xml">&gt; 最后，需要使用静态标签`static`前使用</span><span class="template-tag">&#123;% <span class="name"><span class="name">load</span></span> staticfiles %&#125;</span><span class="xml">标签进行静态资源路径的加载</span></span><br></pre></td></tr></table></figure><h3 id="模型数据库"><a href="#模型数据库" class="headerlink" title="模型数据库"></a>模型数据库</h3><blockquote><p>有了以上内容的修饰，现在感觉还是缺少一些什么，我们在视图函数中为前端页面返回的是一个提前定义好的变量，这显然在真正开发中是很少出现的，我们的数据大都来自于数据库中，那么现在需要我们在项目中加入数据库，并且在视图函数中通过对数据库的访问来拿到数据</p></blockquote><ul><li>创建数据库，这里使用项目自带的<code>SQLite3</code>数据库，默认已经是配置好的，接下来需要我们进入到<code>app</code>下的<code>models.py</code>文件中，编写一个类，这个类就对应数据库中的一张表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myapp/models.py</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="comment"># Create your models here.class Weather(models.Model):  </span></span><br><span class="line">weather = models.CharField(max_length=<span class="number">100</span>,verbose_name=<span class="string">"天气"</span>) </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span>      </span><br><span class="line">    verbose_name_plural = <span class="string">"天气"</span>      </span><br><span class="line">    <span class="comment"># 设置当前表名的一个可读的性更好的名字  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> self.weather</span><br></pre></td></tr></table></figure><blockquote><p>在这里我们使用到了<code>django</code>的<code>orm</code>映射关系用来创建数据库表，继承自<code>django</code>的<code>models.Model</code>类，</p><p><strong>一个类用来表示一张表，类中的一个属性代表一个字段，</strong></p></blockquote><blockquote><p>这里我们定义了一个类型为<code>CharField</code>，长度为<code>100</code>的字段，用来存储天气</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; models.<span class="constructor">CharField(<span class="params">max_length</span>=100,<span class="params">verbose_name</span>=<span class="string">"天气"</span>)</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><hr><blockquote><p>下面的<code>class Meta</code>是模型类的元类，用来设置当前表的一些属性；</p><p>这里我们使用<code>verbose_name_plural</code>属性设置当前表在<code>admin</code>后台查看时的名字</p></blockquote><blockquote><p>在这里我们还定义了一个属于实例的函数<code>__str__</code>，用来描述当前数据在返回时的默认展示结果，为<code>weather</code>字段的值</p></blockquote><blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; django`在创建模型类对应的数据表时，默认使用 `应用名`加`下划线`加`模型类名`作为表的名字；比如当前`Weather`表名为：`myapp_Weather</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><code>orm</code>映射关系，是<code>django</code>与数据库之间的一个桥梁，可以使开发者不再关注如何去编写<code>SQL</code>语句，直接通过一套<code>ORM</code>所提供的<code>API</code>接口即可方便对各种数据库进行交互</p></blockquote><ul><li>当某个子应用<code>APP</code>涉及到了数据库的使用时，要记得在<code>settings</code>文件中进行配置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myproject/settings.py</span></span><br><span class="line">INSTALLED_APPS = [  </span><br><span class="line">    <span class="string">'django.contrib.admin'</span>, </span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,  </span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,  </span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,  </span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,  </span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,  </span><br><span class="line">    <span class="string">'myapp'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>接下来通过<code>manage.py</code>命令行管理工具提供的两条，创建我们所需要的数据</li></ul><blockquote><p><strong>注意</strong>：默认<code>django</code>本身就已经需要一些数据的创建，所以我们在初次执行以下两条命令时可能会看到很多数据表和字段的创建，不要惊讶，这是正常的</p></blockquote><blockquote><p><code>python manage.py migrate</code>：根据数据库迁移文件生成对应<code>SQL</code>语句并执行</p><p>初次执行是为了先把默认django需要的数据库创建出来</p></blockquote><blockquote><p><code>python manage.py makemigrations</code>：创建数据库迁移文件</p><p>这次执行是为了创建APP中Weather模型类的迁移文件</p></blockquote><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> python manage.py migrate</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>将新添加的模型类迁移文件生成对应<code>SQL</code>，实际创建出对应的<code>Weather</code>表</p></blockquote><ul><li>如果提示结果正常，那么代表相应的数据表已经创建好了，接下来就需要我们去到<code>django</code>为我们提供的<code>admin</code>（数据库管理界面）来进行相关表的操作了！</li></ul><h3 id="admin控制台"><a href="#admin控制台" class="headerlink" title="admin控制台"></a>admin控制台</h3><blockquote><p><code>admin</code>控制台是<code>django</code>为我们提供的一个非常便捷的用来管理数据库的界面</p><p>在主控路由文件下，其实你已经看到了它对应的路由设置：<code>path(&#39;admin/&#39;, admin.site.urls),</code></p></blockquote><blockquote><p>进入<code>admin</code>界面，初次访问连接：<code>127.0.0.1/admin</code>，会提示我们输入账号密码，这是因为<code>django</code>的<code>admin</code>界面是需要一个超级管理员来登陆访问的，所以还需要我们创建对应的<code>admin</code>界面下的超级用户</p></blockquote><ul><li>创建<code>admin</code>超级用户，使用<code>manage.py</code>命令行工具执行如下命令</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br><span class="line">Username (leave blank to use <span class="string">'lienze'</span>): rootEmail address:Password:Password (again):This password <span class="keyword">is</span> too short. It must contain at least <span class="number">8</span> characters.This password <span class="keyword">is</span> too common.This password <span class="keyword">is</span> entirely numeric.Password:Password (again):This password <span class="keyword">is</span> too common.This password <span class="keyword">is</span> entirely numeric.Password:Password (again):Superuser created successfully.</span><br></pre></td></tr></table></figure><blockquote><p>以上是我们创建超级用户的过程，非常坎坷；</p><p>可以看到，在输入太短（不满足8位），或是只包含数字的简单密码，超级用户的创建都是被拒绝的</p><p>所以我们把用户账号创建为<code>root</code>，而密码创建为<code>a1234567</code>，</p></blockquote><ul><li>接下来开启测试服务器，并通过创建好的超级用户登陆访问，如果幸运的话，你已经可以看到后台的<code>admin</code>界面啦</li></ul><blockquote><p><code>admin</code>界面已经展示出了默认<code>django</code>所使用的两张表，用户表和组表，用来保存当前管理后台的用户以及对应权限分组，可以点入用户表查看其中我们刚创建的<code>root</code>。</p></blockquote><h3 id="admin注册表"><a href="#admin注册表" class="headerlink" title="admin注册表"></a>admin注册表</h3><blockquote><p>问题还是有的，虽然<code>admin</code>界面已经可以登入，但是为什么看不到刚才创建的<code>Weather</code>表呢</p><p>这是因为默认的表创建之后，还需要通过对应app下的<code>admin.py</code>文件进行<code>admin</code>后台注册，只有注册在这个文件中的模型类对应的表才可以在<code>admin</code>界面所看到</p></blockquote><ul><li>在app下的admin.py文件中进行模型类的注册</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myapp/admin.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> models</span><br><span class="line">admin.site.register(models.Weather)</span><br><span class="line"><span class="comment">#使用register函数接收模型类作为参数即可完成注册</span></span><br></pre></td></tr></table></figure><blockquote><p>注册成功之后，在服务器，通过浏览器访问<code>admin</code>界面，就可以看到创建好的<code>Weather</code>表了</p></blockquote><ul><li>鼠标点击进去之后，就可以看到对应的表数据界面；右上角提供了可以添加功能的选项，试试给这个表来一些数据吧，这里我们添加了三条数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">阴天，晴天，打雷了</span><br></pre></td></tr></table></figure><h3 id="视图操作模型"><a href="#视图操作模型" class="headerlink" title="视图操作模型"></a>视图操作模型</h3><blockquote><p>最终我们希望可以在视图函数中通过<code>orm</code>接口来访问到表中的数据，那么来打开视图文件吧：<code>views.py</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#myapp/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> models</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span>  </span><br><span class="line">    weathers = models.Weather.objects.all()   </span><br><span class="line">    content = &#123;     </span><br><span class="line">        <span class="string">"weathers"</span>:weathers,   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'index.html'</span>, content)</span><br></pre></td></tr></table></figure><ul><li>光返回是不行的，虽然我们绑定到了模板版变量的字典中，但是还得修改一下对应的要渲染的<code>HTML</code>页面哦：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span> </span><br><span class="line">    &#123;% load staticfiles %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line">        &#123;% for weather in weathers %&#125;   </span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; weather &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>   </span><br><span class="line">        &#123;% empty %&#125;    </span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>没有任何天气<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">&gt; 模板标签</span><span class="template-tag">&#123;% <span class="name"><span class="name">for</span></span> xxx <span class="keyword">in</span> xxxs %&#125;</span><span class="xml">可以用来在模板页面出迭代访问取出每一个数据</span></span><br><span class="line"><span class="xml">&gt;</span></span><br><span class="line"><span class="xml">&gt; 具体对于不同序列数据的访问我们会在后面详细为大家介绍</span></span><br><span class="line"><span class="xml">&gt;</span></span><br><span class="line"><span class="xml">&gt; </span><span class="template-tag">&#123;% <span class="name"><span class="name">empty</span></span> %&#125;</span><span class="xml">标签用来判断当循环访问数据为空时要做的事情，最后循环标签要有</span><span class="template-tag">&#123;% <span class="name"><span class="name">endfor</span></span> %&#125;</span><span class="xml">标签进行结束；因为`HTML`中并没有像`Python`缩进这样的方式来控制代码块。</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>至此，我们的<code>HELLO WORLD</code>项目已经涵盖了<code>django</code>框架中的大部分常用的组件；</p><p><strong>路由</strong>、<strong>视图</strong>、<strong>模板</strong>、<strong>静态</strong>、<strong>模型</strong>，<strong>admin</strong></p><p>那么其中每一部分都还有很多内容等着我们去了解，在接下来的章节中我们会继续详细给大家介绍！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始玩耍Django&quot;&gt;&lt;a href=&quot;#开始玩耍Django&quot; class=&quot;headerlink&quot; title=&quot;开始玩耍Django&quot;&gt;&lt;/a&gt;开始玩耍Django&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Django&lt;/em&gt;是一个开放源代码的&lt;code&gt;Web&lt;/code&gt;应用框架，由&lt;code&gt;Python&lt;/code&gt;写成。采用了&lt;code&gt;MVT&lt;/code&gt;的框架模式；最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是&lt;code&gt;CMS&lt;/code&gt;（内容管理系统）软件&lt;/p&gt;
&lt;p&gt;框架是以比利时的吉普赛爵士吉他手&lt;code&gt;Django Reinhardt&lt;/code&gt;来命名的&lt;/p&gt;
&lt;/blockquote&gt;&lt;h3 id=&quot;django安装&quot;&gt;&lt;a href=&quot;#django安装&quot; class=&quot;headerlink&quot; title=&quot;django安装&quot;&gt;&lt;/a&gt;django安装&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django-Views-视图层</title>
    <link href="https://cy-blogs.cn/Django-Views-%E8%A7%86%E5%9B%BE%E5%B1%82/"/>
    <id>https://cy-blogs.cn/Django-Views-视图层/</id>
    <published>2019-12-09T07:43:24.816Z</published>
    <updated>2019-12-09T11:26:17.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h2><blockquote><p>视图函数一般用来接收一个<code>Web</code>请求<code>HttpRequest</code>，之后返回一个Web响应<code>HttpResponse</code></p></blockquote><h3 id="HttpRequest"><a href="#HttpRequest" class="headerlink" title="HttpRequest"></a>HttpRequest</h3><blockquote><p>一个视图函数用来响应用户的<code>Request</code>请求，每个视图函数默认的第一个位置参数<code>request</code>用来接收用户发起请求的<code>HttpRequest</code>信息。</p><p>视图函数的返回值，为一个<code>HttpResponse</code>值，包括我们要返回给用户的<code>HTML</code>页面或者字符串等等，以及对应的头部字段信息</p></blockquote><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Hello world'</span>)</span><br></pre></td></tr></table></figure><h3 id="常见请求方式"><a href="#常见请求方式" class="headerlink" title="常见请求方式"></a>常见请求方式</h3><blockquote><p><code>POST</code>和<code>GET</code>是<code>HTTP</code>协议定义的与服务器交互的方法。</p><p><code>GET</code>一般用于获取/查询资源信息，而<code>POST</code>一般用于更新资源信息。另外，还有<code>PUT</code>和<code>DELETE</code>方法</p></blockquote><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><blockquote><p>常用来从指定地址请求数据；</p><p>如果需要在请求时提交某些数据，则以路由形式传递参数，查询<code>Query</code>字符串如下格式所示：</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http<span class="variable">s:</span>//www.baidu.<span class="keyword">com</span>/?key=<span class="keyword">abc</span>&amp;pos=shanxi</span><br></pre></td></tr></table></figure><ul><li><code>get</code>请求可被浏览器缓存，保存在历史记录中</li><li><code>get</code>不应在使用敏感数据时使用，明文包路在请求地址中</li><li><code>get</code>有长度限制</li></ul><h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><blockquote><p>向指定的资源提交要被处理的数据</p><p>使用<code>POST</code>，提交的数据保存在<code>HTTP</code>协议中的消息主体部分</p></blockquote><ul><li><code>post</code>请求不会被浏览器缓存</li><li><code>post</code>提交数据长度无限制</li><li><code>post</code>比<code>get</code>更加安全</li></ul><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><blockquote><p>如果说<code>urls.py</code>是<code>Django</code>中前端页面和后台程序桥梁，那么<code>request</code>就是桥上负责运输的小汽车，可以说后端接收到的来至前端的信息几乎全部来自于<code>requests</code>中</p></blockquote><h4 id="request-method"><a href="#request-method" class="headerlink" title="request.method"></a>request.method</h4><blockquote><p>获取当前用户请求方式，</p><p>请求方式字符串为纯大写：<code>&#39;GET&#39;</code>、<code>&#39;POST&#39;</code></p><p>如用户以<code>get</code>方式发起请求，对应代码中获取到的结果以及在判断时像是这样</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        …</span><br></pre></td></tr></table></figure><h4 id="request-GET"><a href="#request-GET" class="headerlink" title="request.GET"></a>request.GET</h4><blockquote><p>当用户通过<code>get</code>方式请求站点，并在路由中提供了查询参数，可以通过该属性获取到对应提交的值</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span>   </span><br><span class="line">    print(request.GET) </span><br><span class="line">    <span class="comment"># &lt;QueryDict: &#123;'name': ['jack'], 'id': ['1']&#125;&gt;    </span></span><br><span class="line">    print(type(request.GET))   </span><br><span class="line">    <span class="comment"># &lt;class 'django.http.request.QueryDict'&gt; </span></span><br><span class="line">    name_ = request.GET.get(<span class="string">'name'</span>)   </span><br><span class="line">    id_ = request.GET.get(<span class="string">'id'</span>)  </span><br><span class="line">    content = <span class="string">'%s:%s'</span> % (name_,id_)   </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(content)</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; request.GET`是一个类似字典的数据类型：`QueryDict</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>其中也支持类似对字典的<code>get</code>或直接<code>dict.[key]</code>键值访问方式，当然使用<code>get</code>方式进行对应<code>key</code>获取会更好，因为<code>get</code>在访问不到时不会报错</p></blockquote><ul><li>如果定义了如上所示的视图函数，那么在访问连接时，我们可以通过路由传参：</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//127.0.0.1:8000/?name=jack&amp;id=1</span></span><br></pre></td></tr></table></figure><ul><li>这里对应页面会显示的结果：</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jack:<span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：使用<code>GET</code>方法在连接中进行参数提交，后台接收到的数据类型均是字符串</p></blockquote><hr><h4 id="request-POST"><a href="#request-POST" class="headerlink" title="request.POST"></a>request.POST</h4><blockquote><p>获取用户以<code>post</code>形式提交的数据并保存在后台，为类字典数据，这里和<code>request.GET</code>是一个东西；</p><p>在网页中，一般我们通过<code>html</code>的表单进行数据的提交，<code>POST</code>方式可以提交空数据</p></blockquote><ul><li>因为涉及到了表单页面，所以我们先来弄一个<code>HTML</code>页面</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一个关于POST的测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span>  </span><br><span class="line">        &#123;% csrf_token %&#125;    </span><br><span class="line">        账号:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"account"</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span>      </span><br><span class="line">        密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"passwd"</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在模板页面中，一旦涉及到了表单提交，那么一定要注意在表单区域添加<code>csrf_token</code>标签进行防跨站伪造令牌的加载，否则表单数据的将被认为是无效的。</p></blockquote><blockquote><p>在接下来的视图函数中会使用到<code>input</code>标签中的<code>name</code>属性；</p><p><code>name</code>值属性维护了<code>post</code>的数据传入到后台时的标示，会与表单的数据组合成类字典格式</p><p>如<code>name</code>属性为<code>account</code>的输入框中输入了<code>test</code>，那么后台数据接收到的值类似：<code>{&#39;account&#39;:&#39;test&#39;}</code></p></blockquote><ul><li>写一个视图函数用来捕获当前表单使用POST形式提交的数据：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span>   </span><br><span class="line">    <span class="keyword">if</span> request.method=<span class="string">"POST"</span>:</span><br><span class="line">        print(request.POST)    </span><br><span class="line">        print(type(request.POST))   </span><br><span class="line">        account = request.POST.get(<span class="string">"account"</span>)  </span><br><span class="line">        passwd = request.POST.get(<span class="string">"passwd"</span>)   </span><br><span class="line">        content = <span class="string">"%s:%s"</span> % (account,passwd)    </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(content)  </span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">"index.html"</span>) <span class="comment">#在使用get形式请求时，返回表单页面</span></span><br></pre></td></tr></table></figure><ul><li>如果在表单页面中账号填写为test，密码为123456；在视图函数中捕捉到的结果为：</li></ul><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="symbol">QueryDict</span>: &#123;<span class="string">'csrfmiddlewaretoken'</span>: [<span class="string">'EmyGwsVcrXI2LDkYLS9qflkUH4N7bM1nfTQxr3fsOsZlI4vJFwci7TargtYRAGl2'</span>], <span class="string">'account'</span>: [<span class="string">'test'</span>], <span class="string">'passwd'</span>: [<span class="string">'123456'</span>]&#125;&gt;</span><br></pre></td></tr></table></figure><h5 id="表单多值提交"><a href="#表单多值提交" class="headerlink" title="表单多值提交"></a>表单多值提交</h5><blockquote><p>在<code>request.POST</code>中需要注意，某些情况下，使用POST提交数据的表单数据可能是多个值，类似复选框<code>CheckBox</code>，直接使用<code>request.POST.get()</code>进行获取是有一些问题的，比如修改模板页面如下所示</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span>  </span><br><span class="line">    &#123;% csrf_token %&#125;    </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"taste"</span> <span class="attr">value</span>=<span class="string">"eat"</span>&gt;</span>吃  </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"taste"</span> <span class="attr">value</span>=<span class="string">"sleep"</span>&gt;</span>睡  </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"taste"</span> <span class="attr">value</span>=<span class="string">"play"</span>&gt;</span>耍  </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这是一个<code>name</code>值为<code>taste</code>的兴趣爱好采集的多选框，<code>value</code>值将会作为选中时，提交到后台的值，比如现在我们全选这些表单数据，那么后台接收到的值是这样的</p></blockquote><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="symbol">QueryDict</span>: &#123;<span class="string">'csrfmiddlewaretoken'</span>: [<span class="string">'nuaLzxc2E0artYKUZiefMPv5iHTX5gLFY1sCu8wi1vrKqpVFTWh7EnlCR64Hua5k'</span>], <span class="string">'taste'</span>: [<span class="string">'eat'</span>, <span class="string">'sleep'</span>, <span class="string">'play'</span>]&#125;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>但是问题接踵而至，我们发现使用<code>get</code>函数获取不到对应全选的整个结果，而是只拿到了选中的最后一项</p></blockquote><ul><li><p><code>request.POST.get(key, default=None)</code></p><blockquote><p>返回对应<code>key</code>值的数据中的<strong>最后一个</strong>数据单独返回；<code>key</code>值不存在，取<code>default</code></p></blockquote></li></ul><blockquote><p>要想真正拿出所有的结果，应该使用<code>getlist</code>函数</p></blockquote><ul><li><p><code>request.POST.getlist(key, default=None)</code></p><blockquote><p>将对应<code>key</code>值的所有数据以<strong>一个列表</strong>形式返回；<code>key</code>值不存在，取<code>default</code></p></blockquote></li></ul><h4 id="request-META"><a href="#request-META" class="headerlink" title="request.META"></a>request.META</h4><blockquote><p><code>request.MAT</code>E获取的是一个标准的<code>python</code>字典。它包含了所有的<code>HTTP</code>请求信息</p><p>比如用户IP地址和用户<code>Agent</code>（通常是浏览器的名称和版本号）。</p><p>注意，<code>Header</code>信息的完整列表取决于用户所发送的<code>Header</code>信息和服务器端设置的<code>Header</code>信息</p></blockquote><ul><li><code>CONTENT_LENGTH</code>：请求的正文的长度，字符串类型</li><li><code>CONTENT_TYPE</code>：请求的正文的<code>MIME</code> 类型</li><li><code>HTTP_ACCEPT</code>：响应可接收的<code>Content-Type</code></li><li><code>HTTP_ACCEPT_ENCODING</code>：响应可接收的编码</li><li><code>HTTP_ACCEPT_LANGUAGE</code>：响应可接收的语言</li><li><code>HTTP_HOST</code>：客服端发送的<code>HTTP Host</code>头部</li><li><code>HTTP_REFERER</code>：请求前的连接地址</li><li><code>HTTP_USER_AGENT</code>：客户端的<code>user-agent</code>字符串</li><li><code>QUERY_STRING</code>：单个字符串形式的查询字符串（未解析过的形式）</li><li><code>REMOTE_ADDR</code>：客户端的IP 地址</li><li><code>REMOTE_HOST</code>：客户端的主机名</li><li><code>REMOTE_USER</code>：服务器认证后的用户</li><li><code>REQUEST_METHOD</code>：一个字符串，例如<code>GET</code> 或<code>POST</code></li><li><code>SERVER_NAME</code>：服务器的主机名</li><li><code>SE0RVER_PORT</code>：服务器的端口，字符串类型</li></ul><h4 id="request-FILES"><a href="#request-FILES" class="headerlink" title="request.FILES"></a>request.FILES</h4><blockquote><p>接收用户上传文件及相关信息。同样类似于<code>request.POST</code>，提取到的数据为一个类字典的数据类型，包含所有文件上传的信息</p></blockquote><ul><li><p><code>f = request.FILES.get(&#39;upload_file&#39;)</code></p><blockquote><p><code>file_data = f.read()</code>：读取整个上传文件的内容，适合小文件上传</p><p><code>yiled = f.chunks()</code>：返回一个类似生成器<code>（）</code>的数据，每一次读取按块返回文件，可以通过<code>for</code>迭代访问其中数据；适合上传大文件到服务器。</p><p><code>f.multiple_chunks()</code>：返回文件大小，当文件大小大于<code>2.5M</code>时，返回<code>True</code>，反之返回<code>False</code>，可以通过该函数来选择是否使用<code>chunks</code>方法或<code>read</code>直接存储。</p><p>如果想要修改这个文件判定的默认值，可以通过：<code>FILE_UPLOAD_MAX_MEMORY_SIZE</code>在<code>settings</code>文件下进行设置</p><p><code>f.content_type</code>：上传文件时头部中的<code>Content-Type</code>字段值，参考MIME类型</p><p><code>f.name</code>：上传文件名字</p><p><code>f.charset</code>：上传文件编码</p><p><code>f.size</code>： 上传文件大小，字节为单位：<code>byte</code></p></blockquote></li></ul><blockquote><p>创建好静态资源目录，并在下面创建一个<code>img</code>文件夹，保存我们即将上传的图片；</p><p>完成上传文件的<code>HTML</code>表单页面</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span> </span><br><span class="line">    &#123;% csrf_token %&#125;   </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"upload_file"</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&#123;% static 'img/1.jpg' %&#125;"</span> <span class="attr">alt</span>=<span class="string">"这是一张图片"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这里使用的是即将要上传的文件名字，只做文件是否上传成功的简单测试 --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：上传文件的页面表单，一定要记得设置属性<code>enctype=&quot;multipart/form-data&quot;</code></p></blockquote><ul><li>视图函数如下编写，接收上传图片，并保存在静态目录下刚才创建好的img目录中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"POST"</span>:   </span><br><span class="line">        f = request.FILES.get(<span class="string">"upload_files"</span>)  </span><br><span class="line">        path = os.path.join(settings.STATICFILES_DIRS[<span class="number">0</span>],<span class="string">'img/'</span>+f.name)  </span><br><span class="line">        <span class="comment"># 上传文件本地保存路径   </span></span><br><span class="line">        <span class="keyword">with</span> open(path,<span class="string">'wb'</span>) <span class="keyword">as</span> fp:     </span><br><span class="line">            <span class="keyword">if</span> f.multiple_chunks: <span class="comment">#判断到上传文件为大于2.5MB的大文件     </span></span><br><span class="line">                <span class="keyword">for</span> buf <span class="keyword">in</span> f.chunks(): <span class="comment">#迭代写入文件      </span></span><br><span class="line">                    fp.write(buf)        </span><br><span class="line">                    <span class="keyword">else</span>:             </span><br><span class="line">                        fp.write(f.read())    </span><br><span class="line">                        <span class="keyword">return</span> HttpResponse(<span class="string">"Success!"</span>)  </span><br><span class="line">                    <span class="keyword">return</span> render(request, <span class="string">'index.html'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>测试上传一个名为<code>1.jpg</code>的图片，如果成功上传，那么后台<code>static</code>目录下会出现该图片，并且模板页面也可以展示对应图片效果</p></blockquote><h3 id="HTTPResponse"><a href="#HTTPResponse" class="headerlink" title="HTTPResponse"></a>HTTPResponse</h3><blockquote><p>一个视图的返回值经常是为了向用户返回一个<code>HttpResponse</code>响应，</p><p>有如下常用的可以返回<code>HttpResponse</code>的函数</p></blockquote><h4 id="response"><a href="#response" class="headerlink" title="response"></a>response</h4><ul><li><p><code>HttpResponse(content=b&#39;&#39;)</code></p><blockquote><p>返回一个字符串内容</p><p><em>from</em> django.http <em>import</em> HttpResponse</p></blockquote></li><li><p><code>render(request,template_name,context=None,content_type=None,status=None)</code></p><blockquote><p>返回一个可渲染HTML页面，状态码为<code>200</code></p><p><em>from</em> django.shortcuts <em>import</em> render</p></blockquote><blockquote><p><code>request</code>：固定参数，响应的<code>request</code>请求，来自于参数部分接收的<code>HttpRequest</code></p><p><code>template_name</code>：返回的模板页面路径</p><p><code>context</code>：模板页面渲染所需的数据，默认为字典格式</p><p><code>content_type</code>：生成之后的结果使用的<code>MIME</code>类型</p><p><code>status</code>：响应的状态码，默认为<code>200</code></p></blockquote></li><li><p><code>redirect(to, permanent=False)</code></p><blockquote><p>一个重定向，浏览器通过该状态码自动跳转到一个新的路由地址，默认返回响应状态码<code>302</code></p><p><em>from</em> django.shortcuts <em>import</em> redirect</p></blockquote><blockquote><p><code>to</code>：可以是一个<code>django</code>项目中视图函数的路由映射，也可以是一个<code>reverse</code>的反向路由解析</p><p><code>permanent</code>：如果设置为<code>True</code>，将返回<code>301</code>状态码，代表永久重定向</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">302</span>：临时重定向，旧地址资源临时不能用了，搜索引擎只会暂时抓取新地址的内容而保存旧的地址。<span class="number">301</span>：永久重定向，旧地址资源已经不复存在，搜索引擎不光会抓取新地址的内容，还会替换旧地址为新地址</span><br></pre></td></tr></table></figure></li></ul><h3 id="视图错误处理"><a href="#视图错误处理" class="headerlink" title="视图错误处理"></a>视图错误处理</h3><blockquote><p>为了方便我们开发，<code>django</code>提供了一个异常叫做<code>Http404</code>异常，我们可以在视图函数的代码中按照需求进行抛出，抛出之后<code>django</code>项目会自动捕获该异常，并会展示默认的<code>404</code>页面</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span>   </span><br><span class="line">    <span class="keyword">if</span> request.GET.get(<span class="string">"id"</span>) == <span class="string">"1"</span>:    </span><br><span class="line">        <span class="keyword">raise</span> Http404</span><br></pre></td></tr></table></figure><blockquote><p>在<code>settings</code>中的<code>debug</code>配置项为<code>false</code>时，访问<code>http://127.0.0.1:8000/?id=1</code>，可以看到<code>django</code>为我们提供的错误页面；</p><p>除了<code>django</code>默认提供的，我们还可以可以在模板目录下定义全局<code>404.html</code>进行错误页面的定制</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>    抱歉，找不到你要的东西<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自定义错误处理视图"><a href="#自定义错误处理视图" class="headerlink" title="自定义错误处理视图"></a>自定义错误处理视图</h4><blockquote><p>除去<code>404</code>错误的自定义，<code>django</code>还提供了覆盖默认错误行为处理的办法；</p><p>有些时候，<code>django</code>自动的错误处理可能不能满足我们的需求，那么我们可以重新定义一些新的视图函数，</p><p>来覆盖掉<code>django</code>所提供的错误处理视图函数，最后在<code>urls.py</code>路由配置文件下通过定义全局变量来重新设置默认的错误处理视图函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">handler404：覆盖page_not_found()视图。</span><br><span class="line">handler500：覆盖server_error()视图。</span><br><span class="line">handler403：覆盖permission_denied()视图。</span><br><span class="line">handler400：覆盖bad_request()视图</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line">urlpatterns = [    path(<span class="string">'admin/'</span>, admin.site.urls),  </span><br><span class="line">               path(<span class="string">''</span>, include(<span class="string">"viewapp.urls"</span>)),]</span><br><span class="line">handler404 = <span class="string">"viewapp.views.error_404"</span></span><br><span class="line"><span class="comment"># APP.模块.视图函数</span></span><br><span class="line">handler500 = <span class="string">"viewapp.views.error_500"</span></span><br></pre></td></tr></table></figure><blockquote><p>相关定义好的错误处理视图函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_404</span><span class="params">(request)</span>:</span>    </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"这是404错误"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_403</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"这是403错误"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_500</span><span class="params">(request)</span>:</span> </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"这是500错误"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;视图层&quot;&gt;&lt;a href=&quot;#视图层&quot; class=&quot;headerlink&quot; title=&quot;视图层&quot;&gt;&lt;/a&gt;视图层&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;视图函数一般用来接收一个&lt;code&gt;Web&lt;/code&gt;请求&lt;code&gt;HttpRequest&lt;/code&gt;，之后返回一个Web响应&lt;code&gt;HttpResponse&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;h3 id=&quot;HttpRequest&quot;&gt;&lt;a href=&quot;#HttpRequest&quot; class=&quot;headerlink&quot; title=&quot;HttpRequest&quot;&gt;&lt;/a&gt;HttpRequest&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个视图函数用来响应用户的&lt;code&gt;Request&lt;/code&gt;请求，每个视图函数默认的第一个位置参数&lt;code&gt;request&lt;/code&gt;用来接收用户发起请求的&lt;code&gt;HttpRequest&lt;/code&gt;信息。&lt;/p&gt;
&lt;p&gt;视图函数的返回值，为一个&lt;code&gt;HttpResponse&lt;/code&gt;值，包括我们要返回给用户的&lt;code&gt;HTML&lt;/code&gt;页面或者字符串等等，以及对应的头部字段信息&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django-Urls-路由层</title>
    <link href="https://cy-blogs.cn/Django-Urls-%E8%B7%AF%E7%94%B1%E5%B1%82/"/>
    <id>https://cy-blogs.cn/Django-Urls-路由层/</id>
    <published>2019-12-09T05:56:43.065Z</published>
    <updated>2019-12-09T11:26:14.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路由层"><a href="#路由层" class="headerlink" title="路由层"></a>路由层</h2><blockquote><p>路由是Web服务的入口，就好像办事大厅有各个服务窗口一样</p></blockquote><blockquote><p>Django奉行DRY主义，提倡使用简洁、优雅的URL：</p><p> 可以不用<code>.html</code>、<code>.php</code>或<code>.cgi</code>之类后缀</p><p> 尽量不要单独使用无序随机数字这样无意义的东西</p><p> 让你随心所欲设计你的URL，不受框架束缚</p></blockquote><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="urlpatterns"><a href="#urlpatterns" class="headerlink" title="urlpatterns"></a>urlpatterns</h4><blockquote><p>urlpatterns是路由文件中的一个全局变量，用来存放路由及视图函数的映射关系</p><p>用户发起的请求<code>URL</code>都会首先进入主控制目录下的这个<code>urls.py</code>文件中进行查找匹配</p></blockquote><a id="more"></a><ol><li>首先找到<code>urls.py</code>下的<code>urlpatterns</code>全局变量，这是一个路由规则实例的列表数据。</li><li>按照先后定义顺序，进行路由匹配。</li><li>找到第一个匹配项时停止匹配，执行匹配到的视图函数。</li><li>遍历完全，未发现匹配，<code>django</code>进行异常处理</li></ol><blockquote><p>其中<code>urlpatterns</code>中的每一个路由映射规则可以由<code>path</code>或<code>re_path</code>进行构造</p></blockquote><blockquote><p><strong>注意</strong>：<code>Django</code>的路由不考虑<code>HTTP</code>请求方式，仅根据URL进行路由；即，只要<code>URL</code>相同，无论<code>POST</code>、<code>GET</code>等哪种请求方式都指向同一个操作函数</p></blockquote><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><ul><li><p><code>path(regex, view, kwargs=None, name=None)</code></p><blockquote><p><code>regex</code>：一个匹配对应url地址的规则字符串。</p><p><code>view</code>：路由对应的视图函数，并且会自动封装HttpRequest作为第一个参数给这个视图函</p><p><code>kwargs</code>：视图函数的关键字参数。</p><p><code>name</code>：该路由的全局命名，可以让我们方便的在django项目中任意部分显示的使用，相当于为<code>url</code>取变量名，接下来全局使用该命名值即可；当对应<code>url</code>路由改变之后，结合路由反向解析使用的地方不需要更改路由</p><p>此外，<code>django</code>还提供了一个兼容老版本<strong>url</strong>路由配置函数的<strong>re_path</strong>函数；<code>re_path</code>：第一个参数部分为一个正则匹配规则，其他与path同</p></blockquote></li></ul><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><blockquote><p>静态路由用来映射对应视图函数，以下是一个简单的例子</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span>  </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Hello Worlds!'</span>)</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,re_path</span><br><span class="line"><span class="keyword">from</span> urlapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [    path(<span class="string">''</span>,views.index),    re_path(<span class="string">r"^"</span>,views.index),]</span><br></pre></td></tr></table></figure><h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><blockquote><p>有的时候，我们的路由设置不能一直维持一个一成不变的状态；</p><p>比如遇到一些内容翻页的场景，那么我们的连接可能是：<code>xx.com/airticle_list/1/</code>、<code>xx.com/airticle_list/2/</code></p><p>那么这样的路由其实对应的都应该是一个视图函数，用以展示页面内容，那么如何设计这样的路由，就要涉及到动态路由及路由传参</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request,x,y)</span>:</span>  </span><br><span class="line">    content = <span class="string">"x:%s\ny:%s"</span> % (x,y)  </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(content)</span><br></pre></td></tr></table></figure><blockquote><p>定义如上函数，将会接收连接中的后两部份<code>path</code>值作为参数，分别依次给到<code>x</code>和<code>y</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,re_path</span><br><span class="line"><span class="keyword">from</span> urlapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [    path(<span class="string">'&lt;int:x&gt;/&lt;str:y&gt;/'</span>,views.index), </span><br><span class="line">               <span class="comment">#指明类型    path("&lt;x&gt;/&lt;y&gt;/",views.index)  </span></span><br><span class="line">               <span class="comment">#不指明类型    re_path(r"^(?P&lt;x&gt;\d+)/(?P&lt;y&gt;[a-zA-Z]+)/$"),</span></span><br><span class="line">               <span class="comment"># (?P&lt;name&gt;pattern) 正则分组   </span></span><br><span class="line">               re_path(<span class="string">r"^(\d+)/([a-zA-Z]+)/$"</span>),]</span><br></pre></td></tr></table></figure><blockquote><p>路由通过尖括号进行分组匹配，使用int以及str内置转换器将连接对应部分的值进行转换；并将匹配到的结果传递到视图函数对应的参数位置上；</p><p>访问：<code>http://127.0.0.1:8000/1/abc/</code></p><p>其中<code>1</code>将作为x的参数值，<code>abc</code>将作为y的参数</p><p>但如果访问连接是：<code>http://127.0.0.1:8000/abc/abc/</code>，这会匹配到第二个路由，第二个路由没有对传递参数的类型进行限定</p></blockquote><ul><li>内置Path转换器：</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str：匹配除了路径分隔符（`/`）之外的非空字符串，这是默认的形式<span class="built_in">int</span>：匹配正整数，包含<span class="number">0</span>slug：匹配字母、数字以及横杠、下划线组成的字符串uuid：匹配格式化的uuid，如 <span class="number">075194</span>d3<span class="number">-6885</span><span class="number">-417</span>e-a8a8<span class="number">-6</span>c931e272f00path：匹配任何非空字符串，包含了路径分隔符</span><br></pre></td></tr></table></figure><h4 id="自定义转换器"><a href="#自定义转换器" class="headerlink" title="自定义转换器"></a>自定义转换器</h4><blockquote><p>除了以上<code>django</code>所提供的path转换器，如果还觉得无法实现我们想要的功能，我们可以通过编写一个类进行自定义<code>path</code>转换器</p></blockquote><ol><li><p>定义转换器类，类名随意</p></li><li><p>定义类中必须属性</p><blockquote><p><code>regex</code>：一个字符串形式的正则表达式，也是对应的路由规则</p><p><code>to_python(self, value)</code>：用于将匹配到的路由字符串转换为<code>Python</code>中的数据类型，并传递给视图函数，<strong>如果转换失败，必须抛出ValueError</strong>，路由映射视图函数时使用</p><p><code>to_url(self, value)</code>：将<code>Python</code>数据类型转换为一段url的方法，<code>to_python</code>方法的反向操作，反向解析时使用</p></blockquote></li><li><p>通过django.urls模块中的register_converter函数进行注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数第一个参数为转换器类</span><br><span class="line">函数第二个参数为转换器别名</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>以下定义一个路由参数只能是三位字符的路由规则</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先将转换器类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeChar</span>:</span>  </span><br><span class="line">    regex = <span class="string">"[a-zA-Z]&#123;3&#125;"</span>   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_python</span><span class="params">(self,value)</span>:</span>    </span><br><span class="line">        print(<span class="string">"to_python"</span>)       </span><br><span class="line">        <span class="keyword">return</span> str(value)   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_url</span><span class="params">(self,value)</span>:</span>    </span><br><span class="line">        <span class="comment"># 当通过反向路由解析时，将会调用该函数    </span></span><br><span class="line">        print(<span class="string">'to_url'</span>)        </span><br><span class="line">        <span class="keyword">return</span> str(value)[:<span class="number">3</span>]   </span><br><span class="line">    <span class="comment">#此处切片操作是为了当反向路由解析传参字符串长于3时，可以将其截断，符合转换器正则规则#注册转换器</span></span><br><span class="line">    <span class="keyword">from</span> django.urls <span class="keyword">import</span> register_converterregister_converter(ThreeChar,<span class="string">'tc'</span>)</span><br><span class="line">urlpatterns = [    path(<span class="string">'&lt;tc:x&gt;/&lt;tc:y&gt;/'</span>,views.index)]<span class="comment">#127.0.0.1:8000/aaa/bbb/</span></span><br></pre></td></tr></table></figure><blockquote><p>接下里，通过路由进行访问该视图映射时，一定是三个字符所组成的路由才可以，否则是访问不到的</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line">app_name = <span class="string">"app"</span>path(<span class="string">'&lt;tc:x&gt;/&lt;tc:y&gt;/'</span>,</span><br><span class="line">                     views.index, name=<span class="string">"threechr"</span>)</span><br><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="keyword">return</span> redirect(reverse(<span class="string">"app:threechr"</span>,args=(<span class="string">'aaaa'</span>,<span class="string">'bbbb'</span>)))</span><br><span class="line"><span class="comment">#此时会调用three路由规则中的tc转换器中的to_url反向合成路由，并切片只取参数前三位</span></span><br></pre></td></tr></table></figure><h3 id="路由分发"><a href="#路由分发" class="headerlink" title="路由分发"></a>路由分发</h3><blockquote><p>我们的路由编写都是在项目主要目录下的<code>urls.py</code>文件中，但是如果<code>app</code>有很多的话，这么多路由都写到一起，明显是一件很不方便管理的事情</p><p>其实在之前的练习中，我们使用的方式均是路由分发，每个子<code>app</code>都拥有自己独立的<code>urls.py</code>路由映射文件，而主控路由文件里只需要使用<code>include</code>函数导入子<code>app</code>下路由文件即可，这就是路由分发</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line">urlpatterns = [    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">               path(<span class="string">''</span>,include(<span class="string">"urlapp.urls"</span>)) </span><br><span class="line">               <span class="comment"># 使用include 实现路由分发，找到子app下的路由文件</span></span><br><span class="line">              ]</span><br></pre></td></tr></table></figure><blockquote><p>路由分发为我们带来的好处有很多，可以让我们在多个<code>app</code>的项目中更加方便有效的管理每一个路由</p><p>并且也可以让我们的用户在访问时看到浏览器中的<code>URL</code>地址更加<strong>赏心悦目</strong></p></blockquote><h3 id="路由反向解析"><a href="#路由反向解析" class="headerlink" title="路由反向解析"></a>路由反向解析</h3><blockquote><p>到了这里，思考一下，之前我们已经设置过了很多路由；</p><p>但是现在会出现一个问题，比如我们把其中某个路由规则进行了修改，把<code>aaa</code>换成了<code>aba</code>，那么现在我们需要回到每一个使用到这个路由的地方进行同步修改，这显然非常麻烦的，如果修改的路由更多，这甚至是一个灾难</p></blockquote><blockquote><p><code>django</code>也为我们提供了一个解决办法，通过为路由映射使用<code>name</code>参数，来为每一个路由映射设置一个独立唯一的变量名</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path(<span class="string">'left/&lt;str:x&gt;/'</span>,views.left, name=<span class="string">"left"</span>),</span><br><span class="line">path(<span class="string">'right/&lt;int:x&gt;/'</span>,views.right, name=<span class="string">"right"</span>),</span><br><span class="line"><span class="comment"># 通过正则命名分组方式</span></span><br><span class="line">re_path(<span class="string">r'^left/([a-zA-Z]+)/$'</span>,views.left,name=<span class="string">"left"</span>),</span><br><span class="line">re_path(<span class="string">r'^right/(?P&lt;x&gt;\d+)/$'</span>,views.right, name=<span class="string">"right"</span>)</span><br></pre></td></tr></table></figure><ul><li>两个视图函数对应如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left</span><span class="params">(request,x)</span>:</span></span><br><span class="line">    <span class="comment"># x: str    </span></span><br><span class="line">    content = &#123;        <span class="string">'message'</span>:x,    &#125;    </span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"left.html"</span>, content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right</span><span class="params">(request,x)</span>:</span></span><br><span class="line">    <span class="comment"># x: int</span></span><br><span class="line">    content = &#123;        <span class="string">'message'</span>:x,    &#125;    </span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">"right.html"</span>,content)</span><br></pre></td></tr></table></figure><ul><li>两个HTML页面</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是左页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'right' 123 %&#125;"</span>&gt;</span>右页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ------另一个页面------ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是右页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'left' 'abc' %&#125;"</span>&gt;</span>右页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">&gt; 在模板页面中，对于已命名路由可以通过</span><span class="template-tag">&#123;% <span class="name"><span class="name">url</span></span> “name” “arg” %&#125;</span><span class="xml">模板标签进行反向解析</span></span><br></pre></td></tr></table></figure><blockquote><p>参数以空格隔开，在标签后传入</p></blockquote><ul><li>视图函数反向解析</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span>   </span><br><span class="line">    <span class="keyword">return</span> redirect(reverse(<span class="string">"left"</span>,args=(<span class="string">'aaa'</span>,) ))</span><br></pre></td></tr></table></figure><blockquote><p>在视图函数中需要使用到路由命名时，进行反向解析需要我们通过<code>django.shortcuts</code>模块下的<code>reverse</code>函数</p></blockquote><ul><li><code>reverse(viewname,args=None,kwargs=None)</code></li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数介绍viewname：视图函数、命名路由映射、或视图函数路径的字符串<span class="built_in">args</span>：元组形式路由传参。kwargs：字典形式路由传参</span><br></pre></td></tr></table></figure><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><blockquote><p>如果想在多个<code>app</code>下使用相同的<code>name</code>路由命名，那么我们可以通过路由分发过程中的include函数来指定不同<code>app</code>所属的命名空间</p></blockquote><p>​<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line">urlpatterns = [    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">               path(<span class="string">'app1/'</span>,include((<span class="string">"app1.urls"</span>,<span class="string">'app1'</span>))), </span><br><span class="line">               <span class="comment">#直接传递一个元祖，元祖第一个值为分发路由地址，第二个值为命名空间</span></span><br><span class="line">               path(<span class="string">'app2/'</span>,include((<span class="string">"app2.urls"</span>,<span class="string">'app2'</span>)))]</span><br></pre></td></tr></table></figure></p><blockquote><p>当为每个<code>app</code>的路由分发映射设置了命名空间，接下来在模板页面以及视图函数对路由的反向解析将是如下所示的样子，路由解析前加冒号指明命名空间</p></blockquote><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">def index(request):</span></span><br><span class="line"><span class="xml">    return redirect(reverse("app1:left"))</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-tag">&#123;% <span class="name"><span class="name">url</span></span> 'app2:left' %&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span>app2:left<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="应用命名空间：app-name"><a href="#应用命名空间：app-name" class="headerlink" title="应用命名空间：app_name"></a>应用命名空间：app_name</h4><blockquote><p>使用<code>app_name</code>指明命名空间，在子<code>app</code>的<code>urls.py</code>文件下配置全局变量<code>app_name</code>，这个值是唯一的</p><p>在这个路由文件中定义的其他映射关系，将具有命名空间<code>app1</code></p></blockquote><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app_name</span> = <span class="string">"app1"</span> <span class="comment"># 这个值应该是唯一的urlpatterns = [   ...]</span></span><br></pre></td></tr></table></figure><h4 id="实例命名空间：namespace"><a href="#实例命名空间：namespace" class="headerlink" title="实例命名空间：namespace"></a>实例命名空间：namespace</h4><blockquote><p>当有多个子<code>app</code>同时引入同一个子路由映射文件，比如这样</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line">urlpatterns = [    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">               path(<span class="string">'app1/'</span>,include(<span class="string">"app1.urls"</span>)),</span><br><span class="line">               path(<span class="string">'app2/'</span>,include(<span class="string">"app1.urls"</span>))]</span><br></pre></td></tr></table></figure><blockquote><p>这就会出现一个问题，不同的路由访问在做路由反向解析时，会造成混淆，</p><p>此时需要给每一个路由分发的规则设置<code>namespace</code>属性，为实例进行命名空间</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,include</span><br><span class="line">urlpatterns = [    path(<span class="string">'admin/'</span>, admin.site.urls),    path(<span class="string">'app1/'</span>,include(<span class="string">"app1.urls"</span>,namespace=<span class="string">"app1"</span>)),    path(<span class="string">'app2/'</span>,include(<span class="string">"app1.urls"</span>,namespace=<span class="string">"app2"</span>))]</span><br></pre></td></tr></table></figure><blockquote><p>这样做的好处，可以在不同路由导向同一<code>app</code>下时，为他们的不同命名空间；</p><p>虽然看起来到最后执行的视图函数功能是一样的，但可以分清楚究竟是哪个路由引起视图函数在工作</p><p>接下来视图及模板页面中使用<code>namespace</code>的值</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    我是左页面</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    路由参数: &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app1:right' 123 %&#125;"</span>&gt;</span>app1的右页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是右页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app1:left' 'abc' %&#125;"</span>&gt;</span>app1的左页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ----------------------------------------- --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是左页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app2:right' 123 %&#125;"</span>&gt;</span>app2的右页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是右页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>路由参数: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'app2:left' 'abc' %&#125;"</span>&gt;</span>app2的左页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;路由层&quot;&gt;&lt;a href=&quot;#路由层&quot; class=&quot;headerlink&quot; title=&quot;路由层&quot;&gt;&lt;/a&gt;路由层&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;路由是Web服务的入口，就好像办事大厅有各个服务窗口一样&lt;/p&gt;
&lt;/blockquote&gt;&lt;blockquote&gt;
&lt;p&gt;Django奉行DRY主义，提倡使用简洁、优雅的URL：&lt;/p&gt;
&lt;p&gt; 可以不用&lt;code&gt;.html&lt;/code&gt;、&lt;code&gt;.php&lt;/code&gt;或&lt;code&gt;.cgi&lt;/code&gt;之类后缀&lt;/p&gt;
&lt;p&gt; 尽量不要单独使用无序随机数字这样无意义的东西&lt;/p&gt;
&lt;p&gt; 让你随心所欲设计你的URL，不受框架束缚&lt;/p&gt;
&lt;/blockquote&gt;&lt;h3 id=&quot;路由&quot;&gt;&lt;a href=&quot;#路由&quot; class=&quot;headerlink&quot; title=&quot;路由&quot;&gt;&lt;/a&gt;路由&lt;/h3&gt;&lt;h4 id=&quot;urlpatterns&quot;&gt;&lt;a href=&quot;#urlpatterns&quot; class=&quot;headerlink&quot; title=&quot;urlpatterns&quot;&gt;&lt;/a&gt;urlpatterns&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;urlpatterns是路由文件中的一个全局变量，用来存放路由及视图函数的映射关系&lt;/p&gt;
&lt;p&gt;用户发起的请求&lt;code&gt;URL&lt;/code&gt;都会首先进入主控制目录下的这个&lt;code&gt;urls.py&lt;/code&gt;文件中进行查找匹配&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django-Models-模型层</title>
    <link href="https://cy-blogs.cn/Django-Models-%E6%A8%A1%E5%9E%8B%E5%B1%82/"/>
    <id>https://cy-blogs.cn/Django-Models-模型层/</id>
    <published>2019-12-03T08:05:23.931Z</published>
    <updated>2019-12-09T11:26:11.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模型层"><a href="#模型层" class="headerlink" title="模型层"></a>模型层</h2><blockquote><p>该层开发的首要任务就是定义模型类以及属性</p><p>每个模型都可以被映射为数据库中的一个数据表，而类属性被映射为为数据字段</p></blockquote><h3 id="配置Mysql数据库"><a href="#配置Mysql数据库" class="headerlink" title="配置Mysql数据库"></a>配置Mysql数据库</h3><blockquote><p>在确保<code>mysql</code>数据库可以连接使用的情况下；</p><p>首先在数据库中创建专为<code>django</code>使用的库<code>django_data</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database django_data;</span><br></pre></td></tr></table></figure><a id="more"></a><blockquote><p>配置django的settings.py文件中的DATABASES属性如下</p></blockquote><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">DATABASES = &#123;</span></span><br><span class="line"><span class="xml">    'default': &#123;     </span></span><br><span class="line"><span class="xml">    'ENGINE': 'django.db.backends.mysql', # 数据库引擎 </span></span><br><span class="line"><span class="xml">    'NAME': "django_data", # 使用的库名   </span></span><br><span class="line"><span class="xml">    "USER": "root", # 用户名   </span></span><br><span class="line"><span class="xml">    "PASSWORD": "123456", # 数据库密码    </span></span><br><span class="line"><span class="xml">    "HOST": "localhost", # 数据库主机地址    </span></span><br><span class="line"><span class="xml">    "PORT": "3306"  </span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>由于使用<code>django</code>的<code>Python</code>版本为3+；</p><p>此时对于<code>mysql</code>的支持已经变为<code>pymysql</code>，而对于<code>django</code>加载数据库引擎时还需要使用2版本的<code>mysqldb</code>名称</p><p>现在先需要我们安装<code>pymysql</code>之后在项目中重申mysql引擎</p></blockquote><ol><li><p>首先安装pymysql</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pymysql -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></li><li><p>项目主目录下的<code>__init__</code>文件中添加如下内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure></li><li><p>现在整个项目的数据库使用已经切换到了<code>mysql</code></p></li></ol><h3 id="模型层字段"><a href="#模型层字段" class="headerlink" title="模型层字段"></a>模型层字段</h3><blockquote><p>在模型层类中的字段即是数据库中表的字段，表的字段设计非常重要</p><p>每一个字段都是<code>Field</code>基类的一个实例（<code>Field</code>类用来建立字段与数据库之间的映射）</p><p>模型字段定义不能以下划线结尾</p></blockquote><ul><li>django会根据在模型类中定义的字段属性来确定以下几点工作<ul><li>数据库中使用的数据类型</li><li>模型类对应的表单类渲染时使用的表单类型及<code>HTML</code>部件</li><li>必填字段等最低限度的验证要求检查，包括<code>admin</code>界面下自动生成的表单</li></ul></li></ul><h4 id="BooleanField"><a href="#BooleanField" class="headerlink" title="BooleanField"></a>BooleanField</h4><blockquote><p><code>BooleanField(**options)</code>：True/False字段，默认值为None</p></blockquote><blockquote><p>表单类型：<strong>CheckboxInput</strong>，``</p></blockquote><h4 id="CharField"><a href="#CharField" class="headerlink" title="CharField"></a>CharField</h4><blockquote><p><code>CharField(max_length=None)</code>：字符串字段</p></blockquote><blockquote><p>含有一个必须参数：<code>max_length</code>设置最大的<strong>字符数</strong>长度限制；</p></blockquote><blockquote><p>表单类型：<strong>TextInput</strong>，``</p></blockquote><h4 id="DateField"><a href="#DateField" class="headerlink" title="DateField"></a>DateField</h4><blockquote><p><code>DateField(auto_now=False, auto_now_add=False,**options)</code>：以 <code>datetime.date</code>实例表示的日期</p></blockquote><blockquote><p>含有两个可选参数：<code>auto_now</code>、<code>auto_now_add</code></p><p><code>auto_now</code>：该值为True时，每次在保存数据对象时，自动设置该字段为当前时间，也可以理解为自动更新最后一次修改时间</p><p><code>auto_now_add</code>：该值为<code>True</code>时，该字段设置在第一次数据对象创建时，可以记录当前字段创建的时间值</p></blockquote><blockquote><p><strong>注意</strong>：避免矛盾，<code>auto_now</code>，<code>auto_now_add</code>，<code>default</code>不能同时出现，一个字段属性只能有其中一条设置，当设置了<code>auto_now</code>，或<code>auto_now_add</code>时，也会让该字段默认具有<code>blank=True</code>（字段可以为空）属性</p></blockquote><blockquote><p>表单类型：<strong>TextInput</strong>，``</p></blockquote><h4 id="DatetimeField"><a href="#DatetimeField" class="headerlink" title="DatetimeField"></a>DatetimeField</h4><blockquote><p><code>DatetimeField(auto_now=False, auto_now_add=False,**options)</code>：以<code>datetime.datetime</code>实例表示的日期和时间</p><p>和<code>DateField</code>具有相同的字段属性</p></blockquote><h4 id="DecimalField"><a href="#DecimalField" class="headerlink" title="DecimalField"></a>DecimalField</h4><blockquote><p><code>DecimalField(max_digits=None,decimal_places=None, **options)</code>：以Decimal实例标示的十进制浮点数类型</p></blockquote><blockquote><p>含有两个可选参数：<code>max_digits</code>、<code>decimal_places</code></p><p><code>max_digits</code>：位数总数，包括小数点后的位数，必须大于<code>decimal_places</code>参数</p><p><code>decimal_places</code>：小数点后的数字数量，精度</p></blockquote><blockquote><p>表单类型：<strong>TextInput</strong>，``</p></blockquote><h4 id="EmailField"><a href="#EmailField" class="headerlink" title="EmailField"></a>EmailField</h4><blockquote><p><code>EmailField(max_length=254, **option)</code>：<code>CharField</code>子类，表示<code>Email</code>字段，并会检查是否为合法邮箱地址</p></blockquote><blockquote><p>默认参数：<code>max_length</code>，表示邮箱地址长度，默认为254</p></blockquote><blockquote><p>表单类型：<strong>TextInput</strong>，``</p></blockquote><h4 id="FloatField"><a href="#FloatField" class="headerlink" title="FloatField"></a>FloatField</h4><blockquote><p><code>FloatField(**options)</code>：使用<code>float</code>实例来表示的浮点数</p></blockquote><blockquote><p>表单类型：<strong>TextInput</strong>，``</p></blockquote><h4 id="IntegerField"><a href="#IntegerField" class="headerlink" title="IntegerField"></a>IntegerField</h4><blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; IntegerField(**options)`：一个整数，范围由`-<span class="number">2147483648</span>`到`2147483647</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="GenericIPAddressField"><a href="#GenericIPAddressField" class="headerlink" title="GenericIPAddressField"></a>GenericIPAddressField</h4><blockquote><p><code>GenericIPAddressField(protocol=both, unpack_ipv4=False, **options)</code>：一个IPV4或IPV6地址的字符串</p></blockquote><blockquote><p>默认参数：<code>protocol</code>、<code>unpack_ipv4</code></p><p><code>protocol</code>：IP协议，ipv4或ipv6，默认<code>both</code>为全选</p><p><code>unpack_ipv4</code>：解析IP地址，只有当协议为<code>both</code>时才可以使用</p></blockquote><blockquote><p>表单类型：<strong>TextInput</strong>，``</p></blockquote><h4 id="SlugField"><a href="#SlugField" class="headerlink" title="SlugField"></a>SlugField</h4><blockquote><p><code>SlugField(max_length=50, **option)</code>：只包含字母、数字、下划线的字符串，常用来表示连接中的<code>path</code>部分或者一些其他短标题类型数据</p></blockquote><h4 id="TextField"><a href="#TextField" class="headerlink" title="TextField"></a>TextField</h4><blockquote><p><code>TextField(**options)</code>：大文本字段</p></blockquote><blockquote><p>表单类型：<strong>Textarea</strong>，<code>...</code></p></blockquote><h4 id="URLField"><a href="#URLField" class="headerlink" title="URLField"></a>URLField</h4><blockquote><p><code>URLField(max_length=200, **options)</code>：<code>CharField</code>的子类，存储URL的字段</p></blockquote><blockquote><p>表单类型：<strong>TextInput</strong>，``</p></blockquote><h3 id="字段属性"><a href="#字段属性" class="headerlink" title="字段属性"></a>字段属性</h3><blockquote><p>以上所介绍的字段，均支持以下属性</p></blockquote><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><blockquote><p>如果该值为<code>True</code>，Django将在数据库中将控制存储为<code>NULL</code></p><p>字符串字段<code>CharField</code>与<code>TextField</code>要避免使用<code>null</code>，因为空值字符串将存储空字符串（””）,而不是<code>null</code>值。</p><p>对于字符串类型的数据字段，大多数情况下，<code>django</code>使用空字符串代表空值</p></blockquote><h4 id="blank"><a href="#blank" class="headerlink" title="blank"></a>blank</h4><blockquote><p>如果该值为<code>True</code>，则在验证时该字段值可以为空；</p><p><code>null</code>为数据库存储层面可以为空，而<code>blank</code>为表单验证层面可以填写空值</p></blockquote><h4 id="choices"><a href="#choices" class="headerlink" title="choices"></a>choices</h4><blockquote><p>一个二元组的列表或元组；</p><p>元组中第一个值为真正在数据库中存储的值，第二个值为该选项的描述</p><p>该值一旦被设定，表单样式会显示选择框，而不是标准的文本框，选择框内的选项为<code>choices</code>中的元组</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTable</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    CHAR_CHOICE = [     </span><br><span class="line">        (<span class="string">'H'</span>,<span class="string">"非常苦难"</span>),    </span><br><span class="line">        (<span class="string">'M'</span>,<span class="string">"中等难度"</span>),     </span><br><span class="line">        (<span class="string">'S'</span>,<span class="string">"非常简单"</span>),</span><br><span class="line">    ]</span><br><span class="line">    choicechar = modesl.CharField(max_length=<span class="number">1</span>,choices=CHAR_CHOICE)</span><br></pre></td></tr></table></figure><ul><li><code>choices</code>字段也支持分类的写法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CHAR_CHOICE = [(<span class="string">'A'</span>,</span><br><span class="line">                 (</span><br><span class="line">                     (<span class="string">'H'</span>,<span class="string">"Hard"</span>),</span><br><span class="line">                 )),</span><br><span class="line">               (<span class="string">'B'</span>,</span><br><span class="line">                (</span><br><span class="line">                    (<span class="string">'M'</span>,<span class="string">"Medium"</span>),</span><br><span class="line">                )</span><br><span class="line">               ),</span><br><span class="line">               …</span><br><span class="line">              ]</span><br></pre></td></tr></table></figure><blockquote><p>分类的名称作为元组中的第一个值，</p><p>元组的第二个值为该分类下的一个新的二元组序列数据</p></blockquote><h4 id="db-column"><a href="#db-column" class="headerlink" title="db_column"></a>db_column</h4><blockquote><p>数据库中用来表示该字段的名称，如果未指定，那么Django将会使用<code>Field</code>名作为字段名</p></blockquote><h4 id="db-index"><a href="#db-index" class="headerlink" title="db_index"></a>db_index</h4><blockquote><p>当该值为<code>True</code>时，为该字段创建索引</p></blockquote><h4 id="default"><a href="#default" class="headerlink" title="default"></a>default</h4><blockquote><p>该字段默认值，可以是一个值或是一个回调函数</p><p>当是一个函数对象时，在创建新对象时，函数调用</p></blockquote><h4 id="editable"><a href="#editable" class="headerlink" title="editable"></a>editable</h4><blockquote><p>如果设置该值为False，那么这个字段将不允许被编辑</p><p>不会出现在admin后台界面下，以及其他ModelForm表单中，同时也会跳过模型验证</p></blockquote><h4 id="primary-key"><a href="#primary-key" class="headerlink" title="primary_key"></a>primary_key</h4><blockquote><p>设置该值为<code>True</code>时，该字段成为模型的主键字段，<strong>一个模型类同时只能有一个主键</strong></p><p>如果一个表中不存在任意一个设置好的主键字段，<strong>django会自动设置一个自增</strong>的<code>AutoField</code>字段来充当主键，该值可以用<code>pk</code>，<code>id</code>方式获取。主键的设置还意味着，<code>null=False</code>，<code>unique=True</code></p></blockquote><h4 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h4><blockquote><p>如果该值为True，代表这个数据在当前的表中有唯一值</p><p>这个字段还会在模型层验证存储的数据是否唯一</p><p>unique的设置也意味着当前字段具备索引的创建</p><p><code>ManyToManyField</code>、<code>OneToOneField</code>与<code>FileField</code>字段不可以使用该属性</p></blockquote><h4 id="verbose-name"><a href="#verbose-name" class="headerlink" title="verbose_name"></a>verbose_name</h4><blockquote><p>对于字段的一个可读性更高的名称</p><p>如果没有设置该值，django将字段名中的下换线转换成空格，作为当前字段的数据库中名称</p></blockquote><h3 id="模型元属性"><a href="#模型元属性" class="headerlink" title="模型元属性"></a>模型元属性</h3><blockquote><p>在模型类的<code>Meta</code>类中，可以提供一系列的元选项，可以方便对该模型类进行属性设置或约束等</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTable</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    …</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        ordering = [Fields]</span><br><span class="line">        …</span><br></pre></td></tr></table></figure><h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><blockquote><p>代表当前模型类为抽象基类，不会创建真正的数据表，只是为了其他模型类继承使用</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract = <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="app-label"><a href="#app-label" class="headerlink" title="app_label"></a>app_label</h4><blockquote><p>当模型类被定义在了其他app下，这个属性用来描述当前表属于哪个app应用</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app_label = <span class="string">"MyApp"</span></span><br></pre></td></tr></table></figure><h4 id="db-table"><a href="#db-table" class="headerlink" title="db_table"></a>db_table</h4><blockquote><p>当前模型类所对应的表名，未设置时，django默认将表名与app名由下划线组成，作为表名</p><p>需要注意这个表名为真实在数据库中所使用的，所以该元选项的使用应在数据表创建之前</p><p>如果在表已经存在的情况下去修改，会导致数据库内表与模型类表名不一致而查找不到报错</p></blockquote><h4 id="ordering"><a href="#ordering" class="headerlink" title="ordering"></a>ordering</h4><blockquote><p>当前表中的数据存储时的排序规则，这是一个字段名的字符串，可以是一个列表或元组；</p><p>每一个字符串前可以使用”<code>-</code>“来倒序排序，使用”<code>?</code>“随机排序</p><p>ordering排序规则的添加，也会增加数据库的开销</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ordering = [<span class="string">'-birthday'</span>, <span class="string">'age'</span>]</span><br><span class="line"><span class="comment">#先按照birthday倒序排序，再按照age字段进行排序。</span></span><br></pre></td></tr></table></figure><h4 id="unique-together"><a href="#unique-together" class="headerlink" title="unique_together"></a>unique_together</h4><blockquote><p>用来设置表中的不重复字段组合</p><p>格式为一个元组，元组中的每个数据都是一个元组，用来描述不重复的组合字段</p><p>如果只处理单一字段组合，可以是一个一维的元组</p><p>联合约束</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_together = ((<span class="string">'name'</span>,<span class="string">'phone'</span>),)</span><br></pre></td></tr></table></figure><h4 id="verbose-name-1"><a href="#verbose-name-1" class="headerlink" title="verbose_name"></a>verbose_name</h4><blockquote><p>一般设置该表展示时所用的名称，名称被自动处理为复数，字符串后加一个”s”</p></blockquote><h4 id="verbose-name-plural"><a href="#verbose-name-plural" class="headerlink" title="verbose_name_plural"></a>verbose_name_plural</h4><blockquote><p>与<code>verbose_name</code>功能相同，但是不会自动在字符串后加”<code>s</code>“以表复数</p><p>设置表的复数名称</p></blockquote><h3 id="模型操作"><a href="#模型操作" class="headerlink" title="模型操作"></a>模型操作</h3><blockquote><p>在进行模型操作的学习之前，可以先创建一个测试的数据库模型类，如下所示</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">10</span>,verbose_name=<span class="string">"姓名"</span>)</span><br><span class="line">    age = models.IntegerField(verbose_name=<span class="string">"年龄"</span>)</span><br></pre></td></tr></table></figure><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><blockquote><p>django自带了一个数据库测试的shell工具</p><p>这是一个非常方便可以让我们对django代码进行测试的环境</p><p>可以直接通过<code>python manage.py shell</code>命令行管理工具来打开</p></blockquote><h5 id="实例save创建数据"><a href="#实例save创建数据" class="headerlink" title="实例save创建数据"></a>实例save创建数据</h5><blockquote><p><strong>通过模型类的关键词参数实例化一个对象来进行数据的创建</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> app.models <span class="keyword">import</span> Person</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1 = Person(name=<span class="string">'张三'</span>,age=<span class="number">15</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1.save()</span><br></pre></td></tr></table></figure><blockquote><p>以上的代码，在为字段赋予值之后，通过实例的save函数进行该数据的保存</p><p>在数据库底层执行了<code>SQL</code>语句中的<code>insert</code>操作，并且，在我们显示调用<code>save</code>之前，<code>django</code>不会访问数据库，实例数据只存在于内存中</p></blockquote><blockquote><p><strong>注意</strong>：<code>save</code>函数没有返回值</p></blockquote><h5 id="create方法创建数据"><a href="#create方法创建数据" class="headerlink" title="create方法创建数据"></a>create方法创建数据</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>P1 = Person.objects.create(name=<span class="string">'李四'</span>,age=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这条语句创建一条数据，并且返回一个数据在内存中的实例P1</p><p>之后可以通过这个实例字段P1对数据库中该条数据进行修改或删除操作</p><p><code>create</code> 方法一步到位，<code>save</code>方式可以慢悠悠的赋予字段值，最后赋予结束再save</p></blockquote><h4 id="查找对象"><a href="#查找对象" class="headerlink" title="查找对象"></a>查找对象</h4><blockquote><p>接下来，我们将通过模型类中的管理器进行数据的查询；</p><p>管理器<code>（Manager）</code>是每一个模型类所具有的，默认名为<code>objects</code></p><p>模型类通过模型类调用<code>orm</code>数据接口，其实就是在对数据表进行操作。</p><p><strong>注意</strong>，具体的某一条数据无法访问这个管理器</p></blockquote><h5 id="all"><a href="#all" class="headerlink" title="all()"></a><code>all()</code></h5><blockquote><p>获取一个表中的所有数据，返回<code>QuerySet</code>数据对象</p></blockquote><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_person = Person.objects.all()</span><br></pre></td></tr></table></figure></li></ul><h5 id="filter-kwargs"><a href="#filter-kwargs" class="headerlink" title="filter(**kwargs)"></a><code>filter(**kwargs)</code></h5><blockquote><p>返回一个包含数据对象的集合，满足参数中所给的条件</p></blockquote><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = Person.objects.all().filter(age__lt=<span class="number">16</span>)</span><br><span class="line">res = Person.objects.filter(age__lt=<span class="number">16</span>)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>我们在查询过程中，除了直接使用字段属性进行验证</p><p>还可以在字段名之后使用双下化线来标明更加详细的字段筛选条件（在下一节会有详细的字段筛选条件介绍），也叫做链式过滤</p><p>这也是为什么表单类字段不可以以下换线结尾的原因</p></blockquote><h5 id="exclude-kwargs"><a href="#exclude-kwargs" class="headerlink" title="exclude(**kwargs)"></a><code>exclude(**kwargs)</code></h5><blockquote><p>返回一个包含数据对象的集合，数据为不满足参数中所给的条件</p></blockquote><blockquote><p>filter()查询会始终返回一个结果集，哪怕只有一个数据。</p><p>但是有些时候，我们对于一些在数据表中的唯一数据进行查询时，可以使用更加合适的<code>get</code>方法</p></blockquote><hr><blockquote><p><strong>注意</strong>：创建结果集的过程不涉及任何数据库的操作，查询工作是惰性的，在上面的查询方式中，查询代码不会实际访问数据库，只有查询集在真正使用时，django才会访问数据库</p></blockquote><h5 id="get-kwargs"><a href="#get-kwargs" class="headerlink" title="get(**kwargs)"></a><code>get(**kwargs)</code></h5><blockquote><p>获取唯一单条数据</p></blockquote><blockquote><p>get获取数据只会返回一条匹配的结果，获取的数据只能在数据库中有一条</p><p>如果返回多个结果，会引发<code>MultipleObjectsReturned</code>异常</p><p>如果没有任何匹配到的结果也会引发<code>DoesNotExist</code>异常</p></blockquote><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.objects.get(pk=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul><h5 id="order-by-field"><a href="#order-by-field" class="headerlink" title="order_by(*field)"></a><code>order_by(*field)</code></h5><blockquote><p>默认情况下，数据表使用模型类中的Meta中指定的ordering选项进行排序</p><p>现在也可以通过使用order_by函数进行查询结果的排序</p></blockquote><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.objects.order_by(<span class="string">'age'</span>)</span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.objects.all().order_by(<span class="string">'-age'</span>)</span><br></pre></td></tr></table></figure></li></ul><h5 id="count"><a href="#count" class="headerlink" title="count()"></a><code>count()</code></h5><blockquote><p>返回数据库中对应字段的个数，并且该函数永远不会引发异常</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">models.Person.objects.filter(age=<span class="number">20</span>).count()Person.objects.count()</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>count</code>函数时，还需要对数据表进行迭代访问</p><p>所以有时使用已生产好的结果集，通过len函数获取长度，这种方式效率会更高</p><p><code>count</code>方法的调用会导致额外的数据库查询</p></blockquote><h5 id="values-fields"><a href="#values-fields" class="headerlink" title="values(*fields)"></a><code>values(*fields)</code></h5><blockquote><p>返回一个查询集结果，但是迭代访问时返回的是字典，而不是数据实例对象</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">models.Person.objects.all().values()models.Person.objects.values()</span><br></pre></td></tr></table></figure><h4 id="链式过滤条件"><a href="#链式过滤条件" class="headerlink" title="链式过滤条件"></a>链式过滤条件</h4><ul><li><p><code>exact</code></p><blockquote><p>如果在查询过程中，没有提供查询类型（没有<code>双下划线</code>），那么查询类型就会被默认指定为<code>exact</code>，这是一种严格查找的方式，用来在数据库中查找和查询时的关键词参数完全一致的内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.objects.filter(account=<span class="string">'root'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.objects.filter(account__exact=<span class="string">'root'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>iexact</code></p><blockquote><p>忽略大小写的匹配</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.objects.filter(account__iexact=<span class="string">'root'</span>)</span><br><span class="line"><span class="comment">#匹配到的结果可能是Root，ROot，ROOt，ROOT</span></span><br></pre></td></tr></table></figure></li><li><p><code>startswith、endswith</code></p><blockquote><p>分别匹配开头和结尾，区分大小写</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.objects.filter(passwd__startswith=<span class="string">'admin'</span>)</span><br><span class="line"><span class="comment">#匹配以admin开头的数据</span></span><br></pre></td></tr></table></figure></li><li><p><code>istartswith、iendswith</code></p><blockquote><p>分别匹配开头和结尾，忽略大小写</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.objects.filter(passwd__istartswith=<span class="string">'admin'</span>)匹配以不区分大小写的字符串admin为开头的数据</span><br></pre></td></tr></table></figure></li><li><p><code>gte</code></p><blockquote><p>大于或等于</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.objects.filter(reg_data__gte=datetime.date.today)</span><br></pre></td></tr></table></figure></li><li><p><code>lte</code></p><blockquote><p>小于或等于</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Person.objects.filter(reg_data__lte=datetime.date.today)</span><br></pre></td></tr></table></figure></li></ul><h4 id="修改对象"><a href="#修改对象" class="headerlink" title="修改对象"></a>修改对象</h4><blockquote><p>获取到对应的数据实例之后，通过<code>.</code>的方式访问数据实例中的属性，进行数据的字段修改</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = models.Person.objects.get(pk=<span class="number">1</span>)p.age = <span class="number">21</span>p.save()</span><br></pre></td></tr></table></figure><blockquote><p>对过滤出的结果链式调用<code>update()</code>函数，这样的修改，类似批量修改，<code>update</code>函数会返回成功修改的个数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">models.Person.objects.filter(age__gt=<span class="number">100</span>).update(age=<span class="number">25</span>)<span class="comment"># 将所有年纪小于100的人的年纪改为20</span></span><br></pre></td></tr></table></figure><h4 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h4><blockquote><p>对于普通的单表数据删除，获取到数据实例对象后调用内置的<code>delete()</code>函数即可</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">models.Person.objects.get(pk=<span class="number">1</span>).delete()</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，删除一条数据之后，默认占有的主键ID值并不会被下一个新插入的值所占用</p><p>比如 1，2，3，4；删除掉3之后，剩下：1，2，4；下一个值存储时，id是5，3不会被复用</p></blockquote><h3 id="字段关系"><a href="#字段关系" class="headerlink" title="字段关系"></a>字段关系</h3><ul><li>字段关系是<code>django</code>维护表关系的方式；其中主要有一对一，多对一以及多对多，</li><li>现在的一对一及多对一关系中需要设置<code>on_delete</code>属性用来描述当关联数据被删除时的操作，有如下一些</li></ul><blockquote><p><strong>models.CASCADE</strong>：删除关联数据,与之关联也删除</p><p>models.PROTECT：删除关联数据,引发错误<code>ProtectedError</code></p><p><strong>models.SET_NULL</strong>：与之关联的值设置为<code>null</code>（前提<code>FK</code>字段需要设置为可空）</p><p>models.SET_DEFAULT： 删除关联数据,与之关联的值设置为默认值（前提FK字段需要设置默认值）</p><p>models.DO_NOTHING：删除关联数据,什么也不做</p></blockquote><h4 id="一对一关系"><a href="#一对一关系" class="headerlink" title="一对一关系"></a>一对一关系</h4><blockquote><p>模型类使用<code>OneToOneField</code>用来定义一对一关系；</p><p>比如当你拥有一个老师表时，紧接着你还需要一个教授表，那么教授表可能拥有老师表的一系列属性，那么你还不想把老师表中的字段直接复制到教授表那么可以通过<code>OnToOneField</code>来实现教授表继承老师表。</p><p>其实，在使用模型类继承时，也隐含有一个一对一关系</p></blockquote><ul><li><code>OneToOneField(to, on_delete, parent_link=False, options)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(models.Model)</span>:</span>  </span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    age = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>     </span><br><span class="line">        <span class="keyword">return</span> self.nameclass Professor(models.Model): </span><br><span class="line">        teacher = models.OneToOneField(Teacher,primary_key=<span class="literal">True</span>,on_delete=models.CASCADE)    big_project = models.CharField(max_length=<span class="number">50</span>) </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>    </span><br><span class="line">            <span class="keyword">return</span> self.teacher.name</span><br></pre></td></tr></table></figure><blockquote><p>在<code>manage.py shell</code>下进行数据库操作</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = Teacher.objects.create(name=<span class="string">'Jack'</span>,age=<span class="string">'22'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = Teacher.objects.create(name=<span class="string">'Bob'</span>,age=<span class="string">'17'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1 = Professor.objects.create(teacher=t1,big_project=<span class="string">'雾霾净化术'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1.teacher&lt;Teacher: Jack</span><br><span class="line">&gt;&gt;&gt;&gt; p1.teacher = t2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1.teacher&lt;Teacher: Bob&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的测试中，看似已经将<code>p1</code>对应的教授变成了<code>Bob</code>；</p><p>但是在数据库中之前<code>t1</code>老师所对应的教授信息还存在，此时的赋值操作并不会覆盖掉教授他之前的教授数据，只是重新创建了一条。</p><p>正确的做法应该是将某一条数据的一对一关系通过<code>delete</code>关系先删除之后再重新赋予</p></blockquote><h4 id="多对一关系"><a href="#多对一关系" class="headerlink" title="多对一关系"></a>多对一关系</h4><blockquote><p><code>Django</code>使用<code>django.db.models.ForeignKey</code>定义多对一关系。</p><p><code>ForeignKey</code>需要一个位置参数：与该模型关联的类</p></blockquote><blockquote><p>生活中的多对一关系：班主任，班级关系。一个班主任可以带很多班级，但是每个班级只能有一个班主任</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Headmaster</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>      </span><br><span class="line">        <span class="keyword">return</span> self.nameclass Class(models.Model):  </span><br><span class="line">        class_name = models.CharField(max_length=<span class="number">50</span>)  </span><br><span class="line">        teacher = models.ForeignKey(Headmaster,null=<span class="literal">True</span>,on_delete=models.SET_NULL)    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>   </span><br><span class="line">            <span class="keyword">return</span> self.class_name</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>H1 = Headmaster(name=<span class="string">'渔夫'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>H1.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>H1&lt;Headmaster: 渔夫</span><br><span class="line">&gt;&gt;&gt;&gt; H2 = Headmaster(name=<span class="string">'农夫'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>H2.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Headmaster.objects.all()[&lt;Headmaster: 渔夫&gt;, &lt;Headmaster: 农夫&gt;]</span><br></pre></td></tr></table></figure><blockquote><p>以上创建了两条老师数据</p><p>由于我们设置外键关联可以为空<code>null=True</code>,所以此时在班级表创建时，可以直接保存，不需要提供老师数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C1 = Class(class_name=<span class="string">'一班'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C2 = Class(class_name=<span class="string">'二班'</span>)</span><br><span class="line"><span class="comment">#如果外键设置不为空时，保存会引发以下错误</span></span><br><span class="line"><span class="comment"># IntegrityError: NOT NULL constraint failed: bbs_class.teacher_id</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C1.teacher = H1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C2.teacher = H2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C1.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C2.save()</span><br></pre></td></tr></table></figure><blockquote><p>将老师分配个班级之后，由于班级表关联了老师字段，我们可以通过班级找到对应老师</p><p>虽然老师表中没有关联班级字段，但是也可以通过老师找到他所带的班级，这种查询方式也叫作关联查询</p><p>通过模型类名称后追加一个’_set’，来实现反向查询</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>H1.class_set.all()&lt;QuerySet [&lt;Class: 一班&gt;]&gt;</span><br></pre></td></tr></table></figure><blockquote><p>由于我们这是一个多对一的关系，也就说明我们的老师可以对应多个班级</p><p>我们可以继续给H1老师分配新的班级</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>C3 = Class(class_name=<span class="string">'三班'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C3.teacher = H1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C3.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>H1.class_set.all()[&lt;Class: 一班&gt;, &lt;Class: 三班&gt;]</span><br></pre></td></tr></table></figure><blockquote><p>一个班级只能对应一个老师，外键是唯一的，那么你在继续给C1班级分配一个新的老师时，会覆盖之前的老师信息，并不会保存一个新的老师</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>H3 = Headmaster(name=<span class="string">'伙夫'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>H3.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C1.teacher&lt;Headmaster: 渔夫</span><br><span class="line">&gt;&gt;&gt;&gt; C1.teacher=H3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C1.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C1.teacher&lt;Headmaster: 伙夫&gt;</span><br></pre></td></tr></table></figure><blockquote><p>把这个班级的老师删除，由于设置了外键字段可以为<code>null</code>，此时班级的老师选项为<code>null</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = Headmaster.objects.all().first()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c1 = Class.objects.all().first()&lt;Headmaster: 渔夫</span><br><span class="line">&gt;&gt;&gt;&gt; c1&lt;Class: 一班</span><br><span class="line">&gt;&gt;&gt;&gt; c1.teacher&lt;Headmaster: 渔夫</span><br><span class="line">&gt;&gt;&gt;&gt; t1.delete()(<span class="number">1</span>, &#123;<span class="string">'modelsapp.Headmaster'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c1 = Class.objects.all().first()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c1&lt;Class: 一班</span><br><span class="line">&gt;&gt;&gt;&gt; c1.teacher</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#这里什么都没有，因为此时C1的老师已经是个None了</span></span><br></pre></td></tr></table></figure><blockquote><p>要记得删除之后要重新获取一次数据，否则查看到的结果中还是之前获取到的有老师的班级数据</p></blockquote><h4 id="多对多关系"><a href="#多对多关系" class="headerlink" title="多对多关系"></a>多对多关系</h4><blockquote><p>多对多关系在模型中使用<code>ManyToManyField</code>字段定义</p><p>多对多关系可以是具有关联，也可以是没有关联，所以不需要明确指定<code>on_delete</code>属性</p></blockquote><blockquote><p>生活中，多对多关系：一个音乐家可以隶属于多个乐队，一个乐队可以有多个音乐家</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Artist</span><span class="params">(models.Model)</span>:</span>  </span><br><span class="line">    artist_name = models.CharField(max_length=<span class="number">50</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>      </span><br><span class="line">        <span class="keyword">return</span> self.artist_nameclass Band(models.Model):  </span><br><span class="line">        band_name = models.CharField(max_length=<span class="number">50</span>)  </span><br><span class="line">        artist = models.ManyToManyField(Artist)  </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>      </span><br><span class="line">            <span class="keyword">return</span> self.band_name</span><br></pre></td></tr></table></figure><blockquote><p>创建音乐家以及乐队</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bbs.models <span class="keyword">import</span> Artist,Band</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A1 = Artist.objects.create(artist_name=<span class="string">'Jack'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A2 = Artist.objects.create(artist_name=<span class="string">'Bob'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B1 = Band.objects.create(band_name=<span class="string">'FiveMonthDay'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B2 = Band.objects.create(band_name=<span class="string">'SHE'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>创建出两个乐队之后对其进行音乐家的添加</p><p>多对多字段添加时，可以使用<code>add</code>函数进行多值增加</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>B1.artist.add(A1,A2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B2.artist.add(A2)</span><br></pre></td></tr></table></figure><blockquote><p><code>B1</code>乐队含有<code>A1</code>,<code>A2</code>两名成员</p><p><code>B2</code>乐队含有<code>A1</code>成员</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>B1.artist.all()[&lt;Artist: Bob&gt;, &lt;Artist: Jack&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B2.artist.all()[&lt;Artist: Jack&gt;]</span><br></pre></td></tr></table></figure><blockquote><p>可以在音乐家表中查找某个乐家属于哪些乐队</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Band.objects.filter(artist=A1) </span><br><span class="line"><span class="comment"># 这里使用的是我们模型类来进行查找。</span></span><br><span class="line">[&lt;Band: SHE&gt;, &lt;Band: FiveMonthDay&gt;] </span><br><span class="line"><span class="comment"># A1乐家属于，SHE以及FiveMonthDay</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Band.objects.filter(artist=A2)[&lt;Band: SHE&gt;]</span><br></pre></td></tr></table></figure><blockquote><p>也可以查找这音乐家在哪个乐队</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A1.band_set.all() </span><br><span class="line"><span class="comment"># 直接通过具体数据对象进行查找</span></span><br><span class="line">[&lt;Band: SHE&gt;, &lt;Band: FiveMonthDay&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A2.band_set.all()[&lt;Band: SHE&gt;]</span><br></pre></td></tr></table></figure><blockquote><p>多对多关联字段的删除，要使用<code>remove</code>来进行关系的断开</p><p>而不是直接使用<code>delete</code>，<code>remove</code>只会断开数据之间的联系，但是不会将数据删除</p><p>现在在B1乐队中删除A1乐家</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>B1.artist.remove(A1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B1.artist.all()&lt;QuerySet [&lt;Artist: Bob&gt;]&gt;</span><br></pre></td></tr></table></figure><h3 id="关联表的查询"><a href="#关联表的查询" class="headerlink" title="关联表的查询"></a>关联表的查询</h3><blockquote><p>如果想要查询的字段在关联表，则使用<code>表名小写__字段</code>来进行跨表查询操作</p></blockquote><blockquote><p>创建一个多对一关系的父子表，一个父亲可能有多个儿子</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    age = models.CharField(max_length=<span class="number">30</span>)    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>     </span><br><span class="line">        <span class="keyword">return</span> self.nameclass Son(models.Model):  </span><br><span class="line">        father = models.ForeignKey(Father,on_delete=models.CASCADE)  </span><br><span class="line">        name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>    </span><br><span class="line">            <span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure><blockquote><p>创建数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1 = Father.objects.create(name=<span class="string">'Jack'</span>,age=<span class="string">'30'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = Son.objects.create(name=<span class="string">'Json'</span>,father=f1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = Son.objects.create(name=<span class="string">'Json2'</span>,father=f1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2 = Father.objects.create(name=<span class="string">'Bob'</span>,age=<span class="string">'40'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3 = Son.objects.create(name=<span class="string">'Json3'</span>,father=f2)</span><br></pre></td></tr></table></figure><blockquote><p>查询所有父亲名字是<code>jack</code>的孩子</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Son.objects.filter(father__name__exact=<span class="string">'Jack'</span>)[&lt;Son: Json&gt;, &lt;Son: Json2&gt;]</span><br></pre></td></tr></table></figure><blockquote><p>查询所有儿子名开头为<code>J</code>的父亲</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Father.objects.filter(son__name__startswith=<span class="string">'J'</span>)[&lt;Father: Jack&gt;, &lt;Father: Jack&gt;, &lt;Father: Bob&gt;]</span><br></pre></td></tr></table></figure><blockquote><p>获取到某一个父亲的所有孩子，通过某一条数据的<code>小写表名_set</code>反向查询</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1.son_set.all()&gt;&gt;&gt; [&lt;Son: Json&gt;, &lt;Son: Json2&gt;]</span><br></pre></td></tr></table></figure><h3 id="数据的反向查询"><a href="#数据的反向查询" class="headerlink" title="数据的反向查询"></a>数据的反向查询</h3><blockquote><p>默认的，当有某一条数据获取到之后，我们可以通过模型类名称加上一个 <code>_set</code>，来实现反向查询</p><p>现在设计两个表为军队和士兵表，并且士兵多对一关联军队</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aramy</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>) </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>      </span><br><span class="line">        <span class="keyword">return</span> self.nameclass Soldier(models.Model): </span><br><span class="line">        aramy = models.ForeignKey(Aramy,on_delete=models.CASCADE)    </span><br><span class="line">        name = models.CharField(max_length=<span class="number">30</span>) </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure><blockquote><p>创建一些数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 = Aramy(name=<span class="string">'一军'</span>)&gt;&gt;&gt; a1.save()&gt;&gt;&gt; s1 = Soldier(name=<span class="string">'张三'</span>,aramy=a1)&gt;&gt;&gt; s1.save()&gt;&gt;&gt; s2 = Soldier(name=<span class="string">'李四'</span>,aramy=a1)&gt;&gt;&gt; s2.save()</span><br></pre></td></tr></table></figure><blockquote><p>通过<code>soldier_set</code>我们就可以关联到对应的士兵表</p><p>并且对应返回结果可以执行我们常用的<code>filter</code>，<code>exclude</code>等查询操作</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1.soldier_set.all()[&lt;Soldier: 张三&gt;, &lt;Soldier: 李四&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1.soldier_set.filter(name=<span class="string">'张三'</span>)[&lt;Soldier: 张三&gt;]</span><br></pre></td></tr></table></figure><blockquote><p>也可以通过定义关联字段中的<code>related_name</code>值，来实现自定义的反向查询名字</p><p>且<code>related_name</code>的值必须唯一</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aramy</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>     </span><br><span class="line">        <span class="keyword">return</span> self.nameclass Soldier(models.Model):   </span><br><span class="line">        aramy = models.ForeignKey(Aramy,on_delete=models.CASCADE,related_name=<span class="string">'soldier'</span>)    name = models.CharField(max_length=<span class="number">30</span>)  </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>   </span><br><span class="line">            <span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure><blockquote><p>接下来通过某条数据反向查询</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1 = Aramy.objects.all()[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = Soldier.objects.get(name=<span class="string">'张三'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1.soldier.all()[&lt;Soldier: 张三&gt;, &lt;Soldier: 李四&gt;]</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：<code>related_name</code>一定是一个唯一的值，否则反向查找时会出现二异性错误</p><p>也可以将<code>related_name</code>初始化为<code>+</code>，来取消反向查询</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模型层&quot;&gt;&lt;a href=&quot;#模型层&quot; class=&quot;headerlink&quot; title=&quot;模型层&quot;&gt;&lt;/a&gt;模型层&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;该层开发的首要任务就是定义模型类以及属性&lt;/p&gt;
&lt;p&gt;每个模型都可以被映射为数据库中的一个数据表，而类属性被映射为为数据字段&lt;/p&gt;
&lt;/blockquote&gt;&lt;h3 id=&quot;配置Mysql数据库&quot;&gt;&lt;a href=&quot;#配置Mysql数据库&quot; class=&quot;headerlink&quot; title=&quot;配置Mysql数据库&quot;&gt;&lt;/a&gt;配置Mysql数据库&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在确保&lt;code&gt;mysql&lt;/code&gt;数据库可以连接使用的情况下；&lt;/p&gt;
&lt;p&gt;首先在数据库中创建专为&lt;code&gt;django&lt;/code&gt;使用的库&lt;code&gt;django_data&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;create database django_data;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Cookie和Session</title>
    <link href="https://cy-blogs.cn/Cookie%E5%92%8CSession/"/>
    <id>https://cy-blogs.cn/Cookie和Session/</id>
    <published>2019-10-26T03:24:15.603Z</published>
    <updated>2019-12-09T11:25:59.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h2><blockquote><p><code>Cookie</code>及<code>Session</code>一直以来都是Web开发中非常关键的一环，因为<code>HTTP</code>协议本身为无状态，每一次请求之间没有任何状态信息保持，往往我们的Web服务无法在客户端访问过程中得知用户的一些状态信息，比如是否登录等等；那么这里通过引入<code>Cookie</code>或者<code>Seesion</code>来解决这个问题。</p></blockquote><a id="more"></a><blockquote><p>当客户端访问时，服务端会为客户端生成一个<code>Cookie</code>键值对数据，通过<code>Response</code>响应给到客户端。当下一次客户端继续访问相同的服务端时，浏览器客户端就会将这个<code>Cookie</code>值连带发送到服务端。</p></blockquote><blockquote><p><code>Cookie</code>值存储在浏览器下，一般在你的浏览器安装目录的<code>Cookie</code>目录下，我们也可以通过F12或者各种浏览器的开发者工具来获取到</p></blockquote><blockquote><p>因为<code>cookie</code>是保存在浏览器中的一个纯明文字符串，所以一般来说服务端在生成<code>cookie</code>值时不建议存储敏感信息比如密码</p></blockquote><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><blockquote><p>在<code>django</code>的代码中，我们可以使用一些提供<code>Response</code>响应的类，如：<code>HttpResponse</code>，<code>redirect</code>等实例的内置<code>set_cookie</code>函数来进行<code>django</code>项目中的<code>Cookie</code>设置</p></blockquote><ul><li><p><code>set_cookie(key, value=&#39;&#39;, max_age=None, expires=None, path=&#39;/&#39;,domain=None, secure=False, httponly=False)</code></p><blockquote><p><code>key</code>：<code>Cookie</code>的<code>key</code>值，未来通过该<code>key</code>值获取到对应设置好的<code>Cookie</code>。</p><p><code>value=&#39;&#39;</code>：对应<code>Cookie</code>的<code>key</code>值的<code>value</code>，比如：<code>set_cookie(key=&#39;value&#39;,value=&#39;shuai&#39;)</code></p><p><code>max_age=None</code>：<code>Cookie</code>生效的时间，单位为秒，如果<code>Cookie</code>值只持续在客户端浏览器的会话时长，那么这个值应该为<code>None</code>。存在该值时，<code>expires</code>会被计算得到。</p><p><code>expires=None</code>：<code>Cookie</code>具体过期日期，是一个<code>datetime.datetime</code>对象，如果该值存在，那么<code>max_age</code>也会被计算得到</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">import</span> datetime</span><br><span class="line">  current_time = datetime.datetime.now()</span><br><span class="line"><span class="comment"># 当前时间</span></span><br><span class="line">  expires_time = current_time + datetime.timedelta(seconds=<span class="number">10</span>)</span><br><span class="line">  <span class="comment"># 向后推延十秒</span></span><br><span class="line">  set_cookie(<span class="string">'key'</span>,<span class="string">'value'</span>,expires=expires_time) </span><br><span class="line">  <span class="comment">#设置Cookie及对应超时时间</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><code>path=&#39;/&#39;</code>：指定哪些<code>url</code>可以访问到<code>Cookie</code>，默认<code>/</code>为所有。</p><p><code>domain=None</code>：当我们需要设置的为一个跨域的Cookie值，那么可以使用该参数，比如：<code>domain=&#39;.test.com&#39;</code>，那么这个<code>Cookie</code>值可以被<code>www.test.com</code>、<code>bbs.test.com</code>等主域名相同的域所读取，否则<code>Cookie</code>只被设置的它的域所读取。为<code>None</code>时，代表当前域名下全局生效。</p><p><code>secure=False</code>：<code>https</code>加密传输设置，当使用<code>https</code>协议时，需要设置该值，同样的，如果设置该值为<code>True</code>，如果不是<code>https</code>连接情况下，不会发送该<code>Cookie</code>值。</p><p><code>httponly=False</code>：<code>HTTPOnly</code>是包含在<code>HTTP</code>响应头部中<code>Set-Cookie</code>中的一个标记。为一个<code>bool</code>值，当设置为<code>True</code>时，代表阻止客户端的<code>Javascript</code>访问<code>Cookie</code>。这是一种降低客户端脚本访问受保护的<code>Cookie</code>数据风险的有效的办法</p></blockquote><h4 id="设置COOKIE"><a href="#设置COOKIE" class="headerlink" title="设置COOKIE"></a>设置COOKIE</h4><blockquote><p>简单的实现一下<code>COOKIE</code>的设置</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponse</span><br><span class="line"><span class="comment"># Create your views here.def set_cookie(request): </span></span><br><span class="line"><span class="comment"># 在HTTPResponse部分设置COOKIE值  </span></span><br><span class="line">cookie_reponse = HttpResponse(<span class="string">'这是一个关于cookie的测试'</span>)   cookie_reponse.set_cookie(<span class="string">'test'</span>,<span class="string">'hello cookie'</span>) </span><br><span class="line"><span class="keyword">return</span> cookie_reponse</span><br></pre></td></tr></table></figure><blockquote><p>以上视图函数返回一个<code>HttpResponse</code>对象，并在该对象中集成<code>COOKIE</code>值的设定，设置<code>key</code>值为<code>test</code>，<code>value</code>值为<code>hello cookie</code></p></blockquote><h4 id="获取COOKIE"><a href="#获取COOKIE" class="headerlink" title="获取COOKIE"></a>获取COOKIE</h4><blockquote><p>再来简单的实现一下<code>COOKIE</code>的获取</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cookie</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># 获取cookie值，从request属性中的COOKIE属性中 </span></span><br><span class="line">    cookie_data = request.COOKIES.get(<span class="string">'test'</span>) </span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Cookie值为:%s'</span> % cookie_data)</span><br></pre></td></tr></table></figure><blockquote><p><code>Cookie</code>值存储在，<code>request</code>中的<code>COOKIES</code>属性中</p><p>并且该属性获取到的结果与字典类似，直接通过内置函数<code>get</code>获取即可</p></blockquote><h4 id="删除COOKIE"><a href="#删除COOKIE" class="headerlink" title="删除COOKIE"></a>删除COOKIE</h4><blockquote><p>这里通过该视图函数路由进行COOKIE的删除</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_cookie</span><span class="params">(request)</span>:</span>  </span><br><span class="line">    response = HttpResponseRedirect(<span class="string">'/check_cookie/'</span>)</span><br><span class="line">    response.delete_cookie(<span class="string">'test'</span>) </span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><ul><li><p><code>delete_cookie(key, path=&#39;/&#39;, domain=None)</code></p><blockquote><p>在<code>Cookie</code>中删除指定的<code>key</code>及对应的<code>value</code>，如果<code>key</code>值不存在，也不会引发任何异常。</p><p>由于<code>Cookie</code>的工作方式，<code>path</code>和<code>domain</code>应该与<code>set_cookie</code>时使用的值相同，否则<code>Cookie</code>值将不会被删除</p></blockquote></li></ul><blockquote><p>通过<code>response</code>相应类的<code>delete_cookie</code>方法，本来应该在会话结束之后才消失的<code>Cookie</code>值，现在已经被直接删除掉。后台中通过<code>Request</code>中的<code>Cookie</code>字典获取到值也为<code>None</code></p><p>不要忘记字典的get，获取不到结果时，返回<code>None</code></p></blockquote><blockquote><p>但是，现在还有一个问题，我们在用户浏览器存储的Cookei值为明文，具有极大的安全隐患，django也提供了加密的Cookie值存储及获取方式</p></blockquote><h4 id="防止篡改COOKIE"><a href="#防止篡改COOKIE" class="headerlink" title="防止篡改COOKIE"></a>防止篡改COOKIE</h4><blockquote><p>通过<code>set_signed_cookie</code>函数进行持有签名的<code>COOKIE</code>值设置，避免用户在客户端进行修改</p><p>要记得，这个函数并不是对<code>COOKIE</code>值进行加密</p></blockquote><ul><li><p><code>HttpResonse.set_signed_cookie(key, value, salt=&#39;&#39;, max_age=None, expires=None, path=&#39;/&#39;, domain=None, secure=None, httponly=True)</code></p><blockquote><p>为<code>cookie</code>值添加签名，其余参数与<code>set_cookie</code>相同</p></blockquote></li><li><p><code>Request.get_signed_cookie(key, salt=&#39;&#39;, max_age=None)</code></p><blockquote><p>从用户请求中获取通过salt盐值加了签名的<code>Cookie</code>值。</p><p>这里的<code>salt</code>要与之前存储时使用的<code>salt</code>值相同才可以解析出正确结果。</p><p>还要注意的是，如果对应的key值不存在，则会引发<code>KeyError</code>异常，所以要记得异常捕获来确定是否含有<code>Cookie</code>值</p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_salt_cookie</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        salt_cookie = request.get_signed_cookie(key=<span class="string">'salt_cookie'</span>,salt=<span class="string">'nice'</span>)    </span><br><span class="line">    <span class="keyword">except</span> KeyError: </span><br><span class="line">        <span class="comment">#获取不到该key值的Cookie</span></span><br><span class="line">        response = HttpResponse(<span class="string">'正在设置一个salt Cookie值'</span>)        response.set_signed_cookie(key=<span class="string">'salt_cookie'</span>,salt=<span class="string">'nice'</span>,value=<span class="string">'salt_cookie'</span>)          <span class="keyword">return</span> response    </span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#获取到了对应key值，展示到新的HttpResonse中       </span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'获取到的salt Cookie值:%s'</span> % salt_cookie)</span><br></pre></td></tr></table></figure><blockquote><p>第一次访问的时候，还没有加<code>Cookie</code>值，所以我们在获取的时候会抛出<code>KeyError</code>异常</p><p>此时捕获异常，并且设置<code>Cookie</code>即可；</p><p>再次刷新的时候，因为这里已经给出了<code>Cookie</code>值，则不会引发异常，会在页面中展示获取到的加盐<code>Cookie</code></p></blockquote><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><blockquote><p>虽然说有了<code>Cookie</code>之后，我们把一些信息保存在客户端浏览器中，可以保持用户在访问站点时的状态，但是也存在一定的安全隐患，<code>Cookie</code>值被曝露，<code>Cookie</code>值被他人篡改，等等。我们将换一种更健全的方式，也就是接下来要说的<code>Session</code>。</p><p><code>Session</code>在网络中，又称会话控制，简称会话。用以存储用户访问站点时所需的信息及配置属性。当用户在我们的<code>Web</code>服务中跳转时，存储在<code>Session</code>中的数据不会丢失，可以一直在整个会话过程中存活。</p><p>在<code>django</code>中，默认的<code>Session</code>存储在数据库中<code>session</code>表里。默认有效期为<strong>两个星期</strong>。</p></blockquote><h4 id="session创建流程"><a href="#session创建流程" class="headerlink" title="session创建流程"></a><strong>session创建流程</strong></h4><ol><li>客户端访问服务端，服务端为每一个客户端返回一个唯一的<code>sessionid</code>，比如<code>xxx</code>。</li><li>客户端需要保持某些状态，比如维持登陆。那么服务端会构造一个<code>{sessionid: xxx }</code>类似这样的字典数据加到<code>Cookie</code>中发送给用户。注意此时，只是一个随机字符串，返回给客户端的内容并不会像之前一样包含实际数据。</li><li>服务端在后台把返回给客户端的<code>xxx</code>字符串作为<code>key</code>值，对应需要保存的服务端数据为一个新的字典，存储在服务器上，例如：<code>{xxx : {id:1}}</code></li></ol><blockquote><p>之后的一些客户端数据获取，都是通过获取客户端向服务端发起的<code>HttpRequest</code>请求中里<code>Cookie</code>中的<code>sessionid</code>之后，再用该<code>sessionid</code>从服务端的<code>Session</code>数据中调取该客户端存储的<code>Session</code>数据</p></blockquote><blockquote><p><strong>注意</strong>：补充说明，默认存储在数据库的<code>Session</code>数据，是通过<code>base64</code> 编码的，我们可以通过<code>Python</code>的<code>base64</code>模块下的<code>b64decode()</code>解码得到原始数据</p></blockquote><blockquote><p>整个过程结束之后：客户端浏览器存储的其实也只是一个<strong>识别会话</strong>的随机字符串<code>（xxx）</code></p><p>而服务器中是通过这个随机的字符串<code>（xxx:value）</code>进行真正的存储</p></blockquote><blockquote><p><code>Session</code>的使用必须在<code>Settings</code>配置下</p></blockquote><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">INSTALLED_APPS = (</span></span><br><span class="line"><span class="xml">...    'django.contrib.sessions', </span></span><br><span class="line"><span class="xml">...</span></span><br><span class="line"><span class="xml">)</span></span><br><span class="line"><span class="xml">MIDDLEWARE_CLASSES = (  </span></span><br><span class="line"><span class="xml">'django.contrib.sessions.middleware.SessionMiddleware',</span></span><br><span class="line"><span class="xml">...</span></span><br><span class="line"><span class="xml">)</span></span><br></pre></td></tr></table></figure><blockquote><p>当<code>settings.py</code>中<code>SessionMiddleware</code>激活后</p><p>在视图函数的参数<code>request</code>接收到的客户端发来的<code>HttpResquest</code>请求对象中都会含有一个<code>session</code>属性</p><p>这个属性和之前所讨论的<code>Cookie</code>类似，是一个类字典对象，首先支持如下常用字典内置属性</p></blockquote><h4 id="获取Session"><a href="#获取Session" class="headerlink" title="获取Session"></a>获取Session</h4><ul><li><p><code>session_data = request.session.get(Key)</code></p></li><li><p><code>session_data = request.session[Key]</code></p><blockquote><p>在<code>Session</code>中获取对应值，<code>get</code>方法获取时，如不存在该<code>Key</code>值，不会引发异常，返回<code>None</code></p><p>而第二种直接通过字典获取，如<code>Key</code>值不存在，引发<code>KeyErro</code></p></blockquote></li></ul><h4 id="删除Session"><a href="#删除Session" class="headerlink" title="删除Session"></a>删除Session</h4><ul><li><code>del request.seesion[Key]</code></li></ul><blockquote><p>删除对应session，<code>Key</code>值不存在时，引发<code>KeyError</code></p></blockquote><ul><li><code>request.session.clear()</code></li></ul><blockquote><p>清空<code>Session</code>中的所有数据。这里客户端还会保留<code>sessionid</code></p><p>只不过在服务端<code>sessionid</code>对应的数据没有了。</p></blockquote><ul><li><code>request.session.flush()</code></li></ul><blockquote><p>直接删除当前客户端的的<code>Seesion</code>数据。这里不光服务端<code>sessionid</code>对应的数据没有了，客户端的<code>sessionid</code>也会被删除</p></blockquote><h4 id="设置有效期"><a href="#设置有效期" class="headerlink" title="设置有效期"></a>设置有效期</h4><ul><li><p><code>request.session.set_expiry(value)</code>：</p><blockquote><p>设置<code>Session</code>的有效时间。</p></blockquote><blockquote><p><code>value</code>：有效时间。</p><p><strong>为整数时</strong>：将在<code>value</code>为秒单位之后过期</p><p><strong>为0时</strong>：将在用户关闭浏览器之后过期。</p><p><strong>为None时</strong>：使用全局过期的设置，默认为两个星期，<code>14</code>天。</p><p><strong>为datetime时</strong>：在这个指定时间后过期。</p></blockquote></li><li><p><code>request.session.get_expiry_age()</code></p><blockquote><p>返回距离过期还剩下的秒数。</p></blockquote></li><li><p><code>request.session.clear_expired()</code></p><blockquote><p>清除过期的<code>Session</code>会话。</p></blockquote></li></ul><blockquote><p>编写一个简单的视图函数来玩耍<code>Session</code>吧</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,HttpResponseimport datetime</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_session</span><span class="params">(request)</span>:</span> </span><br><span class="line">    <span class="keyword">if</span> request.session.get(<span class="string">'test_id'</span>): </span><br><span class="line">        session_data = request.session.get(<span class="string">'test_id'</span>)</span><br><span class="line">        <span class="comment"># 用户拿到的的session随机字符串   </span></span><br><span class="line">        session_key = request.session.session_key </span><br><span class="line">        <span class="comment"># 获取客户端浏览器中的SessionID值    </span></span><br><span class="line">        session_expire = request.session.get_expiry_age() </span><br><span class="line">        now = datetime.datetime.now()     </span><br><span class="line">        expire_time = now + datetime.timedelta(seconds=session_expire) </span><br><span class="line">        response = <span class="string">'&lt;div&gt;SessionID : %s&lt;/div&gt;'</span> % session_key + \                   <span class="string">'&lt;div&gt;Session : %s&lt;/div&gt;'</span> % session_data + \                   <span class="string">'&lt;div&gt;ExpireTime : %s&lt;/div&gt;'</span> % expire_time       </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(response)  </span><br><span class="line">    <span class="keyword">else</span>:   </span><br><span class="line">        request.session[<span class="string">'test_id'</span>] = <span class="string">'TEST'</span>    </span><br><span class="line">        request.session.set_expiry(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'已设置好Session'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>用户在第一次访问时，会走<code>else</code>分支，此时还没有任何服务端的<code>Session</code>及客户端的<code>Cookie</code>值设定</p><p>那么我们会通过<code>request.session[Key]</code>的方式来设置一个<code>Session</code>值，值为<code>TEST</code></p><p>当用户第二次访问时将展示出所设置好的Session值及在客户端浏览器中存储的sessionid</p></blockquote><blockquote><p>在编写一个删除<code>Session</code>的视图函数吧</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_session</span><span class="params">(request)</span>:</span>   </span><br><span class="line">    <span class="keyword">if</span> request.session.get(<span class="string">'test_id'</span>):  </span><br><span class="line">        <span class="keyword">del</span> request.session[<span class="string">'test_id'</span>]  </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'Session被删了'</span>)   </span><br><span class="line">    <span class="keyword">else</span>:    </span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'目前没有任何需要删除的session'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这里温柔的使用<code>del request.session[Key]</code>的方式来进行<code>Session</code>的删除</p><p>如果存在对应<code>test_id</code>的<code>Session</code>值则删除，反之返回一个字符串</p></blockquote><h4 id="Session删除总结"><a href="#Session删除总结" class="headerlink" title="Session删除总结"></a>Session删除总结</h4><blockquote><p>使用的是<code>del</code>的针对性删除方式，这样不会将整个客户端的<code>session</code>删除掉</p><p>使用<code>request.session.clear()</code>，只是清空了服务端<code>Session</code>中的数据，但是客户端的<code>Cookie</code>中还会保存<code>sessionid</code>，只不过这个值对应的字符串所对应的用户数据是一个空</p><p>使用<code>request.session.flush()</code>，那么客户端<code>Cookie</code>中保存的<code>sessionid</code>首先会被删除，其次服务端通过<code>sessionid</code>值保存的用户数据也会被全部删除。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Cookie和Session&quot;&gt;&lt;a href=&quot;#Cookie和Session&quot; class=&quot;headerlink&quot; title=&quot;Cookie和Session&quot;&gt;&lt;/a&gt;Cookie和Session&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Cookie&lt;/code&gt;及&lt;code&gt;Session&lt;/code&gt;一直以来都是Web开发中非常关键的一环，因为&lt;code&gt;HTTP&lt;/code&gt;协议本身为无状态，每一次请求之间没有任何状态信息保持，往往我们的Web服务无法在客户端访问过程中得知用户的一些状态信息，比如是否登录等等；那么这里通过引入&lt;code&gt;Cookie&lt;/code&gt;或者&lt;code&gt;Seesion&lt;/code&gt;来解决这个问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://cy-blogs.cn/tags/Django/"/>
    
  </entry>
  
</feed>
